

/**
 * A class for defining and managing enum types. Enum types are readonly. An attempt to overwrite an enum fails 
 * and throws an error in strict mode.
 * 
 */
class Enumerator {
	/**
	 * Sets the default namespace for enum(s). The default namespace is used if {@link Enumerator.enum Enumerator.enum()} is called without 
	 * a namespace argument. This method is usually called once and very early in the application.
	 * @see {@link EnumBase}
	 * @see {@link Enumerator.enum Enumerator.enum()}
	 * @see {@link Enumerator.enumExist Enumerator.enumExist()}
	 * @see {@link Enumerator.getDefaultEnumNampespace Enumerator.getDefaultEnumNampespace()}
	 * @param {string} ns The default enum namespace. 
	 */
	static setDefaultEnumNampespace(ns) {
		Enumerator.defaultEnumNameSpace = ns;
	}

	/**
	 * Applications call this method to get the default namespace.
	 * @returns {object} the default namespace.
	 * @see {@link EnumBase}
	 * @see {@link Enumerator.enumExist Enumerator.enumExist()}
	 * @see {@link Enumerator.setDefaultEnumNampespace Enumerator.setDefaultEnumNampespace()}
	 * @see {@link Enumerator.getDefaultEnumNampespace Enumerator.getDefaultEnumNampespace()}
	 * @see {@link Enumerator.enum Enumerator.enum()}
	 */
	static getDefaultEnumNampespace() {
		return window[Enumerator.defaultEnumNameSpace] || window;
	}

	/**
	 * This method puts Enumerator in a state that prevents{@link Enumerator.enum Enumerator.enum()}frow throwing an error during enum re-definition.{@link Enumerator.enum Enumerator.enum()}silently returns without performing the re-definition. If{@link Enumerator.enum Enumerator.enum()}is called in the constructor, this method may be use to suppress re-definition errors. It is never good to suppress errors. Applications should instead use{@link Enumerator.enumExist Enumerator.enumExist()}in conditional logic. 
	 * @see {@link EnumBase}
	 * @see {@link Enumerator.enumExist Enumerator.enumExist()}
	 * @see {@link Enumerator.setDefaultEnumNampespace Enumerator.setDefaultEnumNampespace()}
	 * @see {@link Enumerator.getDefaultEnumNampespace Enumerator.getDefaultEnumNampespace()}
	 * @see {@link Enumerator.enum Enumerator.enum()}
	 */
	static noThrowOnEnumRedefinition() {
		Enumerator.throwOnError = false;
	}

	/**
	 * Check if the enum exist.
	 * @see {@link EnumBase}
	 * @see {@link Enumerator.enum Enumerator.enum()}
	 * @see {@link Enumerator.setDefaultEnumNampespace Enumerator.setDefaultEnumNampespace()}
	 * @see {@link Enumerator.getDefaultEnumNampespace Enumerator.getDefaultEnumNampespace()}
	 * @see {@link Enumerator.noThrowOnEnumRedefinition Enumerator.noThrowOnEnumRedefinition()}
	 * @param {string} enumName enum name.
	 * @returns {boolean} true/false
	 */
	static enumExist(enumName) {
		var ns = window[Enumerator.defaultEnumNameSpace] || window;
		return ns[enumName] == undefined ? false : true;
	}


	/**
	 * Creates an object that represents an enum. By default, this method throws an error during an enum re-definition attempt. To prevent throwing call{@link Enumerator.noThrowOnEnumRedefinition Enumerator.noThrowOnEnumRedefinition().}See example below.  
	 * @see {@link EnumBase}
	 * @see {@link Enumerator.enumExist Enumerator.enumExist()}
	 * @see {@link Enumerator.setDefaultEnumNampespace Enumerator.setDefaultEnumNampespace()}
	 * @see {@link Enumerator.getDefaultEnumNampespace Enumerator.getDefaultEnumNampespace()}
	 * @see {@link Enumerator.noThrowOnEnumRedefinition Enumerator.noThrowOnEnumRedefinition()}
	 * @throws may throw an error if the first argument is not a string that properly describes a not previously defined enum.
	 * @throws may throw an error if the second argument points to an invalid nameSpace.
	 * @throws may throw an error if the enum was previously defined. Use{@link Enumerator.enumExist Enumerator.enumExist()}to check if a enum exist.
	 * @throws may throw an error if the enum flag value is not an integer or cannot be converted to an integer.
	 * @throws may throw an error if the enum flag values are not in ascending order.
	 * @param {string} enumStr A string describing the enum to be defined (e.g. "ErrorType { noError= 0, start, contain, keyword }").
	 * @param {object} [nameSpace] The namespace in which the enum is defined. If Enumerator.enum() is called without a nameSpace 
	 * argument, the default namespace is used. Unless explicitly set using the{@link Enumerator.setDefaultEnumNampespace Enumerator.setDefaultEnumNampespace(),}the default namespace is the window. 
	 * @example
	 * //Set Enum as the default namespace.
	 * Enumerator.setDefaultEnumNampespace("Enum");
	 * 
	 * //Defines an enum "ErrorType" in the Enum namespace.
	 * Enumerator.enum("ErrorType { noError, start, contain, keyword }"); 
	 * console.log(Enum.ErrorType.keyword); //3
	 * //or
	 * Enumerator.enum("ErrorType { noError=10, start, contain, keyword }");
	 * console.log(Enum.ErrorType.keyword); //13 
	 * 
	 * //Defines an enum "ErrorType" in the MyClass namespace. 
	 * class MyClass {
	 * 		...	  		
	 * }
	 * Enumerator.enum("ErrorType { noError=10, start, contain, keyword }", MyClass); //After class declarion (preferred). Useful 
	 * if the class does not implement a constructor.
	 * 
	 * or
	 * class MyClass {
	 * 	constructor(){
	 * 		//Avoid this. Each time a MyClass object is instantiated this call is executed.
	 * 		Enumerator.enum("ErrorType { noError=10, start, contain, keyword }", MyClass); 
	 * 		...
	 *          
	 * 		//Better do this
	 * 		if(!Enumerator.enumExist("ErrorType")){ //The enum ErrorType does not exist. Safe to create it.
	 * 			Enumerator.enum("ErrorType { noError=10, start, contain, keyword }", MyClass);
	 * 		}
	 * 
	 * 		//or better yet
	 *		//call Enumerator.enum() outside (but after) the class declaration as shown below. 
	 *	}
	 * }
	 * Enumerator.enum("ErrorType { noError=10, start, contain, keyword }", MyClass); //This call represents best practice.
	 * console.log(MyClass.ErrorType.keyword); //13
	 * 
	 * 
	 */
	static enum(enumStr, nameSpace) {
		function isAlpha(ch) {
			return typeof ch === "string" && ch.length === 1
				&& (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z");
		}
		function isValidFlagName(flagName) {
			if (flagName.length == 0 || !isAlpha(flagName[0])) return false;
			for (let i = 1; i < flagName.length; i++) {
				if (!isAlpha(flagName[i]) && flagName[i] !== '_' && !Number.isInteger(parseInt(flagName[i])))
					return false;
			}
			return true;
		}
		if (arguments.length == 1 && window[Enumerator.defaultEnumNameSpace] == undefined) {
			if (Enumerator.defaultEnumNameSpace.length) window[Enumerator.defaultEnumNameSpace] = {};
		}
		if (nameSpace && typeof nameSpace != 'function') throw Error("Enumerator.enum() called with invalid second argument.");
		var ns = nameSpace || window[Enumerator.defaultEnumNameSpace] || window;
		var lastValue = undefined;
		var trimStr = enumStr.trim();
		var arr = trimStr.split('{');
		var enumName = arr[0].trim();
		var flags = arr[1].replace('}', '').split(',');

		if (ns[enumName]) {
			if (Enumerator.throwOnError)
				throw Error(`Redefinition of enum ${enumName}`);
			else
				return;
		}
		ns[enumName] = {};

		var flagName;
		for (var i = 0; i < flags.length; i++) {
			var flag = flags[i].split('=');
			var flagName = flag[0].trim();
			if (!isValidFlagName(flagName)) throw Error(`${flagName} is a invalid name for an enum constant.`);
			if (!isAlpha(flagName[0])) throw Error("Improperly defined Enum");
			if (flag.length > 2) throw Error("Improperly defined Enum");
			if (flag.length == 2) {//we have a name and value;
				var val = parseInt(flag[1])
				if (!Number.isInteger(val)) throw Error("Invalid enum value.");
				if (lastValue && val <= lastValue) {
					throw Error("Enum values must be in ascending order");
				}
				lastValue = val;
			} else {
				if (lastValue == undefined) {
					lastValue = 0
				} else {
					lastValue++;
				}

			}
			ns[enumName][flagName] = lastValue;
		}
		Object.freeze(ns[enumName]);
	}
}

//static variables
Enumerator.defaultEnumNameSpace = "";
Enumerator.throwOnError = true;


/**
 * Classes that are interested in C++ - like enum(s) should inherit EnumBase and use the dot notatation on the derived class to call the static method{@link EnumBase.enum enum().}The enum is always created in the namespace of the derived class. The methods{@link Enumerator.setDefaultEnumNampespace setDefaultEnumNampespace()}and{@link Enumerator.getDefaultEnumNampespace getDefaultEnumNampespace()}are not applicable. See example below. 
 * @see {@link Enumerator.setDefaultEnumNampespace Enumerator.setDefaultEnumNampespace()}
 * @see {@link Enumerator.getDefaultEnumNampespace Enumerator.getDefaultEnumNampespace()}
 * @see {@link Enumerator.enumExist Enumerator.enumExist()}
 * @see {@link Enumerator.enum Enumerator.enum()}
 * @see {@link Enumerator.noThrowOnEnumRedefinition Enumerator.noThrowOnEnumRedefinition()} 
 * 
 * @example 
 * class MyClass extends EnumBase{
 *     //....
 * }
 * MyClass.enum("ErrorValue {a, b, c}"); //create an enum in the MyClass namespace.
 * console.log(MyClass.ErrorValue) //{a: 0, b: 1, c: 2}
 */
class EnumBase {
	/**
	 * Creates an object that represents an enum.
	 * By default, this method throws an error during a re-definition attempt. To prevent throwing call{@link Enumerator.noThrowOnEnumRedefinition Enumerator.noThrowOnEnumRedefinition().} 
	 * @see {@link Enumerator.enumExist Enumerator.enumExist()}
	 * @throws may throw an error if the first argument is not a string that properly describes a not previously defined enum.
	 * @throws may throw an error if the enum was previously defined. Use{@link Enumerator.enumExist Enumerator.enumExist()}to check if a enum exist.
	 * @throws may throw an error if the enum flag value is not an integer or cannot be converted to an integer.
	 * @throws may throw an error if the enum flag values are not in ascending order.
	 * @param {string} enumDefStr A string describing the enum to be defined (e.g. "ErrorType { noError= 0, start, contain, keyword }").
	 */
	static enum(enumDefStr) {
		Enumerator.enum(enumDefStr, this)
	}
};
define("enumerator", function(){});



"include []";

/**
 * The ModalDlg class defines the standard interface that modal dialogs must use. It may be instantiated directly. However, you should 
 * subclass it to create new dialogs.
 * 
 * When subclassing ModalDlg, you may implement {@link ModalDlg.initializeDialog initializeDialog()} 
 * and {@link ModalDlg.beforeClose beforeClose()}. 
 * 
 * @example
 * class MyModal extends ModalDlg {
    constructor(obj) {
      super(obj);

      const columns = [
        '<div class="col-sm-5">Horizontal:</div>',

        '<div class="col-sm-7">\
            <select id="select1">\
              <option value="bottomAxis">Bottom axis</option>\
              <option value="topAxis">Top axis</option>\
            </select>\
        </div>',
      ];

      const columns2 = [
        '<div class="col-sm-5">Vertical:</div>',
        
        '<div class="col-sm-7">\
            <select id="select2">\
              <option value="leftAxis">Left axis</option>\
              <option value="rightAxis">Right axis</option>\
            </select>\
        </div>',
      ];

      //this.removeAttr(this.okId(), "data-dismiss");
      this.addRow(columns);
      this.addRow(columns2);
      this.addHandler(this.cancelId(), "click", function () {
        console.log("cancel");
      });
      this.addHandler(this.okId(), "click", function () {
        console.log(456);
        //if this.removeAttr(this.okId(), "data-dismiss"); is called, you need to explicitly clo9se the dlg.
        //dlg.closeDlg();
      });
      this.addHandler("select1", "change", function () {
        if ($(this).val() == "bottomAxis") {
          console.log("bottomAxis");
        } else {
          console.log("topAxis");
        }
      });

      this.addHandler("select2", "change", function () {
        if ($(this).val() == "bottomAxis2") {
          console.log("bottomAxis2");
        } else {
          console.log("topAxis2");
        }
      });
    }
  }

  const options = {
    title: "Test Modal",
    dialogSize: "modal-md",
    //hideCancelButton: true,
    //spaceRows: true,
    // beforeDetach: function () {
    //   console.log("beforeDetach");
    // },
  };
  var dlg = new MyModal(options);
  dlg.showDlg();
 */
class ModalDlg {
  constructor(obj) {
    const self = this;
    const { title, hideCancelButton, spaceRows, dialogSize } = obj;
    let m_title = title || "Modal Dialog";
    const m_id = Math.floor(Math.random() * 10000).toString();
    const bodyId = "body" + m_id;
    const footerId = "footer" + m_id;
    const okId = "ok" + m_id;
    const cancelId = "cancel" + m_id;
    const titleId = "title" + m_id;

    let focusId = okId;

    let m_appended = false;

    var str = "modal-dialog modal-sm";

    const dlg = $(
      '\
                          <div class="modal fade" role="dialog">\
                          <div id="dialogSizeClass" class="modal-dialog modal-sm">\
                          <div class="modal-content">\
                          <div class="modal-header">\
                          <button type="button" class="close" data-dismiss="modal">&times;</button>\
                          <h4 id=' +
        titleId +
        ' class="modal-title">' +
        m_title +
        "</h4>\
                          </div>\
                          <div id=" +
        bodyId +
        ' class="modal-body">\
                          \
                          <div id=' +
        footerId +
        ' class="modal-footer" style="padding-right:0px">\
                          <button id=' +
        okId +
        ' type="button" class="btn btn-primary"  data-dismiss="modal">Ok</button><button id=' +
        cancelId +
        ' type="button" class="btn btn-default"  data-dismiss="modal">Cancel</button>\
                          </div>\
                          </div>\
                          </div>\
                          </div>\
                          </div>\
                          '
    );

    $("body").append(dlg);
    if (hideCancelButton) $("#" + cancelId).remove();

    if (dialogSize) {
      $("#dialogSizeClass").removeClass("modal-sm");
      $("#dialogSizeClass").addClass(dialogSize);
    }

    this.closeDlg = function () {
      dlg.modal("hide");
    };

    dlg.on("hidden.bs.modal", function () {
      m_appended = false;
      self.beforeClose();
      dlg.detach();
    });

    dlg.on("shown.bs.modal", function () {
      $("#" + focusId).trigger("focus");
    });

    /**
     * Generate an id that is unique within the HTML document from an id that is unique within the dialog.
     * @param {String} idStr Identifier that is unique within the dialog.
     * @returns {String} jQuery selector object that is unique within the HTML document.
     */
    function makeUniqueId(idStr) {
      return idStr + m_id;
    }

    /**
     * Shows the dialog.
     *
     */
    this.showDlg = function () {
      $("body").append(dlg);
      m_appended = true;
      self.initializeDialog();
      dlg.modal({
        backdrop: "static",
      });
    };

    /**
     * Sets the element having the focus when the dialog is displayed.
     * @param {String} id Id of the element having the focus.
     */
    this.setFocus = function (id) {
      focusId = makeUniqueId(id);
    };

    function adjustIds(row) {
      if (row[0].id.length) {
        row[0].id = makeUniqueId(row[0].id);
      }
      const elements = row.find("*");
      for (let i = 0; i < elements.length; i++) {
        if (elements[i].id.length) {
          elements[i].id = makeUniqueId(elements[i].id);
        }
      }
    }

    /**
     * Gets the jQuery selector.
     *
     * @param {String} id Identifier that is unique within the dialog.
     * @returns {object} jQuery selector object that is unique within the HTML document.
     */
    this.selector = function (id) {
      if (!m_appended) $("body").append(dlg);
      const sltr = $("#" + makeUniqueId(id));
      if (!m_appended) dlg.detach();
      return sltr;
    };

    /**
     * Adds a HTML element to the footer.
     * @param {String} element The element to create
     * @example
     * MyModalDlg extends ModalDlg{
     *  constructor(options){
     *    super(options);
     *    ...
     *    this.addFooterElement('<button id="save">Save</button>');
     *    this.addFooterElement('<select name="uploadDefinesType" id="uploadDefinesType"><option value="loadFromLocalFs">from Local System</option><option value="loadFromMongoFs">from Mongo System</option></select>');
     *  }
     * }
     */
    this.addFooterElement = function (element) {
      if (!m_appended) $("body").append(dlg);
      const children = $("#" + footerId)[0].children;
      const el = $(element);
      adjustIds(el);
      $("#" + footerId)[0].insertBefore(el[0], children[0]);
      if (!m_appended) dlg.detach();
    };

    /**
     *
     * @param {Array<String>} arrayOfColumns
     * @param {String} [rowIdOpt]
     * @param {String} [containerIdOpt]
     */
    this.addRow = function (arrayOfColumns, rowIdOpt, containerIdOpt) {
      if (!m_appended) $("body").append(dlg);

      let row = $('<div class="row"/>');
      if (rowIdOpt) {
        //row = $("<div id=" + makeUniqueId(rowIdOpt) + ' class="row"/>');
        row = $("<div id=" + rowIdOpt + ' class="row"/>');
      }

      for (let i = 0; i < arrayOfColumns.length; i++) {
        row.append($(`${arrayOfColumns[i]}`));
      }
      if (arrayOfColumns.length > 0) {
        if (containerIdOpt) {
          const div = $("<div id=" + makeUniqueId(containerIdOpt) + "/>");
          $("#" + bodyId)[0].insertBefore(div[0], $("#" + footerId)[0]);
          div.append(row);
          if (spaceRows) div.append($("<br>"));
        } else {
          $("#" + bodyId)[0].insertBefore(row[0], $("#" + footerId)[0]);
          if (spaceRows)
            $("#" + bodyId)[0].insertBefore($("<br>")[0], $("#" + footerId)[0]);
        }
        adjustIds(row);
      }

      if (!m_appended) dlg.detach();
    };

    /**
     * The addHandler() method sets up a function that will be called whenever the specified event is delivered to the target.
     * @param {String} id Identifier or identifiers (e.g. "myId" or "myId_1, myId_2, myId_3, ...") of the event target.
     * @param {String} eventType Event
     * @param {Function} handler callback function that is invoked when the event is triggered.
     */
    this.addHandler = function (id, eventType, handler) {
      const L = id.split(",");
      if (!m_appended) $("body").append(dlg);
      for (let i = 0; i < L.length; i++) {
        $("#" + makeUniqueId(L[i].trim())).on(eventType, handler);
      }
      if (!m_appended) dlg.detach();
    };

    dlg.detach();
  }

  /**
   * Subclass must implement this method to do all dialog initializing. Attempting to initialize the dialog outside of this method
   * may lead to unexpected behaviour.
   *
   * Internally, this method is called by showDlg() each time showDlg() is invoked. It is called after the dialog is attached to the
   * DOM but before the is shown.
   *
   * Note: The add... methods (i.e. addRow(), addFooterButton() and addHandler()) should not be called within the initializeDialog() method.
   */
  initializeDialog() {}

  /**
   * Subclass must implement this method to do all clean-up annd reset work.
   *
   * Internally, this method is called before the dialog is detached from the DOM but after it is closed.
   */
  beforeClose() {}
}
;
define("modalDlg", function(){});

"include ['modalDlg']";


class MCurveLegendAttributeDlg extends ModalDlg {
  constructor() {
    const options = {
      title: "Curve Legend Attribute",
      spaceRows: true,
      //hideCancelButton: true,
    };
    super(options);
    let self = this;
    self.defaultIconSize = null;

    this.addRow([
      '<div class="col-sm-5">Attribute:</div>',
      '<div class="col-sm-7">\
           <select id="curveAttribute">\
             <option value="default">Brush color(Default)</option>\
             <option value="line">Line</option>\
             <option value="symbol">Symbol</option>\
             <option value="lineAndSymbol">Line and Symbol</option>\
           </select>\
        </div>',
    ]);

    this.addRow(
      [
        '<div class="col-sm-5">Icon size:</div>',
        '<div class="col-sm-7">\
          <select id="iconSize">\
            <option value="small">Small</option>\
            <option value="medium">Medium</option>\
            <option value="large">Large</option>\
          </select>\
        </div>',
      ],
      "iconSizeRow"
    );

    function setIconSize(val) {
      if (val == "small") {
        //We are dealing with square icon
        self.curve.setLegendIconSize(
          new Misc.Size(
            self.defaultIconSize.height - 4,
            self.defaultIconSize.height - 4
          )
        );
      } else if (val == "medium") {
        self.curve.setLegendIconSize(
          new Misc.Size(
            self.defaultIconSize.height,
            self.defaultIconSize.height
          )
        );
      } else {
        self.curve.setLegendIconSize(
          new Misc.Size(
            self.defaultIconSize.height + 4,
            self.defaultIconSize.height + 4
          )
        );
      }
      self.curve.plot().autoRefresh();
    }

    this.addHandler("curveAttribute", "change", function () {
      if ($(this).val() == "line") {
        self.selector("iconSizeRow").hide();
      } else if ($(this).val() == "symbol") {
        self.selector("iconSizeRow").hide();
      } else if ($(this).val() == "lineAndSymbol") {
        self.selector("iconSizeRow").hide();
      } else {
        self.selector("iconSizeRow").show();
      }
    });

    this.addHandler("ok", "click", function () {
      Utility.setLegendAttribute(
        self.curve,
        self.selector("curveAttribute").val(),
        self.defaultIconSize
      );
      if (self.selector("curveAttribute").val() === "default")
        setIconSize(self.selector("iconSize").val());
      self.curve.plot().autoRefresh();
    });

    this.curveAttributeDlg = function () {
      if (!self.curve || self.curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
        return;

      if (
        self.curve.testLegendAttribute(Curve.LegendAttribute.LegendShowLine) &&
        self.curve.testLegendAttribute(Curve.LegendAttribute.LegendShowSymbol)
      ) {
        self.selector("curveAttribute").val("lineAndSymbol");
      } else if (
        self.curve.testLegendAttribute(Curve.LegendAttribute.LegendShowSymbol)
      ) {
        self.selector("curveAttribute").val("symbol");
      } else if (
        self.curve.testLegendAttribute(Curve.LegendAttribute.LegendShowLine)
      ) {
        self.selector("curveAttribute").val("line");
      } else {
        self.selector("curveAttribute").val("default");
      }

      if (
        self.curve.getLegendIconSize().width ==
        self.defaultIconSize.width - 4
      ) {
        self.selector("iconSize").val("small");
      } else if (
        self.curve.getLegendIconSize().width == self.defaultIconSize.width
      ) {
        self.selector("iconSize").val("medium");
      } else if (
        self.curve.getLegendIconSize().width ==
        self.defaultIconSize.width + 4
      ) {
        self.selector("iconSize").val("large");
      }

      if (
        self.selector("curveAttribute").val() == "line" ||
        self.selector("curveAttribute").val() == "symbol" ||
        self.selector("curveAttribute").val() == "lineAndSymbol"
      )
        self.selector("iconSizeRow").hide();
      else {
        self.selector("iconSizeRow").show();
      }
    };

    this.curveAttributeDlgInit = function () {
      self.curveAttributeDlg();
    };

    this.curveAttributeCb = function (curve) {
      if (!self.defaultIconSize)
        self.defaultIconSize = new Misc.Size(curve.getLegendIconSize());
      self.curve = curve;
      self.showDlg();
    };
  }

  initializeDialog() {
    this.curveAttributeDlgInit();
  }

  beforeClose() {
    this.curve = 0;
  }
}
;
define("curveLegendAttributeDlg", ["modalDlg"], function(){});

/**
 * @license
 *
 * Regression.JS - Regression functions for javascript
 * http://tom-alexander.github.com/regression-js/
 *
 * copyright(c) 2013 Tom Alexander
 * Licensed under the MIT license.
 *
 * @module regression - Least-squares regression functions for JavaScript
 **/

/* global define */
(function _umd(global, factory) {
  var returned;
  // UMD Format for exports. Works with all module systems: AMD/RequireJS, CommonJS, and global
  // AMD
  if (typeof define === "function" && define.amd) {
    returned = define("regression", factory);
  } else if (typeof module !== "undefined") {
    returned = module.exports = factory();
  } else {
    returned = global.regression = factory();
  }
  return returned;
})(this, function _regressionUmdFactory() {
  "use strict";
  var exports;

  /**
   * Determine the coefficient of determination (r^2) of a fit from the observations and predictions.
   *
   * @param {Array<Array<number>>} observations - Pairs of observed x-y values
   * @param {Array<Array<number>>} predictions - Pairs of observed predicted x-y values
   *
   * @return {number} - The r^2 value, or NaN if one cannot be calculated.
   */
  function determinationCoefficient(observations, predictions) {
    var sum = observations.reduce(function (accum, observation) {
      return accum + observation[1];
    }, 0);
    var mean = sum / observations.length;

    // Sum of squares of differences from the mean in the dependent variable
    var ssyy = observations.reduce(function (accum, observation) {
      var diff = observation[1] - mean;
      return accum + diff * diff;
    }, 0);

    // Sum of squares of resudulals
    var sse = observations.reduce(function (accum, observation, ix) {
      var prediction = predictions[ix];
      var resid = observation[1] - prediction[1];
      return accum + resid * resid;
    }, 0);

    // If ssyy is zero, r^2 is meaningless, so NaN is an appropriate answer.
    return 1 - sse / ssyy;
  }

  /**
   * Determine the solution of a system of linear equations A * x = b using Gaussian elimination.
   *
   * @param {Array<Array<number>>} matrix - A 2-d matrix of data in row-major form [ A | b ]
   * @param {number} order - How many degrees to solve for
   *
   * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
   */
  function gaussianElimination(matrix, order) {
    var i = 0;
    var j = 0;
    var k = 0;
    var maxrow = 0;
    var tmp = 0;
    var n = matrix.length - 1;
    var coefficients = new Array(order);

    for (i = 0; i < n; i++) {
      maxrow = i;
      for (j = i + 1; j < n; j++) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
          maxrow = j;
        }
      }

      for (k = i; k < n + 1; k++) {
        tmp = matrix[k][i];
        matrix[k][i] = matrix[k][maxrow];
        matrix[k][maxrow] = tmp;
      }

      for (j = i + 1; j < n; j++) {
        for (k = n; k >= i; k--) {
          matrix[k][j] -= (matrix[k][i] * matrix[i][j]) / matrix[i][i];
        }
      }
    }

    for (j = n - 1; j >= 0; j--) {
      tmp = 0;
      for (k = j + 1; k < n; k++) {
        tmp += matrix[k][j] * coefficients[k];
      }

      coefficients[j] = (matrix[n][j] - tmp) / matrix[j][j];
    }

    return coefficients;
  }

  /** Precision to use when displaying string form of equation */
  var _DEFAULT_PRECISION = 2;

  /**
   * Round a number to a precision, specificed in number of decimal places
   *
   * @param {number} number - The number to round
   * @param {number} precision - The number of decimal places to round to:
   *                             > 0 means decimals, < 0 means powers of 10
   *
   *
   * @return {numbr} - The number, rounded
   */
  function _round(number, precision) {
    var factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  }

  /**
   * The set of all fitting methods
   *
   * @namespace
   */
  var methods = {
    linear: function (data, _order, options) {
      var sum = [0, 0, 0, 0, 0];
      var results;
      var gradient;
      var intercept;
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0];
          sum[3] += data[n][0] * data[n][1];
          sum[4] += data[n][1] * data[n][1];
        }
      }

      gradient =
        (len * sum[3] - sum[0] * sum[1]) / (len * sum[2] - sum[0] * sum[0]);
      intercept = sum[1] / len - (gradient * sum[0]) / len;

      results = data.map(function (xyPair) {
        var x = xyPair[0];
        return [x, gradient * x + intercept];
      });

      return {
        r2: determinationCoefficient(data, results),
        equation: [gradient, intercept],
        points: results,
        string:
          "y = " +
          _round(gradient, options.precision) +
          "x + " +
          _round(intercept, options.precision),
      };
    },

    linearthroughorigin: function (data, _order, options) {
      var sum = [0, 0];
      var gradient;
      var results;

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0] * data[n][0]; // sumSqX
          sum[1] += data[n][0] * data[n][1]; // sumXY
        }
      }

      gradient = sum[1] / sum[0];

      results = data.map(function (xyPair) {
        var x = xyPair[0];
        return [x, gradient * x];
      });

      return {
        r2: determinationCoefficient(data, results),
        equation: [gradient],
        points: results,
        string: "y = " + _round(gradient, options.precision) + "x",
      };
    },

    exponential: function (data, _order, options) {
      var sum = [0, 0, 0, 0, 0, 0];
      var denominator;
      var coeffA;
      var coeffB;
      var results;

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0] * data[n][1];
          sum[3] += data[n][1] * Math.log(data[n][1]);
          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
          sum[5] += data[n][0] * data[n][1];
        }
      }

      denominator = sum[1] * sum[2] - sum[5] * sum[5];
      coeffA = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
      coeffB = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;

      results = data.map(function (xyPair) {
        var x = xyPair[0];
        return [x, coeffA * Math.exp(coeffB * x)];
      });

      return {
        r2: determinationCoefficient(data, results),
        equation: [coeffA, coeffB],
        points: results,
        string:
          "y = " +
          _round(coeffA, options.precision) +
          "e^(" +
          _round(coeffB, options.precision) +
          "x)",
      };
    },

    logarithmic: function (data, _order, options) {
      var sum = [0, 0, 0, 0];
      var coeffA;
      var coeffB;
      var results;
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += data[n][1] * Math.log(data[n][0]);
          sum[2] += data[n][1];
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      coeffB =
        (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
      coeffA = (sum[2] - coeffB * sum[0]) / len;

      results = data.map(function (xyPair) {
        var x = xyPair[0];
        return [x, coeffA + coeffB * Math.log(x)];
      });

      return {
        r2: determinationCoefficient(data, results),
        equation: [coeffA, coeffB],
        points: results,
        string:
          "y = " +
          _round(coeffA, options.precision) +
          " + " +
          _round(coeffB, options.precision) +
          " ln(x)",
      };
    },

    power: function (data, _order, options) {
      var sum = [0, 0, 0, 0];
      var coeffA;
      var coeffB;
      var results;
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
          sum[2] += Math.log(data[n][1]);
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      coeffB =
        (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
      coeffA = Math.exp((sum[2] - coeffB * sum[0]) / len);

      results = data.map(function (xyPair) {
        var x = xyPair[0];
        return [x, coeffA * Math.pow(x, coeffB)];
      });

      return {
        r2: determinationCoefficient(data, results),
        equation: [coeffA, coeffB],
        points: results,
        string:
          "y = " +
          _round(coeffA, options.precision) +
          "x^" +
          _round(coeffB, options.precision),
      };
    },

    polynomial: function (data, order, options) {
      var lhs = [];
      var rhs = [];
      var a = 0;
      var b = 0;
      var c;
      var k;

      var i;
      var j;
      var l;
      var len = data.length;

      var results;
      var equation;
      var string;

      if (typeof order === "undefined") {
        k = 3;
      } else {
        k = order + 1;
      }

      for (i = 0; i < k; i++) {
        for (l = 0; l < len; l++) {
          if (data[l][1] !== null) {
            a += Math.pow(data[l][0], i) * data[l][1];
          }
        }

        lhs.push(a);
        a = 0;

        c = [];
        for (j = 0; j < k; j++) {
          for (l = 0; l < len; l++) {
            if (data[l][1] !== null) {
              b += Math.pow(data[l][0], i + j);
            }
          }
          c.push(b);
          b = 0;
        }
        rhs.push(c);
      }
      rhs.push(lhs);

      equation = gaussianElimination(rhs, k);

      results = data.map(function (xyPair) {
        var x = xyPair[0];

        var answer = equation.reduce(function (sum, coeff, power) {
          return sum + coeff * Math.pow(x, power);
        }, 0);

        return [x, answer];
      });

      string = "y = ";
      for (i = equation.length - 1; i >= 0; i--) {
        if (i > 1) {
          string += _round(equation[i], options.precision) + "x^" + i + " + ";
        } else if (i === 1) {
          string += _round(equation[i], options.precision) + "x" + " + ";
        } else {
          string += _round(equation[i], options.precision);
        }
      }

      return {
        r2: determinationCoefficient(data, results),
        equation: equation,
        points: results,
        string: string,
      };
    },

    lastvalue: function (data, _order, options) {
      var results = [];
      var lastvalue = null;

      for (var i = 0; i < data.length; i++) {
        if (data[i][1] !== null && isFinite(data[i][1])) {
          lastvalue = data[i][1];
          results.push([data[i][0], data[i][1]]);
        } else {
          results.push([data[i][0], lastvalue]);
        }
      }

      return {
        r2: determinationCoefficient(data, results),
        equation: [lastvalue],
        points: results,
        string: "" + _round(lastvalue, options.precision),
      };
    },
  };

  exports = function regression(method, data, order, options) {
    var methodOptions =
      typeof order === "object" && typeof options === "undefined"
        ? order
        : options || {};

    if (!methodOptions.precision) {
      methodOptions.precision = _DEFAULT_PRECISION;
    }

    if (typeof method === "string") {
      return methods[method.toLowerCase()](data, order, methodOptions);
    }
    return null;
  };

  window.regression = exports;
  // Since we are redefining the "exports" object to a new function, we must return it here.
  return exports;
});


// var MoveToElement = 0;
// var LineToElement = 1;
// var Misc.CurveToElement = 2;
// var CurveToDataElement = 3;

/**
 * A collection useful clases.
 * @namespace
 */
var Misc = {};

Misc.EPSILON = Number.MIN_VALUE;

Misc.MoveToElement = 0;
Misc.LineToElement = 1;
Misc.CurveToElement = 2;
Misc.CurveToDataElement = 3;

/**
 * @classdesc Image is a class designed and optimized for direct pixel access and manipulation.
 *
 * The constructor is overloaded. See example.
 * @constructor
 * @param {Misc.Size|Number} [w] The image size or width. Defaults to a width of 0
 * @param {Number} [h] The image height. Defaults to a height of 0
 * @example
 * new Image()//Creates an image of width == height == 0;
 * new Image(new Misc.Size(20, 30))//Creates an image of width == 20 and height == 30;
 * new Image(20, 30)//Creates an image of width == 20 and height == 30;
 *
 */
Misc.Image = function (w, h /* , a */) {
  var _w = w;
  var _h = h;

  var _colorTable = null;
  //var _a = 255;
  //var m_ctx = ctx;
  if (typeof w === "object" && _.has(w, "width") && _.has(w, "height")) {
    _w = w.width;
    _h = w.height;
    //a = h;
  }
  if (w == undefined) {
    _w = 0;
    _h = 0;
  }

  /* if(a !== undefined){
        if(a < 255 && a >=0)
            _a = a;
    } */

  var cnvs = $("<canvas/>");
  var m_ctx = cnvs[0].getContext("2d");

  /*
    For every pixel in an ImageData object there are four pieces of information, the RGBA values:
    R - The color red (from 0-255)
    G - The color green (from 0-255)
    B - The color blue (from 0-255)
    A - The alpha channel (from 0-255; 0 is transparent and 255 is fully visible)
    The color/alpha information is held in an array, and is stored in the data property of the ImageData object.
    */
  var m_data = null;
  if (_w !== 0 && _h !== 0) m_data = m_ctx.createImageData(_w, _h);

  /**
   *
   * @returns {Uint8ClampedArray} one-dimensional array containing the data in the RGBA order, with integer values between 0 and 255 (inclusive).
   */
  this.data = function () {
    return m_data.data;
  };

  /**
   * Scales the image
   *
   * Both width and height are scaled by the same factor
   * @param {Number} scale Scale factor
   */
  this.scaleImageData = function (scale) {
    if (!m_data) return;
    var scaled = m_ctx.createImageData(
      m_data.width * scale,
      m_data.height * scale
    );
    var subLine = m_ctx.createImageData(scale, 1).data;
    for (var row = 0; row < m_data.height; row++) {
      for (var col = 0; col < m_data.width; col++) {
        var sourcePixel = m_data.data.subarray(
          (row * m_data.width + col) * 4,
          (row * m_data.width + col) * 4 + 4
        );
        for (var x = 0; x < scale; x++) subLine.set(sourcePixel, x * 4);
        for (var y = 0; y < scale; y++) {
          var destRow = row * scale + y;
          var destCol = col * scale;
          scaled.data.set(subLine, (destRow * scaled.width + destCol) * 4);
        }
      }
    }

    m_data = scaled;
  };

  /**
   *
   * @returns {ImageData} ImageData object
   */
  this.imageData = function () {
    return m_data;
  };

  /**
   * Sets a new ImageData object
   * @param {ImageData} d ImageData object
   */
  this.setImageData = function (d) {
    m_data = d;
  };

  /**
   *
   * @returns {Number} image width
   */
  this.width = function () {
    return _w;
  };

  /**
   *
   * @param {Nimber} w Width of the image
   */
  this.setWidth = function (w) {
    _w = w;
  };

  /**
   *
   * @returns {Number} image height
   */
  this.height = function () {
    return _h;
  };

  /**
   *
   * @param {Number} h Height of the image
   */
  this.setHeight = function (h) {
    _h = h;
  };

  /**
   *
   * @returns {Misc.Size} Size of image
   */
  this.size = function () {
    return new Misc.Size(_w, _h);
  };

  /**
   *
   * @returns {Boolean} true, if Image data == null
   */
  this.isNull = function () {
    return m_data == null;
  };

  /**
   *
   * @returns {Misc.Image} Deep copy of the image
   */
  this.copy = function () {
    var res = new Misc.Image(this.width(), this.height());
    var imageDataCopy = new ImageData(
      new Uint8ClampedArray(this.imageData().data),
      this.imageData().width,
      this.imageData().height
    );
    res.setImageData(imageDataCopy);
    return res;
  };

  /**
   * Set the alpha value
   * @param {Number} a alpha value (0 - 255 inclusive)
   */
  this.setAlpha = function (a) {
    if (m_data.data && m_data.data[3] == a) return;
    var data = m_data.data;
    var i,
      len = data.length;
    for (i = 3; i < len; i += 4) {
      data[i] = a;
    }
  };

  /**
   * Set a pixel value at position with coordinate (x, y)
   * @param {Number} x X coordinate position
   * @param {Number} y Y coordinate position
   * @param {object} rgba (e.g. {r:240, g:20, b:0, a:50})
   */
  this.setPixel = function (x, y, rgba) {
    if (typeof rgba == "number") {
      rgba = _colorTable[Math.round(rgba)];
    }

    var redAddress = y * (_w * 4) + x * 4;

    // Copy the values into the array starting at index redAddress
    // m_data.data.set([rgba.r, rgba.g, rgba.b, 255], redAddress);

    m_data.data[redAddress] = rgba.r;
    m_data.data[redAddress + 1] = rgba.g;
    m_data.data[redAddress + 2] = rgba.b;
    m_data.data[redAddress + 3] = 255;
    if (rgba.a) {
      if (rgba.a > 255) rgba.a = 255;
      if (rgba.a < 0) rgba.a = 0;
      m_data.data[redAddress + 3] = rgba.a;
    }
  };

  this.setColorTable = function (ct) {
    _colorTable = ct;
  };

  /**
   *
   * Get a pixel value at position with coordinate (x, y)
   * @param {Number} x X coordinate position
   * @param {Number} y Y coordinate position
   * @returns {object} the rgba (e.g. {r:240, g:20, b:0, a:50})
   */
  this.pixel = function (x, y) {
    if (y == undefined && _colorTable) {
      //x is a index into the colorTable
      return _colorTable[Math.round(x)];
    }
    var redAddress = y * (_w * 4) + x * 4;
    return {
      r: m_data.data[redAddress],
      g: m_data.data[redAddress + 1],
      b: m_data.data[redAddress + 2],
      a: m_data.data[redAddress + 3],
    };
  };
};

/*style
          solid
          dash : ctx.setLineDash([10, 5])
          dashDot : ctx.setLineDash([12, 5, 3, 5])
          dashDotDot : ctx.setLineDash([12, 5, 3, 5, 3, 5])
          dot : ctx.setLineDash([2, 8])
        */
/**
 * @classdesc A pen has a color, width and style property.
 *
 * The constructor is overloaded. See example.
 * @constructor
 * @param {String|Misc.Pen} [c] Color or other pen
 * @param {Number} [w] Width
 * @param {String} [s] Style. Possible values are:
 * - `solid`
 * - `dash`
 * - `dashDot`
 * - `dashDotDot`
 * - `dot`
 * @example
 * new Misc.Pen(); //Creates a black solid pen of width 1.
 * new Misc.Pen("red"); //Creates a red solid pen of width 1.
 * new Misc.Pen("red", 2); //Creates a red solid pen of width 2.
 * new Misc.Pen("red", 2, "dash"); //Creates a red dash pen of width 2.
 * new Misc.Pen(existingPen); //Creates a pen with color == existingPen.color, width == existingPen.width and style == existingPen.style.
 */
Misc.Pen = function (c, w, s) {
  if (typeof c === "object") {
    return new Misc.Pen(c.color, c.width, c.style);
  }
  this.color = "black";
  this.width = 1.0;
  this.style = "solid";
  if (c == Static.NoPen || s == Static.NoPen) this.style = Static.NoPen;

  if (typeof s !== "undefined") this.style = s;
  if (typeof w !== "undefined") this.width = w;
  if (typeof c !== "undefined") this.color = c;
};

/**
 *
 * @returns A string representing the object.
.
 */
Misc.Pen.prototype.toString = function () {
  return (
    "[color:" +
    this.color +
    ", width:" +
    this.width +
    ", style:" +
    this.style +
    "]"
  );
};

/**
 * Check pen for equality.
 * @param {Misc.Pen} otherPen pen
 * @returns {Boolean} true, if otherPen is equal to this pen
 */
Misc.Pen.prototype.isEqual = function (otherPen) {
  if (otherPen == undefined) return false;
  if (
    this.color == otherPen.color &&
    this.style == otherPen.style &&
    this.width == otherPen.width
  )
    return true;

  return false;
};

/**
 * @classdesc Brush used for painting / filling
 *
 * The constructor is overloaded. See example.
 * @constructor
 * @param {String} type valid html color
 * new Misc.Brush(); //Creates a colorless brush.
 * new Misc.Brush("red"); //Creates a red brush.
 */
Misc.Brush = function (type) {
  this.color = Static.NoBrush;
  if (typeof type !== "undefined" /*  && typeof(type)=="string" */)
    this.color = type;
};

/**
 *
 * @returns A string representing the object.
.
 */
Misc.Brush.prototype.toString = function () {
  return "[Brush: " + this.color + "]";
};

/**
 * Check brush for equality.
 * @param {Misc.Brush} otherBrush pen
 * @returns {Boolean} true, if otherPen is equal to this pen
 */
Misc.Brush.prototype.isEqual = function (otherBrush) {
  if (this.color == otherBrush.color) return true;
  return false;
};

/**
 * @classdesc A Line describes a finite length line (or a line segment) on a two-dimensional surface.
 * The start and end points of the line are specified using floating point accuracy for coordinates.
 *
 * @constructor
 * @param {Misc.Point} point1 First point
 * @param {Misc.Point} point2 Second point
 *
 */
Misc.Line = function (point1, point2) {
  var m_p1 = point1;
  var m_p2 = point2;

  /**
   *
   * @returns {Misc.Point} Returns the line's start point.
   */
  this.p1 = function () {
    return m_p1;
  };

  /**
   *
   * @returns {Misc.Point} Returns the line's end point.
   */
  this.p2 = function () {
    return m_p2;
  };
};

/**
 *
 * @returns {Number} Returns the x-coordinate of the line's start point.
 */
Misc.Line.prototype.x1 = function () {
  return this.p1().x;
};

/**
 *
 * @returns {Number} Returns the x-coordinate of the line's end point.
 */
Misc.Line.prototype.x2 = function () {
  return this.p2().x;
};

/**
 *
 * @returns {Number} Returns the y-coordinate of the line's start point.
 */
Misc.Line.prototype.y1 = function () {
  return this.p1().y;
};

/**
 *
 * @returns {Number} Returns the y-coordinate of the line's end point.
 */
Misc.Line.prototype.y2 = function () {
  return this.p2().y;
};

// Misc.Line.prototype.x2 = function () {
//   return this.p2().x;
// };

/**
 *
 * @returns {Number} the length of the line
 */
Misc.Line.prototype.length = function () {
  return Math.sqrt(
    (this.p2().x - this.p1().x) * (this.p2().x - this.p1().x) +
      (this.p2().y - this.p1().y) * (this.p2().y - this.p1().y)
  );
};

/**
 * @classdesc A size is specified by a width and a height. It can be set in the constructor
 * and changed by assigning to the width and height property.
 *
 * The isValid() function determines if a size is valid (a valid size has
 * both width and height greater than or equal to zero).
 *
 * The isEmpty() function returns true if either of the width and height is less
 * than, or equal to, zero.
 *
 * Use the expandedTo() function to retrieve a size which holds the maximum
 * height and width of this size and a given size. Similarly, the boundedTo() function
 * returns a size which holds the minimum height and width of this size and a given
 * size.
 *
 * Size can be compared.
 *
 * The constructor is overloaded. See example.
 * @constructor
 * @param {Misc.Size|Number} [w] Width or an existing Misc.Size object
 * @param {Number} [h] Height
 * @example
 * new Misc.Size(); //Creates a Size of width == height == 0.
 * new Misc.Size(20, 100); //Creates a Size of width == 20 and height == 100.
 * new Misc.Size(existingSize); //Creates a Size of width == existingSize.width and height == existingSize.height.
 */
Misc.Size = function (w, h) {
  if (w instanceof Misc.Size) {
    h = w.height;
    w = w.width;
  }
  this.width = 0.0;
  this.height = 0.0;
  if (typeof h !== "undefined") {
    this.width = w;
    this.height = h;
  }
};

/**
 *
 * @returns {Boolean} Returns true if both the width and height is equal to or greater than 0; otherwise returns false.
 */
Misc.Size.prototype.isValid = function () {
  if (this.width < 0 || this.height < 0) return false;
  return true;
};

/**
 *
 * @returns {Boolean} Returns true if either of the width and height is less than or equal to 0; otherwise returns false.
 */
Misc.Size.prototype.isEmpty = function () {
  return this.width <= 0 || this.height <= 0;
};

/**
 *
 * @returns {Misc.Size} A deep copy of the object
 */
Misc.Size.prototype.copy = function () {
  return new Misc.Size(this.width, this.height);
};

/**
 *
 * @param {Misc.Size} size
 * @returns {Boolean} true if size is equal to this size; otherwise returns false.
 */
Misc.Size.prototype.isEqual = function (size) {
  /* if ((this.width == size.width) && (this.height == size.height))
        return true;
    return false; */
  var x = this.width - size.width,
    y = this.height - size.height;
  return x * x + y * y < Misc.EPSILON;
};

/**
 *
 * @param {Misc.Size} otherSize
 * @returns {Misc.Size} A size holding the maximum width and height of this size and the given otherSize.
 */
Misc.Size.prototype.expandedTo = function (otherSize) {
  return new Misc.Size(
    Math.max(this.width, otherSize.width),
    Math.max(this.height, otherSize.height)
  );
};

/**
 *
 * @param {Misc.Size} otherSize
 * @returns {Misc.Size} A size holding the minimum width and height of this size and the given otherSize.
 */
Misc.Size.prototype.boundedTo = function (otherSize) {
  return new Misc.Size(
    Math.min(this.width, otherSize.width),
    Math.min(this.height, otherSize.height)
  );
};

/**
 *
 * @returns A string representing the object.
.
 */
Misc.Size.prototype.toString = function () {
  return "[" + this.width + ", " + this.height + "]";
};

/**
 * @classdesc A point is specified by a x coordinate and an y coordinate which can be accessed
 * using pt.x and pt.y. The coordinates can be set (or altered) by assigning directly to the property (e.g. pt.x = 4.5).
 *
 * The constructor is overloaded. See example.
 * @constructor
 * @param {Number|Misc.Point} [x]  x coordinate or an existingPoint object
 * @param {Number} [y]  y coordinate
 * @example
 * new Misc.Point(); //Creates a point with x coordinate == 0 and y coordinate == 0.
 * new Misc.Point(10, 20); //Creates a point with x coordinate == 10 and y coordinate == 20.
 * new Misc.Point(existingPoint); //Creates a point with x coordinate == existingPoint.x and y coordinate == existingPoint.y.
 */
Misc.Point = function (x, y) {
  if (x instanceof Misc.Point) {
    this.x = x.x;
    this.y = x.y;
    return;
  }
  this.x = 0.0;
  this.y = 0.0;

  if (typeof y !== "undefined") {
    this.y = y;
  }
  if (typeof x !== "undefined") {
    this.x = x;
  }
};

/**
 * Calculate the linear interpolated point
 * @param {Misc.Point} pt other point
 * @param {Number} xVal x coordinate for interpolation
 * @returns {Misc.Point} interpolated point
 */
Misc.Point.prototype.interpolatedPoint = function (pt, xVal) {
  if (xVal == pt.x) {
    return pt;
  }
  if (xVal == this.x) {
    return this;
  }
  var yVal = ((this.y - pt.y) / (this.x - pt.x)) * (xVal - pt.x) + pt.y;
  return new Misc.Point(xVal, yVal);
};

/**
 * Calculate the log interpolated point
 * @param {Misc.Point} pt other point
 * @param {Number} xVal x coordinate for interpolation
 * @returns {Misc.Point} interpolated point
 */
Misc.Point.prototype.logInterpolatedPoint = function (pt, xVal) {
  if (xVal == pt.x) {
    return pt;
  }
  if (xVal == this.x) {
    return this;
  }
  var yVal =
    ((this.y - pt.y) / (math.log(this.x, 10) - math.log(pt.x, 10))) *
      (math.log(xVal, 10) - math.log(pt.x, 10)) +
    pt.y;
  return new Misc.Point(xVal, yVal);
};

/**
 *
 * @param {Misc.Point} pt
 * @returns {Boolean} true if pt is equal to this point; otherwise returns false.
 */
Misc.Point.prototype.isEqual = function (pt) {
  //return (this.x === pt.x && this.y === pt.y)
  var x = this.x - pt.x,
    y = this.y - pt.y;
  return x * x + y * y < Misc.EPSILON;
};

/**
 *
 * @returns A string representing the object.
.
 */
Misc.Point.prototype.toString = function () {
  return "(" + this.x + ", " + this.y + ")";
};

/**
 * @classdesc A rectangle is normally expressed as a top-left corner and a size. The size (width and height) of a Rect is always equivalent to the mathematical rectangle that forms the basis for its rendering.
 *
 * The constructor is overloaded. See example.
 * @constructor
 * @param {Number|Misc.Point} [param1] x coordinate of the top-left corner or the {@link Misc.Point} representing the top-left corner
 * @param {Number|Misc.Point|Misc.Size} [param2] The width of the rectangle or a {@link Misc.Point} representing the bottom-right corner of the rectangle or a {@link Misc.Size} object specifying the width and height of the rectangle.
 * @param {Number} [param3] Width of the rectangle
 * @param {Number} [param4] Height of the rectangle
 * @example
 * new Misc.Rect(x, y width, height); //Constructs a rectangle with `(x, y)` as its top-left corner and the given `width` and `height`.
 * new Misc.Rect(topLeft, size); //Constructs a rectangle with the given topLeft({@link Misc.Point}) corner and the given size({@link Misc.Size}).
 * new Misc.Rect(topLeft, bottomRight); //Constructs a rectangle with the given topLeft({@link Misc.Point}) corner and the given bottomRight({@link Misc.Point}).
 * new Misc.Rect(); //Constructs an invalid rectangle. (i.e. a rectangle of width == height == -1).
 */
Misc.Rect = function (param1, param2, param3, param4) {
  var m_left = 0.0;
  var m_top = 0.0;
  var m_right = -1.0;
  var m_bottom = -1.0;
  var m_width = -1.0;
  var m_height = -1;
  if (typeof param4 !== "undefined") {
    m_left = param1;
    m_top = param2;
    m_width = param3;
    m_height = param4;
    m_right = m_left + m_width;
    m_bottom = m_top + m_height;
  } else if (typeof param3 !== "undefined") {
    m_left = param1.x;
    m_top = param1.y;
    m_width = param2;
    m_height = param3;
    m_right = m_left + m_width;
    m_bottom = m_top + m_height;
  } else if (typeof param2 !== "undefined") {
    m_left = param1.x;
    m_top = param1.y;
    if (typeof param2.x !== "undefined") {
      m_right = param2.x;
      m_bottom = param2.y;
      m_width = m_right - m_left;
      m_height = m_bottom - m_top;
    } else {
      m_width = param2.width;
      m_height = param2.height;
      m_right = m_left + m_width;
      m_bottom = m_top + m_height;
    }
  }

  /**
   *
   * @returns {Number} The x-coordinate of the rectangle's left edge. Equivalent to x().
   */
  this.left = function () {
    return m_left;
  };

  /**
   * Sets the left edge of the rectangle to the given x coordinate.
   *
   * May change the width, but will never change the right edge of the rectangle.
   * @param {Number} val Value
   */
  this.setLeft = function (val) {
    if (m_left === val) return;
    m_left = val;
    m_width = m_right - m_left;
  };

  /**
   *
   * @returns {Number} The y-coordinate of the rectangle's top edge. Equivalent to y().
   */
  this.top = function () {
    return m_top;
  };

  /**
   * Sets the top edge of the rectangle to the given y coordinate.
   *
   * May change the height, but will never change the bottom edge of the rectangle.
   * @param {Number} val Value
   */
  this.setTop = function (val) {
    if (m_top === val) return;
    m_top = val;
    m_height = m_bottom - m_top;
  };

  /**
   *
   * @returns {Number} The x-coordinate of the rectangle's right edge.
   */
  this.right = function () {
    return m_right;
  };

  /**
   * Sets the right edge of the rectangle to the given x coordinate.
   *
   * May change the width, but will never change the leftt edge of the rectangle.
   * @param {Number} val Value
   */
  this.setRight = function (val) {
    if (m_right === val) return;
    m_right = val;
    m_width = m_right - m_left;
  };

  /**
   *
   * @returns {Number} The y-coordinate of the rectangle's bottom edge.
   */
  this.bottom = function () {
    return m_bottom;
  };

  /**
   * Sets the bottom edge of the rectangle to the given y coordinate.
   *
   * May change the height, but will never change the top edge of the rectangle.
   * @param {Number} val Value
   */
  this.setBottom = function (val) {
    if (m_bottom === val) return;
    m_bottom = val;
    m_height = m_bottom - m_top;
  };

  /**
   *
   * @returns {Number} The width of the rectangle.
   */
  this.width = function () {
    return m_width;
  };

  /**
   *
   * @returns {Number} The height of the rectangle.
   */
  this.height = function () {
    return m_height;
  };
};

/**
 * Sets the width of the rectangle to the given width.
 *
 * The right edge is changed, but not the left one.
 * @param {Number} val Value
 */
Misc.Rect.prototype.setWidth = function (val) {
  if (this.width() === val) return;
  //m_width = val;
  //m_right = m_left + m_width;
  this.setRight(this.left() + val);
};

/**
 * A valid rectangle has a left() <= right() and top() <= bottom(). Note that non-trivial operations like intersections are not defined for invalid rectangles. A valid rectangle is not empty (i.e., isValid() == !isEmpty()).
 * @returns {Boolean} true, if the rectangle is valid, otherwise returns false.
 */
Misc.Rect.prototype.isValid = function () {
  if (this.width() <= 0 || this.height() <= 0) return false;
  return true;
};

/**
 *
 * @returns {Misc.Rect} A deep copy of the object
 */
Misc.Rect.prototype.copy = function () {
  return new Misc.Rect(this.left(), this.top(), this.width(), this.height());
};

/**
 * Sets the height of the rectangle to the given height.
 *
 * The bottom edge is changed, but not the top one.
 * @param {Number} val Value
 */
Misc.Rect.prototype.setHeight = function (val) {
  if (this.height() === val) return;
  //m_height = val;
  //m_bottom = m_top + m_height
  this.setBottom(this.top() + val);
};

/**
 * Adds dx1, dy1, dx2 and dy2 respectively to the existing coordinates of the rectangle.
 * @param {Number} dx1
 * @param {Number} dy1
 * @param {Number} dx2
 * @param {Number} dy2
 */
Misc.Rect.prototype.adjust = function (dx1, dy1, dx2, dy2) {
  this.setLeft(this.left() + dx1);
  this.setTop(this.top() + dy1);
  this.setRight(this.right() + dx2);
  this.setBottom(this.bottom() + dy2);
};

/**
 *
 * @returns {Misc.Size} The size of the rectangle.
 */
Misc.Rect.prototype.size = function () {
  return new Misc.Size(this.width(), this.height());
};

/**
 * Sets the size of the rectangle to the given size. The top-left corner is not moved.
 * @param {Misc.Size} sz size
 */
Misc.Rect.prototype.setSize = function (sz) {
  this.setWidth(sz.width);
  this.setHeight(sz.height);
  //return new Misc.Size(this.width(), this.height());
};

/**
 * Sets the coordinates of the rectangle's top-left corner to (x, y), and its size to the given width and height.
 * @param {Number} x Left
 * @param {Number} y Top
 * @param {Number} width Width
 * @param {Number} height Height
 */
Misc.Rect.prototype.setRect = function (x, y, width, height) {
  //m_left = x;
  this.setLeft(x);
  // m_top = y;
  this.setTop(y);
  // m_width = width;
  this.setWidth(width);
  // m_height = height;
  this.setHeight(height);
  // m_right = m_left + m_width;
  // m_bottom = m_top + m_height;
};

/**
 *
 * @param {Misc.Rect} rect
 * @returns {Misc.Rect} The bounding rectangle of this rectangle and the given rectangle.
 */
Misc.Rect.prototype.united = function (rect) {
  return new Misc.Rect(
    Math.min(this.left(), rect.left()),
    Math.min(this.top(), rect.top()),
    Math.max(this.right(), rect.right()) - Math.min(this.left(), rect.left()),
    Math.max(this.bottom(), rect.bottom()) - Math.min(this.top(), rect.top())
  );
};

/**
 *
 * @returns {Misc.Rect} A normalized rectangle; i.e., a rectangle that has a non-negative width and height.
 */
Misc.Rect.prototype.normalized = function () {
  //normalize the rect.
  var rc = new Misc.Rect(this.left(), this.top(), this.width(), this.height());
  if (rc.width() < 0) {
    var temp = rc.right();
    rc.setRight(rc.left());
    rc.setLeft(temp);
  }
  if (this.height() < 0) {
    var temp = rc.bottom();
    rc.setBottom(rc.top());
    rc.setTop(temp);
  }
  return rc;
};

/**
 *
 * @returns {Misc.Rect} A modified Rect based on the values of this rectangle. The coordinates in the returned rectangle are rounded to the nearest integer.
 */
Misc.Rect.prototype.toRect = function () {
  return new Misc.Rect(
    Math.round(this.left()),
    Math.round(this.top()),
    Math.round(this.width()),
    Math.round(this.height())
  );
};

/**
 *
 * @returns {Misc.Point} The center point of the rectangle.
 */
Misc.Rect.prototype.center = function () {
  return new Misc.Point(
    0.5 * (this.left() + this.right()),
    0.5 * (this.top() + this.bottom())
  );
};

//Moves the rectangle, leaving the top-left corner at
//the given position. The rectangle's size is unchanged.

/**
 * Moves the rectangle, leaving the top-left corner at the given position. The rectangle's size is unchanged.
 * @param {Misc.Point} pt
 */
Misc.Rect.prototype.moveTopLeft = function (pt) {
  var w = this.width();
  var h = this.height();
  //m_left = pt.x;
  this.setLeft(pt.x);
  //m_top = pt.y;
  this.setTop(pt.y);
  //m_right = pt.x+m_width;
  this.setRight(pt.x + w);
  //m_bottom = pt.y+m_height;
  this.setBottom(pt.y + h);
};

/**
 * Moves the rectangle, leaving the bottom-right corner at the given position. The rectangle's size is unchanged.
 * @param {Misc.Point} pt
 */
Misc.Rect.prototype.moveBottomRight = function (pt) {
  var w = this.width();
  var h = this.height();
  // m_right = pt.x;
  this.setRight(pt.x);
  // m_bottom = pt.y;
  this.setBottom(pt.y);
  // m_left = pt.x-m_width
  this.setLeft(pt.x - w);
  // m_top = pt.y-m_height;
  this.setTop(pt.y - h);
};

/**
 * Moves the rectangle, leaving the center point at the given position. The rectangle's size is unchanged.
 * @param {Misc.Point} pt
 */
Misc.Rect.prototype.moveCenter = function (pt) {
  var w = this.width();
  var h = this.height();
  // m_right = pt.x + 0.5*m_width;
  this.setRight(pt.x + 0.5 * w);
  // m_bottom = pt.y+0.5*m_height;
  this.setBottom(pt.y + 0.5 * h);
  // m_left = pt.x-0.5*m_width;
  this.setLeft(pt.x - 0.5 * w);
  // m_top = pt.y-0.5*m_height;
  this.setTop(pt.y - 0.5 * h);
  return this; //for chaining
};

/**
 *
 * @param {Misc.Rect} rect
 * @returns {Boolean} true, if this rectangle intersects with the given rectangle (i.e., there is at least one pixel that is within both rectangles), otherwise returns false.
 */
Misc.Rect.prototype.intersects = function (rect) {
  // var bres =
  //   this.contains(rect.leftTop(), false) ||
  //   this.contains(rect.rightTop(), false) ||
  //   this.contains(rect.leftBottom(), false) ||
  //   this.contains(rect.rightBottom(), false);
  // var bres1 =
  //   rect.contains(this.leftTop(), false) ||
  //   rect.contains(this.rightTop(), false) ||
  //   rect.contains(this.leftBottom(), false) ||
  //   rect.contains(this.rightBottom(), false);
  // return bres || bres1;

  var xmin = Math.max(this.left(), rect.left());
  var xmax1 = this.left() + this.width();
  var xmax2 = rect.left() + rect.width();
  var xmax = Math.min(xmax1, xmax2);

  if (xmax > xmin) {
    var ymin = Math.max(this.top(), rect.top());
    var ymax1 = this.top() + this.height();
    var ymax2 = rect.top() + rect.height();
    var ymax = Math.min(ymax1, ymax2);
    if (ymax >= ymin) {
      return true;
    }
  }
  return false;
};

/**
 *
 * @param {Misc.Rect} rect
 * @returns {Misc.Rect} The intersection of this rectangle and the given rectangle.
 */
Misc.Rect.prototype.intersected = function (rect) {
  if (
    rect.contains(new Misc.Point(this.left(), this.top()), false) ||
    rect.contains(new Misc.Point(this.right(), this.top()), false) ||
    rect.contains(new Misc.Point(this.right(), this.bottom()), false) ||
    rect.contains(new Misc.Point(this.left(), this.bottom()), false) ||
    this.contains(new Misc.Point(rect.left(), rect.top()), false) ||
    this.contains(new Misc.Point(rect.right(), rect.top()), false) ||
    this.contains(new Misc.Point(rect.right(), rect.bottom()), false) ||
    this.contains(new Misc.Point(rect.left(), rect.bottom()), false)
  ) {
    var left = Math.max(this.left(), rect.left());
    var top = Math.max(this.top(), rect.top());
    var width = Math.min(this.right() - left, rect.right() - left);
    var height = Math.min(this.bottom() - top, rect.bottom() - top);
    return new Misc.Rect(left, top, width, height);
  }
  return new Misc.Rect();
};

/**
 *
 * @param {Number} left
 * @param {Number} top
 * @param {Number} right
 * @param {Number} bottom
 * @returns {Misc.Rect} A new rectangle with left, top, right and bottom added respectively to the existing coordinates of this rectangle.
 */
Misc.Rect.prototype.adjusted = function (left, top, right, bottom) {
  var pt1 = new Misc.Point(this.left() + left, this.top() + top);
  var pt2 = new Misc.Point(this.right() + right, this.bottom() + bottom);
  return new Misc.Rect(pt1, pt2);
};

/**
 *
 * @param {Misc.Point} pt
 * @param {Boolean} proper
 * @returns {Boolean} true, if the given point is inside or on the edge of the rectangle, otherwise
 * returns false. If proper is true, this function only returns true if the given point is inside the rectangle (i.e., not on the edge).
 */
Misc.Rect.prototype.contains = function (pt, proper) {
  if (typeof proper === "undefined" || proper === true)
    return (
      pt.x > this.left() &&
      pt.y > this.top() &&
      pt.x < this.right() &&
      pt.y < this.bottom()
    );
  else
    return (
      pt.x >= this.left() &&
      pt.y >= this.top() &&
      pt.x <= this.right() &&
      pt.y <= this.bottom()
    );
};

/**
 *
 * @param {Misc.Rect} other
 * @returns {Boolean} true, if this rectangle is approximately equal to other rectangle, otherwise returns false.
 */
Misc.Rect.prototype.isEqual = function (other) {
  var otherPoint = new Misc.Point(other.left(), other.top());

  if (new Misc.Point(this.left(), this.top()).isEqual(otherPoint)) {
    var x = this.width() - other.width(),
      y = this.height() - other.height();
    return x * x + y * y < Misc.EPSILON;
  }
  return false;
};

/**
 *
 * @returns {Misc.Point} The position of the rectangle's top-left corner.
 */
Misc.Rect.prototype.leftTop = function () {
  return new Misc.Point(this.left(), this.top());
};

/**
 *
 * @returns {Misc.Point} The position of the rectangle's top-left corner.
 */
Misc.Rect.prototype.topLeft = function () {
  return this.leftTop();
};

/**
 *
 * @returns {Misc.Point} The position of the rectangle's top-right corner.
 */
Misc.Rect.prototype.rightTop = function () {
  return new Misc.Point(this.right(), this.top());
};

/**
 *
 * @returns {Misc.Point} The position of the rectangle's top-right corner.
 */
Misc.Rect.prototype.topRight = function () {
  return new Misc.Point(this.right(), this.top());
};

/**
 *
 * @returns {Misc.Point} The position of the rectangle's bottom-left corner.
 */
Misc.Rect.prototype.leftBottom = function () {
  return new Misc.Point(this.left(), this.bottom());
};

/**
 *
 * @returns {Misc.Point} The position of the rectangle's bottom-left corner.
 */
Misc.Rect.prototype.bottomLeft = function () {
  return this.rightBottom();
};

/**
 *
 * @returns {Misc.Point} The position of the rectangle's bottom-right corner.
 */
Misc.Rect.prototype.rightBottom = function () {
  return new Misc.Point(this.right(), this.bottom());
};

/**
 *
 * @returns {Misc.Point} The position of the rectangle's bottom-right corner.
 */
Misc.Rect.prototype.bottomRight = function () {
  return this.rightBottom();
};

/**
 *
 * @returns A string representing the object.
.
 */
Misc.Rect.prototype.toString = function () {
  return (
    "[" +
    this.left() +
    ", " +
    this.top() +
    ", " +
    this.width() +
    ", " +
    this.height() +
    "]"
  );
};

/**
 * An empty rectangle has width() <= 0 or height() <= 0. An empty rectangle is not valid (i.e., isEmpty() == !isValid()).
 * @returns {Boolean} true, if the rectangle is empty, otherwise returns false.
 *
 *
 */
Misc.Rect.prototype.isEmpty = function () {
  return this.width() <= 0 || this.height() <= 0;
};

/**
 *
 * @returns {Number} The x-coordinate of the rectangle's left edge. Equivalent to left().
 */
Misc.Rect.prototype.x = function () {
  return this.left();
};

/**
 *
 * @returns {Number} The y-coordinate of the rectangle's left edge. Equivalent to left().
 */
Misc.Rect.prototype.y = function () {
  return this.top();
};

/* Constructs a polygon from the given rectangle. If closed is false, the polygon just contains the four points of 
the rectangle ordered clockwise, otherwise the polygon's fifth point is set to rectangle.topLeft().

Note that the bottom-right corner of the rectangle is located at (rectangle.x() + rectangle.width(), 
rectangle.y() + rectangle.height()). */

/**
 * @classdesc A Polygon object holds an Array<Misc.Point>. You add points to the polygon with the add method.
 *
 * Constructs a polygon from the given rectangle. If closed is false, the polygon just
 * contains the four points of the rectangle ordered clockwise, otherwise the polygon's
 * fifth point is set to rectangle.topLeft().
 *
 * Note that the bottom-right corner of the rectangle is located at (rectangle.x() + rectangle.width(), rectangle.y() + rectangle.height()).
 *
 * The constructor is overloaded. See example.
 * @constructor
 * @param {Misc.Rect} [rectangle] Rectangle
 * @param {Boolean} [closed] if true, close the polygon. Defaults to false.
 * @example
 * new Misc.Polygon(); //Creates an empty polygon
 * new Misc.Polygon(new Misc.Rect(1, 2, 40, 50)); //Creates a open polygon from the rectangle
 * new Misc.Polygon(new Misc.Rect(1, 2, 40, 50), true); //Creates a close polygon from the rectangle
 */
Misc.Polygon = function (/* const QRect & */ rectangle, /*  bool  */ closed) {
  this.points = [];
  if (rectangle == undefined) {
    return;
  }
  if (close == undefined) {
    close = false;
  }
  this.points.push(
    new Misc.Point(rectangle.left(), rectangle.top()),
    new Misc.Point(rectangle.right(), rectangle.top()),
    new Misc.Point(rectangle.right(), rectangle.bottom()),
    new Misc.Point(rectangle.left(), rectangle.bottom())
  );
  if (close) {
    this.points.push(new Misc.Point(rectangle.left(), rectangle.top()));
  }
};

/**
 * Adds a point to the polygon
 * @param {Misc.Point} pt Point to add
 */
Misc.Polygon.prototype.add = function (pt) {
  this.points.push(pt);
};

/**
 *
 * @returns A string representing the object.
.
 */
Misc.Polygon.prototype.toString = function () {
  return "[Polygon]";
};

/**
 * @classdesc Specify the font face, font size, and color of text
 * @constructor
 * @param {number|object} th text height
 * @param {string} name font name
 * @param {string} style font style. Available styles are "normal", "italic", and "oblique". (This param is mostly used to specify italic text.)
 * @param {string | number} weight specify the font weight. Possible string values are "normal", "bold", "bolder" and "lighter". Possible number values are 100, 200, 300, 400, 500, 600, 700, 800, 900.
 * @param {string} color Set the color of text. The string provided should represent a valid html color.
 *
 */
Misc.Font = function (th, name, style, weight, color) {
  if (typeof th == "object") {
    this.th = th.th;
    this.name = th.name;
    this.style = th.style; //normal italic or oblique
    this.weight = th.weight; //normal lighter or bold or 100, 200, ...900
    this.fontColor = th.fontColor;
  } else {
    this.th = 12;
    this.name = "Arial";
    this.style = "normal"; //normal italic or oblique
    this.weight = "normal"; //normal lighter or bold or 100, 200, ...900
    this.fontColor = "black";
  }
  if (typeof th != "object") {
    if (typeof color !== "undefined") this.fontColor = color;
    if (typeof weight !== "undefined") this.weight = weight;
    if (typeof style !== "undefined") this.style = style;
    if (typeof name !== "undefined") this.name = name;
    if (typeof th !== "undefined") this.th = th;
  }
};

/**
 * Calculate the width and height of the text drawn with this Font and return it as a Misc.Size object.
 * @param {String} str text
 * @returns {Misc.Size} text size
 */
Misc.Font.prototype.textSize = function (str) {
  if (str == "" || typeof str == "undefined") return new Misc.Size(0, 0);
  var canvas = $("<canvas />");
  var context = canvas[0].getContext("2d");
  context.font =
    this.weight + " " + this.style + " " + this.th + "px " + this.name;

  var w = context.measureText(str).width * 1.16;
  var h = context.measureText("M").width;
  canvas.remove();
  return new Misc.Size(w, h);
};

/**
 *
 * @returns A string representing the object.
.
 */
Misc.Font.prototype.toString = function () {
  return (
    "[th:" +
    this.th +
    ", name:" +
    this.name +
    ", style:" +
    this.style +
    ", weight:" +
    this.weight +
    ", color:" +
    this.fontColor +
    "]"
  );
};

/**
 * Check fonts for equality.
 * @param {Misc.Font} otherFont font
 * @returns {Boolean} true, if otherFont is equal to this font
 */
Misc.Font.prototype.isEqual = function (otherFont) {
  return this.toString() == otherFont.toString();
};

/**
 * @classdesc MPathElement is use to define a MPath.
 *
 * Possible element types are:
 * - Misc.MoveToElement
 * - Misc.LineToElement
 * - Misc.CurveToElement
 * - Misc.CurveToDataElement
 * @constructor
 * @param {Number} [elementType]
 * @param {Number} [xVal]
 * @param {Number} [yVal]
 *
 */
Misc.MPathElement = function (elementType, xVal, yVal) {
  this.type = Misc.MoveToElement;
  this.x = 0.0;
  this.y = 0.0;
  if (typeof xVal !== "undefined") this.x = xVal;
  if (typeof yVal !== "undefined") this.y = yVal;
  if (typeof elementType !== "undefined") this.type = elementType;
};

/**
 *
 * @returns A string representing the object.
 */
Misc.MPathElement.prototype.toString = function () {
  return (
    "[MPathElement: type(" +
    this.type +
    "), point" +
    new Misc.Point(this.x, this.y) +
    "]"
  );
};

/**
 * @classdesc MPath is use to define a SVG Path.
 * @constructor
 */
Misc.MPath = function () {
  var m_elements = [];
  this.data = {}; //useful for passing any data in path

  /**
   *
   * @returns {Array<Misc.MPathElement>} List of elements defining the path
   */
  this.elements = function () {
    return m_elements;
  };
};

/**
 *
 * @returns {Number} Number of MPathElement in the path
 */
Misc.MPath.prototype.elementCount = function () {
  return this.elements().length;
};

/**
 *
 * @param {Number} index Index
 * @returns {Misc.MPathElement} element at index
 */
Misc.MPath.prototype.elementAt = function (index) {
  if (index < 0 || index >= this.elements().length) return null;
  return this.elements()[index];
};

/**
 * Adds a MoveToElement to the path
 * @param {Number} x x - coordinate
 * @param {Number} y y - coordinate
 */
Misc.MPath.prototype.moveTo = function (x, y) {
  this.elements().push(new Misc.MPathElement(Misc.MoveToElement, x, y));
};

/**
 * Adds a LineToElement to the path
 * @param {Number} x x - coordinate
 * @param {Number} y y - coordinate
 */
Misc.MPath.prototype.lineTo = function (x, y) {
  this.elements().push(new Misc.MPathElement(Misc.LineToElement, x, y));
};

/**
 * Builds a cubic curve for the path from three Misc.CurveToElement using (x, y), (x1, y1) and (x2, y2).
 * @param {Number} x x - coordinate
 * @param {Number} y y - coordinate
 * @param {Number} x1 x - coordinate
 * @param {Number} y1 y - coordinate
 * @param {Number} x2 x - coordinate
 * @param {Number} y2 y - coordinate
 */
Misc.MPath.prototype.cubicTo = function (x, y, x1, y1, x2, y2) {
  var els = this.elements();
  els.push(new Misc.MPathElement(Misc.CurveToElement, x, y));
  els.push(new Misc.MPathElement(Misc.CurveToElement, x1, y1));
  els.push(new Misc.MPathElement(Misc.CurveToElement, x2, y2));
};

/**
 *
 * @returns A string representing the object.
 */
Misc.MPath.prototype.toString = function () {
  var s = "[MPath: elementCount = " + this.elements().length + "]";
  return s;
};

/**
 *
 * @returns {Boolean} true, if the path does not have a MPathElement
 */
Misc.MPath.prototype.isEmpty = function () {
  return this.elements().length == 0 ? true : false;
};

/**
 * Adds a rectangle to the path
 * @param {Misc.Rect} rect Rect
 */
Misc.MPath.prototype.addRect = function (rect) {
  var els = this.elements();
  els.push(new Misc.MPathElement(Misc.MoveToElement, rect.left(), rect.top()));
  els.push(new Misc.MPathElement(Misc.LineToElement, rect.right(), rect.top()));
  els.push(
    new Misc.MPathElement(Misc.LineToElement, rect.right(), rect.bottom())
  );
  els.push(
    new Misc.MPathElement(Misc.LineToElement, rect.left(), rect.bottom())
  );
  els.push(new Misc.MPathElement(Misc.LineToElement, rect.left(), rect.top()));
};

/**
 * Adds a polygon to the path
 * @param {Misc.Polygon} rect Rect
 */
Misc.MPath.prototype.addPolygon = function (polygon) {
  if (!polygon || !polygon.length) return;
  this.elements().push(
    new Misc.MPathElement(Misc.MoveToElement, polygon[0].x, polygon[0].y)
  );
  for (var i = 1; i < polygon.length; ++i) {
    this.elements().push(
      new Misc.MPathElement(Misc.LineToElement, polygon[i].x, polygon[i].y)
    );
  }
};

/**
 * Adds a MPathElement to the path
 * @param {MPathElement} pathElement
 */
Misc.MPath.prototype.addPathElement = function (pathElement) {
  this.elements().push(pathElement);
};

/**
 *
 * @returns {Misc.Rect} Bounding rectagle of the path
 */
Misc.MPath.prototype.boundingRect = function () {
  var pts = [];

  var left = 0;
  var top = 0;
  var right = 0;
  var bottom = 0;
  var firstPass = false;

  for (var i = 0; i < this.elements().length; i++) {
    var element = this.elements()[i];

    switch (element.type) {
      case Misc.LineToElement:
      case Misc.MoveToElement:
      case Misc.CurveToElement: {
        if (!firstPass) {
          left = element.x;
          top = element.y;
          right = element.x;
          bottom = element.y;
          firstPass = true;
        }
        left = Math.min(left, element.x);
        right = Math.max(right, element.x);
        top = Math.min(top, element.y);
        bottom = Math.max(bottom, element.y);
        break;
      }
      case Misc.CurveToDataElement: {
        break;
      }
    }
  }

  if (this.data.rotation == undefined || this.data.rotation == 0) {
    return new Misc.Rect(left, top, right - left, bottom - top);
  }

  let theta = this.data.rotation;

  theta = (theta * Math.PI) / 180; //in radians

  let w = right - left;
  let h = bottom - top;

  let newHeight = Math.abs(w * Math.sin(theta)) + Math.abs(h * Math.cos(theta));

  let newWidth = Math.abs(h * Math.sin(theta)) + Math.abs(w * Math.cos(theta));
  return new Misc.Rect(
    left - (newWidth - w) / 2,
    top - (newHeight - h) / 2,
    newWidth,
    newHeight
  );
};

define("miscObjects", function(){});


/**
 * The Static namespace contains miscellaneous identifiers and a few utility methods used throughout the jsQwt library.
 *
 * @namespace
 *
 * @property {} <br><h5><b>Miscellaneous_Const_Values</b></h5>
 * @property {String} NoPen="noPen"                 The color use in the buildiong of a colorless{@link Misc.Pen Pen}
 * @property {String} NoBrush="noBrush"               The color use in the buildiong of a colorless{@link Misc.Brush Brush}
 * @property {Number} _eps=1.0e-300                 The smallest positive value (epsilon)
 * @property {} <br><h5><b>Keyboard_KeyCodes</b></h5>
 * @property {Number} Key_Escape=27                 Escape key pressed
 * @property {Number} Key_Plus=107                  Plus key pressed
 * @property {Number} Key_Minus=109                 Minus key pressed
 * @property {Number} Key_Ctrl=17                   Control key pressed
 * @property {Number} Key_Shift=16                  Shift key pressed
 * @property {Number} Key_Return=13                 Return key pressed
 * @property {Number} Key_Space=32                  Space bar pressed
 * @property {Number} Key_Left=37                   Left arror key pressed
 * @property {Number} Key_Right=39                  Right arrow key pressed
 * @property {Number} Key_Up=38                    Up arrow key pressed
 * @property {Number} Key_Down=40                   Down arrow key pressed
 * @property {Number} Key_Undo=90                   Undo key pressed
 * @property {Number} Key_Redo=89                   Redo key pressed
 * @property {Number} Key_Home=36                   Home key pressed
 * @property {Number} Key_I=73                      I key pressed
 * @property {Number} Key_O=79                      O key pressed
 * @property {Number} Key_unknown=-1                Unknown key pressed
 * @property {} <br><h5><b>Bitwise_Combinable_Modifier_Flags</b></h5> <br>Example<br>To detect shift-control keys combination, use:<br><b>ShiftModifier | ControlModifier</b>
 * @property {Number} NoModifier=0x00000000         No modifier flag              (No modifier key is pressed)
 * @property {Number} ShiftModifier=0x02000000      Shift modifier flag           (Shift key on the keyboard is pressed)
 * @property {Number} ControlModifier=0x04000000    Control modifier flag         (Ctrl key on the keyboard is pressed)
 * @property {Number} AltModifier=0x08000000        Alt modifier flag             (Alt key on the keyboard is pressed)
 * @property {} <br><h5><b>Bitwise_Combinable_Alignment_Flags</b></h5>
 * @property {Number} AlignRight=1                  Align right flag
 * @property {Number} AlignLeft=2                   Align left flag
 * @property {Number} AlignBottom=4                 Align bottom flag
 * @property {Number} AlignTop=8                    Align top flag
 * @property {Number} AlignCenter=16                Align center flag
 * @property {} <br><h5><b>Mouse_Button_Ids</b></h5>
 * @property {Number} NoButton=-1                   No mouse button pressed
 * @property {Number} LeftButton=0                  Left mouse button pressed
 * @property {Number} MidButton=1                   Middle mouse button pressed
 * @property {Number} RightButton=2                 Right mouse button pressed
 * @property {} <br><h5><b>Bitwise_Combinable_Orientation_Flags</b></h5>
 * @property {Number} Horizontal=1                  Oriented horizontaly
 * @property {Number} Vertical=2                    Oriented vertically
 */
var Static = {};

math.config({ epsilon: 1e-301 });

/*Returns a sub-vector which contains elements from this vector, starting at position pos. If length is -1 (the default), all elements after pos are included; otherwise length elements (or all remaining elements if there are less than length elements) are included. */
Array.prototype.mid = function (pos, length = -1) {
  if (length == -1) return this.slice(pos + 1);
  length = Math.max(length, 0);
  return this.slice(pos, pos + length);
};

String.prototype.insertAt = function (idx, rem, str) {
  return this.slice(0, idx) + str + this.slice(idx + Math.abs(rem));
};

String.prototype.replaceAt = function (index, replacement) {
  return (
    this.substr(0, index) +
    replacement +
    this.substr(index + replacement.length)
  );
};

Array.prototype.resize = function (newSize, init = undefined) {
  while (newSize > this.length) this.push(init);
};

Array.prototype.containsPoint = function (point) {
  var self = this;
  for (var i = 0; i < self.length; ++i) {
    if (self[i].isEqual(point)) return true;
  }
  return false;
};

Static.NoPen = "noPen";
Static.NoBrush = "noBrush";
Static._eps = 1.0e-300;

Static.Horizontal = 1;
Static.Vertical = 2;

Static.NoButton = -1;
Static.LeftButton = 0;
Static.MidButton = 1;
Static.RightButton = 2;

Static.Key_Escape = 27;
Static.Key_Plus = 107;
Static.Key_Minus = 109;
Static.Key_Ctrl = 17;
Static.Key_Shift = 16;
Static.Key_Return = 13;
Static.Key_Space = 32;
Static.Key_Left = 37;
Static.Key_Right = 39;
Static.Key_Up = 38;
Static.Key_Down = 40;
Static.Key_Undo = 90;
Static.Key_Redo = 89;
Static.Key_Home = 36;
Static.Key_I = 73;
Static.Key_O = 79;
Static.Key_unknown = -1;

/**
 * No modifier key pressed
 * @constant
 * @default [0x00000000]
 *
 */
Static.NoModifier = 0x00000000;
/**A Shift key on the keyboard is pressed.
 *
 * @constant
 * @default [0x02000000]
 *
 */
Static.ShiftModifier = 0x02000000;
/**
 * A Ctrl key on the keyboard is pressed.
 * @constant
 * @default  [0x04000000]
 */
Static.ControlModifier = 0x04000000; //
/**
 * An Alt key on the keyboard is pressed.
 * @constant
 * @default  [0x08000000]
 */
Static.AltModifier = 0x08000000;

Static.AlignRight = 1;
Static.AlignLeft = 2;
Static.AlignBottom = 4;
Static.AlignTop = 8;
Static.AlignCenter = 16;

/**
 * A function to execute when the event is triggered. The value false is also allowed as a shorthand
 * for a function that simply does return false.
 * @callback EventHandler
 * @param {Event} eventObject
 * @param {any} [extraParameter]
 * @param {...any} param
 * @returns {void}
 */

/**
 * Attach an event handler function for one or more events to the window element.
 * @param {string} events One or more space-separated event types and optional namespaces, such as "click" or "keydown.myPlugin".
 * @param {string} [selector] A selector string to filter the descendants of the selected elements that trigger the event. If the selector is null or omitted, the event is always triggered when it reaches the selected element.
 * @param {any} [data] Data to be passed to the handler in event.data when an event is triggered.
 * @param {EventHandler} handler A function to execute when the event is triggered. The value false is also allowed as a shorthand for a function that simply does return false.
 */
Static.bind = function (events, selector, data, handler) {
  $(window).off(events, selector, handler).on(events, selector, data, handler);
};

/**
 * Removes an event handler.
 * @param {string} events One or more space-separated event types and optional namespaces, or just namespaces, such as "click", "keydown.myPlugin", or ".myPlugin".
 * @param {string} [selector] A selector which should match the one originally passed to .on() when attaching event handlers.
 * @param {EventHandler} [handler] A handler function previously attached for the event(s), or the special value false.
 */
Static.unbind = function (events, selector, handler) {
  $(window).off(events, selector, handler);
};

/**
 * Execute all handlers and behaviors attached to the window element for the given event type.
 * @param {string} events A string containing a JavaScript event type, such as click or submit.
 * @param {...any} param Additional parameters to pass along to the event handler.
 */
Static.trigger = function (events, param) {
  $(window).trigger(events, param);
};

Static.stopkeyPressPropagation = function (element) {
  element.keydown(function (event) {
    event.stopPropagation();
  });
};

Static.onHtmlElementResize = function (dom_elem, callback) {
  const resizeObserver = new ResizeObserver(() => callback());
  resizeObserver.observe(dom_elem);
};

/**
 *
 * @returns {boolean} true / false
 */
Static.isMobile = function () {
  return (
    /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino|android|ipad|playbook|silk/i.test(
      navigator.userAgent || navigator.vendor || window.opera
    ) ||
    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
      (navigator.userAgent || navigator.vendor || window.opera).substr(0, 4)
    )
  );
};

Static.trigKeywords = [
  "asinh",
  "acosh",
  "atanh",
  "acoth",
  "asech",
  "acsch",
  "asin",
  "acos",
  "atan",
  "acot",
  "asec",
  "acsc",
  "sinh",
  "cosh",
  "tanh",
  "coth",
  "sech",
  "csch",
  "sin",
  "cos",
  "tan",
  "sec",
  "csc",
  "cot",
];

Static.keywords = [
  "unaryMinus",
  "sqrt",
  "nthRoot",
  "asinh",
  "acosh",
  "atanh",
  "acoth",
  "asech",
  "acsch",
  "asin",
  "acos",
  "atan",
  "acot",
  "asec",
  "acsc",
  "sinh",
  "cosh",
  "tanh",
  "coth",
  "sech",
  "csch",
  "sin",
  "cos",
  "tan",
  "sec",
  "csc",
  "cot",
  "ln",
  "log",
  // "log2",
  // "log3",
  // "log4",
  // "log5",
  // "log6",
  // "log7",
  // "log8",
  // "log9",
  // "log10",
  "deg",
  "pi",
  "PI",
  "e",
  // "E",
  "abs",
  "mod",
]; //"deg" comes before "e", deliberately.

///Prevent default right click menu
$("body").on("contextmenu", function (e) {
  e.preventDefault();
});

Static.enableRightClickLight = function (el) {
  el.addEventListener("contextmenu", Static.bringBackDefault, true);
};

Static.bringBackDefault = function (event) {
  event.returnValue = true;
  typeof event.stopPropagation === "function" && event.stopPropagation();
  typeof event.cancelBubble === "function" && event.cancelBubble();
};

Static.enableContextMenu = function (el) {
  void (el.ondragstart = null);
  void (el.onselectstart = null);
  void (el.onclick = null);
  void (el.onmousedown = null);
  void (el.onmouseup = null);
  void (el.oncontextmenu = null);
  Static.enableRightClickLight(el);
};

Static.dicontinuityFactor = 1e6;
Static.dicontinuityOffsetFactor = 2 / Static.dicontinuityFactor; //8e6;

Static.negativeRoot = false;
Static.aspectRatioOneToOne = false;

Static.swapAxes = 0; //0 == Implict, 1==Do not swap and 2 == swap

Static.uniqueParameter = false;

Static.animationDuration_Moderate = 4000;
Static.animationDuration_Slow = Static.animationDuration_Moderate * 2;
Static.animationDuration_Fast = Static.animationDuration_Moderate / 2;

Static.animationDuration = Static.animationDuration_Moderate;

Static.dicontinuityUserSetting = false;

Static.userDecimalPlacesForCalculation = false;

Static.showTooltipLegend = true;

//Change types used in steps (working)
Static.operation = 0;
Static.constructEquation = 1;
Static.rearrangeEquation = 2;
Static.solveEquation = 3;

////////////////////////////////////////////////
;
define("static", ["miscObjects"], function(){});

"include ['static', 'modalDlg']";

class DefinesDlg extends ModalDlg {
  constructor(defines, editor) {
    const options = {
      title: "Defines",
      spaceRows: true,
      dialogSize: "modal-md",
    };
    super(options);
    const self = this;

    //Modal body code
    this.addRow([
      '<div class="col-md-1">Name:</div>',
      '<div class="col-md-5">\
      <input id="definesName" type="text" style="width:100%">\
      </input>\
      </div>',
      '<div class="col-md-1">Value:</div>',
      '<div class="col-md-5">\
      <input id="definesValue" type="text" style="width:100%">\
      </input>\
      </div>',
    ]);

    this.addRow([
      '<div class="col-md-12"><input id="simplify" type="checkbox" checked> <label for="simplify">Simplify expanded equation</label> \
                          </input>\
                          </div>',
    ]);

    this.addRow([
      '<div class="col-md-12"><table>\
      <tr style="border: 1px solid black">\
      <th style="border: 0px"> Name</th>\
      <th style="text-align: right; border: 0px">Value </th>\
      </tr>\
      </table>\
      <div style="position:relative; overflow: auto;height: 100px">\
      <table id="definesTable" style="border: 1px solid black">\
      <col width="15%">\
      </table>\
      </div>\
      </div>',
    ]);

    //Footer code
    this.selector("cancel").text("Close");
    this.selector("ok").hide();

    this.addFooterElement(
      '<button id="definesRemoveAll" type="button" class="btn btn-default" >Remove All</button>'
    );

    this.addFooterElement(
      '<button id="definesRemove" type="button" class="btn btn-default" >Remove</button>'
    );

    this.addFooterElement(
      '<button id="definesAdd" type="button" class="btn btn-default" >Add</button>'
    );

    this.addFooterElement(
      '<select name="uploadDefinesType" id="uploadDefinesType" style="margin:4px"><option value="loadFromLocalFs">from Local System</option><option value="loadFromMongoFs">from Mongo System</option></select>'
    );

    this.addFooterElement(
      '<label>\
      <input id="definesUpload" type="file" style="display: none;" name="files[]" multiple />\
      </label>'
    );

    this.addFooterElement(
      '<button id="definesUploadButton" type="button" class="btn btn-default">\
  Load\
  </button>'
    );

    this.addHandler("definesUploadButton", "click", function () {
      if (self.selector("uploadDefinesType").val() === "loadFromLocalFs") {
        self.selector("definesUpload").trigger("click");
      } else {
        editor.openFile();
      }
    });

    function setRemoveButtonAttribute() {
      var define = defines.hasDefine(self.selector("definesName").val());
      if (!define) {
        self.selector("definesRemove").attr("disabled", true);
        self.selector("definesRemoveAll").attr("disabled", true);
      } else {
        self.selector("definesRemove").attr("disabled", false);
        self.selector("definesRemoveAll").attr("disabled", false);
      }
    }

    this.doAdd = function (name, value) {
      name = name.replace(/\s/g, "");
      value = value.replace(/\s/g, "");
      var define = defines.getDefine(name);
      if (define) {
        defines.define(name, value); //update
        let _name = name
          .replaceAll("(", "openPar")
          .replaceAll(")", "closePar")
          .replaceAll("'", "prime");

        $("#" + _name)[0].children[1].innerText = value;
        //self.closeDlg();
      } else {
        defines.define(name, value);
        self.selector("definesRemoveAll").attr("disabled", false);
        let id = name
          .replaceAll("(", "openPar")
          .replaceAll(")", "closePar")
          .replaceAll("'", "prime");
        //id = id.replace(")", "closePar");
        const m_row = $(
          `<tr id= ${id} style="border: 1px solid black"><td style="border: 1px solid black"> ${name} </td><td>  ${value} </td></tr>`
        );
        self.selector("definesTable").append(m_row);
      }
      self.selector("definesName").val("");
      self.selector("definesValue").val("");
      self.selector("definesName").focus();
      self.selector("definesAdd").attr("disabled", true);
      self.selector("definesRemove").attr("disabled", true);
    };

    this.addHandler("definesUpload", "change", function (evt) {
      var files = evt.target.files; // FileList object
      defines.upload(files);
    });

    this.addHandler("definesAdd", "click", function () {
      var name = self.selector("definesName").val();
      var error = defines.validateDefineName(
        self.selector("definesName").val()
      );
      if (error.errorType == Defines.DefineError.start) {
        alert('Define name,"' + name + '", must start with alpha character.');
        self.selector("definesName").val("");
        if (defines.definesSize()) {
          self.selector("definesRemoveAll").attr("disabled", false);
        }
        return;
      }
      if (error.errorType == Defines.DefineError.contain) {
        alert(
          'Define name,"' +
            name +
            '", contains, or is part of, the earlier define.'
        );
        self.selector("definesName").val("");
        if (defines.definesSize()) {
          self.selector("definesRemoveAll").attr("disabled", false);
        }
        return;
      }
      if (error.errorType == Defines.DefineError.keyword) {
        alert(
          'Define name,"' + name + '", contains "' + error.name + '" keyword!'
        );
        self.selector("definesName").val("");
        if (defines.definesSize()) {
          self.selector("definesRemoveAll").attr("disabled", false);
        }
        return;
      }
      var value = self.selector("definesValue").val();
      self.doAdd(name, value);
    });

    this.addHandler("definesName", "input", function (e) {
      if (
        self.selector("definesName").val().length &&
        _.isString(self.selector("definesName").val())
      ) {
        var define = defines.getDefine(self.selector("definesName").val());
        if (define) self.selector("definesValue").val(define);
      }
      if (!self.selector("definesName").val().length) {
        self.selector("definesValue").val("");
      }
      if (
        self.selector("definesName").val().length &&
        _.isString(self.selector("definesName").val()) &&
        self.selector("definesValue").val().length &&
        _.isString(self.selector("definesValue").val())
      ) {
        setRemoveButtonAttribute();
        self.selector("definesAdd").attr("disabled", false);
      } else {
        self.selector("definesAdd").attr("disabled", true);
        self.selector("definesRemove").attr("disabled", true);
        self.selector("definesRemoveAll").attr("disabled", true);
      }
    });

    this.addHandler("definesValue", "input", function (e) {
      if (
        self.selector("definesName").val().length &&
        _.isString(self.selector("definesName").val()) &&
        self.selector("definesValue").val().length &&
        _.isString(self.selector("definesValue").val())
      ) {
        setRemoveButtonAttribute();
        self.selector("definesAdd").attr("disabled", false);
      } else {
        self.selector("definesAdd").attr("disabled", true);
        self.selector("definesRemove").attr("disabled", true);
        self.selector("definesRemoveAll").attr("disabled", true);
      }
    });

    this.addHandler("definesRemove", "click", function () {
      let id = self.selector("definesName").val();
      id =
        "#" +
        id
          .replaceAll("(", "openPar")
          .replaceAll(")", "closePar")
          .replaceAll("'", "prime");
      //var id = "#" + self.selector("definesName").val();
      defines.removeDefine(self.selector("definesName").val());
      if (!defines.definesSize()) {
        self.selector("definesRemove").attr("disabled", true);
        self.selector("definesRemoveAll").attr("disabled", true);
        self.selector("definesAdd").attr("disabled", true);
      }
      $(id).remove();
      self.selector("definesName").val("");
      self.selector("definesValue").val("");
      self.selector("definesName").focus();
      self.selector("definesRemove").attr("disabled", true);
      self.selector("definesAdd").attr("disabled", true);
    });

    this.addHandler("definesRemoveAll", "click", function () {
      defines.defineNames().forEach(function (key) {
        let _id = key
          .replaceAll("(", "openPar")
          .replaceAll(")", "closePar")
          .replaceAll("'", "prime");
        //_id = _id.replace(")", "closePar");
        var id = "#" + _id;
        $(id).remove();
      });
      self.selector("definesRemoveAll").attr("disabled", true);
      self.selector("definesRemove").attr("disabled", true);
      defines.removeAllDefines();
    });

    this.addHandler("simplify", "click", function () {
      defines.simplify($(this)[0].checked);
    });

    this.defineDlgInit = function () {
      self.selector("definesAdd").attr("disabled", true);
      // self.selector("definesRemove").attr("disabled", true);
      // self.selector("definesRemoveAll").attr("disabled", true);
      if (!defines.definesSize()) {
        self.selector("definesRemoveAll").attr("disabled", true);
        self.selector("definesRemove").attr("disabled", true);
      }

      const rows = self.selector("definesTable").find("TR");

      for (let index = 0; index < rows.length; index++) {
        const row = rows[index];
        const rowId = row.id
          .replaceAll("openPar", "(")
          .replaceAll("closePar", ")")
          .replaceAll("prime", "'");
        if (!defines.hasDefine(rowId)) {
          $("#" + row.id).remove();
        }
      }
    };
  }

  initializeDialog() {
    this.defineDlgInit();
  }
}

class Defines {
  constructor() {
    let self = this;
    let m_defines = new Map();
    //let keywordMarkers = [];
    let m_simplify = true;

    /* function replaceKeywordMarkers(str) {
      for (var i = 0; i < keywordMarkers.length; ++i) {
        while (str.indexOf(keywordMarkers[i].marker) != -1) {
          str = str.replace(
            keywordMarkers[i].marker,
            keywordMarkers[i].keyword
          );
        }
      }
      keywordMarkers = [];
      return str;
    }

    function purgeAndMarkKeywords(str) {
      for (var i = 0; i < Static.keywords.length; ++i) {
        while (str.indexOf(Static.keywords[i]) != -1) {
          var _marker = "%" + keywordMarkers.length + "%";
          str = str.replace(Static.keywords[i], _marker);
          keywordMarkers.push({ marker: _marker, keyword: Static.keywords[i] });
        }
      }
      return str;
    } */

    function getParenthesizeDefine(name) {
      if (m_defines.has(name)) {
        return "(" + m_defines.get(name) + ")";
      }
      console.warn('"' + name + '"' + " is not predefined!");
      return "";
    }

    this.simplify = function (on) {
      m_simplify = on;
    };

    this.validateDefineName = function (_name) {
      let c = _name[0].toLowerCase().charCodeAt(0);
      if (!(c > 96 && c < 122)) {
        return { errorType: Defines.DefineError.start, name: _name };
      }
      var earlier = m_defines.has(_name);
      if (earlier) {
        return { errorType: Defines.DefineError.contain, name: earlier };
      }
      var keyword = Utility.containsKeyword(_name);
      if (keyword) {
        return { errorType: Defines.DefineError.keyword, name: keyword };
      }
      return { errorType: Defines.DefineError.noError, name: _name };
    };

    this.define = function (_name, _value) {
      m_defines.set(_name, _value);
    };

    /* function derivativeOrder(name) {
      let order = 0;
      name = name.trim();
      if (
        name.length < 4 ||
        name.indexOf("(") == -1 ||
        name.indexOf(")") == -1
      ) {
        return 0;
      }
      for (let i = 1; i < name.length; i++) {
        if (name[i] !== "'") {
          break;
        }
        order++;
      }
      return order;
    } */

    function getFunctionDeclarationArgument(str) {
      const ind = str.indexOf("(");
      if (ind == -1) return null;
      const startIndex = ind + 1;
      let res = "(";
      let par = 1;
      for (let i = startIndex; i < str.length; i++) {
        res += str[i];
        if (str[i] == "(") par++;
        if (str[i] == "(") par--;
        if (par == 0) break;
      }
      res = res.substring(1);
      res = res.slice(0, -1);
      return res;
    }

    let counter = 0;
    function doExpandDefines(str) {
      var defined;
      var i;
      let startIndex = 0;
      let res = str.slice().replace(/\s/g, "");
      let m_res = res.slice();
      res = Utility.purgeAndMarkKeywords(res);
      m_defines.forEach(function (value, key, map) {
        if (key.indexOf("(") == -1) {
          while (res.indexOf(key) !== -1) {
            res = res.replace(
              key,
              Utility.purgeAndMarkKeywords(getParenthesizeDefine(key))
            );
          }
        } else {
          const f = key.substring(0, key.indexOf("(") + 1);
          const names = self.defineNames();

          for (let i = 0; i < names.length; i++) {
            if (names[i].indexOf(f) != -1) {
              let n = 0;

              while (res.indexOf(f, startIndex) !== -1 && n < 100) {
                startIndex = res.indexOf(f);
                n++;
                let def = getParenthesizeDefine(names[i]);
                let m_x = names[i].substring(
                  names[i].indexOf("(") + 1,
                  names[i].indexOf(")")
                );
                let subInd = 0;
                let s_par = 0;
                let o_par = false;
                for (let index = startIndex; index < m_res.length; index++) {
                  if (m_res[index] == "(") s_par++;
                  if (m_res[index] == ")") s_par--;
                  if (
                    !o_par &&
                    index > 0 &&
                    m_res[index] == "(" /*  && */
                    /* m_res[index - 1] == f[0] */
                    /* m_res[index - 1] == f[index - 1] */
                  ) {
                    o_par = true;
                  }
                  if (o_par && s_par == 0) {
                    subInd = index;
                    break;
                  }
                }
                let m_x_replacement = m_res.substring(
                  m_res.indexOf(f),
                  subInd + 1
                );
                m_x_replacement =
                  getFunctionDeclarationArgument(m_x_replacement);
                def = def.replaceAll(m_x, "(" + m_x_replacement + ")");
                res = res.replace(f + m_x_replacement + ")", def);
                m_res = res.slice();
                startIndex = 0;
              }
              break;
            }
          }
        }
      });

      /* [
  { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },
  'n1*n3 + n2*n3 -> (n1+n2)*n3',
  function (node) {
    // ... return a new node or return the node unchanged
    return node
  }
] 
[{ l: 'c1*v1', r: 'c1v1' }]
*/
      res = Utility.replaceKeywordMarkers(res);
      if (m_simplify) {
        try {
          res = math
            .simplify(res, {}, { exactFractions: false })
            .toString()
            .replace(/\s/g, "")
            .replaceAll("+-", "-")
            .replaceAll("-+", "-");
          //Replace the whitespace delimiters stripped out by simplify()
          res = res.replaceAll("mod", " mod ");
          //counter++;
          //console.log(counter, res);
          return Utility.removeUnwantedAsterisk(res);
        } catch (error) {
          //console.log(counter, res);
          Utility.alert(error, "small", "m_simplify");
          throw "MathJs throwed an error.";
          //return res;
        }
      } //else return Utility.replaceKeywordMarkers(res);
    }

    this.expandDefines = function (str) {
      let prevExpanded = str;
      str = doExpandDefines(str);
      //let prevExpanded = null;
      let n = 0;
      while (str !== prevExpanded && n < 200) {
        prevExpanded = str;
        str = doExpandDefines(str);
        n++;
      }
      return Utility.insertProductSign(str);
    };

    this.removeDefine = function (name) {
      m_defines.delete(name);
    };

    this.removeAllDefines = function () {
      m_defines.clear();
    };

    this.defineNames = function () {
      return Array.from(m_defines.keys());
    };

    this.isCharPartOfAdefine = function (c) {
      const defines = this.defineNames();
      let definesFirstChar = "";
      for (let i = 0; i < defines.length; i++) {
        definesFirstChar += defines[i][0];
      }
      return definesFirstChar.indexOf(c) != -1;
    };

    this.definesSize = function () {
      return m_defines.size;
    };

    this.hasDefine = function (name) {
      return m_defines.has(name);
    };

    this.getDefine = function (name) {
      return m_defines.get(name);
    };

    this.processUploadData = function (data) {
      var extension = data.fileName.split(".")[1];
      //console.log(extension)
      if (
        extension == "xls" ||
        extension == "xlsx" ||
        extension == "txt" ||
        extension == "def"
      ) {
        //csv
        var samples = null;
        var csvArray = null;
        if (extension == "xls" || extension == "xlsx") {
          var workbook = XLSX.read(data.content, {
            type: "binary",
          });
          //Fetch the name of First Sheet.
          var firstSheet = workbook.SheetNames[0];

          csvArray = XLSX.utils
            .sheet_to_csv(workbook.Sheets[firstSheet])
            .split("\n");
        } else {
          csvArray = data.content.split("\n");
        }
        var errorFound = false;
        for (var i = 0; i < csvArray.length; i++) {
          var row = csvArray[i].split(",");
          if (row.length !== 2) continue;
          var name = row[0];
          var value = row[1];
          if (name.length && value.length) {
            var error = self.validateDefineName(name);
            if (!errorFound && error.errorType > Defines.DefineError.noError)
              errorFound = true;
            if (error.errorType == Defines.DefineError.noError)
              $(window).trigger("defineAdded", [name, value]);
          }
        }
        if (errorFound) {
          alert(
            "One or more invalid names found or an attempt to load the same file more than once."
          );
          return -1; //error
        }
        return 0; //No error
      }
    };

    this.upload = function (files) {
      // Loop through the FileList and render image files as thumbnails.
      for (var i = 0, f; (f = files[i]); i++) {
        // Only process image files.
        var fileExtension = f.name.split(".")[1];

        if (
          fileExtension != "txt" &&
          fileExtension != "xls" &&
          fileExtension != "xlsx" &&
          fileExtension != "plt"
        ) {
          continue;
        }

        var reader = new FileReader();

        // Closure to capture the file information.
        reader.onload = (function (theFile) {
          return function (e) {
            //console.log(e)
            const result = self.processUploadData({
              fileName: theFile.name,
              content: e.target.result,
            });
          };
        })(f);

        //console.log(f)
        // Read in the image file as a data URL.
        if (fileExtension == "xls" || fileExtension == "xlsx") {
          reader.readAsBinaryString(f);
        } else {
          reader.readAsText(f);
        }
      }
    };
  }
}

Enumerator.enum("DefineError { noError= 0, start, contain, keyword }", Defines);

class MDefines extends Defines {
  constructor(plot, editor) {
    super();
    const self = this;
    this.plot = plot;

    const dlg = new DefinesDlg(this, editor);

    this.defines = function () {
      dlg.showDlg();
    };

    $(window).bind("fileOpened", function (e, data, filename, ext, editorName) {
      if (ext !== ".txt" && ext !== ".def") {
        return;
      }
      if (editorName === self.plot.definesEditor.getEditorData().name) {
        const result = self.processUploadData({
          fileName: filename,
          content: data,
        });
      }
    });

    $(window).bind("defineAdded", function (e, name, value) {
      value = self.expandDefines(value);
      dlg.doAdd(name, value);
    });
  }
}
;
define("defines", ["static","modalDlg"], function(){});

"include ['defines']";

class MFunctionDlg {
  constructor(plot) {
    let self = this;

    class Replacement {
      // our extended configuration options
      /* static config = {
        angles: "deg", // 'rad', 'deg', 'grad'
      }; */

      //static originalFunctionMap = {};

      static restore() {
        if (Replacement.originalFunctionMap["sin"] !== undefined) {
          //replaced. so restore
          let replacements = {};

          // create trigonometric functions replacing the input depending on angle config
          const fns1 = ["sin", "cos", "tan", "sec", "cot", "csc"];

          fns1.forEach(function (name) {
            const fnNumber = Replacement.originalFunctionMap[name];

            // create a typed-function which check the input types
            replacements[name] = math.typed(name, {
              number: fnNumber,
              "Array | Matrix": function (x) {
                return math.map(x, fnNumber);
              },
            });
          });

          // create trigonometric functions replacing the output depending on angle config
          const fns2 = [
            "asin",
            "acos",
            "atan",
            "atan2",
            "acot",
            "acsc",
            "asec",
          ];
          fns2.forEach(function (name) {
            const fnNumber = Replacement.originalFunctionMap[name];

            // create a typed-function which check the input types
            replacements[name] = math.typed(name, {
              number: fnNumber,
              "Array | Matrix": function (x) {
                return math.map(x, fnNumber);
              },
            });
          });

          // import all replacements into math.js, override existing trigonometric functions
          math.import(replacements, { override: true });
          Replacement.originalFunctionMap = {};
        }
      }

      static replace() {
        if (Replacement.originalFunctionMap["sin"] === undefined) {
          let replacements = {};

          // create trigonometric functions replacing the input depending on angle config
          const fns1 = ["sin", "cos", "tan", "sec", "cot", "csc"];

          fns1.forEach(function (name) {
            const fn = math[name]; // the original function
            Replacement.originalFunctionMap[name] = fn;

            const fnNumber = function (x) {
              // convert from configured type of angles to radians
              switch (Replacement.config.angles) {
                case "deg":
                  return fn((x / 360) * 2 * Math.PI);
                case "grad":
                  return fn((x / 400) * 2 * Math.PI);
                default:
                  return fn(x);
              }
            };

            // create a typed-function which check the input types
            replacements[name] = math.typed(name, {
              number: fnNumber,
              "Array | Matrix": function (x) {
                return math.map(x, fnNumber);
              },
            });
          });

          // create trigonometric functions replacing the output depending on angle config
          const fns2 = [
            "asin",
            "acos",
            "atan",
            "atan2",
            "acot",
            "acsc",
            "asec",
          ];
          fns2.forEach(function (name) {
            const fn = math[name]; // the original function
            Replacement.originalFunctionMap[name] = fn;

            const fnNumber = function (x) {
              const result = fn(x);

              if (typeof result === "number") {
                // convert to radians to configured type of angles
                switch (Replacement.config.angles) {
                  case "deg":
                    return (result / 2 / Math.PI) * 360;
                  case "grad":
                    return (result / 2 / Math.PI) * 400;
                  default:
                    return result;
                }
              }

              return result;
            };

            // create a typed-function which check the input types
            replacements[name] = math.typed(name, {
              number: fnNumber,
              "Array | Matrix": function (x) {
                return math.map(x, fnNumber);
              },
            });
          });

          // import all replacements into math.js, override existing trigonometric functions
          math.import(replacements, { override: true });
        }
      }
    }

    Replacement.config = {
      angles: "deg", // 'rad', 'deg', 'grad'
    };

    Replacement.originalFunctionMap = {};

    var m_dlg1 = $(
      '\
                <div class="modal fade" id="functionModal" role="dialog">\
                <div class="modal-dialog modal-md">\
                <div class="modal-content">\
                <div class="modal-header">\
                <button type="button" class="close" data-dismiss="modal">&times;</button>\
                <h4 class="modal-title">Curve Function</h4>\
                </div>\
                <div class="modal-body">\
                <div class="row">\
                <div class="col-sm-2">Three D:</div>\
                <div class="col-sm-1"><input id="fnDlg_threeD" type="checkbox"/></div>\
                <div id="threedTypeContainer">\
                <div class="col-sm-1">Type:</div>\
                <div class="col-sm-3"><select id="threeDType">\
                <option value="spectrocurve">Spectrocurve</option>\
                <option value="spectrogram">Spectrogram</option>\
                </select>\
                </div>\
                <div id="interpolationContainer">\
                <div class="col-sm-2">Interpolation:</div>\
                <div class="col-sm-3"><select id="interpolationType">\
                <option value="biLinear">Bi-linear</option>\
                <option value="biCubic">Bi-cubic</option>\
                </select>\
                </div>\
                </div>\
                </div>\
                </div>\
                <br>\
                <!--div class="row"-->\
                <!--div class="col-sm-2">Curve title:</div-->\
                <!--div class="col-sm-10"><input id="fnDlg_title" style="width:100%" type="text" value="curve_1"/></div-->\
                <!--div id="fx" class="col-sm-1">f(x):</div-->\
                <!--div class="col-sm-5"><input id="fnDlg_function" style="width:85%" type="text" value="x^2"><button id="equationEditor" style="width:15%"><img style="width:100%" src="images/function.png"></img></button></input></div-->\
                <!--div class="col-sm-7"><math-field id="fnDlg_function" style="width:91%; font-size: 20px; border-style: solid; border-width: 1px;" value="x^2"></math-field><button id="equationEditor" style="position:absolute; top:0px; right:15px; width:30px; height:100%;"><img style="width:100%" src="images/function.png"></img></button></div-->\
                <!--div class="col-sm-7"><math-field id="fnDlg_function2" style="font-size: 20px; border-style: solid; border-width: 1px">x^2</math-field></div-->\
                <!--/div>\
                <br-->\
                <div id="limits" class="row">\
                <div class="col-sm-3">Lower limit(x):</div>\
                <div class="col-sm-3"><math-field style="font-size:1.2em;" id="fnDlg_lowerLimit" value="-10.0"/></math-field></div>\
                <div class="col-sm-3">Upper limit(x):</div>\
                <div class="col-sm-3"><math-field style="font-size:1.2em;" id="fnDlg_upperLimit" style="width:100%" value="10.0"/></math-field></div>\
                </div>\
                <!--br-->\
                <div id="limitsY" class="row">\
                <div class="col-sm-3">Lower limit(y):</div>\
                <div class="col-sm-3"><math-field style="font-size:1.2em;" id="fnDlg_lowerLimitY" style="width:100%" value="-10.0"/></math-field></div>\
                <div class="col-sm-3">Upper limit(y):</div>\
                <div class="col-sm-3"><math-field style="font-size:1.2em;" id="fnDlg_upperLimitY" style="width:100%" value="10.0"/></math-field></div>\
                </div>\
                <!--br-->\
                <div id="limitsFxy" class="row">\
                <div class="col-sm-3">Lower limit(f(xy)):</div>\
                <div class="col-sm-3"><math-field style="font-size:1.2em;" id="fnDlg_lowerLimitFxy" style="width:100%" value="0"/></math-field></div>\
                <div class="col-sm-3">Upper limit(f(xy)):</div>\
                <div class="col-sm-3"><math-field style="font-size:1.2em;" id="fnDlg_upperLimitFxy" style="width:100%" value="10.0"/></math-field></div>\
                </div>\
                <!--br-->\
                <div id="colorInterval" class="row">\
                <div class="col-sm-3">Color1(min):</div>\
                <div class="col-sm-3"><input id="fnDlg_color1" type="color" value="#008b8b"/></div>\
                <div class="col-sm-3">Color2(max):</div>\
                <div class="col-sm-3"><input id="fnDlg_color2" type="color" value="#ff0000"/></div>\
                </div>\
                <br>\
                <div class="row">\
                <div id="unboundedContainer">\
                <div class="col-sm-3">Unbounded range:</div>\
                <div class="col-sm-3"><input id="fnDlg_unboundedRange" type="checkbox"/></div>\
                </div>\
                <div class="col-sm-3">Number of points:</div>\
                <div class="col-sm-3"><input id="fnDlg_numberOfPoints" style="width:100%" type="number" min="2" value="200"/></div>\
                </div>\
                <br>\
                <div id="cont_variable" class="row">\
                <div class="col-sm-3">Enter variable(x):</div>\
                <div class="col-sm-1"><input id="fnDlg_variable" style="width:100%" type="text" value="x" /></div>\
                </div>\
                <br>\
                <div id="cont_parametric_variable" class="row">\
                <div class="col-sm-3">Enter parameter(t):</div>\
                <div class="col-sm-1"><input id="fnDlg_parametric_variable" style="width:100%" type="text" value="t" /></div>\
                </div>\
                <div id="cont_variableY" class="row">\
                <div class="col-sm-3">Enter variable(y):</div>\
                <div class="col-sm-1"><input id="fnDlg_variableY" style="width:100%" type="text" value="y" /></div>\
                </div>\
                <div class="col-sm-12">\
                  <input type="radio" id="deg" name="math_mode" value="deg" checked>\
                 <label for="deg">deg</label>\
                 <input type="radio" id="rad" name="math_mode" value="rad">\
                 <label for="rad">rad</label>\
                 <input type="radio" id="grad" name="math_mode" value="grad">\
                 <label for="grad">grad</label>\
                </div>\
                <br>\
                <br>\
                <div class="modal-footer">\
                <!--button id="fnDlg_enter" type="button" class="btn btn-default">Enter</button-->\
                <button id="fnDlg_ok" type="button" class="btn btn-default" data-dismiss="modal">Ok</button>\
                <button id="fnDlg_cancel" type="button" class="btn btn-default"  data-dismiss="modal">Close</button>\
                </div>\
                </div>\
                </div>\
                </div>\
                </div>\
                '
    );

    $("body").append(m_dlg1);

    Utility.extendGetValue($("#fnDlg_lowerLimit")[0]);
    Utility.extendGetValue($("#fnDlg_upperLimit")[0]);

    Utility.extendGetValue($("#fnDlg_lowerLimitY")[0]);
    Utility.extendGetValue($("#fnDlg_upperLimitY")[0]);

    Utility.extendGetValue($("#fnDlg_lowerLimitFxy")[0]);
    Utility.extendGetValue($("#fnDlg_upperLimitFxy")[0]);

    Replacement.replace();

    $('input[name="math_mode"]').on("change", function () {
      Replacement.config.angles = $(this).val();
    });

    function uniqueChars(str) {
      var result = [];
      str = Utility.purgeKewords(str).str;
      for (var i = 0; i < str.length; ++i) {
        if (Utility.isAlpha(str[i])) {
          if (result.indexOf(str[i]) == -1) {
            result.push(str[i]);
          }
        }
      }
      return result;
    }

    function selectorCont(index) {
      return $("#coeff_cont" + (index + 1));
    }

    function selector(index) {
      return $("#coeff" + (index + 1));
    }
    /*
        math.acos(x)	Calculate the inverse cosine of a value.
        math.acosh(x)	Calculate the hyperbolic arccos of a value, defined as acosh(x) = ln(sqrt(x^2 - 1) + x).
        math.acot(x)	Calculate the inverse cotangent of a value, defined as acot(x) = atan(1/x).
        math.acoth(x)	Calculate the hyperbolic arccotangent of a value, defined as acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2.
        math.acsc(x)	Calculate the inverse cosecant of a value, defined as acsc(x) = asin(1/x).
        math.acsch(x)	Calculate the hyperbolic arccosecant of a value, defined as acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1)).
        math.asec(x)	Calculate the inverse secant of a value.
        math.asech(x)	Calculate the hyperbolic arcsecant of a value, defined as asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x).
        math.asin(x)	Calculate the inverse sine of a value.
        math.asinh(x)	Calculate the hyperbolic arcsine of a value, defined as asinh(x) = ln(x + sqrt(x^2 + 1)).
        math.atan(x)	Calculate the inverse tangent of a value.
        math.atan2(y, x)	Calculate the inverse tangent function with two arguments, y/x.
        math.atanh(x)	Calculate the hyperbolic arctangent of a value, defined as atanh(x) = ln((1 + x)/(1 - x)) / 2.
        math.cos(x)	Calculate the cosine of a value.
        math.cosh(x)	Calculate the hyperbolic cosine of a value, defined as cosh(x) = 1/2 * (exp(x) + exp(-x)).
        math.cot(x)	Calculate the cotangent of a value.
        math.coth(x)	Calculate the hyperbolic cotangent of a value, defined as coth(x) = 1 / tanh(x).
        math.csc(x)	Calculate the cosecant of a value, defined as csc(x) = 1/sin(x).
        math.csch(x)	Calculate the hyperbolic cosecant of a value, defined as csch(x) = 1 / sinh(x).
        math.sec(x)	Calculate the secant of a value, defined as sec(x) = 1/cos(x).
        math.sech(x)	Calculate the hyperbolic secant of a value, defined as sech(x) = 1 / cosh(x).
        math.sin(x)	Calculate the sine of a value.
        math.sinh(x)	Calculate the hyperbolic sine of a value, defined as sinh(x) = 1/2 * (exp(x) - exp(-x)).
        math.tan(x)	Calculate the tangent of a value.
        math.tanh(x)	Calculate the hyperbolic tangent of a value, defined as tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1).
         */

    /*var keywords =
        ["asinh", "acosh", "atanh", "acoth", "asech", "acsch",
        "asin", "acos", "atan", "acot", "asec", "acsc",
        "sinh", "cosh", "tanh", "coth", "sech", "csch",
        "sin", "cos", "tan", "sec", "csc", "cot", "log2", "log3",  "log4", "log5", "log6", "log7", "log8", "log9", "log10", "deg",
        "pi", "PI", "e", "E"]//"deg" comes before "e", deliberately.
         */

    /* function hasKeyword(str) {
      for (var i = 0; i < Static.keywords.length; ++i) {
        while (
          str.indexOf(Static.keywords[i]) != -1 
        )
          return true;
      }
      return false;
    } */

    /* function insertProductSign(str) {
      if (hasKeyword(str)) return str;
      var result = "";
      result += str[0];
      for (var i = 1; i < str.length; ++i) {
        if (
          (Utility.isAlpha(str[i - 1]) && Utility.isAlpha(str[i])) ||
          (Utility.isAlpha(str[i - 1]) && str[i] == "(")
        ) {
          result += "*";
        }
        if (_.isFinite(str[i - 1]) && Utility.isAlpha(str[i])) {
          result += "*";
        }
        result += str[i];
      }
      return result;
    } */

    /* function replaceLogWithLog10(str) {
            var result = str;
            if (result.includes("log")) {
                if (!result.includes("log10")) {
                    result = result.replace("log", "log10");
                }
            }
            return result;
        } */

    function replaceLnWithLog(str) {
      // var result = str;
      // if (result.includes("ln")) {
      //   result = result.replace("ln", "log");
      // }
      // return result;
      return str.replaceAll("ln", "log");
    }

    function getCoeffs(fnStr) {
      var result = [];

      var fn = fnStr;

      fn = Utility.purgeKewords(fn).str;

      var indepVar = $("#fnDlg_variable").val();
      while (fn.indexOf(indepVar) != -1) fn = fn.replace(indepVar, "");
      for (var i = 0; i < fn.length; ++i) {
        if (Utility.isAlpha(fn[i])) {
          if (result.indexOf(fn[i]) == -1) {
            result.push(fn[i]);
          }
        }
      }
      return result;
    }

    function validateLimits(lowerLimit, upperLimit) {
      if (lowerLimit >= upperLimit) {
        Utility.alert(
          "Upper limit is less than Lower limit. Scale will be inverted."
        );
      }
      return true;
    }

    const options2 = {
      hideAlphas: true,
      title: "Function Editor",
      screenColor: "#fff",
      screenTextColor: "#00f",
      prettyOnly: true,
      initializeWithLastValue: true,
      validOnly: true,
      bigDialog: true,
      //operatorButtonTextColor: "red"
      //buttonImages: {xSquareImg: "img/xSquare3.png"}
      // buttonImages: {xSquareImg: "Sqr", squareRootImg: "Sqrt", xToPowYImg: "x^y"}
    };

    let editor = null;
    Static.enterButton = null;

    this.init = function (cb) {
      $("#functionModal").on("shown.bs.modal", function () {
        $("#fnDlg_ok").trigger("focus");
      });

      //$("#cont_parametric_variable").hide();
      //$("#cont_variable").hide();
      $("#cont_variableY").hide();
      $("#threedTypeContainer").hide();
      $("#colorInterval").hide();
      $("#limitsY").hide();
      $("#limitsFxy").hide();
      $("#interpolationContainer").hide();

      self.threeD = false;

      $("#fnDlg_unboundedRange").change(function () {
        if ($(this)[0].checked) {
          //$("#limits").hide();
        } else {
          //$("#limits").show();
        }
      });

      $("#fnDlg_threeD").change(function () {
        self.threeD = $(this)[0].checked;
        if (!self.threeD) {
          $("#threedTypeContainer").hide();
          $("#limitsY").hide();
          $("#limitsFxy").hide();
          $("#unboundedContainer").show();
          $("#fx").html("f(x):");
          $("#fnDlg_function").val("x^2");
          $("#colorInterval").hide();
          $("#cont_parametric_variable").show();
          $("#cont_variable").show();
        } else {
          $("#threedTypeContainer").show();
          $("#limitsY").show();
          $("#limitsFxy").show();
          $("#unboundedContainer").hide();
          $("#fx").html("f(x,y):");
          $("#fnDlg_function").val("x^2 + y^2");
          $("#colorInterval").show();
          $("#cont_parametric_variable").hide();
          $("#cont_variable").hide();
        }
        //$("#cont_variable").hide();
        //$("#cont_parametric_variable").hide();
        $("#cont_variableY").hide();
        $("#fnDlg_variable").val("x");
        $("#fnDlg_variableY").val("y");
        $("#fnDlg_function").change();
      });

      $("#threeDType").change(function () {
        if ($(this).val() == "spectrogram") {
          $("#interpolationContainer").show();
        } else {
          $("#interpolationContainer").hide();
        }
      });

      /* let functionDlgData = {
        rtti: PlotItem.RttiValues.Rtti_PlotCurve,
        lowerLimit: -15, //Number
        upperLimit: 10, //Number
        threeD: false,
        title: "MyCurve", //String
        variable: "x", //String
        fn: "x^3", //String
        expandedFn: "x^3", //String
        numOfPoints: 100, //Number
        unboundedRange: false, //Boolean
        coeffs: [], //Array
        threeDType: null, //String e.g. "spectrocurve"
        threeDInterpolationType: null, //String e.g. "bilinear"
        lowerLimitY: undefined, //Number
        upperLimitY: undefined, //Number
        lowerLimitFxy: undefined, //Number
        upperLimitFxy: undefined, //Number
        variableY: null, //String
        color1: "#008b8b", //String
        color2: "#ff0000", //String
      }; */

      function negativeRootFn() {
        let fn = [];
        if (!self.expandedFn) return fn;
        const node = math.parse(self.expandedFn);
        let filtered = node.filter(function (node) {
          return node.op === "^";
        });

        filtered = filtered.concat(
          node.filter(function (node) {
            return node.fn && node.fn.name === "sqrt";
          })
        );

        for (let i = 0; i < filtered.length; i++) {
          //console.log(filtered[i].args);
          // if (filtered[i].args[0].indexOf(self.variable) == -1) {
          //   return null;
          // }
          let rhs = filtered[i].args[1];
          if (
            rhs &&
            rhs.content &&
            rhs.content.op == "/" &&
            rhs.content.args[1].value
          ) {
            let val = rhs.content.args[1].value;
            if (val % 2 == 0) {
              let s = self.expandedFn.replace(
                filtered[i].toString(),
                `-(${filtered[i].toString()})`
              );
              //console.log(456, filtered[i].toString());
              try {
                s = math.simplify(s, {}, { exactFractions: false }).toString();
              } catch (error) {}
              //Replace the whitespace delimiters stripped out by simplify()
              fn = fn.replaceAll("mod", " mod ");
              fn.push(s);
            }
          }
          if (filtered[i].fn && filtered[i].fn.name === "sqrt") {
            let s = self.expandedFn.replace(
              filtered[i].toString().replace(/\s/g, ""),
              `-(${filtered[i].toString()})`
            );
            try {
              s = math.simplify(s, {}, { exactFractions: false }).toString();
            } catch (error) {}
            //Replace the whitespace delimiters stripped out by simplify()
            //fn = fn.replaceAll("mod", " mod "); //removed
            s = s.replaceAll("mod", " mod "); //added
            fn.push(s);
          }
        }

        return fn;
      }

      function derivativeOrder(name) {
        let order = 0;
        name = name.trim();
        if (
          name.length < 4 ||
          name.indexOf("(") == -1 ||
          name.indexOf(")") == -1
        ) {
          return 0;
        }
        for (let i = 1; i < name.length; i++) {
          if (name[i] !== "'") {
            break;
          }
          order++;
        }
        return order;
      }

      function getDerivativeDeclaration(str) {
        let ind = str.lastIndexOf("'(");
        for (let index = ind - 1; index > 0; index--) {
          if (str[index] == "'") ind--;
          else break;
        }
        if (ind == -1) return null;
        //const startIndex = str.indexOf("'") - 1;
        let res = ""; //str[ind - 1] + "'";
        for (let index = ind - 1; index < str.length; index++) {
          res += str[index];
          if (str[index] == "(") {
            ind = index;
            break;
          }
        }
        let par = 1;
        for (let i = ind + 1; i < str.length; i++) {
          res += str[i];
          if (str[i] == "(") par++;
          if (str[i] == ")") par--;
          if (par == 0) break;
        }
        return res;
      }

      function doExpandDefinesAndAdjustLogBase(fnDlgFunctionVal) {
        fnDlgFunctionVal = plot.defines.expandDefines(fnDlgFunctionVal);
        // let j = 0;
        // let prevExpanded = null;
        // while (fnDlgFunctionVal !== prevExpanded && j < 100) {
        //   j++;
        //   prevExpanded = fnDlgFunctionVal;
        //   fnDlgFunctionVal = plot.defines.expandDefines(fnDlgFunctionVal);
        // }
        return Utility.logBaseAdjust(fnDlgFunctionVal);
      }

      this.doEnter = function (closeDlg) {
        self.expandedParametricFnX = null;
        self.expandedParametricFnY = null;

        self.expandedFn = null;
        self.xIsDependentVariable = false;
        self.domainRangeRestriction = [];
        //console.log(456)
        if ($("#fnDlg_numberOfPoints").val() < 2) {
          $("#fnDlg_numberOfPoints").val(60);
          Utility.alert('"Number of points" cannot be \nless than 2');
        } else {
          ////
          Static.trigger(
            "numberOfPoints",
            parseInt($("#fnDlg_numberOfPoints").val())
          );

          const mf = $("#fnDlg_function")[0];

          //let fnDlgFunctionVal = Utility.latexToAscii(mf);
          let fnDlgFunctionVal = mf.getValue("ascii-math");

          if (!fnDlgFunctionVal) {
            return false;
          }

          //self.latex = mf.value;

          //y=x{-2<x<2}
          let domainRangeRestriction = fnDlgFunctionVal.substring(
            fnDlgFunctionVal.indexOf("{"),
            fnDlgFunctionVal.indexOf("}") + 1
          );
          fnDlgFunctionVal = fnDlgFunctionVal.replace(
            domainRangeRestriction,
            ""
          );
          //domainRangeRestriction = domainRangeRestriction.replace(/\s/g, "");
          if (
            domainRangeRestriction.length > 0 &&
            domainRangeRestriction.length < 7
          ) {
            Utility.alert(`${domainRangeRestriction} is improperly declared.`);
            return false;
          }
          self.variable = $("#fnDlg_variable").val();
          self.parametric_variable = $("#fnDlg_parametric_variable").val();
          //self.xIsDependentVariable
          if (domainRangeRestriction.length && self.variable) {
            if (!Utility.isParametricFunction(fnDlgFunctionVal)) {
              domainRangeRestriction = domainRangeRestriction
                .replaceAll("<", "")
                .replace("{", "")
                .replace("}", "")
                .split(self.variable);
            } else {
              domainRangeRestriction = domainRangeRestriction
                .replaceAll("<", "")
                .replace("{", "")
                .replace("}", "")
                .split(self.parametric_variable);
            }
            if (domainRangeRestriction.length != 2) {
              Utility.alert(
                `${domainRangeRestriction} is improperly declared.`
              );
              return false;
            }
            $("#fnDlg_lowerLimit").val(domainRangeRestriction[0]);
            $("#fnDlg_upperLimit").val(domainRangeRestriction[1]);
            self.domainRangeRestriction = domainRangeRestriction;
          }
          let arr = fnDlgFunctionVal.split("=");

          /* const mf = document.getElementById('formula');
          // Change the color and size of the first two characters of the mathfield
          mf.applyStyle({color: "red", fontSize: 7 }, { range: [0, 2] });

          To remove a style, set the value of the fontFamily, color or backgroundColor property to "none"
          mf.applyStyle({color: "none", fontSize: 7 }, { range: [0, 2] }); */

          if (arr[0].indexOf(",") == -1) {
            //not parametric
            let ind = 0;
            let lhs = "Left hand side:";
            let dotAdded = false;
            if (arr.length < 2) {
              lhs = "";
            }
            /* try {
              math.parse(arr[0]);
            } catch (error) {
              //let pos = parseInt(error.message.match(/(\d+)/)[0]) - 1;
              let pos = Utility.mathjsErrorToPosition(error.message) - 1;
              console.log(pos);
              let mfValueCpy = mf.value.slice();
              mfValueCpy = mfValueCpy.replace(/[\\\{\}]/g, "");
              //mfValueCpy = mfValueCpy.replace(/\{/g, "");
              //mfValueCpy = mfValueCpy.replace(/\}/g, "");

              const diff = mf.value.length - mfValueCpy.length;

              let ltxt = mf.value;
              //console.log(ltxt, mfValueCpy);
              ind = pos - diff < 0 ? 0 : pos - diff;

              if (mfValueCpy.length == 1) {
                dotAdded = true;
                mf.value += ".";
              }

              //mf.style.color = "red";
              mf.applyStyle({ color: "red" }, { range: [ind, ind + 1] });
              if (dotAdded) {
                mf.value = mf.value.substring(0, mf.value.length - 1);
              }
              dotAdded = false;
              return;
            } */
            try {
              let indexOf_ = arr[0].indexOf("_");
              if (indexOf_ !== -1) {
                throw { message: `${indexOf_}` };
              }
              // indexOf_ = arr[0].indexOf("~");
              // if (indexOf_ !== -1) {
              //   throw { message: `${indexOf_ + 2}` };
              // }
              math.parse(arr[0]);
              //const p = mf.computeEngine.parse(mf.value);
              //console.log(mf.getValue("ascii-math"));
            } catch (error) {
              //console.log(error.message);
              // let pos = Utility.mathjsErrorToPosition(error.message) - 1;
              // Utility.highLightErrorInMathField(mf, pos);
              Utility.displayErrorMessage(mf, error.message);
              return;
            }

            if (arr.length > 1) {
              try {
                math.parse(arr[1]);
              } catch (error) {
                //Utility.highLightErrorInMathField(mf, pos);
                Utility.displayErrorMessage(mf, error.message);

                /* console.log(pos);
                let mfValueCpy = mf.value.slice();
                mfValueCpy = mfValueCpy.replace(/\\/g, "");
                mfValueCpy = mfValueCpy.replace(/\{/g, "");
                mfValueCpy = mfValueCpy.replace(/\}/g, "");
                const diff = mf.value.length - mfValueCpy.length;

                // let ltxt = mf.value;
                // console.log(ltxt);
                ind = pos - diff < 0 ? 0 : pos - diff;
                ind = ind + arr[0].length + 1;

                // if (mfValueCpy.length == 1) {
                //   dotAdded = true;
                //   mf.value += ".";
                // }

                //mf.style.color = "red";
                mf.applyStyle({ color: "red" }, { range: [ind, ind + 1] });
                if (dotAdded) {
                  mf.value = mf.value.substring(0, mf.value.length - 1);
                }
                dotAdded = false; */
                return;
              }
            }
          }

          // const restoreColor = mf.style.color;
          // $("#fnDlg_function").on("change", function (e) {
          //   mf.style.color = "none";
          //   // mf.applyStyle({ color: "none" }, { range: [ind, ind + 1] });
          // });

          if (self.variable == "y") {
            if (arr.length !== 2 && arr[0].length != 1) {
              alert(
                "Improrper declaration. Try adding 'x=' to the start of the equation"
              );
              return false;
            }
            self.xIsDependentVariable = true;
          }
          if (arr.length == 2) {
            if (
              arr[0].length != 4 ||
              arr[0].indexOf("(") == -1 ||
              arr[0].indexOf(")") == -1
            ) {
              //console.log("Implicit");
              fnDlgFunctionVal = Utility.insertProductSign(
                fnDlgFunctionVal,
                plot.defines
              );

              var eq = nerdamer(fnDlgFunctionVal);
              var solution =
                self.variable == "y" ? eq.solveFor("x") : eq.solveFor("y");
              //console.log(y[0].toString());
              arr = [solution[0].toString()];
              fnDlgFunctionVal = arr[0];
              nerdamer.flush();
            }
          }
          if (arr.length == 2) {
            if (arr[0].length != 1) {
              if (
                arr[0].length != 4 ||
                arr[0].indexOf("(") == -1 ||
                arr[0].indexOf(")") == -1
              ) {
                Utility.alert(
                  "Invalid function declaration.\nExpected something of the form 'f(x)=X^2'."
                );
                return false;
              }
              const errorType = plot.defines.validateDefineName(
                arr[0]
              ).errorType;
              if (errorType == Defines.DefineError.start) {
                alert(
                  'Define name,"' +
                    arr[0] +
                    '", must start with alpha character.'
                );
                return false;
              }
              if (errorType == Defines.DefineError.contain) {
                alert(
                  'Define name,"' +
                    arr[0] +
                    '", contains, or is part of, the earlier define.'
                );
                return false;
              }
              if (errorType == Defines.DefineError.keyword) {
                alert(
                  'Define name,"' +
                    arr[0] +
                    '", contains "' +
                    error.name +
                    '" keyword!'
                );
                return false;
              }
              if (errorType != Defines.DefineError.noError) {
                return false;
              }
              //const val = doExpandDefinesAndAdjustLogBase(arr[1]);
              $(window).trigger("defineAdded", [arr[0], arr[1]]);
              fnDlgFunctionVal = arr[1];
            } else {
              fnDlgFunctionVal = arr[1];
            }
          }

          if (arr.length == 1) {
            let n = 0;
            while (1 && n < 100) {
              n++;

              let dec = getDerivativeDeclaration(fnDlgFunctionVal);
              if (!dec) {
                self.expandedFn =
                  self.fn =
                  fnDlgFunctionVal =
                    Utility.insertProductSign(fnDlgFunctionVal, plot.defines);

                break;
              }
              let _derivativeOrder = derivativeOrder(dec);
              //dec = dec.replace("'", "");
              let fnDec = dec.replaceAll("'", "");

              let _fnDec = fnDec[0] + "(" + self.variable + ")";
              if (!plot.defines.hasDefine(_fnDec)) {
                alert(
                  `Cannot find ${dec} before ${dec.replaceAll(
                    "'",
                    ""
                  )} is defined.`
                );
                return false;
              }
              let exp = plot.defines.expandDefines(_fnDec);
              // let j = 0;
              // while (exp.indexOf("(" + self.variable + ")") != -1 && j < 100) {
              //   j++;
              //   exp = plot.defines.expandDefines(exp);
              // }
              exp = plot.defines.expandDefines(exp);
              let arg = fnDec.substring(1);
              // if (denom.length > 3)
              //   exp = math.simplify(exp + "/" + denom).toString();

              let _derivative = exp;
              for (let index = 0; index < _derivativeOrder; index++) {
                _derivative = math
                  .derivative(_derivative, self.variable)
                  .toString();
                _derivative = _derivative.replaceAll(self.variable, arg);
              }

              fnDlgFunctionVal = fnDlgFunctionVal
                .replace(dec, "(" + _derivative + ")")
                .replace(/\s/g, "");

              $(window).trigger("defineAdded", [arr[0], fnDlgFunctionVal]);
              //console.log(456, fnDlgFunctionVal);
            }
          }
          if (!Utility.isParametricFunction(fnDlgFunctionVal)) {
            self.expandedFn = doExpandDefinesAndAdjustLogBase(fnDlgFunctionVal);

            // if (self.expandedFn.indexOf("'") !== -1) {
            if (self.expandedFn.charAt(1) === "'") {
              $(window).trigger("defineRemoved", arr[0]);
              plot.defines.removeDefine(arr[0]);

              Utility.alert(
                `You are attempting to use an unknown derivative on the right-hand-side of the equation.`
              );
              return;
            }
          } else {
            //Parametric function
            self.expandedFn = null;
            //fnDlgFunctionVal = fnDlgFunctionVal.substring(1);
            //fnDlgFunctionVal = fnDlgFunctionVal.slice(0, -1);
            // const arr = fnDlgFunctionVal.split(",");
            const obj = Utility.splitParametricFunction(fnDlgFunctionVal);
            if (!obj) {
              alert("Improperrly defined parametric function.");
              return;
            }
            let arr = [obj.operand, obj.base];
            self.expandedParametricFnX = doExpandDefinesAndAdjustLogBase(
              arr[0]
            );
            self.expandedParametricFnY = doExpandDefinesAndAdjustLogBase(
              arr[1]
            );
          }

          if (!self.threeD) {
            if (self.expandedFn) {
              if (/Infinity/.test(self.expandedFn)) {
                Utility.alert("Invalid function. Probably yields infinity.");
                return false;
              }
              self.coeffs = getCoeffs(self.expandedFn);
              self.expandedFn = replaceLnWithLog(self.expandedFn);
              if (self.coeffs.length > 5) {
                Utility.alert(
                  "Number of unknown coefficient cannot be greater than 5."
                );
                $("#cont_variable").show();
                return false;
              }
            } else if (
              self.expandedParametricFnX &&
              self.expandedParametricFnY
            ) {
              $("#cont_parametric_variable").show();
              //self.parametric_variable = $("#fnDlg_parametric_variable").val();
              self.coeffs = getCoeffs(
                (
                  self.expandedParametricFnX + self.expandedParametricFnY
                ).replaceAll(self.parametric_variable, "")
              );
              self.expandedParametricFnX = replaceLnWithLog(
                self.expandedParametricFnX
              );
              self.expandedParametricFnY = replaceLnWithLog(
                self.expandedParametricFnY
              );
              if (self.coeffs.length > 5) {
                Utility.alert(
                  "Number of unknown coefficient cannot be greater than 5."
                );
                $("#cont_variable").show();
                return false;
              }
            }
          }

          if (domainRangeRestriction.length) {
            let s = Utility.purgeAndMarkKeywords(domainRangeRestriction[0]);
            for (let index = 0; index < s.length; index++) {
              if (
                Utility.isAlpha(s[index]) &&
                !plot.defines.hasDefine(s[index])
              ) {
                if (self.coeffs.indexOf(s[index]) == -1) {
                  self.coeffs.push(s[index]);
                }
              }
            }
            domainRangeRestriction[0] = Utility.replaceKeywordMarkers(s);

            s = Utility.purgeAndMarkKeywords(domainRangeRestriction[1]);
            for (let index = 0; index < s.length; index++) {
              if (
                Utility.isAlpha(s[index]) &&
                !plot.defines.hasDefine(s[index])
              ) {
                if (self.coeffs.indexOf(s[index]) == -1) {
                  self.coeffs.push(s[index]);
                }
              }
            }
            domainRangeRestriction[1] = Utility.replaceKeywordMarkers(s);

            //console.log(domainRangeRestriction[0], domainRangeRestriction[1]);
          }

          function replaceParameterWith_1(str) {
            if (self.coeffs == undefined || self.coeffs.length == 0) return str;
            let s = Utility.purgeAndMarkKeywords(str);
            for (let i = 0; i < self.coeffs.length; i++) {
              if (s.indexOf(self.coeffs[i]) != -1) {
                s = s.replaceAll(self.coeffs[i], "(1)");
              }
            }
            return Utility.replaceKeywordMarkers(s);
          }

          try {
            // console.log(
            //   plot.defines.expandDefines($("#fnDlg_lowerLimit").val())
            // );

            self.lowerLimit = $("#fnDlg_lowerLimit")[0].getValue("ascii-math");

            $("#fnDlg_lowerLimit")[0].value = self.lowerLimit = math.evaluate(
              replaceParameterWith_1(
                plot.defines.expandDefines(self.lowerLimit)
              )
            );
            if (self.lowerLimit == undefined) {
              Utility.alert("Please enter a valid lower(x) limit.");
              return false;
            }
            var lower = Math.abs(self.lowerLimit);
            if (self.lowerLimit > 0 && lower < Math.cbrt(Static._eps)) {
              Utility.alert(
                `Absolute value of lower(x) limit must not be less than ${Math.cbrt(
                  Static._eps
                )}.`
              );
              return false;
            }
          } catch (err) {
            /* try {
              self.lowerLimit = math.evaluate(
                replaceParameterWith_1($("#fnDlg_lowerLimit").val())
              );
              if (!self.lowerLimit) {
                Utility.alert("Please enter a valid lower(x) limit.");
                return false;
              }
              var lower = Math.abs(self.lowerLimit);
              if (self.lowerLimit > 0 && lower < Math.cbrt(Static._eps)) {
                Utility.alert(
                  `Absolute value of lower(x) limit must not be less than ${Math.cbrt(
                    Static._eps
                  )}.`
                );
                return false;
              }
            } catch (err) {
              Utility.alert("Please enter a valid lower(x) limit.");
              return;
            } */
            Utility.alert("Please enter a valid lower(x) limit.");
            return false;
          }

          try {
            $("#fnDlg_upperLimit")[0].value = self.upperLimit =
              $("#fnDlg_upperLimit")[0].getValue("ascii-math");
            self.upperLimit = math.evaluate(
              replaceParameterWith_1(
                plot.defines.expandDefines(self.upperLimit)
              )
            );
            if (!self.upperLimit) {
              Utility.alert("Please enter a valid upper(x) limit.");
              return false;
            }
            var upper = Math.abs(self.upperLimit);
            if (self.upperLimit > 0 && upper < Math.cbrt(Static._eps)) {
              Utility.alert(
                `Absolute value of upper(x) limit must not be less than ${Math.cbrt(
                  Static._eps
                )}.`
              );
              return false;
            }
          } catch (err) {
            /* try {
              self.upperLimit = math.evaluate(
                replaceParameterWith_1($("#fnDlg_upperLimit").val())
              );
              if (!self.upperLimit) {
                Utility.alert("Please enter a valid upper(x) limit.");
                return false;
              }
              var upper = Math.abs(self.upperLimit);
              if (self.upperLimit > 0 && upper < Math.cbrt(Static._eps)) {
                Utility.alert(
                  `Absolute value of upper(x) limit must not be less than ${Math.cbrt(
                    Static._eps
                  )}.`
                );
                return false;
              }
            } catch (err) { */
            Utility.alert("Please enter a valid upper(x) limit.");
            return false;
            //}
          }

          self.title = $("#fnDlg_title").val();
          //self.variable = $("#fnDlg_variable").val();
          self.fn = self.expandedFn;
          //self.expandedFn = insertProductSign(expandedFn);
          self.numOfPoints = parseInt($("#fnDlg_numberOfPoints").val());

          if (!self.threeD) {
            if (self.expandedFn) {
              var uniqChars = uniqueChars(self.expandedFn);
              if (
                uniqChars.length > 0 &&
                uniqChars.indexOf($("#fnDlg_variable").val()) == -1
              ) {
                /* if(self.coeffs && self.coeffs.length){
                  for (let index = 0; index < uniqChars.length; index++) {
                    const element = uniqChars[index];
                    if(self.coeffs.indexOf(element)==-1 ){
                      
                    }
                  }
                } */
                /*  Utility.alert(
                  "Please enter a valid variable.",
                  "small",
                  "valid variable"
                );*/
                //$("#cont_variable").show();
                /*plot.defines.removeDefine(arr[0]);
                return false; */
              }
            }
            if (self.expandedParametricFnX) {
              var uniqChars = uniqueChars(self.expandedParametricFnX);
              if (
                uniqChars.length > 0 &&
                uniqChars.indexOf($("#fnDlg_parametric_variable").val()) == -1
              ) {
                /* Utility.alert(
                  "Please enter a valid parameter.",
                  "small",
                  "valid parameter"
                );
                $("#cont_parametric_variable").show();
                return false; */
              }
            }
            if (self.expandedParametricFnY) {
              var uniqChars = uniqueChars(self.expandedParametricFnY);
              if (
                uniqChars.length > 0 &&
                uniqChars.indexOf($("#fnDlg_parametric_variable").val()) == -1
              ) {
                /* Utility.alert(
                  "Please enter a valid parameter.",
                  "small",
                  "valid parameter"
                );
                $("#cont_parametric_variable").show();
                return false; */
              }
            }

            if (
              !validateLimits(
                parseFloat(self.lowerLimit),
                parseFloat(self.upperLimit)
              )
            )
              return false;
            self.unboundedRange = $("#fnDlg_unboundedRange")[0].checked;
          } else {
            //do 3d initialization
            self.threeDType = $("#threeDType").val();
            if (self.threeDType === "spectrogram") {
              self.threeDInterpolationType = $("#interpolationType").val();
            }
            try {
              $("#fnDlg_lowerLimitY")[0].value = self.lowerLimitY =
                $("#fnDlg_lowerLimitY")[0].getValue("ascii-math");
              self.lowerLimitY = math.evaluate(self.lowerLimitY);
            } catch (err) {
              Utility.alert("Please enter a valid lower(y) limit.");
              return false;
            }
            try {
              $("#fnDlg_upperLimitY")[0].value = self.upperLimitY =
                $("#fnDlg_upperLimitY")[0].getValue("ascii-math");
              self.upperLimitY = math.evaluate(self.upperLimitY);
            } catch (err) {
              Utility.alert("Please enter a valid upper(y) limit.");
              return false;
            }
            try {
              $("#fnDlg_lowerLimitFxy")[0].value = self.lowerLimitFxy = $(
                "#fnDlg_lowerLimitFxy"
              )[0].getValue("ascii-math");
              self.lowerLimitFxy = math.evaluate(self.lowerLimitFxy);
            } catch (err) {
              Utility.alert("Please enter a valid lower(f(xy)) limit.");
              return false;
            }
            try {
              $("#fnDlg_upperLimitFxy")[0].value = self.upperLimitFxy = $(
                "#fnDlg_upperLimitFxy"
              )[0].getValue("ascii-math");
              self.upperLimitFxy = math.evaluate(self.upperLimitFxy);
            } catch (err) {
              Utility.alert("Please enter a valid upper(f(xy)) limit.");
              return false;
            }
            self.variableY = $("#fnDlg_variableY").val();
            self.color1 = $("#fnDlg_color1").val();
            self.color2 = $("#fnDlg_color2").val();
          }
          cb();
          ///Determine if a negative Root curve is required and add it
          const fn = negativeRootFn();
          if (Static.negativeRoot && fn) {
            const title = self.title;
            for (let i = 0; i < fn.length; i++) {
              self.fn = self.expandedFn = fn[i];
              self.title = i + "~" + title;
              cb();
            }
          }
          if (
            self.coeffs &&
            self.coeffs.length &&
            !$("#sideBarCheckBoxId")[0].checked
          ) {
            $("#sideBarCheckBoxId").click();
          }
          if (closeDlg /*  && self.closeDlg */) {
            self.close();
          }
        } ///

        return true;
      };

      $("#fnDlg_function").on("input", function () {
        $("#fnDlg_function2").val($(this).val());
        var fn = $(this).val();
        if (!self.threeD) {
          if (uniqueChars(fn).length > 1 || fn.indexOf("x") == -1) {
            $("#cont_variable").show();
          } else {
            $("#cont_variable").hide();
          }
        } else {
          if (
            uniqueChars(fn).length > 2 ||
            fn.indexOf("x") == -1 ||
            fn.indexOf("y") == -1
          ) {
            $("#cont_variable").show();
            $("#cont_variableY").show();
          } else {
            $("#cont_variable").hide();
            $("#cont_variableY").hide();
          }
        }
      });

      //m_dlg1.detach();
    };

    this.functionDlg = function (curveName) {
      //$("body").append(m_dlg1);
      $("#functionModal").modal({
        backdrop: "static",
      });
      $("#fnDlg_title").val(curveName);
    };

    m_dlg1.on("hidden.bs.modal", function () {
      //m_dlg1.detach();
    });

    this.close = function () {
      $("#fnDlg_cancel").click();
      //m_dlg1.detach();
    };

    // const options = {
    //             hideAlphas: true,
    //             title: 'Function Editor',
    //             screenColor: "#fff",
    //             screenTextColor: "#00f",
    //             prettyOnly: true,
    //             initializeWithLastValue: true,
    //             validOnly: true,
    //             bigDialog: true,
    //             //operatorButtonTextColor: "red"
    //             //buttonImages: {xSquareImg: "img/xSquare3.png"}
    //              buttonImages: {xSquareImg: "Sqr", squareRootImg: "Sqrt", xToPowYImg: "x^y"}
    //         }

    //         //Create a second equation editor that will be trigger when a clickable html element with id 'test2' is clicked.
    //         let edlg = new EquationEditor("equationEditor", options);

    //         console.log(edlg)

    /* $(window).on(
      "equationEdited",
      function (e, asciiEquation, latexEquation, idOfTriggerElement) {
        if (idOfTriggerElement == "equationEditor") {
          console.log(
            "Ascii:" + asciiEquation,
            "\nLatex:" + latexEquation,
            "\nTriggerElement:" + idOfTriggerElement
          );
          //$("#fnDlg_function").val(asciiEquation);
          $("#fnDlg_function").val(latexEquation);
          $("#fnDlg_function").trigger("input");
        }
      }
    ); */

    //jQuery("#equationEditor").click();
  }
}
;
define("functionDlg", ["defines"], function(){});



"include ['static', 'modalDlg']";

class MCurveFitDlg extends ModalDlg {
  constructor() {
    const options = {
      title: "Curve Fitter",
      spaceRows: true,
    };
    super(options);

    let numOfSamples = 100;
    let self = this;
    let m_type = "";
    let m_retain = false;
    let m_generate = false;
    let m_initialize = false;
    let m_name = "";
    let m_color = "";
    let m_order = -1;
    let m_origin = false;
    let m_tolerance = -1;
    let m_chunksize = -1;
    let m_plot = null;
    let m_curve = null;
    let m_option = { precision: 2 };

    function getRightHandSide(fn) {
      fn = fn.replace(/\s/g, "");
      fn = fn.replace("y=", "");
      // try {
      //   fn = math.simplify(fn, {}, { exactFractions: false }).toString(); //Here
      // } catch (error) {}

      while (fn.indexOf("+ -") != -1) {
        fn = fn.replace("+ -", "- ");
      }
      //Replace the whitespace delimiters stripped out by simplify()
      fn = fn.replaceAll("mod", " mod ");
      return fn;
    }

    function residuals(observations, predictions, curve) {
      let result = [];
      for (let i = 0; i < observations.length; i++) {
        let resid = Utility.adjustForDecimalPlaces(
          observations[i][1] - predictions[i][1],
          curve.plot().axisPrecision(curve.yAxis())
        );
        result.push(
          parseFloat(
            Utility.toPrecision(
              resid,
              curve.plot().axisPrecision(curve.yAxis())
            )
          )
        );
      }
      return result;
    }

    function regress(curve, type, order, throughOrigin, option) {
      if (type == "linear" && throughOrigin) {
        type = "linearthroughorigin";
      }
      //if(!curve.fitType){
      //curve.fitType = type
      //}
      var samples = curve.data().samples();
      var points = [];
      //var point = [0, 0]
      for (var i = 0; i < samples.length; ++i) {
        points.push([samples[i].x, samples[i].y]);
      }
      let result = regression(type, points, order, option);
      result.residuals = residuals(points, result.points, curve);
      return result;
    }

    //Clear cache
    this.cleanup = function () {
      m_curve = null;
    };

    this.curveFitInfoCb = function (curve) {
      //console.log(curve.title())
      var info = "";
      if (curve.fitType == "natural") {
        info += "Fit type:Natural Spline";
      } else if (curve.fitType == "periodic") {
        info += "Fit type:Periodic Spline";
      } else if (curve.fitType == "polynomial") {
        info += "Fit type:Polynomial";
        info += "; Equation:" + curve.equation;
      } else if (curve.fitType == "exponential") {
        info += "Fit type:Exponential";
        info += "; Equation:" + curve.equation;
      } else if (curve.fitType == "logarithmic") {
        info += "Fit type:Logarithmic";
        info += "; Equation:" + curve.equation;
      } else if (curve.fitType == "power") {
        info += "Fit type:Power";
        info += "; Equation:" + curve.equation;
      } else if (curve.fitType == "weeding") {
        info += "Fit type:Weeding";
        info += "; Tolerance:" + m_tolerance;
      } else if (curve.fitType == "linear") {
        if (curve.origin) {
          info += "Fit type:Linear Through Origin";
        } else {
          info += "Fit type:Linear";
        }
        info += "; Equation:" + curve.equation;
      }
      if (curve.residuals) {
        info += "\n" + `Residuals: [${curve.residuals}]`;
      }
      return info;
    };

    // this.curveFitDlg = function () {
    //   if (!m_curve || m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
    //     return;
    //   self
    //     .selector("curveFitDlg_name")
    //     .val(Utility.generateCurveName(m_plot, m_curve.title() + "_fit"));
    //   self
    //     .selector("curveFitDlg_color")
    //     .val(Utility.colorNameToHex(m_curve.pen().color));
    // };

    /* 
    y=mx+c
    m = (12-2)/(4-2) = 5
    12 = 5*4 + c
    c = 12 - 20 = -8
    y = 5x - 8
     */

    this.curveFitDlgInit = function () {
      if (!m_curve || m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
        return;

      const ord = Math.min(m_curve.dataSize() - 1, 9);
      const prec = Math.max(Math.min(ord * 5 - 8, 12), 2);
      //console.log(prec);
      this.selector("curveFitDlg_precision").val(prec);
      self.selector("order").val(ord);

      self
        .selector("curveFitDlg_name")
        .val(Utility.generateCurveName(m_plot, m_curve.title() + "_fit"));
      self
        .selector("curveFitDlg_color")
        .val(Utility.colorNameToHex(m_curve.pen().color));

      if (m_initialize) return;
      m_initialize = true;
      self.selector("ok").removeAttr("data-dismiss");
      self.selector("cont_origin").hide();
      self.selector("cont_order").hide();
      self.selector("cont_tolerance").hide();
      self.selector("cont_chunksize").hide();

      self.selector("attributes1").hide();
      self.selector("attributes2").hide();
      self.selector("curveFitDlg_retain")[0].checked = false;
    };

    this.addRow([
      '<div class="col-sm-5">Fitter type:</div>',
      '<div class="col-sm-7">\
        <select id="curveFitDlg_type">\
          <option value="natural">Natural spline</option>\
          <option value="periodic">Periodic spline</option>\
          <option value="weeding">Weeding</option>\
          <option value="linear">Linear</option>\
          <option value="polynomial">Polynomial</option>\
          <option value="exponential">Exponential</option>\
          <option value="logarithmic">Logarithmic</option>\
          <option value="power">Power</option>\
          <option value="noFitting">No fitting</option>\
        </select>\
      </div>',
    ]);

    this.addRow(
      [
        '<div class="col-sm-7">Through origin:</div>',
        '<div class="col-sm-2"><input id="origin" type="checkbox"/></div>',
      ],
      null,
      "cont_origin"
    );

    this.addRow(
      [
        '<div class="col-sm-2">Order:</div>',
        '<div class="col-sm-3"><input id="order" type="number" style="width:100%" value="2" min="1" max="20"/></div>',
        '<div>Precision: <input id="curveFitDlg_precision" type="number" min="1" max="100" value="2" /></div>',
      ],
      null,
      "cont_order"
    );

    this.addRow(
      [
        '<div class="col-sm-5">Tolerance:</div>',
        '<div class="col-sm-4"><input id="tolerance" type="number" style="width:100%" value="10.0" min="0.0" max="200.0"/></div>',
      ],
      null,
      "cont_tolerance"
    );

    this.addRow(
      [
        '<div class="col-sm-5">Chunk size:</div>',
        '<div class="col-sm-4"><input id="chunksize" type="number" style="width:100%" value="0" min="0" /></div>',
      ],
      null,
      "cont_chunksize"
    );

    this.addRow(
      [
        '<div class="col-sm-7">Retain original curve:</div>',
        '<div class="col-sm-2"><input id="curveFitDlg_retain" type="checkbox"/></div>',
      ],
      null,
      "cont_retain"
    );

    this.addRow(
      [
        '<div class="col-sm-7">Generate points:</div>',
        '<div class="col-sm-2"><input id="curveFitDlg_generate" type="checkbox" checked/></div>',
      ],
      null,
      "cont_generate"
    );

    this.addRow(
      [
        '<div class="col-sm-6">Fitted curve name:</div>',
        '<div class="col-sm-6"><input id="curveFitDlg_name" type="text" style="width:100%"/></div>',
      ],
      null,
      "attributes1"
    );

    this.addRow(
      [
        '<div class="col-sm-6">Fitted curve color:</div>',
        '<div class="col-sm-2"><input id="curveFitDlg_color" type="color"/></div>',
      ],
      null,
      "attributes2"
    );

    this.cb = function () {
      if (m_retain) {
        var title = m_name;
        if (m_plot.findPlotCurve(title)) {
          Utility.alert(title + " already exist");
          return; //false;
        }
      }
      self.closeDlg();
      var doReplot = m_plot.autoReplot();
      m_plot.setAutoReplot(false);

      var curve = new MyCurve();
      curve.setPen(new Misc.Pen(m_color));
      curve.fn = m_curve.fn;
      curve.variable = m_curve.variable;

      curve.setAxes(m_curve.xAxis(), m_curve.yAxis());

      //curve.fitType = self.type;
      curve.origin = m_origin;
      curve.setStyle(m_curve.style());

      if (m_type == "natural" || m_type == "periodic") {
        //console.log(self.curve.data())
        curve.setData(m_curve.data());
        var splineCurveFitter = new SplineCurveFitter();
        var s = splineCurveFitter.spline();
        if (m_type == "periodic") {
          s.setSplineType(Static.SplineType.Periodic);
          //curve.fitType = "periodic spline"
        } else {
          s.setSplineType(Static.SplineType.Natural);
          //curve.fitType = "natural spline"
        }
        curve.setCurveFitter(splineCurveFitter);
        /////////Start modification//////////
        /* generate and Set Fitted XY Points */
        if (m_generate) {
          var xMap = m_plot.axisScaleDraw(m_curve.xAxis()).scaleMap();
          var yMap = m_plot.axisScaleDraw(m_curve.yAxis()).scaleMap();
          var samp = m_curve.data().samples();
          var samps = [];
          for (var i = 0; i < samp.length; i++) {
            samps.push(
              new Misc.Point(
                xMap.transform(samp[i].x),
                yMap.transform(samp[i].y)
              )
            );
          }
          samps = splineCurveFitter.fitCurve(samps);
          curve.setCurveFitter(null);
          var _samps = [];
          for (var i = 0; i < samps.length; i++) {
            _samps.push(
              new Misc.Point(
                xMap.invTransform(samps[i].x),
                yMap.invTransform(samps[i].y)
              )
            );
          }
          curve.setSamples(_samps);
        } else {
          curve.setSamples(m_curve.data().samples());
        }
        /////////end modification//////////
      } else if (m_type == "weeding") {
        curve.setData(m_curve.data());
        //curve.fn = self.curve.fn;
        var weedingCurveFitter = new WeedingCurveFitter(10);
        weedingCurveFitter.setChunkSize(parseInt(m_chunksize));
        weedingCurveFitter.setTolerance(parseInt(m_tolerance));
        curve.setCurveFitter(weedingCurveFitter);
        /////////Start modification//////////
        /* generate and Set Fitted XY Points */
        if (m_generate) {
          var xMap = m_plot.axisScaleDraw(m_curve.xAxis()).scaleMap();
          var yMap = m_plot.axisScaleDraw(m_curve.yAxis()).scaleMap();
          var samp = m_curve.data().samples();
          var samps = [];
          for (var i = 0; i < samp.length; i++) {
            samps.push(
              new Misc.Point(
                xMap.transform(samp[i].x),
                yMap.transform(samp[i].y)
              )
            );
          }
          samps = weedingCurveFitter.fitCurve(samps);
          curve.setCurveFitter(null);
          var _samps = [];
          for (var i = 0; i < samps.length; i++) {
            _samps.push(
              new Misc.Point(
                xMap.invTransform(samps[i].x),
                yMap.invTransform(samps[i].y)
              )
            );
          }
          curve.setSamples(_samps);
        } else {
          curve.setSamples(m_curve.data().samples());
        }
        /////////end modification//////////
      } else if (m_type == "noFitting") {
        curve.setData(m_curve.data());
        //curve.fn = self.curve.fn;
        //console.log(self.curve.fn)
        curve.setCurveFitter(null);
        //return
      } else {
        var regr = regress(
          m_curve,
          m_type,
          parseInt(m_order),
          m_origin,
          m_option
        );
        //var regr = regress()//CurveFitDlg.curve, parseInt(CurveFitDlg.type))
        var rc = m_curve.data().boundingRect();
        var fn = regr.string;
        // while (fn.indexOf("+ -") != -1) {
        //   fn = fn.replace("+ -", "- ");
        // }

        fn = getRightHandSide(fn).replace("ln", "log");

        // let expStr = fn[0];
        // for (let i = 1; i < fn.length; i++) {
        //   const c = fn[i];
        //   if (fn[i - 1] === "0" && Utility.isAlpha(c)) {
        //     expStr += "*";
        //     expStr += c;
        //   } else {
        //     expStr += c;
        //   }
        // }
        // fn = math.simplify(expStr, {}, { exactFractions: false }).toString();
        fn = fn
          .replaceAll(" ", "")
          .replaceAll("+-", "-")
          .replaceAll("-+", "-")
          .replaceAll("0x", "0");

        fn = math.simplify(fn, {}, { exactFractions: false }).toString();

        curve.equation = "y=" + fn;

        curve.expandedFn = curve.fn = fn; // = fn.replace('y =', '');
        curve.variable = "x";

        let functionDlgData = {};
        functionDlgData.rtti = PlotItem.RttiValues.Rtti_PlotCurve;
        functionDlgData.coeffs = [];
        functionDlgData.expandedFn = curve.expandedFn;
        functionDlgData.fn = curve.expandedFn;
        functionDlgData.lowerLimit = rc.left();
        functionDlgData.numOfPoints = numOfSamples;
        functionDlgData.threeD = false;
        functionDlgData.title = m_retain == true ? title : m_curve.title();
        functionDlgData.unboundedRange = false;
        functionDlgData.upperLimit = rc.right();
        functionDlgData.variable = "x";

        curve.functionDlgData = functionDlgData;

        //fn = fn.replace('=', '')
        const makeSamplesData = {
          fx: fn,
          lowerX: rc.left(),
          upperX: rc.right(),
          numOfSamples: numOfSamples,
        };
        var s = Utility.makeSamples(makeSamplesData);
        if (!s) return;
        curve.turningPoints = makeSamplesData.turningPoints;
        curve.residuals = regr.residuals;
        curve.setSamples(s);
      }
      //curve.attach(self.plot);//attach before detach
      if (m_retain) {
        curve.setTitle(title);
      } else {
        curve.setTitle(m_curve.title());
        m_curve.detach();
        m_curve.delete();
      }
      curve.fitType = m_type;
      /* if (m_type == "natural" || m_type == "periodic" || m_type == "weeding") {
                      if(m_generate)
                         curve.setCurveFitter(null);
                 } */
      curve.attach(m_plot);
      m_plot.setAutoReplot(doReplot);
      m_plot.autoRefresh();
      //self.close();
      //console.log(curve.curveFitter().spline().points())
    };

    this.addHandler("ok", "click", function () {
      m_type = self.selector("curveFitDlg_type").val();
      m_retain = self.selector("curveFitDlg_retain")[0].checked;
      m_generate = self.selector("curveFitDlg_generate")[0].checked;
      m_name = self.selector("curveFitDlg_name").val();
      m_color = self.selector("curveFitDlg_color").val();
      m_order = self.selector("order").val() || 1;
      m_option = {
        precision: parseInt(self.selector("curveFitDlg_precision").val()),
      };
      m_origin = self.selector("origin")[0].checked;
      m_tolerance = self.selector("tolerance").val();
      m_chunksize = self.selector("chunksize").val();
      self.cb();
    });

    this.addHandler("curveFitDlg_type", "change", function () {
      let form = "";
      //console.log($(this).val())
      if ($(this).val() == "linear") {
        self.selector("cont_origin").show();
        form = "y = mx + c";
      } else {
        self.selector("cont_origin").hide();
      }
      self.selector("cont_order").hide();
      if ($(this).val() == "polynomial") {
        // const ord = Math.min(12, m_curve.dataSize() - 1);
        // console.log("ord2", ord);
        //self.selector("order").val(ord);
        self.selector("cont_order").show();
        form = "y = aix^j ... + a0x^0";
      } /* else {
        self.selector("cont_order").hide();
      } */
      if ($(this).val() == "exponential") {
        // const ord = Math.min(12, m_curve.dataSize() - 1);
        // console.log("ord2", ord);
        //self.selector("order").val(ord);
        self.selector("cont_order").show();
        form = "y = ae^(bx)";
      } /* else {
        self.selector("cont_order").hide();
      } */
      if ($(this).val() == "logarithmic") {
        // const ord = Math.min(12, m_curve.dataSize() - 1);
        // console.log("ord2", ord);
        //self.selector("order").val(ord);
        self.selector("cont_order").show();
        form = "y = a + b ln x";
      } /* else {
        self.selector("cont_order").hide();
      } */
      if ($(this).val() == "power") {
        // const ord = Math.min(12, m_curve.dataSize() - 1);
        // console.log("ord2", ord);
        //self.selector("order").val(ord);
        self.selector("cont_order").show();
        form = "y = ax^b";
      } /* else {
        self.selector("cont_order").hide();
      } */
      if (
        $(this).val() == "natural" ||
        $(this).val() == "periodic" ||
        $(this).val() == "weeding"
      ) {
        self.selector("cont_generate").show();
      } else {
        self.selector("cont_generate").hide();
      }
      if ($(this).val() == "weeding") {
        self.selector("cont_tolerance").show();
        self.selector("cont_chunksize").show();
      } else {
        self.selector("cont_tolerance").hide();
        self.selector("cont_chunksize").hide();
      }
      if ($(this).val() !== "noFitting") {
        self.selector("cont_retain").show();
        self.selector("cont_retain").show();
        //self.selector("attributes").show();
        //self.selector("curveFitDlg_color").show();
      } else {
        self.selector("curveFitDlg_retain").prop("checked", false);
        self.selector("cont_retain").hide();
        self.selector("attributes1").hide();
        self.selector("attributes2").hide();
        //self.selector("curveFitDlg_color").hide();
      }
      self
        .selector("curveFitDlg_type")
        .attr("title", `Equation of the form "${form}".`);
    });

    this.addHandler("curveFitDlg_retain", "change", function () {
      if (!$(this)[0].checked) {
        self.selector("attributes1").hide();
        self.selector("attributes2").hide();
      } else {
        self.selector("attributes1").show();
        self.selector("attributes2").show();
      }
    });

    this.init = function () {};

    //     //Called by LegendMenu
    this.curveFitCb = function (curve) {
      m_plot = curve.plot();
      m_curve = curve;
      this.showDlg();
      //self.curveFitDlg();
    };
  }

  initializeDialog() {
    this.curveFitDlgInit();
  }

  beforeClose() {
    this.cleanup();
  }
}
;
define("curveFitDlg", ["static","modalDlg"], function(){});

"include ['modalDlg']";


class MCurveStyleDlg extends ModalDlg {
  constructor() {
    const options = {
      title: "Curve Style",
      spaceRows: true,
      //hideCancelButton: true,
    };
    super(options);
    const self = this;
    self.curve = null;
    let styleMap = {
      Lines: Curve.CurveStyle.Lines,
      Sticks: Curve.CurveStyle.Sticks,
      Steps: Curve.CurveStyle.Steps,
      Dots: Curve.CurveStyle.Dots,
      NoCurve: Curve.CurveStyle.NoCurve,
    };
    let invertedStyleMap = _.invert(styleMap);

    this.addRow([
      '<div class="col-sm-5">Curve style:</div>',
      '<div class="col-sm-7">\
        <select id="curveStyleDlgStyle">\
          <option value="Lines">Lines (Default)</option>\
          <option value="Sticks">Sticks</option>\
          <option value="Steps">Steps</option>\
          <option value="Dots">Dots</option>\
          <option value="NoCurve">NoCurve</option>\
        </select>\
      </div>',
    ]);

    this.curveStyleCb = function (curve) {
      self.curve = curve;
      if (!self.curve || self.curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
        return;
      this.showDlg();
    };

    self.addHandler("ok", "click", function () {
      var style = styleMap[self.selector("curveStyleDlgStyle").val()];
      self.curve.setStyle(style);
      Static.trigger("curveStyleChanged", self.curve);
    });

    this.init = function () {
      self
        .selector("curveStyleDlgStyle")
        .val(invertedStyleMap[self.curve.style()]);
    };
  }

  initializeDialog() {
    this.init();
  }

  beforeClose() {
    this.curve = 0;
  }
}
;
define("curveStyleDlg", ["modalDlg"], function(){});



"include ['modalDlg']";

class MAxisDlg extends ModalDlg {
  constructor() {
    const options = {
      title: "Curve Axis",
      spaceRows: true,
    };
    super(options);
    const self = this;
    let _curve = null;

    //Clear cache
    this.cleanup = function () {
      _curve = null;
    };

    this.addRow([
      '<div class="col-sm-5">Horizontal:</div>',
      '<div class="col-sm-7">\
        <select id="axisHorizontal1">\
          <option value="2">Bottom axis</option>\
          <option value="3">Top axis</option>\
        </select>\
      </div>',
    ]);

    this.addRow([
      '<div class="col-sm-5">Vertical:</div>',
      '<div class="col-sm-7">\
        <select id="axisVertical1">\
          <option value="0">Left axis</option>\
          <option value="1">Right axis</option>\
        </select>\
      </div>',
    ]);

    let hChanged = false;
    let vChanged = false;

    this.axisDlgInit = function () {
      if (_curve.xAxis() == Axis.AxisId.xBottom) {
        self.selector("axisHorizontal1").val("2");
      } else {
        self.selector("axisHorizontal1").val("3");
      }
      if (_curve.yAxis() == Axis.AxisId.yLeft) {
        self.selector("axisVertical1").val("0");
      } else {
        self.selector("axisVertical1").val("1");
      }
      self.selector("ok").prop("disabled", true);
      hChanged = false;
      vChanged = false;
    };

    this.addHandler("axisHorizontal1", "change", function () {
      if ($(this).val() == "2") {
        if (_curve.xAxis() !== Axis.AxisId.xBottom) {
          hChanged = true;
        } else {
          hChanged = false;
        }
      } else {
        if (_curve.xAxis() !== Axis.AxisId.xTop) {
          hChanged = true;
        } else {
          hChanged = false;
        }
      }
      if (vChanged || hChanged) {
        self.selector("ok").prop("disabled", false);
      } else {
        self.selector("ok").prop("disabled", true);
      }
    });

    this.addHandler("axisVertical1", "change", function () {
      if ($(this).val() == "0") {
        if (_curve.yAxis() !== Axis.AxisId.yLeft) {
          vChanged = true;
        } else {
          vChanged = false;
        }
      } else {
        if (_curve.yAxis() !== Axis.AxisId.yRight) {
          vChanged = true;
        } else {
          vChanged = false;
        }
      }
      if (vChanged || hChanged) {
        self.selector("ok").prop("disabled", false);
      } else {
        self.selector("ok").prop("disabled", true);
      }
    });

    this.addHandler("ok", "click", function () {
      const xAxis = parseInt(self.selector("axisHorizontal1").val());
      _curve.setXAxis(xAxis);
      Static.trigger("axisChanged", [xAxis, _curve]);
      const yAxis = parseInt(self.selector("axisVertical1").val());
      _curve.setYAxis(yAxis);
      Static.trigger("axisChanged", [yAxis, _curve]);
    });

    this.axisCb = function (curve) {
      _curve = curve; //The axis of this curve could be change via the dialog.
      this.showDlg();
    };
  }
  initializeDialog() {
    this.axisDlgInit();
  }

  beforeClose() {
    this.cleanup();
  }
}
;
define("axisDlg", ["modalDlg"], function(){});



"include []";

class ZoneDlg {
  constructor() {
    var self = this;
    var _plot = null;
    const dlg = $(
      '\
                        <div class="modal fade" id="zoneModal" role="dialog">\
                        <div class="modal-dialog modal-sm">\
                        <div class="modal-content">\
                        <div class="modal-header">\
                        <button type="button" class="close" data-dismiss="modal">&times;</button>\
                        <h4 class="modal-title">Zone Item</h4>\
                        </div>\
                        <div class="modal-body">\
                        <div class="row">\
                        <div class="col-sm-4">Zone title:</div>\
                        <div class="col-sm-8">\
                        <input id="zoneTitle" type="text" style="width:100%"/>\
                        </div>\
                        </div>\
                        <br>\
                        <div class="row">\
                        <div class="col-sm-5">Orientation:</div>\
                        <div class="col-sm-7">\
                        <select id="zoneOrientation" style="width:100%">\
                        <option value="Vertical">Vertical</option>\
                        <option value="Horizontal">Horizontal</option>\
                        </select>\
                        </div>\
                        </div>\
                        <br>\
                        <div class="row">\
                        <div class="col-sm-7">Horizontal axis:</div>\
                        <div class="col-sm-5">\
                        <select id="zoneHorizontalAxis" style="width:100%">\
                        <option value="Bottom">Bottom</option>\
                        <option value="Top">Top</option>\
                        </select>\
                        </div>\
                        </div>\
                        <br>\
                        <div class="row">\
                        <div class="col-sm-7">Vertical axis:</div>\
                        <div class="col-sm-5">\
                        <select id="zoneVerticalAxis" style="width:100%">\
                        <option value="Left">Left</option>\
                        <option value="Right">Right</option>\
                        </select>\
                        </div>\
                        </div>\
                        <br>\
                        \
                        \
                        <div class="row">\
                        <div id="lowerLimitLabel" class="col-sm-2">\
                        Left:\
                        </div>\
                        <div class="col-sm-4">\
                        <input id="lowerLimit" type="number" value="0" style="width:100%"/>\
                        </div>\
                        <div id="upperLimitLabel" class="col-sm-2">\
                        Right:\
                        </div>\
                        <div class="col-sm-4">\
                        <input id="upperLimit" type="number" value="1" style="width:100%"/>\
                        </div>\
                        </div>\
                        <br>\
                        \
                        \
                        <div class="row">\
                        <div class="col-sm-6">\
                        <input id="brushColor" type="color" value="#D3D3D3"> Brush</color>\
                        </div>\
                        <div class="col-sm-6">\
                        <input id="penColor" type="color" value="#000000"> Pen</color>\
                        </div>\
                        </div>\
                        <br>\
                        <div class="row">\
                        <div class="col-sm-7">Represent zone item on the legend:</div>\
                        <div class="col-sm-2"><input id="representOnLegend" type="checkbox" checked/></div>\
                        </div>\
                        </div>\
                        <br>\
                        <div class="modal-footer">\
                        <button id="zoneDlg_ok" type="button" class="btn btn-default">Ok</button>\
                        </div>\
                        </div>\
                        </div>\
                        </div>\
                        </div>\
                        '
    );

    $("body").append(dlg);

    $("#zoneModal").on("shown.bs.modal", function () {
      $("#zoneDlg_ok").trigger("focus");
    });

    $("#zoneDlg_ok").click(function () {
      if (_plot.findPlotCurve($("#zoneTitle").val())) {
        alert(`${$("#zoneTitle").val()} already exist.`);
        return;
      }

      const z = new PlotZoneItem($("#zoneTitle").val());
      z.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
      const lowerLimit = parseFloat($("#lowerLimit").val());
      const upperLimit = parseFloat($("#upperLimit").val());
      if (lowerLimit > upperLimit) {
        alert(
          `${$("#lowerLimitLabel")
            .html()
            .trim()
            .replace(":", "")} cannot be greater than ${$("#upperLimitLabel")
            .html()
            .trim()
            .replace(":", "")}. Please retry.`
        );
        return;
      }
      z.setInterval(
        parseFloat($("#lowerLimit").val()),
        parseFloat($("#upperLimit").val())
      );

      z.setAxes(
        $("#zoneHorizontalAxis").val() == "Bottom"
          ? Axis.AxisId.xBottom
          : Axis.AxisId.xTop,
        $("#zoneVerticalAxis").val() == "Left"
          ? Axis.AxisId.xLeft
          : Axis.AxisId.yRight
      );
      z.setPen(new Misc.Pen($("#penColor").val()));
      z.setBrush(new Misc.Brush($("#brushColor").val()));
      if ($("#zoneOrientation").val() == "Vertical")
        z.setOrientation(Static.Vertical);
      else z.setOrientation(Static.Horizontal);
      if ($("#representOnLegend")[0].checked)
        z.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
      z.attach(_plot);
      $("#zoneModal").modal("hide");
    });

    $("#zoneOrientation").change(function () {
      if ($(this).val() == "Vertical") {
        $("#lowerLimitLabel").html("Left:");
        $("#upperLimitLabel").html("Right:");
      } else {
        $("#lowerLimitLabel").html("Bottom:");
        $("#upperLimitLabel").html("Top:");
      }
      let ortn = "V_";
      if ($("#zoneOrientation").val() !== "Vertical") ortn = "H_";

      $("#zoneTitle").val(Utility.generateCurveName(_plot, ortn + "zone_"));
    });

    function showDlg() {
      $("#zoneModal").modal({
        backdrop: "static",
      });
    }

    this.zoneCb = function (plot) {
      $("body").append(dlg);
      _plot = plot;
      let ortn = "V_";
      if ($("#zoneOrientation").val() !== "Vertical") ortn = "H_";

      $("#zoneTitle").val(Utility.generateCurveName(plot, ortn + "zone_"));
      showDlg();
    };

    dlg.on("hidden.bs.modal", function () {
      dlg.detach();
    });

    dlg.detach();
  }
}
;
define("zoneDlg", function(){});

"include ['modalDlg']";

// class MPointEntryDlg {
//   constructor() {
//     const self = this;
//     let dlg = null;
//     let buildDlg = _.once(function () {
//       /* Remove any $("#pointEntryModal") from the DOM before appending a new one.*/
//       $("#pointEntryModal").remove();
//       dlg = $(
//         '\
//                         <div class="modal fade" id="pointEntryModal" role="dialog">\
//                         <div class="modal-dialog modal-sm">\
//                         <div class="modal-content">\
//                         <div class="modal-header">\
//                         <button type="button" class= "close" id="closePointEntryDlg">&times;</button>\
//                         <h4 id="pointEntryTitle" class="modal-title">Add/Romve Point</h4>\
//                         </div>\
//                         <div class="modal-body">\
//                         <div class="row">\
//                         </div>\
//                         <br>\
//                         <div class="row">\
//                         </div>\
//                         <br>\
//                         <div class="row">\
//                         </div>\
//                         <br>\
//                         <div class="modal-footer">\
//                         <button id="pointEntryDlg_enter" type="button" class="btn btn-default" >Add</button>\
//                         <button id="pointEntryDlg_remove" type="button" class="btn btn-default" >Remove</button>\
//                         <button id="pointEntryDlg_ok" type="button" class="btn btn-default"  data-dismiss="modal">Finish</button>\
//                         </div>\
//                         </div>\
//                         </div>\
//                         </div>\
//                         </div>\
//                         '
//       );
//       $("body").append(dlg);
//       $("#pointEntryDlg_enter").click(enterCb);
//       $("#pointEntryDlg_remove").click(removeCb);
//       $("#closePointEntryDlg").click(closeCb);
//       $("#curve_name, #abscissa, #ordinate").keyup(keyupCb);

//       $("#pointEntryDlg_remove").attr("disabled", false);
//       $("#pointEntryDlg_enter").attr("disabled", true);

//       $("#pointEntryModal").on("shown.bs.modal", function () {
//         $("#pointEntryDlg_enter").trigger("focus");
//       });
//     });
//     buildDlg();

//     this.setDlgTitle = function (title) {
//       $("#pointEntryTitle").html(title);
//       if (title == "Modify/Remove Point") {
//         $("#pointEntryDlg_enter").html("Modify");
//       } else {
//         $("#pointEntryDlg_enter").html("Add");
//       }
//     };

//     this.dlgTitle = function (title) {
//       return $("#pointEntryTitle").html();
//     };

//     this.pointEntryCb = function (dlgTitle, plot, curveName, point) {
//       //self.modify = false;
//       self.curveName = curveName;
//       self.point = point;
//       //buildDlg();
//       $("body").append(dlg);
//       self.setDlgTitle(dlgTitle);
//       if (curveName !== undefined) {
//         $("#curve_name").val(curveName);
//       }
//       if (point !== undefined) {
//         $("#abscissa").val(point.x);
//         $("#ordinate").val(point.y);
//       }
//       self.plot = plot;
//       showDlg();
//       //if (self.curveName !== undefined && self.point !== undefined) {
//       if (dlgTitle == "Modify/Remove Point") {
//         //self.modify = true;
//         //self.setDlgTitle(dlgTitle)
//         $("#curve_name").attr("disabled", true);
//         //var curve = self.plot.findPlotCurve($("#curve_name").val());
//         //if(curve && curve.data().samples().length <= 1){
//         $("#pointEntryDlg_enter").attr("disabled", true);
//         //}
//       } else {
//         //self.setDlgTitle("Add/Romve Point")
//         //self.modify = false;
//         $("#curve_name").attr("disabled", false);
//         if (
//           !findPoint(new Misc.Point($("#abscissa").val(), $("#ordinate").val()))
//         )
//           $("#pointEntryDlg_enter").attr("disabled", false);
//       }
//     };

//     dlg.on("hidden.bs.modal", function () {
//       dlg.detach();
//     });

//     function closeCb() {
//       $("#pointEntryDlg_ok").click();
//     }

//     function showDlg() {
//       /* if (!self.plot.findPlotCurve($("#curve_name").val())) {
//                 $('#pointEntryDlg_remove').attr('disabled', true);
//             } */
//       setRemoveButtonAttribute();
//       $("#pointEntryModal").modal({
//         backdrop: "static",
//       });
//     }

//     dlg.detach();
//   }
// }

class MPointEntryDlg extends ModalDlg {
  constructor() {
    const options = {
      title: "Add/Romve Point",
      spaceRows: true,
      hideCancelButton: true,
    };
    super(options);
    const self = this;

    this.addFooterElement(
      '<button id="pointEntryDlg_remove" class="btn btn-default">Remove</button>'
    );

    this.addFooterElement(
      '<button id="pointEntryDlg_enter" class="btn btn-default">Add</button>'
    );

    this.addRow([
      '<div class="col-sm-4">Name:</div>',
      '<div class="col-sm-8"><input id="curve_name" type="text" value="curve_1" style="width:100%"></div>',
    ]);

    this.addRow([
      '<div class="col-sm-4">Abscissa(X):</div>',
      '<div class="col-sm-8"><input id="abscissa" type="text" value="0.0" style="width:100%"></div>',
    ]);

    this.addRow([
      '<div class="col-sm-4">Ordinate(Y):</div>',
      '<div class="col-sm-8"><input id="ordinate" type="text" value="0.0" style="width:100%"></div>',
    ]);

    function findPoint(pt) {
      var curve = self.plot.findPlotCurve($("#curve_name").val());
      if (!curve) return false;
      var samples = curve.data().samples();
      if (samples.length > 0) {
        for (var i = 0; i < samples.length; ++i) {
          if (pt.x == samples[i].x && pt.y == samples[i].y) {
            return true;
          }
        }
      }
      return false;
    }

    function enterCb() {
      let curve = self.plot.findPlotCurve(self.selector("curve_name").val());
      if (curve) {
        //if (self.modify) {
        if (self.selector("title").html() == "Modify/Remove Point") {
          curve.removePoint(self.point, true);
          //self.plot.cs.setLimits(); //set curveShapeItem limits to undefined
          Static.trigger("curveAdjusted");
        }
      } else {
        //"Create curve"
        curve = new MyCurve(self.selector("curve_name").val());
        //curve = new MyCurve(Utility.generateCurveName(self.plot));
        //curve.attach(self.plot);
        let color = Utility.randomColor();
        curve.setPen(new Misc.Pen(color));
        let sym = new Symbol2(
          Symbol2.Style.MRect,
          new Misc.Brush(Utility.invert(color)),
          new Misc.Pen(color),
          new Misc.Size(8, 8)
        );
        curve.setSymbol(sym);
        let attribute = "";
        if (Static.showline && Static.showsymbol) {
          attribute = "lineAndSymbol";
        } else if (Static.showline) {
          attribute = "line";
        } else if (Static.showsymbol) {
          attribute = "symbol";
        }
        Utility.setLegendAttribute(curve, attribute, curve.getLegendIconSize()); //attribute = "line" or "symbol" or "lineAndSymbol"
        curve.attach(self.plot);
      }
      let samples = curve.data().samples();
      var abscissaVal = math.evaluate(
        self.plot.defines.expandDefines(self.selector("abscissa").val())
      );

      var ordinateVal = math.evaluate(
        self.plot.defines.expandDefines(self.selector("ordinate").val())
      );

      let p = new Misc.Point(abscissaVal, ordinateVal);
      self.point = p;
      if (!samples.containsPoint(p)) {
        samples.push(p);
      }
      samples.sort(function (a, b) {
        /* if(a.x < b.x) return -1;
                if(a.x > b.x) return 1;
                return 0; */
        return a.x - b.x;
      });
      curve.setSamples(samples);
      self.plot.autoRefresh();
      Static.trigger("pointAdded", curve);
      //self.plot.cs.setLimits(); //set curveShapeItem limits to undefined
      Static.trigger("curveAdjusted");
      /* We have at least one point. Ensure remove button is enabled. */
      //$('#pointEntryDlg_remove').attr('disabled', false);
      //setRemoveButtonAttribute();
      self.selector("pointEntryDlg_enter").attr("disabled", true);
      if (samples.length > 1)
        self.selector("pointEntryDlg_remove").attr("disabled", false);
    }

    function removeCb() {
      let curve = self.plot.findPlotCurve(self.selector("curve_name").val());
      curve.removePoint(
        new Misc.Point(
          parseFloat(self.selector("abscissa").val()),
          parseFloat(self.selector("ordinate").val())
        )
      );
      //self.plot.cs.setLimits(); //set curveShapeItem limits to undefined
      self.selector("pointEntryDlg_remove").attr("disabled", true);
      self.selector("pointEntryDlg_enter").attr("disabled", false);
      Static.trigger("curveAdjusted");
    }

    function keyupCb() {
      var curve = self.plot.findPlotCurve(self.selector("curve_name").val());
      var samples;
      if (curve) samples = curve.data().samples();
      if (self.selector("abscissa").val() == "-") {
        self.selector("pointEntryDlg_remove").attr("disabled", true);
        self.selector("pointEntryDlg_enter").attr("disabled", true);
        return;
      }
      var abscissaVal; // = math.evaluate(self.plot.defines.expandDefines(self.selector("abscissa").val())).toString(10);
      try {
        abscissaVal = math.evaluate(
          self.plot.defines.expandDefines(self.selector("abscissa").val())
        ); //.toString(10);
      } catch (error) {
        self.selector("pointEntryDlg_remove").attr("disabled", true);
        self.selector("pointEntryDlg_enter").attr("disabled", true);
        return;
      }
      if (self.selector("ordinate").val() == "-") {
        self.selector("pointEntryDlg_remove").attr("disabled", true);
        self.selector("pointEntryDlg_enter").attr("disabled", true);
        return;
      }
      var ordinateVal; // = math.evaluate(self.plot.defines.expandDefines(self.selector("ordinate").val())).toString(10);
      try {
        ordinateVal = math.evaluate(
          self.plot.defines.expandDefines(self.selector("ordinate").val())
        ); //.toString(10);
      } catch (error) {
        self.selector("pointEntryDlg_remove").attr("disabled", true);
        self.selector("pointEntryDlg_enter").attr("disabled", true);
        return;
      }

      if (ordinateVal == undefined || abscissaVal == undefined) {
        self.selector("pointEntryDlg_remove").attr("disabled", true);
        self.selector("pointEntryDlg_enter").attr("disabled", true);
        return;
      }

      if (findPoint(new Misc.Point(abscissaVal, ordinateVal))) {
        if (samples.length > 1)
          self.selector("pointEntryDlg_remove").attr("disabled", false);
        self.selector("pointEntryDlg_enter").attr("disabled", true);
      } else {
        self.selector("pointEntryDlg_remove").attr("disabled", true);
        self.selector("pointEntryDlg_enter").attr("disabled", false);
      }
    }

    self.addHandler("pointEntryDlg_enter", "click", enterCb);
    self.addHandler("pointEntryDlg_remove", "click", removeCb);
    self.addHandler("curve_name, abscissa, ordinate", "keyup", keyupCb);

    function setRemoveButtonAttribute() {
      var curve = self.plot.findPlotCurve(self.selector("curve_name").val());

      if (!curve) {
        self.selector("pointEntryDlg_remove").attr("disabled", true);
      } else {
        if (curve.data().samples().length > 1) {
          self.selector("pointEntryDlg_remove").attr("disabled", false);
        } else {
          self.selector("pointEntryDlg_remove").attr("disabled", true);
        }
      }
    }

    this.pointEntryCb = function (dlgTitle, plot, curveName, point) {
      self.curveName = curveName;
      self.point = point;
      self.dlgTitle = dlgTitle;
      self.plot = plot;
      this.showDlg();
      //this.init(); //or call init() inside of initializeDialog()
    };

    this.init = function () {
      this.selector("ok").text("Finish");
      self.selector("title").html(self.dlgTitle);

      if (self.dlgTitle == "Modify/Remove Point") {
        self.selector("pointEntryDlg_enter").text("Modify");
      } else {
        self.selector("pointEntryDlg_enter").text("Add");
      }

      if (self.curveName !== undefined) {
        self.selector("curve_name").val(self.curveName);
      }
      if (self.point !== undefined) {
        self.selector("abscissa").val(self.point.x);
        self.selector("ordinate").val(self.point.y);
      }

      if (self.dlgTitle == "Modify/Remove Point") {
        self.selector("curve_name").attr("disabled", true);
        self.selector("pointEntryDlg_enter").attr("disabled", true);
      } else {
        self.selector("curve_name").attr("disabled", false);
        if (
          !findPoint(
            new Misc.Point(
              self.selector("abscissa").val(),
              self.selector("ordinate").val()
            )
          )
        )
          self.selector("pointEntryDlg_enter").attr("disabled", false);
      }
      setRemoveButtonAttribute();
    };
  }

  initializeDialog() {
    this.init();
  }

  beforeClose() {
    this.curveName = 0;
    this.point = 0;
    this.dlgTitle = 0;
    this.plot = 0;
  }
}
;
define("pointEntryDlg", ["modalDlg"], function(){});

"include []";

class ToolBar {
  constructor(obj, plotDiv) {
    var self = this;
    self.tbarHeight = 0;
    var buttonList = [];
    obj = obj || {};
    function defaultCb() {
      console.log("No callback defined for button");
    }
    var tbDiv = $(
      '<div id="toolBar1" class="noprint" style="border-radius:8px; margin-left:5px; margin-right:5px; position:relative; border-style: ridge; background-color: lightBlue"></div>'
    );
    if (obj.zIndex !== undefined) tbDiv.css("zIndex", obj.zIndex);
    tbDiv.insertBefore(plotDiv);
    //tbDiv[0].parent = plotDiv.parent()[0];
    //plotDiv.removeClass("noToolBar")
    //plotDiv.addClass("toolBar")
    //tbDiv.addClass("no-print")

    //Helper that gets a integer id from element's innerText.
    function buttonTextAttribToId(text) {
      for (let i = 0; i < buttonList.length; ++i) {
        if (buttonList[i].attr("buttonText") == text) {
          return i;
        }
      }
      return -1; //invalid ID
    }

    var addToggleSwitch = function (obj) {
      // style="margin-left:30px"
      var option = obj.label || "Option 1";
      var checked = "";
      if (obj.checked) checked = "checked";
      obj.innerHtmlId = obj.innerHtmlId || "elem_" + buttonList.length;
      var chkbox = $(
        '<label data-toggle="tooltip" class="checkbox-inline switch">\
                                    <input id=' +
          obj.innerHtmlId +
          '  type="checkbox" value="" ' +
          checked +
          '>\
                                    <span class="slider round" style="width:48px"></span>\
                                    <span style="margin-left:30px">' +
          option +
          "</span>\
                                  </label>"
      );
      chkbox.css("marginLeft", obj.marginLeft || 4);
      chkbox.css("marginRight", obj.marginRight || 2);
      tbDiv.append(chkbox);
      // chkbox.css("width", "48px");
      chkbox.attr("title", obj.tooltip);
      var _cb =
        obj.cb ||
        function () {
          console.log("No callback defined for button");
        };
      $("#" + obj.innerHtmlId).on("change", function () {
        _cb($(this)[0].checked);
      });
      buttonList.push(chkbox);
      return buttonList.length - 1;
    };

    var addPushbutton = function (obj) {
      obj.text = obj.text; /* || "Button"*/
      obj.class = obj.class || "btn btn-primary";
      obj.innerHtmlId = obj.innerHtmlId || "elem_" + buttonList.length;
      obj.duration = obj.duration || 40;
      var b = $(
        "<button id=" +
          obj.innerHtmlId +
          ' type="button" data-toggle="tooltip">'
      );
      b.addClass(obj.class);
      if (obj.icon !== undefined) {
        if (obj.text !== undefined && obj.text.length) b.text(obj.text + " ");
        var img = $("<img src=" + obj.icon + ' alt="Img" width=18px>');
        b.append(img);
      } else {
        b.text(obj.text);
      }

      //We store the unmodified text on the buttonText attribute. The text may be modified by adding spaces
      //or by locale translation.
      b.attr("buttonText", obj.text);

      tbDiv.append(b);

      b.css("zIndex", tbDiv.css("zIndex"));

      //b[0].innerHTML = '<img src=' + "images/save.png"+ ' alt="Img" width=20px/>'

      b.attr("title", obj.tooltip);
      var _cb =
        obj.cb ||
        function () {
          console.log("No callback defined for button");
        };
      var clickEvent = "click";
      var mousedownEvent = "mousedown";
      var mouseupEvent = "mouseup";
      if (Static.isMobile()) {
        clickEvent = "tap";
        mousedownEvent = "touchstart";
        mouseupEvent = "touchend";
      }

      if (obj.repeat) {
        b.interval = null;
        b.bind(mousedownEvent, function (e) {
          //console.log(mousedownEvent)
          if (mousedownEvent == "mousedown") {
            if (e.button != 0) {
              return;
            }
          }
          b.interval = setInterval(_cb, obj.duration);
        });
        /* $(window) */ b.bind(mouseupEvent + " mouseleave", function () {
          clearInterval(b.interval);
          //console.log(444)
        });
        // b.mouseup(function(){
        //             clearInterval(b.interval)
        //         });
      } else {
        b.bind(clickEvent, _cb);
      }
      buttonList.push(b);

      return buttonList.length - 1;
    };

    this.html = function () {
      return tbDiv;
    };

    this.disable = function (identifier) {
      if (typeof identifier == "string")
        identifier = buttonTextAttribToId(identifier);
      buttonList[identifier].attr("disabled", true);
    };

    this.enable = function (identifier) {
      if (typeof identifier == "string")
        identifier = buttonTextAttribToId(identifier);
      buttonList[identifier].attr("disabled", false);
    };

    this.hide = function (identifier) {
      if (typeof identifier == "string")
        identifier = buttonTextAttribToId(identifier);
      if (identifier == undefined) identifier = -1;
      if (identifier > -1 && identifier < buttonList.length) {
        buttonList[identifier].hide();
      } else {
        tbDiv.hide();
        //plotDiv.removeClass("toolBar")
        //plotDiv.addClass("noToolBar")
      }
      if (obj.refreshCb) refreshCb();
    };
    this.show = function (identifier) {
      if (typeof identifier == "string")
        identifier = buttonTextAttribToId(identifier);
      if (identifier == undefined) identifier = -1;
      if (identifier > -1 && identifier < buttonList.length) {
        buttonList[identifier].show();
      } else {
        tbDiv.show();
        //plotDiv.removeClass("noToolBar")
        //plotDiv.addClass("toolBar")
      }
      if (obj.refreshCb) refreshCb();
    };

    var addCheckbox = function (obj) {
      var option = obj.label || "Option 1";
      var checked = "";
      if (obj.checked) checked = "checked";

      obj.tooltip = obj.tooltip || "";

      const indexOfAmpersand = option.indexOf("&");
      if (indexOfAmpersand !== -1) {
        obj.ampersandNizeChar = option[indexOfAmpersand + 1].toUpperCase();
        option = option.replace("&", "");

        obj.tooltip = obj.tooltip + "\tAlt " + obj.ampersandNizeChar;

        $("body").on("keydown", function (event) {
          const keyCode = event.keyCode ? event.keyCode : event.which;
          if (
            event.altKey &&
            String.fromCharCode(keyCode) == obj.ampersandNizeChar
          ) {
            //event.preventDefault();
            $("#" + obj.innerHtmlId).click();
          }
        });
      }

      obj.innerHtmlId = obj.innerHtmlId || option + "elem_" + buttonList.length;
      var chkbox = $(
        '<label data-toggle="tooltip" class="checkbox-inline">\
                                    <input id=' +
          obj.innerHtmlId +
          '  type="checkbox" value="" ' +
          checked +
          ">" +
          option +
          "\
                                  </label>"
      );
      chkbox.css("marginLeft", obj.marginLeft || 8);
      chkbox.css("marginRight", obj.marginRight || 8);
      tbDiv.append(chkbox);

      if (obj.disabled) {
        $("#" + obj.innerHtmlId).attr("disabled", true);
      }

      chkbox.attr("title", obj.tooltip);
      var _cb =
        obj.cb ||
        function () {
          console.log("No callback defined for button");
        };
      $("#" + obj.innerHtmlId).click(function () {
        _cb($(this).is(":checked"));
      });
      buttonList.push($("#" + obj.innerHtmlId));
      return buttonList.length - 1;
    };

    var addSlider = function (obj) {
      var option = obj.label || "Option 1";
      var min = "";
      if (obj.min !== undefined) min = " min=" + '"' + obj.min + '"';
      var max = "";
      if (obj.max !== undefined) max = " max=" + '"' + obj.max + '"';
      var value = "";
      if (obj.value !== undefined) value = " value=" + obj.value + " ";
      var width = " width:" + 100 + "px ";
      if (obj.width !== undefined) width = " width:" + obj.width + "px ";
      //console.log(value)
      obj.innerHtmlId = obj.innerHtmlId || "elem_" + buttonList.length;
      var sliderCntrl = $(
        '<input style="position:absolute; ' +
          width +
          '" id=' +
          obj.innerHtmlId +
          " " +
          value +
          '  type="range" ' +
          min +
          " " +
          max +
          "/>"
      );
      var slider = $(
        "<label for=" +
          obj.innerHtmlId +
          'data-toggle="tooltip">' +
          option +
          "</label>"
      );
      slider.append(sliderCntrl);
      slider.css("marginLeft", obj.marginLeft || 8);
      slider.css("marginRight", obj.marginRight || 8);

      sliderCntrl.css("marginLeft", obj.marginLeft || 8);
      sliderCntrl.css("marginTop", obj.marginTop || 2);
      tbDiv.append(slider);
      sliderCntrl.css("top", tbDiv.css("top"));
      //var pos = parseInt($($("#"+obj.innerHtmlId).parent()).css("right"));
      var parent = $("#" + obj.innerHtmlId).parent()[0];
      var pos = parent.offsetLeft + parent.offsetWidth;
      //console.log()
      sliderCntrl.css("left", pos);
      slider.css(
        "width",
        parent.offsetWidth + parseInt(sliderCntrl.css("width"))
      );
      slider.attr("title", obj.tooltip);
      var _cb =
        obj.cb ||
        function () {
          console.log("No callback defined for button");
        };
      sliderCntrl.on("change", function () {
        _cb(parseInt($(this).val()));
        //console.log($(this).val())
      });
      buttonList.push(slider);
      return buttonList.length - 1;
    };

    var addRadiobutton = function (obj) {
      let _cb = obj.cb || defaultCb;
      let r = null;
      let inp = null;
      var option = obj.label || "Option 1";
      obj.tooltip = obj.tooltip || "";

      const indexOfAmpersand = option.indexOf("&");
      if (indexOfAmpersand !== -1) {
        obj.ampersandNizeChar = option[indexOfAmpersand + 1].toUpperCase();
        option = option.replace("&", "");

        obj.tooltip = obj.tooltip + "\tAlt " + obj.ampersandNizeChar;

        $("body").on("keydown", function (event) {
          const keyCode = event.keyCode ? event.keyCode : event.which;
          if (
            event.altKey &&
            String.fromCharCode(keyCode) == obj.ampersandNizeChar
          ) {
            //event.preventDefault();
            r.click();
          }
        });
      }
      obj.value = obj.value || option;
      obj.innerHtmlId = obj.innerHtmlId || option + "elem_" + buttonList.length;
      var name = obj.name || "optradio";
      var checked = "";
      if (obj.checked) checked = "checked";

      if (obj.checked)
        inp = $(
          "<input id=" +
            obj.innerHtmlId +
            ' type="radio" checked value=' +
            obj.value +
            " name=" +
            name +
            ">"
        );
      else
        inp = $(
          "<input id=" +
            obj.innerHtmlId +
            ' type="radio" value=' +
            obj.value +
            " name=" +
            name +
            ">"
        );
      r = $(
        '<label data-toggle="tooltip" class="checkbox-inline">\
                                    ' +
          option +
          "\
                                  </label>"
      );
      r.append(inp);
      r.css("marginLeft", obj.marginLeft || 0);
      r.css("marginRight", obj.marginRight || 0);
      tbDiv.append(r);

      r.attr("title", obj.tooltip);

      //We store the unmodified text on the buttonText attribute. The text may be modified by adding spaces
      //or by locale translation.
      r.attr("buttonText", option);

      r.addClass(obj.class);
      r.click(function (event) {
        _cb(r.find("INPUT").val());
      });
      buttonList.push(r);
      return buttonList.length - 1;
    };

    function makeListElement(obj) {
      var str = "";
      var checkbox = obj.hasCheckbox || false;
      var elementsInfo = obj.listElements || [];
      for (var i = 0; i < elementsInfo.length; ++i) {
        //elementsInfo[i].hasCheckbox = elementsInfo[i].hasCheckbox || false
        elementsInfo[i].icon = elementsInfo[i].icon || "";
        elementsInfo[i].checked = elementsInfo[i].checked || "unchecked";
        if (checkbox && !elementsInfo[i].icon.length) {
          if (elementsInfo[i].tooltip) {
            str +=
              '<li title="' +
              elementsInfo[i].tooltip +
              '"><a href="#"><label><input type="checkbox" ' +
              elementsInfo[i].checkboxState +
              " value=" +
              i +
              ">" +
              elementsInfo[i].text +
              "</label></a></li>";
          } else {
            str +=
              '<li><a href="#"><label><input type="checkbox" ' +
              elementsInfo[i].checkboxState +
              " value=" +
              i +
              ">" +
              elementsInfo[i].text +
              "</label></a></li>";
          }
        }
        if (!checkbox && elementsInfo[i].icon.length) {
          if (elementsInfo[i].tooltip) {
            str +=
              '<li title="' +
              elementsInfo[i].tooltip +
              '"><a href="#"><label><img src=' +
              elementsInfo[i].icon +
              ' alt="Img" width=20px>' +
              " " +
              elementsInfo[i].text +
              "</label></a></li>";
          } else {
            str +=
              '<li><a href="#"><label>' +
              elementsInfo[i].icon +
              elementsInfo[i].text +
              "</label></a></li>";
          }
        }
        if (checkbox && elementsInfo[i].icon.length) {
          if (elementsInfo[i].tooltip) {
            str +=
              '<li title="' +
              elementsInfo[i].tooltip +
              '"><a href="#"><label><img src=' +
              elementsInfo[i].icon +
              ' alt="Img" width=20px><input type="checkbox" ' +
              elementsInfo[i].checkboxState +
              ' value="">' +
              elementsInfo[i].text +
              "</label></a></li>";
          } else {
            str +=
              '<li><a href="#"><label><input type="checkbox" ' +
              elementsInfo[i].checkboxState +
              ' value="">' +
              elementsInfo[i].icon +
              elementsInfo[i].text +
              "</label></a></li>";
          }
        }
        if (!checkbox && !elementsInfo[i].icon.length) {
          //str += '<li><a href="#">'+elementsInfo[i].text+'</a></li>'
          if (elementsInfo[i].tooltip) {
            str +=
              '<li title="' +
              elementsInfo[i].tooltip +
              '"><a href="#"><label>' +
              elementsInfo[i].text +
              "</label></a></li>";
          } else {
            str +=
              '<li><a href="#"><label>' +
              elementsInfo[i].text +
              "</label></a></li>";
          }
        }
      }
      return str;
    }
    /*
<div class="dropdown">
<button class="btn btn-primary dropdown-toggle" type="button" id="about-us" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
About Us
<span class="caret"></span>
</button>
<ul class="dropdown-menu" aria-labelledby="about-us">
<li class="dropdown-header">Company Information</li>
<li><a href="#">Our Story</a></li>
<li><a href="#">Our Team</a></li>
<li class="dropdown-header">Contact Us</li>
<li><a href="#">Call Center</a></li>
<li><a href="#">Store Locations</a></li>
</ul>
</div> */

    var addDropdown = function (obj) {
      var option = obj.label || "Option 1";
      obj.text = obj.text || "Button";
      obj.tooltip = obj.tooltip || "";
      let m_ampersandNizeChar = null;
      const indexOfAmpersand = obj.text.indexOf("&");
      if (indexOfAmpersand !== -1) {
        m_ampersandNizeChar = obj.text[indexOfAmpersand + 1];
        obj.ampersandNizeChar = m_ampersandNizeChar.toUpperCase();
        obj.text = obj.text.replace("&", "");

        obj.tooltip = obj.tooltip + "\tAlt " + obj.ampersandNizeChar;

        $("body").on("keydown", function (event) {
          const keyCode = event.keyCode ? event.keyCode : event.which;
          if (
            event.altKey &&
            String.fromCharCode(keyCode) == obj.ampersandNizeChar
          ) {
            //event.preventDefault();
            $("#" + obj.innerHtmlId).click();
          }
        });
      } //////
      obj.innerHtmlId =
        obj.innerHtmlId || obj.text + "elem_" + buttonList.length;
      let d = $(
        '<span data-toggle="tooltip" class="dropdown">\
                              <button id=' +
          obj.innerHtmlId +
          ' class="btn btn-primary dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">' +
          obj.text +
          '\
                              <span class="caret"></span></button>\
                              <ul class="dropdown-menu">' +
          makeListElement(obj) +
          "</ul>\
                          </span>"
      );
      d.css("marginLeft", obj.marginLeft || 0);
      d.css("marginRight", obj.marginRight || 0);

      // console.log(456, tbDiv.css("zIndex"));

      // d.css({ position: "relative", zIndex: 100000 });

      d.addClass(obj.class);

      d.attr("title", obj.tooltip);

      //We store the unmodified text on the buttonText attribute. The text may be modified by adding spaces
      //or by locale translation.
      d.attr("buttonText", obj.text);
      d.attr("ampersandNizeChar", m_ampersandNizeChar);

      //console.log(obj.innerHtmlId)
      tbDiv.append(d);
      d.css("zIndex", tbDiv.css("zIndex"));
      // d.find("UL").css("zIndex", tbDiv.css("zIndex") );
      // console.log(d.find("UL").css("zIndex"));

      obj.cb = obj.cb || defaultCb;

      d.on("click", function (e) {
        var el = $(e.target);
        if (el.parent().parent().parent().hasClass("disabled")) return false;
        if (obj.hasCheckbox) return;

        var el = $(e.target);
        var index = el.closest("li").index();
        //var checked = el.prop("checked")
        if (index == -1) return;
        obj.cb(e, index);
      });

      d.on("change", function (e) {
        var el = $(e.target);

        //console.log()
        var checked = el.prop("checked");
        //if(index == -1 || checked==undefined)
        //return
        obj.cb(e, el.closest("li").index(), el.prop("checked"));
      });

      //d.css("zIndex", tbDiv.css("zIndex"));

      buttonList.push(d);
      return buttonList.length - 1;
    };

    var addSelect = function (obj) {
      obj.label = obj.label || "Select One";
      obj.innerHtmlId = obj.innerHtmlId || "elem_" + buttonList.length;
      //obj.text = obj.text || "Button"
      var sel = $("<select/>");
      var s = $(
        '<span data-toggle="tooltip"><label for=' +
          obj.innerHtmlId +
          ">" +
          obj.label +
          ":</label>\
                            </span>"
      );
      s.append(sel);
      var seltns = obj.selections || [];
      for (var i = 0; i < seltns.length; ++i) {
        sel.append($("<option>" + seltns[i] + "</option>"));
      }
      s.css("marginLeft", obj.marginLeft || 8);
      s.css("marginRight", obj.marginRight || 8);

      s.addClass(obj.class);

      s.attr("title", obj.tooltip);

      //We store the unmodified text on the buttonText attribute. The text may be modified by adding spaces
      //or by locale translation.
      s.attr("buttonText", obj.label);

      tbDiv.append(s);
      var _cb =
        obj.cb ||
        function () {
          console.log("No callback defined for button");
        };
      sel.on("change", function () {
        _cb($(this)[0].selectedIndex);
      });
      buttonList.push(s);
      return buttonList.length - 1;
    };

    var addMenu = function (obj) {
      var option = obj.label || "Menu one";
      obj.text = obj.text || "Button";
      obj.tooltip = obj.tooltip || "";
      let m_ampersandNizeChar = null;
      const indexOfAmpersand = obj.text.indexOf("&");
      if (indexOfAmpersand !== -1) {
        m_ampersandNizeChar = obj.text[indexOfAmpersand + 1];
        obj.ampersandNizeChar = m_ampersandNizeChar.toUpperCase();
        obj.text = obj.text.replace("&", "");

        obj.tooltip = obj.tooltip + "\tAlt " + obj.ampersandNizeChar;

        $("body").on("keydown", function (event) {
          const keyCode = event.keyCode ? event.keyCode : event.which;
          if (
            event.altKey &&
            String.fromCharCode(keyCode) == obj.ampersandNizeChar
          ) {
            //event.preventDefault();
            $("#" + obj.innerHtmlId).click();
          }
        });
      }
      obj.innerHtmlId =
        obj.innerHtmlId || obj.text + "elem_" + buttonList.length;
      var d = $(
        "<button id=" +
          obj.innerHtmlId +
          ' class="btn btn-primary dropdown-toggle" type="button" data-toggle="dropdown">' +
          obj.text +
          "\
                              </button>"
      );
      d.css("marginLeft", obj.marginLeft || 0);
      d.css("marginRight", obj.marginRight || 0);

      d.addClass(obj.class);

      d.attr("title", obj.tooltip);

      //We store the unmodified text on the buttonText attribute. The text may be modified by adding spaces
      //or by locale translation.
      d.attr("buttonText", obj.text);
      d.attr("ampersandNizeChar", m_ampersandNizeChar);

      //console.log(obj.innerHtmlId)
      tbDiv.append(d);

      d.css("zIndex", tbDiv.css("zIndex"));
      //console.log(d.css("zIndex"));

      obj.cb = obj.cb || defaultCb;

      // d.on("click", function (e) {
      //   var el = $(e.target);
      //   if (el.parent().parent().parent().hasClass("disabled")) return false;
      //   if (obj.hasCheckbox) return;
      //   var el = $(e.target);
      //   var index = el.closest("li").index();
      //   //var checked = el.prop("checked")
      //   if (index == -1) return;
      //   obj.cb(e, index);
      // });

      // d.on("change", function (e) {
      //   var el = $(e.target);

      //   //console.log()
      //   var checked = el.prop("checked");
      //   //if(index == -1 || checked==undefined)
      //   //return
      //   obj.cb(e, el.closest("li").index(), el.prop("checked"));
      // });

      d.contextMenu(obj.menu, {
        //zIndex: tbDiv.css("zIndex"),
        // displayAround: "trigger",
        // horAdjust: -parseInt(d.css("width")),
        // verAdjust: parseInt(d.css("height")),
      });

      // d.contextMenu(menu1, {
      //   triggerOn: "contextmenu",
      //   zIndex: 1,
      //   // onClose: function (data, event) {
      //   //   m_curve = 0;
      //   // },
      // });

      buttonList.push(d);
      return buttonList.length - 1;
    };

    var addUpload = function (obj) {
      obj.label = obj.label || "Select One";
      obj.innerHtmlId = obj.innerHtmlId || "elem_" + buttonList.length;
      //obj.text = obj.text || "Button"
      var inp = $(
        "<input id=" +
          obj.innerHtmlId +
          '  type="file" name="files[]" multiple />'
      );
      var u = $('<button data-toggle="tooltip"></button>');
      inp.css("marginLeft", -8);
      inp.css("marginRight", -8);
      inp.css("marginTop", -3);
      inp.css("marginBottom", -3);
      u.append(inp);
      /*var u = $('<button data-toggle="tooltip">\
                  <input type="file" id="files" name="files[]" multiple />\
                  </button>')*/
      u.css("marginLeft", obj.marginLeft || 8);
      u.css("marginRight", obj.marginRight || 8);

      u.addClass(obj.class);

      u.attr("title", obj.tooltip);

      tbDiv.append(u);
      buttonList.push(u);

      //A workaround to get the input file tag to work in some
      //IE browsers
      var click = false;
      u.click(function () {
        if (!click) {
          click = true;
          inp.trigger("click");
          return false;
        }
      });

      return buttonList.length - 1;
    };

    var addNumber = function (obj) {
      obj.label = obj.label || "Select One";
      obj.innerHtmlId = obj.innerHtmlId || "elem_" + buttonList.length;
      //obj.text = obj.text || "Button"
      obj.min = obj.min || -1000000;
      obj.max = obj.max || 1000000;
      obj.value = obj.value || obj.min;
      if (obj.value > obj.max) obj.value = obj.max;
      if (obj.value < obj.min) obj.value = obj.min;
      //console.log(typeof(obj.min))
      var n = $(
        '<span data-toggle="tooltip"><label for="sel1">' +
          obj.label +
          ":</label>\
                                   </span>"
      );
      var spinBox = $(
        "<input id=" +
          obj.innerHtmlId +
          '  type="number"\
                            value="10" name="some-name"/>'
      );
      n.append(spinBox);
      tbDiv.append(n);
      spinBox.attr({
        width: 200,
        min: obj.min,
        max: obj.max,
        step: obj.step,
        value: obj.value,
      });

      n.attr("title", obj.tooltip);

      n.css("marginLeft", obj.marginLeft || 8);
      n.css("marginRight", obj.marginRight || 8);

      n.addClass(obj.class);

      var _cb =
        obj.cb ||
        function () {
          console.log("No callback defined for button");
        };
      //n.click(_cb)
      spinBox.on("change", function () {
        _cb(parseFloat($(this).val()));
      });
      buttonList.push(n);
      return buttonList.length - 1;
    };

    var addLink = function (obj) {
      obj.text = obj.text || "Button";
      obj.innerHtmlId = obj.innerHtmlId || "elem_" + buttonList.length;
      var l = $("<A HREF=" + obj.href + " id=" + obj.innerHtmlId + "></a>");
      tbDiv.append(l);
      l.addClass(obj.class);

      l.attr("target", obj.target);

      let m_ampersandNizeChar = null;
      const indexOfAmpersand = obj.text.indexOf("&");
      if (indexOfAmpersand !== -1) {
        m_ampersandNizeChar = obj.text[indexOfAmpersand + 1];
        obj.ampersandNizeChar = m_ampersandNizeChar.toUpperCase();
        obj.text = obj.text.replace("&", "");

        obj.tooltip = obj.tooltip + "\tAlt " + obj.ampersandNizeChar;

        $("body").on("keydown", function (e) {
          const keyCode = e.keyCode ? e.keyCode : e.which;
          if (
            e.altKey &&
            String.fromCharCode(keyCode) == obj.ampersandNizeChar
          ) {
            l[0].dispatchEvent(new MouseEvent("click"));
          }
        });
      }

      l.text(obj.text);
      l.attr("title", obj.tooltip);

      var _cb =
        obj.cb ||
        function () {
          console.log("No callback defined for button");
        };
      l.click(_cb);
      buttonList.push(l);
      return buttonList.length - 1;
    };

    this.addToolButton = function (type, obj) {
      if (type == "pushbutton") return addPushbutton(obj);
      if (type == "checkbox") return addCheckbox(obj);
      if (type == "toggleSwitch") return addToggleSwitch(obj);
      if (type == "radio") return addRadiobutton(obj);
      if (type == "dropdown") return addDropdown(obj);
      if (type == "select") return addSelect(obj);
      if (type == "menu") return addMenu(obj);
      if (type == "slider") return addSlider(obj);
      if (type == "number") return addNumber(obj);
      if (type == "upload") return addUpload(obj);
      if (type == "link") return addLink(obj);
    };

    this.setButtonCheck = function (buttonId, on) {
      if (typeof buttonId == "string") {
        buttonId = buttonTextAttribToId(buttonId);
      }

      //buttonList[buttonId].prop("checked", on);
      if (buttonList[buttonId][0].children[0]) {
        //$(buttonList[buttonId][0].children[0]).prop("checked", on);
        if (buttonList[buttonId][0].children[0].tagName == "INPUT")
          buttonList[buttonId][0].children[0].checked = on;
        else buttonList[buttonId][0].children[1].checked = on; //Some how translation requires thid
      } else buttonList[buttonId][0].checked = on;
    };

    this.isButtonChecked = function (buttonId) {
      if (typeof buttonId == "string") {
        buttonId = buttonTextAttribToId(buttonId);
      }

      //buttonList[buttonId].prop("checked", on);
      if (buttonList[buttonId][0].children[0]) {
        //$(buttonList[buttonId][0].children[0]).prop("checked", on);
        if (buttonList[buttonId][0].children[0].tagName == "INPUT")
          return buttonList[buttonId][0].children[0].checked;
        else return buttonList[buttonId][0].children[1].checked; //Some how translation requires thid
      } else return buttonList[buttonId][0].checked;
    };

    this.isDropdownItemChecked = function (buttonId, listIndex) {
      if (typeof buttonId == "string")
        buttonId = buttonTextAttribToId(buttonId);
      var input = $($(buttonList[buttonId].children()[1]).children()[listIndex])
        .children()
        .children()
        .children();
      return input.prop("checked");
    };

    this.setDropdownItemCheck = function (buttonId, listIndex, on) {
      if (typeof buttonId == "string")
        buttonId = buttonTextAttribToId(buttonId);
      var input = $($(buttonList[buttonId].children()[1]).children()[listIndex])
        .children()
        .children()
        .children();
      input.prop("checked", on);
    };

    this.hideDropdownItem = function (buttonId, listIndex) {
      if (typeof buttonId == "string")
        buttonId = buttonTextAttribToId(buttonId);
      $($(buttonList[buttonId].children()[1]).children()[listIndex]).hide();
    };

    this.showDropdownItem = function (buttonId, listIndex) {
      if (typeof buttonId == "string")
        buttonId = buttonTextAttribToId(buttonId);
      $($(buttonList[buttonId].children()[1]).children()[listIndex]).show();
    };

    this.enableDropdownItem = function (buttonId, listIndex, on) {
      if (typeof buttonId == "string")
        buttonId = buttonTextAttribToId(buttonId);
      var liItem = $(
        $(buttonList[buttonId].children()[1]).children()[listIndex]
      ).addClass("disabled");
      if (!on) {
        liItem.addClass("disabled");
      } else {
        liItem.removeClass("disabled");
      }
    };

    var _prevH = parseFloat(tbDiv.css("height"));
    //console.log(_prevH)

    Static.onHtmlElementResize(tbDiv[0], function () {
      var changeOfHeight = parseFloat(tbDiv.css("height")) - _prevH;
      _prevH = parseFloat(tbDiv.css("height")); //console.log(changeOfHeight)
      self.tbarHeight = parseFloat(tbDiv.css("height"));
      plotDiv.css("height", parseFloat(plotDiv.css("height")) - changeOfHeight);
      Static.trigger("toolBarResized", [tbDiv, changeOfHeight]);
    });

    //Enable the default context menu for the toolbar
    Static.enableContextMenu(tbDiv[0]);
  }
}
;
define("toolBar", function(){});

"include []";

class MCurveSettings {
  constructor(_plot) {
    let self = this;
    //let _plot = null;
    let _curveFitCb = null;
    let _curveFitInfoCb = null;
    let _curveAttributeCb = null;
    let _curveStyleCb = null;
    let _curveAxisCb = null;
    $("body").append(
      $(
        '\
                <!-- Modal -->\
                <div class="modal fade" id="curveSettingsModal" role="dialog">\
                <div class="modal-dialog">\
                \
                <!-- Modal content-->\
                <div class="modal-content">\
                <div class="modal-header">\
                <!--button type="button" class="close" data-dismiss="modal">&times;</button-->\
                <h4 class="modal-title">Curve attributes</h4>\
                </div>\
                <div class="modal-body">\
                \
                \
                <div class="row">\
                <div class="col-sm-3">Curve name:</div>\
                <div class="col-sm-5"><select id="curveSelect" style="width:100%"></select></div>\
                <div class="col-sm-2"><button id="remove">Remove</button></div>\
                <div class="col-sm-2"><button id="rename">Rename</button></div>\
                </div>\
                \
                <br>\
                <div class="row">\
                <div class="col-sm-3">Pen color:<input id="penColor" type="color"/></div>\
                <div class="col-sm-4">Pen width:<select id="penWidth" style="width:50%"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option></select></div>\
                <div class="col-sm-5">Pen style:<select id="penStyle" style="width:60%"><option>solid</option><option>dot</option><option>dash</option><option>dashDot</option><option>dashDotDot</option></select></div>\
                </div>\
                \
                <br>\
                <div class="row">\
                <div class="col-sm-6">Horizontal axis:<select id="horizontalAxis" style="width:50%"><option value="2">Bottom</option><option value="3">Top</option></select></div>\
                <div class="col-sm-5">Vertical axis:<select id="verticalAxis" style="width:60%"><option value="0">Left</option><option value="1">Right</option></select></div>\
                </div>\
                \
                <br>\
                <div class="row">\
                <div class="col-sm-1"><button id="fit">Fit</button></div><div class="col-sm-3"><button id="legendAttribute">Legend attribute</button></div><div class="col-sm-3"><button id="curveStyle">Curve style</button></div><div class="col-sm-2"><button id="curveBrush"> Brush</button></div><div class="col-sm-3"><button id="clearBrush">No brush</button></div><!--div class="col-sm-2"><button id="curveAxis">Axis</button></div-->\
                <div class="col-sm-3"><button id="fitInfo">Curve Fit Info...</button></div>\
                </div>\
                \
                <br>\
                <div class="row">\
                <div class="col-sm-2">Symbols</div>\
                <div class="col-sm-8"><select id="symbolType"><option value="None">None</option><option value="MRect">Rectangle</option><option value="Cross">Cross</option><option value="Diamond">Diamond</option><option value="Ellipse">Ellipse</option><option value="XCross">Diagonal cross</option></select></div>\
                </div>\
                \
                <br>\
                <div id="symbolContainer">\
                <div class="row">\
                <div class="col-sm-6">Symbol pen color:<input id="penColorSymbol" type="color"/></div>\
                <div class="col-sm-6">Symbol pen width:<select id="penWidthSymbol" style="width:50%"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option></select></div>\
                </div>\
                <br>\
                <div class="row">\
                <div class="col-sm-6">Symbol fill brush:<input id="fillBrushSymbol" type="color"/></div>\
                <div class="col-sm-6">Symbol size:<select id="sizeSymbol" style="width:50%"><option value="5">5x5</option><option value="6">6x6</option><option value="8">8x8</option><option value="10">10x10</option><option value="12">12x12</option><option value="15">15x15</option></select></div>\
                </div>\
                </div>\
                \
                \
                </div>\
                <div class="modal-footer">\
                <button id="cancelAxisDlg" type="button" class="btn btn-default" data-dismiss="modal">Cancel</button>\
                <button type="button" class="btn btn-default" data-dismiss="modal">Ok</button>\
                </div>\
                </div>\
                \
                </div>\
                </div>\
                '
      )
    );
    $("#curveSelect").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      initDlg(curve);
    });
    $("#remove").click(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      curve.detach();
      curve.delete();
      if (!_plot.hasPlotCurve()) {
        $("#cancelAxisDlg").click();
        return;
      }
      let opts = $("#curveSelect").children();
      $("#curveSelect")[0].removeChild(
        opts[$("#curveSelect")[0].selectedIndex]
      );
      initDlg(_plot.findPlotCurve($("#curveSelect").val()));
    });
    $("#rename").click(function () {
      Utility.curveRenameDlg($("#curveSelect").val(), _plot, function () {
        let ind = $("#curveSelect")[0].selectedIndex;
        initCurveSelect();
        $("#curveSelect")[0].selectedIndex = ind;
        return true;
      });
      return true;
    });
    $("#fit").click(function () {
      _curveFitCb(_plot.findPlotCurve($("#curveSelect").val()));
    });
    $("#legendAttribute").click(function () {
      _curveAttributeCb(_plot.findPlotCurve($("#curveSelect").val()));
    });
    $("#clearBrush").click(function () {
      Utility.removeCurveBrush(_plot.findPlotCurve($("#curveSelect").val()));
      initClearBrushButton(_plot.findPlotCurve($("#curveSelect").val()));
    });
    $("#curveBrush").click(function () {
      Utility.setCurveBrush(
        _plot.findPlotCurve($("#curveSelect").val()),
        initClearBrushButton
      );
    });
    $("#curveStyle").click(function () {
      _curveStyleCb(_plot.findPlotCurve($("#curveSelect").val()));
    });
    $("#curveAxis").click(function () {
      _curveAxisCb(_plot.findPlotCurve($("#curveSelect").val()));
    });
    $("#fitInfo").click(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      let info = _curveFitInfoCb(curve);
      if (info.length) {
        Utility.alert(info);
      } else {
        Utility.alert(
          'No curve fitting equation found for "' + curve.title() + '."'
        );
      }
    });
    $("#penColor").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      let pen = curve.pen();
      pen.color = $(this).val();
      curve.setPen(pen);
    });
    $("#penWidth").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      let pen = curve.pen();
      pen.width = $(this).val();
      curve.setPen(pen);
    });
    $("#penStyle").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      let pen = curve.pen();
      pen.style = $(this).val();
      curve.setPen(pen);
    });
    $("#horizontalAxis").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      curve.setXAxis($(this).val());
      Static.trigger("axisChanged", [$(this).val(), curve]);
    });
    $("#verticalAxis").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      curve.setYAxis($(this).val());
      Static.trigger("axisChanged", [$(this).val(), curve]);
    });
    $("#symbolType").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      if ($("#symbolType").val() == "None") {
        $("#symbolContainer").hide();
        //restore default pen, brush color and symbol size
        $("#penWidthSymbol").val(1);
        $("#penColorSymbol").val(Utility.colorNameToHex("black"));
        $("#fillBrushSymbol").val(Utility.colorNameToHex("transparent"));
        $("#sizeSymbol").val(10);
      } else {
        $("#symbolContainer").show();
      }
      addSymbol(curve, $(this).val());
    });
    $("#penColorSymbol").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      let sym = curve.symbol();
      if (!sym) {
        return;
      }
      let pen = sym.pen();
      pen.color = $(this).val();
      sym.setPen(pen);
      curve.plot().autoRefresh();
      curve.plot().updateLegend(curve);
    });
    $("#penWidthSymbol").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      setSymbolPenWidth(curve, parseInt($(this).val()));
    });
    $("#fillBrushSymbol").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      let sym = curve.symbol();
      if (!sym) {
        return;
      }
      let pen = sym.brush();
      pen.color = $(this).val();
      sym.setBrush(pen);
      curve.plot().autoRefresh();
      curve.plot().updateLegend(curve);
    });
    $("#sizeSymbol").change(function () {
      let curve = _plot.findPlotCurve($("#curveSelect").val());
      setSymbolSize(curve, parseInt($(this).val()));
    });
    function addSymbol(curve, style) {
      if (style == "None") {
        curve.setSymbol(null);
        return;
      }
      let _style = -1;
      if (style == "MRect") {
        _style = Symbol2.Style.MRect;
      }
      if (style == "Cross") {
        _style = Symbol2.Style.Cross;
      }
      if (style == "Diamond") {
        _style = Symbol2.Style.Diamond;
      }
      if (style == "Ellipse") {
        _style = Symbol2.Style.Ellipse;
      }
      if (style == "XCross") {
        _style = Symbol2.Style.XCross;
      }
      Utility.addSymbol(curve, _style);
    }
    function setSymbolPenWidth(curve, width) {
      Utility.setSymbolPenWidth(curve, width);
    }
    function setSymbolSize(curve, value) {
      Utility.setSymbolSize(curve, value);
    }
    function initCurveSelect() {
      let opts = $("#curveSelect").children();
      for (let i = 0; i < opts.length; ++i) {
        $("#curveSelect")[0].removeChild(opts[i]);
      }
      let curves = _plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
      for (let i = 0; i < curves.length; ++i) {
        if (curves[i].isVisible()) {
          let opt = $("<option>" + curves[i].title() + "</option>");
          opt.attr("value", curves[i].title());
          $("#curveSelect").append(opt);
        }
      }
      $("#sizeSymbol").val(10);
      if (curves.length) {
        return curves[0];
      }
      return null;
    }
    function initClearBrushButton(curve) {
      if (curve.brush().color == Static.NoBrush) {
        $("#clearBrush").hide();
      } else {
        $("#clearBrush").show();
      }
    }
    function initDlg(curve) {
      if (!curve) return;
      let penStyles = ["solid", "dot", "dash", "dashDot", "dashDotDot"];
      $("#penColor").val(Utility.colorNameToHex(curve.pen().color));
      $("#penWidth")[0].selectedIndex = curve.pen().width - 1;
      $("#penStyle")[0].selectedIndex = penStyles.indexOf(curve.pen().style);
      $("#horizontalAxis")[0].selectedIndex = curve.xAxis() - 2;
      $("#verticalAxis")[0].selectedIndex = curve.yAxis();
      if (!curve.fitType) {
        $("#fitInfo").hide();
      } else {
        $("#fitInfo").show();
      }
      initClearBrushButton(curve);
      let symbol = curve.symbol();
      if (symbol) {
        let symbolStyle = symbol.style();
        if (symbolStyle == Symbol2.Style.MRect) $("#symbolType").val("MRect");
        if (symbolStyle == Symbol2.Style.Cross) $("#symbolType").val("Cross");
        if (symbolStyle == Symbol2.Style.Diamond)
          $("#symbolType").val("Diamond");
        if (symbolStyle == Symbol2.Style.Ellipse)
          $("#symbolType").val("Ellipse");
        if (symbolStyle == Symbol2.Style.XCross) $("#symbolType").val("XCross");
      } else {
        $("#symbolType").val("None");
      }
      if ($("#symbolType").val() == "None") {
        $("#symbolContainer").hide();
      } else {
        $("#symbolContainer").show();
        $("#penColorSymbol").val(symbol.pen().color);
        $("#penWidthSymbol").val(symbol.pen().width);
        $("#fillBrushSymbol").val(symbol.brush().color);
        $("#sizeSymbol").val(symbol.size().width);
      }
    }
    this.init = function () {
      _curveFitCb = _plot.curveFitDlg.curveFitCb;
      _curveFitInfoCb = _plot.curveFitDlg.curveFitInfoCb;
      _curveAttributeCb = _plot.curveAttributeDlg.curveAttributeCb;
      _curveStyleCb = _plot.curveStyleDlg.curveStyleCb;
      _curveAxisCb = _plot.axisDlg.axisCb;
    };
    this.curveSettingsDlg = function () {
      if (!_plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve).length) {
        Utility.alert("No curves found", "small");
      } else {
        initDlg(initCurveSelect());
        $("#curveSettingsModal").modal({
          backdrop: "static",
        });
      }
    };

    this.init();
  }
}
;
define("curveSettings", function(){});

"include ['toolBar', 'curveSettings']";


class MToolBar extends ToolBar {
  constructor(_plot, obj, plotDiv) {
    super(obj, plotDiv);

    var self = this;
    //var _plot = data.plot;

    var watches = new Watches(_plot);
    var m_watchElements = watches.watchElements();

    /* Callbacks */
    /* function addRemovePointCb(checked) {
        _plot.addRemovePoint.activate(checked);
        }  */

    function radioButtonCb(checkedValue) {
      // var myRadio = $("input[name=viewMode]");
      // var checkedValue = myRadio.filter(":checked").val();

      /* if (checkedValue == "Neutral") {
            _plot.pan.setEnabled(false);
            Utility.setAutoScale(_plot, false);
            _plot.zm.setEnabled(false);
            _plot.addRemovePoint.activate(false);
            _plot.rv.preventDragging(false);
            } */

      /* if (checkedValue == "Add/Remove") {
            _plot.pan.setEnabled(false);
            Utility.setAutoScale(_plot, false);
            _plot.zm.setEnabled(false);
            _plot.addRemovePoint.activate(true);
            //_plot.rv.preventDragging(true);
            } */

      //if (checkedValue == Static.getTranslation(document.documentElement.getAttribute("lang"), "Zoom")) {
      if (checkedValue == "Zoom") {
        //_plot.addRemovePoint.activate(false);
        _plot.pan.setEnabled(false);
        Utility.setAutoScale(_plot, false);
        Static.trigger("autoScalingEnabled", false);
        _plot.zm.setEnabled(true);
        _plot.zm.setZoomBase(_plot.zm.scaleRect());

        _plot.curveSelector.abortSelection();
        //_plot.rv.preventDragging(false);
      }
      //if (checkedValue == Static.getTranslation(document.documentElement.getAttribute("lang"), "Pan")) {
      if (checkedValue == "Pan") {
        //_plot.addRemovePoint.activate(false);
        _plot.zm.setEnabled(false);
        _plot.pan.setEnabled(true);
        _plot.curveSelector.abortSelection();

        Utility.setAutoScale(_plot, false);
        Static.trigger("autoScalingEnabled", false);
        //_plot.rv.preventDragging(false);
      }

      //if (checkedValue == Static.getTranslation(document.documentElement.getAttribute("lang"), "Auto")) {
      if (checkedValue == "Auto") {
        //_plot.addRemovePoint.activate(false);
        _plot.pan.setEnabled(false);
        _plot.zm.setEnabled(false);
        Utility.setAutoScale(_plot, true);
        Static.trigger("autoScalingEnabled", true);
        //_plot.rv.preventDragging(false);
      }
    }

    var fnListView = [
      /* function pointSelection(on) {
                _plot.curveClosestPoint.setEnabled(on);
            },  */ function leftAxis(on) {
        _plot.enableAxis(Axis.AxisId.yLeft, on);
      },
      function bottomAxis(on) {
        _plot.enableAxis(Axis.AxisId.xBottom, on);
      },
      function rightAxis(on) {
        _plot.enableAxis(Axis.AxisId.yRight, on);
      },
      function topAxis(on) {
        _plot.enableAxis(Axis.AxisId.xTop, on);
      },
      function majorGridLines(on) {
        Utility.majorGridLines(_plot.grid, on);
        self.enableDropdownItem("View", 5, on);
      },
      function minorGridLines(on) {
        Utility.minorGridLines(_plot.grid, on);
      },
      function titleFn(on) {
        if (on) {
          _plot.showTitle();
        } else {
          _plot.hideTitle();
        }
      },
      function footerFn(on) {
        if (on) {
          _plot.showFooter();
        } else {
          _plot.hideFooter();
        }
      },
      function legendFn(on) {
        _plot.enableLegend(on);
      },
    ];

    Static.bind("majorGridLines", function (e, grid, on) {
      self.setDropdownItemCheck("View", 4, on);
      self.enableDropdownItem("View", 5, on);
    });
    Static.bind("minorGridLines", function (e, grid, on) {
      self.setDropdownItemCheck("View", 5, on);
    });

    function pointEntryFn() {
      _plot.pointEntryDlg.pointEntryCb("Add/Romve Point", _plot);
      //_plot.pointEntryDlg.setDlgTitle("Add/Romve Point")
    }

    var w;
    function calculatorFn() {
      // if (!w || w.closed) {
      //     w = window.open("https://www.tcsion.com/OnlineAssessment/ScientificCalculator/Calculator.html#nogo", "_blank", "width=480,height=345, top=200, left=200");
      // }
      // w.focus();
      window.open("Calculator:///");
    }

    function definesFn(val) {
      _plot.defines.defines(/* _plot */);
    }

    function markerFn(val) {
      _plot.markerDlg.markerCb(_plot);
    }

    function trashFn(val) {
      _plot.trashDlg.trashCb(_plot);
    }

    function functionFn() {
      _plot._functionDlg.functionDlg(Utility.generateCurveName(_plot));
    }

    function zoneFn() {
      console.log(456);
      _plot.zoneDlg.zoneCb(_plot);
    }

    var fnListFile = [
      _plot.file.save,
      /* _plot.curveSettings.curveSettingsDlg, */ /* _plot.settings().settingsDlg, */ functionFn,
      pointEntryFn,
      calculatorFn,
      definesFn,
      markerFn,
      zoneFn,
      _plot.print,
      trashFn,
    ];

    this.addToolButton("dropdown", {
      text: "F&ile",
      //tooltip: "AAA",
      cb: function (e, index) {
        //console.log(index, checked)
        //data.fnList[index]();
        fnListFile[index]();
      },
      listElements: [
        {
          text: "Save",
          icon: "images/save.png",
          tooltip: "Save the current graph.",
        } /*,  {
                    text: "Curve settings",
                    icon: 'images/curveSettings.png',
                    tooltip: "Launches the curve settings dialog."
                } */ /* , {
                    text: "Plot settings",
                    icon: 'images/settings.png',
                    tooltip: "Launches the plot settings dialog."
                } */,
        {
          text: "Curve Function",
          icon: "images/function.png",
          tooltip: "Launches the function dialog.",
        },
        {
          text: "Point entry",
          icon: "images/pointEntry.png",
          tooltip: "Launches the point entry dialog.",
        },
        {
          text: "Calculator",
          icon: "images/calculator.png",
          tooltip: "Launches the calculator.",
        },
        {
          text: "Defines",
          icon: "images/defines.png",
          tooltip: "Launches the defines dialog.",
        },
        {
          text: "Marker",
          icon: "images/marker.png",
          tooltip: "Launches the marker dialog.",
        },
        {
          text: "Zone",
          icon: "images/zone.jfif",
          tooltip: "Adds a zone.",
        },
        {
          text: "Print",
          icon: "images/print.png",
          tooltip: "Print the current graph.",
        },
        {
          text: "Recycle bin",
          icon: "images/trash.png",
          tooltip: "Open the recycle bin.",
        },
      ],
    });

    var cProp = this.addToolButton("checkbox", {
      label: "&C-Prop" /*checked: true,*/,
      cb: function (on) {
        _plot.leftSidebar.showGridItem(0, on);
      },
      tooltip: "Show/Hide curve properties pane",
      disabled: true,
    });

    var pProp = this.addToolButton("checkbox", {
      label: "&P-Prop",
      checked: true,
      cb: function (on) {
        _plot.leftSidebar.showGridItem(1, on);
      },
      tooltip: "Show/Hide plot properties pane",
    });

    Static.bind("showGridItem", function (e, m_anchorPosition, gridIndex, on) {
      if (m_anchorPosition == "left") {
        //if(!on){
        if (gridIndex == 0) self.setButtonCheck(cProp, on);
        else self.setButtonCheck(pProp, on);
        //}
      }
      /* if(gridIndex === 0){
                self.setButtonCheck(cProp, on);
            }else{
                self.setButtonCheck(pProp, on);
            }  */
    });

    this.addToolButton("upload", {
      //text:"Title",
      //cb:uploadFn,
      innerHtmlId: "fileInput",
      class: "btn btn-primary",
      tooltip: "Upload data files",
    });

    let zoom = this.addToolButton("radio", {
      label: "&Zoom",
      tooltip: "Enable zooming. Press the mouse left button and drag.",
      name: "viewMode",
      cb: radioButtonCb,
    });
    this.addToolButton("radio", {
      label: "Pa&n",
      tooltip:
        "Allow dragging of all plot items to new positions. Press the mouse left button and drag.",
      name: "viewMode",
      cb: radioButtonCb,
    });
    self.auto = this.addToolButton("radio", {
      label: "&Auto",
      tooltip:
        "Determine and and apply the scale that\nallows the extent of all curves to be shown.",
      name: "viewMode",
      cb: radioButtonCb,
      checked: true,
    });

    // Static.bind("aspectRatioChanged", function (e, checked) {
    //   if (!checked && Utility.isAutoScale(_plot)) {
    //     Utility.setAutoScale(_plot, false);
    //     Utility.setAutoScale(_plot, true);
    //   }
    // });

    //self.setButtonCheck(auto, false);
    //self.hide(auto);

    this.addToolButton("dropdown", {
      text: "&View",
      //tooltip: "Allow for hiding/showing various components of a plot.",
      hasCheckbox: true,
      cb: function (e, index, checked) {
        //console.log(index, checked)
        //data.fnListView[index](checked);
        fnListView[index](checked);
        Static.trigger("viewChanged", checked);
      },
      listElements: [
        /* {
                    text: "Point selection",
                    icon: "images/pointSelection.png",
                    tooltip: "Turn on point selection. This may affect response." //,
                    //checkboxState: "checked"
                },  */ {
          text: "Left axis",
          icon: "images/axis.png",
          tooltip: "Enable left axis",
          checkboxState: "checked",
        },
        {
          text: "Bottom axis",
          icon: "images/axis.png",
          tooltip: "Enable bottom axis",
          checkboxState: "checked",
        },
        {
          text: "Right axis",
          icon: "images/axis.png",
          tooltip: "Enable right axis",
        },
        {
          text: "Top axis",
          icon: "images/axis.png",
          tooltip: "Enable top axis",
        },
        {
          text: "Major gridlines",
          icon: "images/major_grid.png",
          tooltip: "Enable major gridlines",
          checkboxState: "checked",
        },
        {
          text: "Minor gridlines",
          icon: "images/minor_grid.png",
          tooltip: "Enable minor gridlines",
          checkboxState: "checked",
        },
        {
          text: "Title",
          icon: "images/title.png",
          tooltip: "Enable title",
          checkboxState: "checked",
        },
        {
          text: "Footer",
          icon: "images/footer.png",
          tooltip: "Enable footor",
          checkboxState: "checked",
        },
        {
          text: "Legend",
          icon: "images/legend.png",
          tooltip: "Enable the legend (at least one curve should be present)",
          checkboxState: "checked",
        } /* , {
                    text: "Sidebar",
                    icon: "images/side_bar.png",
                    tooltip: "Display the sidebar"
                } */,
      ],
    });

    var sBar = this.addToolButton("checkbox", {
      label: "&S-Bar",
      innerHtmlId: "sideBarCheckBoxId",
      cb: function (on) {
        if (
          _plot
            .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
            .concat(_plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
            .concat(_plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
            .concat(_plot.itemList(PlotItem.RttiValues.Rtti_PlotZone)).length
        ) {
          //_plot.rightSidebar.showSidebar(on);
          _plot.rightSidebar.showGridItem(0, on);
          _plot.rv.updateWatchesAndTable();
          Static.trigger("resize");
          /* if(!on){
                            _plot.cs.setEnabled(false)
                        } */
          //console.log(458, on)
        }
        if (!on) _plot.sidebar.setSidebarReDisplay(false);
      },
      tooltip: "Show/Hide sidbar",
      disabled: true,
    });
    var pSel = this.addToolButton("checkbox", {
      label: "P-Se&l",
      cb: function (on) {
        _plot.curveClosestPoint.setEnabled(on);
        _plot.curveSelector.abortSelection();
        Static.trigger("pSel", on);
      },
      tooltip:
        'Turn on "Point Selection" and turns off "Add/Remove Point". This may affect response.',
    });

    Static.bind("addRemovePoint curveSel", function (e, on) {
      if (on) {
        self.setButtonCheck(pSel, false);
        _plot.curveClosestPoint.setEnabled(false);
        _plot.plotPropertiesPane.hide("pointSelected");
      }
    });

    this.addToolButton("pushbutton", {
      text: "+",
      icon: "images/zoom_in.png",
      repeat: true,
      tooltip: "Zoom in.\tShift +",
      cb: function (e) {
        var f = 0.98; //0.995; //magnifier.mouseFactor();
        // for (var axisId = 0; axisId < Axis.AxisId.axisCnt; axisId++) {
        //var scaleDiv = _plot.axisScaleDiv(axisId);
        //if (scaleDiv.range() > 0.000000001) {
        _plot.magnifier.rescale(f);
        // }
        // }
      },
    });

    this.addToolButton("pushbutton", {
      text: "-",
      icon: "images/zoom_out.png",
      repeat: true,
      tooltip: "Zoom out.\tShift -",
      cb: function (e) {
        var f = 1 / 0.98; //magnifier.mouseFactor();
        _plot.magnifier.rescale(f);
      },
    });

    this.addToolButton("dropdown", {
      text: "&Watch",
      tooltip: "Enable/disable watches.",
      hasCheckbox: true,
      cb: function (e, index, checked) {
        if (checked && !$("#sideBarCheckBoxId")[0].checked) {
          $("#sideBarCheckBoxId").click();
        }
        _plot.rv.watch(index).setEnable(checked);
        _plot.rv.updateWatchesAndTable();
        Static.trigger("curveAdjusted"); //shapeItem update
      },
      listElements: m_watchElements,
    });

    ///////////////////////////////////////////////////////////////////
    let m_index;

    /* this.addToolButton("dropdown", {
      text: "&Combine",
      tooltip: "Combine functions",
      //hasCheckbox: true,
      cb: function (e, index, checked) {
        if (!_plot.hasVisiblePlotCurve()) {
          Utility.alert("No visible 2D curves", "small");
          return;
        }

        _plot.curveSelector.setEnabled(true);
        _plot.pan.setEnabled(false);
        self.setButtonCheck("Pan", false);
        _plot.zm.setEnabled(false);
        self.setButtonCheck("Zoom", false);

        Static.trigger("curveSel", true);

        if (index == 0) {
          _plot.curveSelector.operationType = "Add";
          //console.log("(f + g)(x)");
        }
        if (index == 1) {
          _plot.curveSelector.operationType = "Subtract";
          //console.log("(f - g)(x)");
        }
        if (index == 2) {
          _plot.curveSelector.operationType = "Multiply";
          //console.log("(f * g)(x)");
        }
        if (index == 3) {
          _plot.curveSelector.operationType = "Divide";
          //console.log("(f / g)(x)");
        }
        if (index == 4) {
          _plot.curveSelector.operationType = "Composite";
        }
        if (index == 5) {
          _plot.curveSelector.operationType = "Join";
        }
        if (index == 6) {
          _plot.curveSelector.operationType = "Join and keep";
        }
      },
      listElements: [
        { text: "(f + g)(x)", tooltip: "Add functions" },
        { text: "(f - g)(x)", tooltip: "Subtract functions" },
        { text: "(f * g)(x)", tooltip: "Multiply functions" },
        { text: "(f / g)(x)", tooltip: "Divide functions" },
        { text: "(f o g)(x)", tooltip: "Composite function" },
        { text: "Join", tooltip: "Join curves" },
        { text: "Join and keep", tooltip: "Join curves and keep segments." },
      ],
    }); */

    function operationPrep(operation) {
      if (!_plot.hasVisiblePlotCurve()) {
        Utility.alert("No visible 2D curves", "small");
        return;
      }
      _plot.curveSelector.setEnabled(true);
      _plot.pan.setEnabled(false);
      self.setButtonCheck("Pan", false);
      _plot.zm.setEnabled(false);
      self.setButtonCheck("Zoom", false);

      Static.trigger("curveSel", true);
      _plot.curveSelector.operationType = operation;
    }

    this.addToolButton("menu", {
      text: "&Operation",
      tooltip: "Function operations",
      menu: [
        {
          name: "Combine",
          subMenu: [
            {
              name: "(f + g)(x)",
              //img: "images/brush.png",
              title: "Add functions",
              fun: function () {
                operationPrep("Add");
              },
            },
            {
              name: "(f - g)(x)",
              //img: "images/brush.png",
              title: "Subtract functions",
              fun: function () {
                operationPrep("Subtract");
              },
            },
            {
              name: "(f * g)(x)",
              //img: "images/brush.png",
              title: "Multiply functions",
              fun: function () {
                operationPrep("Multiply");
              },
            },
            {
              name: "(f / g)(x)",
              //img: "images/brush.png",
              title: "Divide functions",
              fun: function () {
                operationPrep("Divide");
              },
            },
            {
              name: "(f o g)(x)",
              //img: "images/brush.png",
              title: "Composite function",
              fun: function () {
                operationPrep("Composite");
              },
            },
            {
              name: "join",
              subMenu: [
                {
                  name: "Join and discard",
                  //img: "images/brush.png",
                  title: "Join curves and discard segments",
                  fun: function () {
                    operationPrep("Join");
                  },
                },
                {
                  name: "Join and keep",
                  //img: "images/brush.png",
                  title: "Join curves and keep segments.",
                  fun: function () {
                    operationPrep("Join and keep");
                  },
                },
              ],
            },
          ],
        }, ///
        {
          name: "Transform",
          subMenu: [
            {
              name: "Translate",
              //img: "images/brush.png",
              title: "Translate the curve",
              fun: function () {
                operationPrep("Translate");
              },
            },
            {
              name: "Scale",
              //img: "images/brush.png",
              title: "Scale the function",
              fun: function () {
                operationPrep("Scale");
              },
            },
            {
              name: "Reflect",
              subMenu: [
                {
                  name: "over x-axis",
                  //img: "images/brush.png",
                  title: "Reflect the curve over the x-axis",
                  fun: function () {
                    operationPrep("Reflect x-axis");
                  },
                },
                {
                  name: "over y-axis",
                  //img: "images/brush.png",
                  title: "Reflect the curve over the y-axis",
                  fun: function () {
                    operationPrep("Reflect y-axis");
                    //operationPrep("Join and keep");
                  },
                },
                {
                  name: "over x and y-axes",
                  //img: "images/brush.png",
                  title: "Reflect the curve over the x and y-axes",
                  fun: function () {
                    operationPrep("Reflect x and y-axes");
                    //operationPrep("Join and keep");
                  },
                },
              ],
            },
          ],
        },
        {
          name: "Point",
          subMenu: [
            {
              name: "Intersection",
              //img: "images/brush.png",
              title:
                "Find the point of intersection between two curves or two straight lines or a curve and straight line",
              fun: function () {
                operationPrep("Intersection");
              },
            },
            {
              name: "Turning point(s)",
              //img: "images/brush.png",
              title: "Find the turning point(s) in a curve.",
              fun: function () {
                operationPrep("Turning point");
              },
            },
            {
              name: "Inflection point(s)",
              //img: "images/brush.png",
              title: "Find the inflection point(s) in a curve.",
              fun: function () {
                operationPrep("Inflection point");
              },
            },
            {
              name: "Discontinuity point(s)",
              //img: "images/brush.png",
              title: "Find the abscissa values of any discontinuities.",
              fun: function () {
                operationPrep("Discontinuity point");
              },
            },
          ],
        },
        {
          name: "Create table",
          //img: "images/brush.png",
          title: "Create a points table for the curve",
          fun: function () {
            operationPrep("Create table");
          },
        },
        {
          name: "Copy curve",
          //img: "images/brush.png",
          title: "Create a copyy of the curve",
          fun: function () {
            operationPrep("Copy curve");
          },
        },
      ],
    });

    ///////////////////////////////////////////////////////////////////////////////////////////
    this.addToolButton("pushbutton", {
      text: "Mongo-Filesystem",
      //tooltip: "Zoom out",
      class: "mongo-fs-login-logout-register btn btn-primary",
      cb: function () {
        //console.log("Callback called")
      },
    });

    /////////////////////////////////////////////////////////////////////////////////

    //We add the help button last. This way it is always to the right
    this.addToolButton("link", {
      text: "&Help",
      cb: function () {
        //console.log("Callback called")
      },
      //href: 'C:\\Users\\anthony\\Documents\\helpFiles\\_tmphhp\\grapher.chm',
      href: "grapherHelp/Grapher.html",
      //href: 'help.html',
      target: "_blank",
      class: "noSelect",
      tooltip: "Launches online help.",
    });

    Static.bind("showGridItem", function (e, m_anchorPosition, gridIndex, on) {
      if (m_anchorPosition == "right") {
        if (!on) {
          self.setButtonCheck(sBar, false);
          if (_plot.sidebar) _plot.sidebar.setSidebarReDisplay(false);
        }
      }
    });

    Static.bind("visibilityChange", function (e, plotItem, on) {
      if (
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram
      ) {
        if (_plot.sidebar) {
          _plot.sidebar.initSidebar();
        }
        if (!_plot.hasVisibleCurveSpectrocurveOrSpectrogram()) {
          //_plot.tbar.setDropdownItemCheck("View", 10, false);
          self.disable(sBar);
          _plot.tbar.hideDropdownItem("View", 10);
          if (_plot.rightSidebar && _plot.rightSidebar.isSideBarVisible()) {
            Utility.alert("Ooops!! Nothing to watch.");
            _plot.rightSidebar.showSidebar(false);
            _plot.sidebar.setSidebarReDisplay(true);
          }
        } else {
          //_plot.tbar.showDropdownItem("View", 10);
          self.enable(sBar);
          if (_plot.sidebar && _plot.sidebar.sidebarReDisplay()) {
            //_plot.tbar.setDropdownItemCheck("View", 10, true);

            _plot.rightSidebar.showSidebar(true);
            //m_sidebarReDisplay = false;
            _plot.sidebar.setSidebarReDisplay(false);
          }
          //Static.trigger("positionChanged"); //force sidebar update
        }
      }
    });

    Static.bind("itemChanged", function (e, plotItem, on) {
      if (plotItem.rtti == PlotItem.RttiValues.Rtti_PlotGrid) {
        if (!on) {
          _plot.tbar.hideDropdownItem("View", 5);
        } else {
          _plot.tbar.showDropdownItem("View", 5);
        }
      }
    });

    Static.bind("rescaled", function (e, auto) {
      if (!auto) {
        self.setButtonCheck("Auto", false);
      }
    });

    if (_plot.title() == "") {
      self.hideDropdownItem("View", 6);
    }
    Static.bind("titleAdded", function (e, param) {
      //console.log(44, param)
      if (param) {
        self.showDropdownItem("View", 6);
      } else {
        self.hideDropdownItem("View", 6);
      }
    });

    if (_plot.footer() == "") {
      self.hideDropdownItem("View", 7);
    }
    Static.bind("footerAdded", function (e, param) {
      //console.log(44, param)
      if (param) {
        self.showDropdownItem("View", 7);
      } else {
        self.hideDropdownItem("View", 7);
      }
    });

    Static.bind("itemAttached", function (e, plotItem, on) {
      if (
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram
      ) {
        if (on) {
          //attached
          if (
            plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve ||
            plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
            plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram
          )
            self.enable(sBar);
          self.enable(cProp);
        } else {
          //detached
          if (
            _plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve).length == 0 &&
            _plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve).length ==
              0 &&
            _plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram).length == 0
          ) {
            self.disable(cProp);
          }
          if (
            !_plot
              .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
              .concat(_plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
              .concat(_plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
              .concat(_plot.itemList(PlotItem.RttiValues.Rtti_PlotZone)).length
              .length ||
            !_plot.hasVisibleCurveSpectrocurveOrSpectrogram()
          ) {
            self.disable(sBar);
            self.setButtonCheck(sBar, false);
          }
        }
        Static.trigger("visibilityChange", [plotItem, on]);
      }
    });

    Static.bind("showSidebar", function (e, anchorPosition, on) {
      if (anchorPosition !== "right") return;
      self.setButtonCheck(sBar, on);
      //console.log(459, on)
      if (on && _plot.tbar.isDropdownItemChecked("Watch", 6))
        _plot.cs.setEnabled(true);
      else _plot.cs.setEnabled(false);
    });

    /* The following code must be the last part of object construction. This way toolbar height is based on elements added to it. */
    if (_plot.sidebar !== undefined) {
      //sidebar created before toolbar
      //_plot.sidebar.setTop(parseInt($("#toolBar1").css("height")) + 2);
    } else {
      //sidebar created after toolbar. We listen for sidebar creation
      /* Static.bind("sidebarCreated", function (e, sidebar) {
                _plot.sidebar = sidebar;
                sidebar.setTop(parseInt($("#toolBar1").css("height")) + 2);
                Static.unbind("sidebarCreated");
            }); */
    }

    /* $(window).resize(function (e) {
            _plot.sidebar.setTop(parseInt($("#toolBar1").css("height")) + 2);
        }); */

    //this.hideDropdownItem("View", 10);
    //this.setButtonCheck('Auto', false);

    //"https://cah12.github.io/grapher/test.txt"

    /* mongodb://<dbuser>:<dbpassword>@ds023468.mlab.com:23468/cahuserdb
	var level = function(levelIndex, cb){
		//console.log("levelIndex:" + levelIndex);
		$.ajax({
          method: "POST",          
          url: '/level',
          data: {levelIndex: levelIndex},
          success: cb || defaultCb
        });
	}	 */

    /* $.ajaxPrefilter(function(options, originalOptions, jqXHR){
            options.url = 'https://game-service.herokuapp.com' + originalOptions.url;
            //options.url = 'http://localhost:3000' + originalOptions.url;           
        }); */

    function defaultCb(data, status) {
      console.log(status, data);
    }

    /* var level = function(levelIndex, cb){
		//console.log("levelIndex:" + levelIndex);
		$.ajax({
          method: "POST",          
          url: '/level',
          data: {levelIndex: levelIndex},
          success: cb || defaultCb
        });
	} */

    /* this.addToolButton("pushbutton", {
            text: "Test",
            tooltip: "Testing.",
            cb: function (e) {
                
				  $.ajax({
					  //Access-Control-Allow-Origin: https://example.com
					  
					  method: "GET",          
					  url: '/grapher/test.php/?name=tt&address=ttRd',
					  success: function(data, status){
						  console.log(status)
						  console.log(data)
					  }
					});
            }
        }); */
  }
}
;
define("mtoolBar", ["toolBar","curveSettings"], function(){});

/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var DO_NOT_EXPORT_CODEPAGE=true;var DO_NOT_EXPORT_JSZIP=true;(function(e){if("object"==typeof exports&&"undefined"!=typeof module&&"undefined"==typeof DO_NOT_EXPORT_JSZIP)module.exports=e();else if("function"==typeof define&&define.amd&&"undefined"==typeof DO_NOT_EXPORT_JSZIP){JSZipSync=e();define('xlsx',[],e)}else{var r;"undefined"!=typeof window?r=window:"undefined"!=typeof global?r=global:"undefined"!=typeof $&&$.global?r=$.global:"undefined"!=typeof self&&(r=self),r.JSZipSync=e()}})(function(){var e,r,t;return function a(e,r,t){function n(s,f){if(!r[s]){if(!e[s]){var l=typeof require=="function"&&require;if(!f&&l)return l(s,!0);if(i)return i(s,!0);throw new Error("Cannot find module '"+s+"'")}var o=r[s]={exports:{}};e[s][0].call(o.exports,function(r){var t=e[s][1][r];return n(t?t:r)},o,o.exports,a,e,r,t)}return r[s].exports}var i=typeof require=="function"&&require;for(var s=0;s<t.length;s++)n(t[s]);return n}({1:[function(e,r,t){"use strict";var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";t.encode=function(e,r){var t="";var n,i,s,f,l,o,c;var u=0;while(u<e.length){n=e.charCodeAt(u++);i=e.charCodeAt(u++);s=e.charCodeAt(u++);f=n>>2;l=(n&3)<<4|i>>4;o=(i&15)<<2|s>>6;c=s&63;if(isNaN(i)){o=c=64}else if(isNaN(s)){c=64}t=t+a.charAt(f)+a.charAt(l)+a.charAt(o)+a.charAt(c)}return t};t.decode=function(e,r){var t="";var n,i,s;var f,l,o,c;var u=0;e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");while(u<e.length){f=a.indexOf(e.charAt(u++));l=a.indexOf(e.charAt(u++));o=a.indexOf(e.charAt(u++));c=a.indexOf(e.charAt(u++));n=f<<2|l>>4;i=(l&15)<<4|o>>2;s=(o&3)<<6|c;t=t+String.fromCharCode(n);if(o!=64){t=t+String.fromCharCode(i)}if(c!=64){t=t+String.fromCharCode(s)}}return t}},{}],2:[function(e,r,t){"use strict";function a(){this.compressedSize=0;this.uncompressedSize=0;this.crc32=0;this.compressionMethod=null;this.compressedContent=null}a.prototype={getContent:function(){return null},getCompressedContent:function(){return null}};r.exports=a},{}],3:[function(e,r,t){"use strict";t.STORE={magic:"\0\0",compress:function(e){return e},uncompress:function(e){return e},compressInputType:null,uncompressInputType:null};t.DEFLATE=e("./flate")},{"./flate":8}],4:[function(e,r,t){"use strict";var a=e("./utils");var n=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];r.exports=function i(e,r){if(typeof e==="undefined"||!e.length){return 0}var t=a.getTypeOf(e)!=="string";if(typeof r=="undefined"){r=0}var i=0;var s=0;var f=0;r=r^-1;for(var l=0,o=e.length;l<o;l++){f=t?e[l]:e.charCodeAt(l);s=(r^f)&255;i=n[s];r=r>>>8^i}return r^-1}},{"./utils":21}],5:[function(e,r,t){"use strict";var a=e("./utils");function n(e){this.data=null;this.length=0;this.index=0}n.prototype={checkOffset:function(e){this.checkIndex(this.index+e)},checkIndex:function(e){if(this.length<e||e<0){throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")}},setIndex:function(e){this.checkIndex(e);this.index=e},skip:function(e){this.setIndex(this.index+e)},byteAt:function(e){},readInt:function(e){var r=0,t;this.checkOffset(e);for(t=this.index+e-1;t>=this.index;t--){r=(r<<8)+this.byteAt(t)}this.index+=e;return r},readString:function(e){return a.transformTo("string",this.readData(e))},readData:function(e){},lastIndexOfSignature:function(e){},readDate:function(){var e=this.readInt(4);return new Date((e>>25&127)+1980,(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(e&31)<<1)}};r.exports=n},{"./utils":21}],6:[function(e,r,t){"use strict";t.base64=false;t.binary=false;t.dir=false;t.createFolders=false;t.date=null;t.compression=null;t.comment=null},{}],7:[function(e,r,t){"use strict";var a=e("./utils");t.string2binary=function(e){return a.string2binary(e)};t.string2Uint8Array=function(e){return a.transformTo("uint8array",e)};t.uint8Array2String=function(e){return a.transformTo("string",e)};t.string2Blob=function(e){var r=a.transformTo("arraybuffer",e);return a.arrayBuffer2Blob(r)};t.arrayBuffer2Blob=function(e){return a.arrayBuffer2Blob(e)};t.transformTo=function(e,r){return a.transformTo(e,r)};t.getTypeOf=function(e){return a.getTypeOf(e)};t.checkSupport=function(e){return a.checkSupport(e)};t.MAX_VALUE_16BITS=a.MAX_VALUE_16BITS;t.MAX_VALUE_32BITS=a.MAX_VALUE_32BITS;t.pretty=function(e){return a.pretty(e)};t.findCompression=function(e){return a.findCompression(e)};t.isRegExp=function(e){return a.isRegExp(e)}},{"./utils":21}],8:[function(e,r,t){"use strict";var a=typeof Uint8Array!=="undefined"&&typeof Uint16Array!=="undefined"&&typeof Uint32Array!=="undefined";var n=e("pako");t.uncompressInputType=a?"uint8array":"array";t.compressInputType=a?"uint8array":"array";t.magic="\b\0";t.compress=function(e){return n.deflateRaw(e)};t.uncompress=function(e){return n.inflateRaw(e)}},{pako:24}],9:[function(e,r,t){"use strict";var a=e("./base64");function n(e,r){if(!(this instanceof n))return new n(e,r);this.files={};this.comment=null;this.root="";if(e){this.load(e,r)}this.clone=function(){var e=new n;for(var r in this){if(typeof this[r]!=="function"){e[r]=this[r]}}return e}}n.prototype=e("./object");n.prototype.load=e("./load");n.support=e("./support");n.defaults=e("./defaults");n.utils=e("./deprecatedPublicUtils");n.base64={encode:function(e){return a.encode(e)},decode:function(e){return a.decode(e)}};n.compressions=e("./compressions");r.exports=n},{"./base64":1,"./compressions":3,"./defaults":6,"./deprecatedPublicUtils":7,"./load":10,"./object":13,"./support":17}],10:[function(e,r,t){"use strict";var a=e("./base64");var n=e("./zipEntries");r.exports=function(e,r){var t,i,s,f;r=r||{};if(r.base64){e=a.decode(e)}i=new n(e,r);t=i.files;for(s=0;s<t.length;s++){f=t[s];this.file(f.fileName,f.decompressed,{binary:true,optimizedBinaryString:true,date:f.date,dir:f.dir,comment:f.fileComment.length?f.fileComment:null,createFolders:r.createFolders})}if(i.zipComment.length){this.comment=i.zipComment}return this}},{"./base64":1,"./zipEntries":22}],11:[function(e,r,t){(function(e){"use strict";var t=function(){};if(typeof e!=="undefined"){var a=!e.from;if(!a)try{e.from("foo","utf8")}catch(n){a=true}t=a?function(r,t){return t?new e(r,t):new e(r)}:e.from.bind(e);if(!e.alloc)e.alloc=function(r){return new e(r)}}r.exports=function(r,a){return typeof r=="number"?e.alloc(r):t(r,a)};r.exports.test=function(r){return e.isBuffer(r)}}).call(this,typeof Buffer!=="undefined"?Buffer:undefined)},{}],12:[function(e,r,t){"use strict";var a=e("./uint8ArrayReader");function n(e){this.data=e;this.length=this.data.length;this.index=0}n.prototype=new a;n.prototype.readData=function(e){this.checkOffset(e);var r=this.data.slice(this.index,this.index+e);this.index+=e;return r};r.exports=n},{"./uint8ArrayReader":18}],13:[function(e,r,t){"use strict";var a=e("./support");var n=e("./utils");var i=e("./crc32");var s=e("./signature");var f=e("./defaults");var l=e("./base64");var o=e("./compressions");var c=e("./compressedObject");var u=e("./nodeBuffer");var h=e("./utf8");var d=e("./stringWriter");var v=e("./uint8ArrayWriter");var p=function(e){if(e._data instanceof c){e._data=e._data.getContent();e.options.binary=true;e.options.base64=false;if(n.getTypeOf(e._data)==="uint8array"){var r=e._data;e._data=new Uint8Array(r.length);if(r.length!==0){e._data.set(r,0)}}}return e._data};var m=function(e){var r=p(e),t=n.getTypeOf(r);if(t==="string"){if(!e.options.binary){if(a.nodebuffer){return u(r,"utf-8")}}return e.asBinary()}return r};var b=function(e){var r=p(this);if(r===null||typeof r==="undefined"){return""}if(this.options.base64){r=l.decode(r)}if(e&&this.options.binary){r=y.utf8decode(r)}else{r=n.transformTo("string",r)}if(!e&&!this.options.binary){r=n.transformTo("string",y.utf8encode(r))}return r};var g=function(e,r,t){this.name=e;this.dir=t.dir;this.date=t.date;this.comment=t.comment;this._data=r;this.options=t;this._initialMetadata={dir:t.dir,date:t.date}};g.prototype={asText:function(){return b.call(this,true)},asBinary:function(){return b.call(this,false)},asNodeBuffer:function(){var e=m(this);return n.transformTo("nodebuffer",e)},asUint8Array:function(){var e=m(this);return n.transformTo("uint8array",e)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var w=function(e,r){var t="",a;for(a=0;a<r;a++){t+=String.fromCharCode(e&255);e=e>>>8}return t};var k=function(){var e={},r,t;for(r=0;r<arguments.length;r++){for(t in arguments[r]){if(arguments[r].hasOwnProperty(t)&&typeof e[t]==="undefined"){e[t]=arguments[r][t]}}}return e};var E=function(e){e=e||{};if(e.base64===true&&(e.binary===null||e.binary===undefined)){e.binary=true}e=k(e,f);e.date=e.date||new Date;if(e.compression!==null)e.compression=e.compression.toUpperCase();return e};var S=function(e,r,t){var a=n.getTypeOf(r),i;t=E(t);if(t.createFolders&&(i=_(e))){C.call(this,i,true)}if(t.dir||r===null||typeof r==="undefined"){t.base64=false;t.binary=false;r=null}else if(a==="string"){if(t.binary&&!t.base64){if(t.optimizedBinaryString!==true){r=n.string2binary(r)}}}else{t.base64=false;t.binary=true;if(!a&&!(r instanceof c)){throw new Error("The data of '"+e+"' is in an unsupported format !")}if(a==="arraybuffer"){r=n.transformTo("uint8array",r)}}var s=new g(e,r,t);this.files[e]=s;return s};var _=function(e){if(e.slice(-1)=="/"){e=e.substring(0,e.length-1)}var r=e.lastIndexOf("/");return r>0?e.substring(0,r):""};var C=function(e,r){if(e.slice(-1)!="/"){e+="/"}r=typeof r!=="undefined"?r:false;if(!this.files[e]){S.call(this,e,null,{dir:true,createFolders:r})}return this.files[e]};var B=function(e,r){var t=new c,a;if(e._data instanceof c){t.uncompressedSize=e._data.uncompressedSize;t.crc32=e._data.crc32;if(t.uncompressedSize===0||e.dir){r=o["STORE"];t.compressedContent="";t.crc32=0}else if(e._data.compressionMethod===r.magic){t.compressedContent=e._data.getCompressedContent()}else{a=e._data.getContent();t.compressedContent=r.compress(n.transformTo(r.compressInputType,a))}}else{a=m(e);if(!a||a.length===0||e.dir){r=o["STORE"];a=""}t.uncompressedSize=a.length;t.crc32=i(a);t.compressedContent=r.compress(n.transformTo(r.compressInputType,a))}t.compressedSize=t.compressedContent.length;t.compressionMethod=r.magic;return t};var T=function(e,r,t,a){var f=t.compressedContent,l=n.transformTo("string",h.utf8encode(r.name)),o=r.comment||"",c=n.transformTo("string",h.utf8encode(o)),u=l.length!==r.name.length,d=c.length!==o.length,v=r.options,p,m,b="",g="",k="",E,S;if(r._initialMetadata.dir!==r.dir){E=r.dir}else{E=v.dir}if(r._initialMetadata.date!==r.date){S=r.date}else{S=v.date}p=S.getHours();p=p<<6;p=p|S.getMinutes();p=p<<5;p=p|S.getSeconds()/2;m=S.getFullYear()-1980;m=m<<4;m=m|S.getMonth()+1;m=m<<5;m=m|S.getDate();if(u){g=w(1,1)+w(i(l),4)+l;b+="up"+w(g.length,2)+g}if(d){k=w(1,1)+w(this.crc32(c),4)+c;b+="uc"+w(k.length,2)+k}var _="";_+="\n\0";_+=u||d?"\0\b":"\0\0";_+=t.compressionMethod;_+=w(p,2);_+=w(m,2);_+=w(t.crc32,4);_+=w(t.compressedSize,4);_+=w(t.uncompressedSize,4);_+=w(l.length,2);_+=w(b.length,2);var C=s.LOCAL_FILE_HEADER+_+l+b;var B=s.CENTRAL_FILE_HEADER+"\0"+_+w(c.length,2)+"\0\0"+"\0\0"+(E===true?"\0\0\0":"\0\0\0\0")+w(a,4)+l+b+c;return{fileRecord:C,dirRecord:B,compressedObject:t}};var y={load:function(e,r){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(e){var r=[],t,a,n,i;for(t in this.files){if(!this.files.hasOwnProperty(t)){continue}n=this.files[t];i=new g(n.name,n._data,k(n.options));a=t.slice(this.root.length,t.length);if(t.slice(0,this.root.length)===this.root&&e(a,i)){r.push(i)}}return r},file:function(e,r,t){if(arguments.length===1){if(n.isRegExp(e)){var a=e;return this.filter(function(e,r){return!r.dir&&a.test(e)})}else{return this.filter(function(r,t){return!t.dir&&r===e})[0]||null}}else{e=this.root+e;S.call(this,e,r,t)}return this},folder:function(e){if(!e){return this}if(n.isRegExp(e)){return this.filter(function(r,t){return t.dir&&e.test(r)})}var r=this.root+e;var t=C.call(this,r);var a=this.clone();a.root=t.name;return a},remove:function(e){e=this.root+e;var r=this.files[e];if(!r){if(e.slice(-1)!="/"){e+="/"}r=this.files[e]}if(r&&!r.dir){delete this.files[e]}else{var t=this.filter(function(r,t){return t.name.slice(0,e.length)===e});for(var a=0;a<t.length;a++){delete this.files[t[a].name]}}return this},generate:function(e){e=k(e||{},{base64:true,compression:"STORE",type:"base64",comment:null});n.checkSupport(e.type);var r=[],t=0,a=0,i,f,c=n.transformTo("string",this.utf8encode(e.comment||this.comment||""));for(var u in this.files){if(!this.files.hasOwnProperty(u)){continue}var h=this.files[u];var p=h.options.compression||e.compression.toUpperCase();var m=o[p];if(!m){throw new Error(p+" is not a valid compression method !")}var b=B.call(this,h,m);var g=T.call(this,u,h,b,t);t+=g.fileRecord.length+b.compressedSize;a+=g.dirRecord.length;r.push(g)}var E="";E=s.CENTRAL_DIRECTORY_END+"\0\0"+"\0\0"+w(r.length,2)+w(r.length,2)+w(a,4)+w(t,4)+w(c.length,2)+c;var S=e.type.toLowerCase();if(S==="uint8array"||S==="arraybuffer"||S==="blob"||S==="nodebuffer"){i=new v(t+a+E.length)}else{i=new d(t+a+E.length)}for(f=0;f<r.length;f++){i.append(r[f].fileRecord);i.append(r[f].compressedObject.compressedContent)}for(f=0;f<r.length;f++){i.append(r[f].dirRecord)}i.append(E);var _=i.finalize();switch(e.type.toLowerCase()){case"uint8array":;case"arraybuffer":;case"nodebuffer":return n.transformTo(e.type.toLowerCase(),_);case"blob":return n.arrayBuffer2Blob(n.transformTo("arraybuffer",_));case"base64":return e.base64?l.encode(_):_;default:return _;}},crc32:function(e,r){return i(e,r)},utf8encode:function(e){return n.transformTo("string",h.utf8encode(e))},utf8decode:function(e){return h.utf8decode(e)}};r.exports=y},{"./base64":1,"./compressedObject":2,"./compressions":3,"./crc32":4,"./defaults":6,"./nodeBuffer":11,"./signature":14,"./stringWriter":16,"./support":17,"./uint8ArrayWriter":19,"./utf8":20,"./utils":21}],14:[function(e,r,t){"use strict";t.LOCAL_FILE_HEADER="PK";t.CENTRAL_FILE_HEADER="PK";t.CENTRAL_DIRECTORY_END="PK";t.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK";t.ZIP64_CENTRAL_DIRECTORY_END="PK";t.DATA_DESCRIPTOR="PK\b"},{}],15:[function(e,r,t){"use strict";var a=e("./dataReader");var n=e("./utils");function i(e,r){this.data=e;if(!r){this.data=n.string2binary(this.data)}this.length=this.data.length;this.index=0}i.prototype=new a;i.prototype.byteAt=function(e){return this.data.charCodeAt(e)};i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)};i.prototype.readData=function(e){this.checkOffset(e);var r=this.data.slice(this.index,this.index+e);this.index+=e;return r};r.exports=i},{"./dataReader":5,"./utils":21}],16:[function(e,r,t){"use strict";var a=e("./utils");var n=function(){this.data=[]};n.prototype={append:function(e){e=a.transformTo("string",e);this.data.push(e)},finalize:function(){return this.data.join("")}};r.exports=n},{"./utils":21}],17:[function(e,r,t){(function(e){"use strict";t.base64=true;t.array=true;t.string=true;t.arraybuffer=typeof ArrayBuffer!=="undefined"&&typeof Uint8Array!=="undefined";t.nodebuffer=typeof e!=="undefined";t.uint8array=typeof Uint8Array!=="undefined";if(typeof ArrayBuffer==="undefined"){t.blob=false}else{var r=new ArrayBuffer(0);try{t.blob=new Blob([r],{type:"application/zip"}).size===0}catch(a){try{var n=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder;var i=new n;i.append(r);t.blob=i.getBlob("application/zip").size===0}catch(a){t.blob=false}}}}).call(this,typeof Buffer!=="undefined"?Buffer:undefined)},{}],18:[function(e,r,t){"use strict";var a=e("./dataReader");function n(e){if(e){this.data=e;this.length=this.data.length;this.index=0}}n.prototype=new a;n.prototype.byteAt=function(e){return this.data[e]};n.prototype.lastIndexOfSignature=function(e){var r=e.charCodeAt(0),t=e.charCodeAt(1),a=e.charCodeAt(2),n=e.charCodeAt(3);for(var i=this.length-4;i>=0;--i){if(this.data[i]===r&&this.data[i+1]===t&&this.data[i+2]===a&&this.data[i+3]===n){return i}}return-1};n.prototype.readData=function(e){this.checkOffset(e);if(e===0){return new Uint8Array(0)}var r=this.data.subarray(this.index,this.index+e);this.index+=e;return r};r.exports=n},{"./dataReader":5}],19:[function(e,r,t){"use strict";var a=e("./utils");var n=function(e){this.data=new Uint8Array(e);this.index=0};n.prototype={append:function(e){if(e.length!==0){e=a.transformTo("uint8array",e);this.data.set(e,this.index);this.index+=e.length}},finalize:function(){return this.data}};r.exports=n},{"./utils":21}],20:[function(e,r,t){"use strict";var a=e("./utils");var n=e("./support");var i=e("./nodeBuffer");var s=new Array(256);for(var f=0;f<256;f++){s[f]=f>=252?6:f>=248?5:f>=240?4:f>=224?3:f>=192?2:1}s[254]=s[254]=1;var l=function(e){var r,t,a,i,s,f=e.length,l=0;for(i=0;i<f;i++){t=e.charCodeAt(i);if((t&64512)===55296&&i+1<f){a=e.charCodeAt(i+1);if((a&64512)===56320){t=65536+(t-55296<<10)+(a-56320);i++}}l+=t<128?1:t<2048?2:t<65536?3:4}if(n.uint8array){r=new Uint8Array(l)}else{r=new Array(l)}for(s=0,i=0;s<l;i++){t=e.charCodeAt(i);if((t&64512)===55296&&i+1<f){a=e.charCodeAt(i+1);if((a&64512)===56320){t=65536+(t-55296<<10)+(a-56320);i++}}if(t<128){r[s++]=t}else if(t<2048){r[s++]=192|t>>>6;r[s++]=128|t&63}else if(t<65536){r[s++]=224|t>>>12;r[s++]=128|t>>>6&63;r[s++]=128|t&63}else{r[s++]=240|t>>>18;r[s++]=128|t>>>12&63;r[s++]=128|t>>>6&63;r[s++]=128|t&63}}return r};var o=function(e,r){var t;r=r||e.length;if(r>e.length){r=e.length}t=r-1;while(t>=0&&(e[t]&192)===128){t--}if(t<0){return r}if(t===0){return r}return t+s[e[t]]>r?t:r};var c=function(e){var r,t,n,i,f;var l=e.length;var o=new Array(l*2);for(n=0,t=0;t<l;){i=e[t++];if(i<128){o[n++]=i;continue}f=s[i];if(f>4){o[n++]=65533;t+=f-1;continue}i&=f===2?31:f===3?15:7;while(f>1&&t<l){i=i<<6|e[t++]&63;f--}if(f>1){o[n++]=65533;continue}if(i<65536){o[n++]=i}else{i-=65536;o[n++]=55296|i>>10&1023;o[n++]=56320|i&1023}}if(o.length!==n){if(o.subarray){o=o.subarray(0,n)}else{o.length=n}}return a.applyFromCharCode(o)};t.utf8encode=function u(e){if(n.nodebuffer){return i(e,"utf-8")}return l(e)};t.utf8decode=function h(e){if(n.nodebuffer){return a.transformTo("nodebuffer",e).toString("utf-8")}e=a.transformTo(n.uint8array?"uint8array":"array",e);var r=[],t=0,i=e.length,s=65536;while(t<i){var f=o(e,Math.min(t+s,i));if(n.uint8array){r.push(c(e.subarray(t,f)))}else{r.push(c(e.slice(t,f)))}t=f}return r.join("")}},{"./nodeBuffer":11,"./support":17,"./utils":21}],21:[function(e,r,t){"use strict";var a=e("./support");var n=e("./compressions");var i=e("./nodeBuffer");t.string2binary=function(e){var r="";for(var t=0;t<e.length;t++){r+=String.fromCharCode(e.charCodeAt(t)&255)}return r};t.arrayBuffer2Blob=function(e){t.checkSupport("blob");try{return new Blob([e],{type:"application/zip"})}catch(r){try{var a=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder;var n=new a;n.append(e);return n.getBlob("application/zip")}catch(r){throw new Error("Bug : can't construct the Blob.")}}};function s(e){return e}function f(e,r){for(var t=0;t<e.length;++t){r[t]=e.charCodeAt(t)&255}return r}function l(e){var r=65536;var a=[],n=e.length,s=t.getTypeOf(e),f=0,l=true;try{switch(s){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,i(0));break;}}catch(o){l=false}if(!l){var c="";for(var u=0;u<e.length;u++){c+=String.fromCharCode(e[u])}return c}while(f<n&&r>1){try{if(s==="array"||s==="nodebuffer"){a.push(String.fromCharCode.apply(null,e.slice(f,Math.min(f+r,n))))}else{a.push(String.fromCharCode.apply(null,e.subarray(f,Math.min(f+r,n))))}f+=r}catch(o){r=Math.floor(r/2)}}return a.join("")}t.applyFromCharCode=l;function o(e,r){for(var t=0;t<e.length;t++){r[t]=e[t]}return r}var c={};c["string"]={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return c["string"]["uint8array"](e).buffer},uint8array:function(e){return f(e,new Uint8Array(e.length))},nodebuffer:function(e){return f(e,i(e.length))}};c["array"]={string:l,array:s,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return i(e)}};c["arraybuffer"]={string:function(e){return l(new Uint8Array(e))},array:function(e){return o(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:s,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return i(new Uint8Array(e))}};c["uint8array"]={string:l,array:function(e){return o(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:s,nodebuffer:function(e){return i(e)}};c["nodebuffer"]={string:l,array:function(e){return o(e,new Array(e.length))},arraybuffer:function(e){return c["nodebuffer"]["uint8array"](e).buffer},uint8array:function(e){return o(e,new Uint8Array(e.length))},nodebuffer:s};t.transformTo=function(e,r){if(!r){r=""}if(!e){return r}t.checkSupport(e);var a=t.getTypeOf(r);var n=c[a][e](r);return n};t.getTypeOf=function(e){if(typeof e==="string"){return"string"}if(Object.prototype.toString.call(e)==="[object Array]"){return"array"}if(a.nodebuffer&&i.test(e)){return"nodebuffer"}if(a.uint8array&&e instanceof Uint8Array){return"uint8array"}if(a.arraybuffer&&e instanceof ArrayBuffer){return"arraybuffer"}};t.checkSupport=function(e){var r=a[e.toLowerCase()];if(!r){throw new Error(e+" is not supported by this browser")}};t.MAX_VALUE_16BITS=65535;t.MAX_VALUE_32BITS=-1;t.pretty=function(e){var r="",t,a;for(a=0;a<(e||"").length;a++){t=e.charCodeAt(a);r+="\\x"+(t<16?"0":"")+t.toString(16).toUpperCase()}return r};t.findCompression=function(e){for(var r in n){if(!n.hasOwnProperty(r)){continue}if(n[r].magic===e){return n[r]}}return null};t.isRegExp=function(e){return Object.prototype.toString.call(e)==="[object RegExp]"}},{"./compressions":3,"./nodeBuffer":11,"./support":17}],22:[function(e,r,t){"use strict";var a=e("./stringReader");var n=e("./nodeBufferReader");var i=e("./uint8ArrayReader");var s=e("./utils");var f=e("./signature");var l=e("./zipEntry");var o=e("./support");var c=e("./object");function u(e,r){this.files=[];this.loadOptions=r;if(e){this.load(e)}}u.prototype={checkSignature:function(e){var r=this.reader.readString(4);if(r!==e){throw new Error("Corrupted zip or bug : unexpected signature "+"("+s.pretty(r)+", expected "+s.pretty(e)+")")}},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2);this.diskWithCentralDirStart=this.reader.readInt(2);this.centralDirRecordsOnThisDisk=this.reader.readInt(2);this.centralDirRecords=this.reader.readInt(2);this.centralDirSize=this.reader.readInt(4);this.centralDirOffset=this.reader.readInt(4);this.zipCommentLength=this.reader.readInt(2);this.zipComment=this.reader.readString(this.zipCommentLength);this.zipComment=c.utf8decode(this.zipComment)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8);this.versionMadeBy=this.reader.readString(2);this.versionNeeded=this.reader.readInt(2);this.diskNumber=this.reader.readInt(4);this.diskWithCentralDirStart=this.reader.readInt(4);this.centralDirRecordsOnThisDisk=this.reader.readInt(8);this.centralDirRecords=this.reader.readInt(8);this.centralDirSize=this.reader.readInt(8);this.centralDirOffset=this.reader.readInt(8);this.zip64ExtensibleData={};var e=this.zip64EndOfCentralSize-44,r=0,t,a,n;while(r<e){t=this.reader.readInt(2);a=this.reader.readInt(4);n=this.reader.readString(a);this.zip64ExtensibleData[t]={id:t,length:a,value:n}}},readBlockZip64EndOfCentralLocator:function(){this.diskWithZip64CentralDirStart=this.reader.readInt(4);this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8);this.disksCount=this.reader.readInt(4);if(this.disksCount>1){throw new Error("Multi-volumes zip are not supported")}},readLocalFiles:function(){var e,r;for(e=0;e<this.files.length;e++){r=this.files[e];this.reader.setIndex(r.localHeaderOffset);this.checkSignature(f.LOCAL_FILE_HEADER);r.readLocalPart(this.reader);r.handleUTF8()}},readCentralDir:function(){var e;this.reader.setIndex(this.centralDirOffset);while(this.reader.readString(4)===f.CENTRAL_FILE_HEADER){e=new l({zip64:this.zip64},this.loadOptions);e.readCentralPart(this.reader);this.files.push(e)}},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(f.CENTRAL_DIRECTORY_END);if(e===-1){throw new Error("Corrupted zip : can't find end of central directory")}this.reader.setIndex(e);this.checkSignature(f.CENTRAL_DIRECTORY_END);this.readBlockEndOfCentral();if(this.diskNumber===s.MAX_VALUE_16BITS||this.diskWithCentralDirStart===s.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===s.MAX_VALUE_16BITS||this.centralDirRecords===s.MAX_VALUE_16BITS||this.centralDirSize===s.MAX_VALUE_32BITS||this.centralDirOffset===s.MAX_VALUE_32BITS){this.zip64=true;e=this.reader.lastIndexOfSignature(f.ZIP64_CENTRAL_DIRECTORY_LOCATOR);if(e===-1){throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator")}this.reader.setIndex(e);this.checkSignature(f.ZIP64_CENTRAL_DIRECTORY_LOCATOR);this.readBlockZip64EndOfCentralLocator();this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);this.checkSignature(f.ZIP64_CENTRAL_DIRECTORY_END);this.readBlockZip64EndOfCentral()}},prepareReader:function(e){var r=s.getTypeOf(e);if(r==="string"&&!o.uint8array){this.reader=new a(e,this.loadOptions.optimizedBinaryString)}else if(r==="nodebuffer"){this.reader=new n(e)}else{this.reader=new i(s.transformTo("uint8array",e))}},load:function(e){this.prepareReader(e);this.readEndOfCentral();this.readCentralDir();this.readLocalFiles()}};r.exports=u},{"./nodeBufferReader":12,"./object":13,"./signature":14,"./stringReader":15,"./support":17,"./uint8ArrayReader":18,"./utils":21,"./zipEntry":23}],23:[function(e,r,t){"use strict";var a=e("./stringReader");var n=e("./utils");var i=e("./compressedObject");var s=e("./object");function f(e,r){this.options=e;this.loadOptions=r}f.prototype={isEncrypted:function(){return(this.bitFlag&1)===1},useUTF8:function(){return(this.bitFlag&2048)===2048},prepareCompressedContent:function(e,r,t){return function(){var a=e.index;e.setIndex(r);var n=e.readData(t);e.setIndex(a);return n}},prepareContent:function(e,r,t,a,i){return function(){var e=n.transformTo(a.uncompressInputType,this.getCompressedContent());var r=a.uncompress(e);if(r.length!==i){throw new Error("Bug : uncompressed data size mismatch")}return r}},readLocalPart:function(e){var r,t;e.skip(22);this.fileNameLength=e.readInt(2);t=e.readInt(2);this.fileName=e.readString(this.fileNameLength);e.skip(t);if(this.compressedSize==-1||this.uncompressedSize==-1){throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory "+"(compressedSize == -1 || uncompressedSize == -1)")}r=n.findCompression(this.compressionMethod);if(r===null){throw new Error("Corrupted zip : compression "+n.pretty(this.compressionMethod)+" unknown (inner file : "+this.fileName+")")}this.decompressed=new i;this.decompressed.compressedSize=this.compressedSize;this.decompressed.uncompressedSize=this.uncompressedSize;this.decompressed.crc32=this.crc32;this.decompressed.compressionMethod=this.compressionMethod;this.decompressed.getCompressedContent=this.prepareCompressedContent(e,e.index,this.compressedSize,r);this.decompressed.getContent=this.prepareContent(e,e.index,this.compressedSize,r,this.uncompressedSize);if(this.loadOptions.checkCRC32){this.decompressed=n.transformTo("string",this.decompressed.getContent());if(s.crc32(this.decompressed)!==this.crc32){throw new Error("Corrupted zip : CRC32 mismatch")}}},readCentralPart:function(e){this.versionMadeBy=e.readString(2);this.versionNeeded=e.readInt(2);this.bitFlag=e.readInt(2);this.compressionMethod=e.readString(2);this.date=e.readDate();this.crc32=e.readInt(4);this.compressedSize=e.readInt(4);this.uncompressedSize=e.readInt(4);this.fileNameLength=e.readInt(2);this.extraFieldsLength=e.readInt(2);this.fileCommentLength=e.readInt(2);this.diskNumberStart=e.readInt(2);this.internalFileAttributes=e.readInt(2);this.externalFileAttributes=e.readInt(4);this.localHeaderOffset=e.readInt(4);if(this.isEncrypted()){throw new Error("Encrypted zip are not supported")}this.fileName=e.readString(this.fileNameLength);this.readExtraFields(e);this.parseZIP64ExtraField(e);this.fileComment=e.readString(this.fileCommentLength);this.dir=this.externalFileAttributes&16?true:false},parseZIP64ExtraField:function(e){if(!this.extraFields[1]){return}var r=new a(this.extraFields[1].value);if(this.uncompressedSize===n.MAX_VALUE_32BITS){this.uncompressedSize=r.readInt(8)}if(this.compressedSize===n.MAX_VALUE_32BITS){this.compressedSize=r.readInt(8)}if(this.localHeaderOffset===n.MAX_VALUE_32BITS){this.localHeaderOffset=r.readInt(8)}if(this.diskNumberStart===n.MAX_VALUE_32BITS){this.diskNumberStart=r.readInt(4)}},readExtraFields:function(e){var r=e.index,t,a,n;this.extraFields=this.extraFields||{};while(e.index<r+this.extraFieldsLength){t=e.readInt(2);a=e.readInt(2);n=e.readString(a);this.extraFields[t]={id:t,length:a,value:n}}},handleUTF8:function(){if(this.useUTF8()){this.fileName=s.utf8decode(this.fileName);this.fileComment=s.utf8decode(this.fileComment)}else{var e=this.findExtraFieldUnicodePath();if(e!==null){this.fileName=e}var r=this.findExtraFieldUnicodeComment();if(r!==null){this.fileComment=r}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var r=new a(e.value);if(r.readInt(1)!==1){return null}if(s.crc32(this.fileName)!==r.readInt(4)){
return null}return s.utf8decode(r.readString(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var r=new a(e.value);if(r.readInt(1)!==1){return null}if(s.crc32(this.fileComment)!==r.readInt(4)){return null}return s.utf8decode(r.readString(e.length-5))}return null}};r.exports=f},{"./compressedObject":2,"./object":13,"./stringReader":15,"./utils":21}],24:[function(e,r,t){"use strict";var a=e("./lib/utils/common").assign;var n=e("./lib/deflate");var i=e("./lib/inflate");var s=e("./lib/zlib/constants");var f={};a(f,n,i,s);r.exports=f},{"./lib/deflate":25,"./lib/inflate":26,"./lib/utils/common":27,"./lib/zlib/constants":30}],25:[function(e,r,t){"use strict";var a=e("./zlib/deflate.js");var n=e("./utils/common");var i=e("./utils/strings");var s=e("./zlib/messages");var f=e("./zlib/zstream");var l=0;var o=4;var c=0;var u=1;var h=-1;var d=0;var v=8;var p=function(e){this.options=n.assign({level:h,method:v,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},e||{});var r=this.options;if(r.raw&&r.windowBits>0){r.windowBits=-r.windowBits}else if(r.gzip&&r.windowBits>0&&r.windowBits<16){r.windowBits+=16}this.err=0;this.msg="";this.ended=false;this.chunks=[];this.strm=new f;this.strm.avail_out=0;var t=a.deflateInit2(this.strm,r.level,r.method,r.windowBits,r.memLevel,r.strategy);if(t!==c){throw new Error(s[t])}if(r.header){a.deflateSetHeader(this.strm,r.header)}};p.prototype.push=function(e,r){var t=this.strm;var s=this.options.chunkSize;var f,h;if(this.ended){return false}h=r===~~r?r:r===true?o:l;if(typeof e==="string"){t.input=i.string2buf(e)}else{t.input=e}t.next_in=0;t.avail_in=t.input.length;do{if(t.avail_out===0){t.output=new n.Buf8(s);t.next_out=0;t.avail_out=s}f=a.deflate(t,h);if(f!==u&&f!==c){this.onEnd(f);this.ended=true;return false}if(t.avail_out===0||t.avail_in===0&&h===o){if(this.options.to==="string"){this.onData(i.buf2binstring(n.shrinkBuf(t.output,t.next_out)))}else{this.onData(n.shrinkBuf(t.output,t.next_out))}}}while((t.avail_in>0||t.avail_out===0)&&f!==u);if(h===o){f=a.deflateEnd(this.strm);this.onEnd(f);this.ended=true;return f===c}return true};p.prototype.onData=function(e){this.chunks.push(e)};p.prototype.onEnd=function(e){if(e===c){if(this.options.to==="string"){this.result=this.chunks.join("")}else{this.result=n.flattenChunks(this.chunks)}}this.chunks=[];this.err=e;this.msg=this.strm.msg};function m(e,r){var t=new p(r);t.push(e,true);if(t.err){throw t.msg}return t.result}function b(e,r){r=r||{};r.raw=true;return m(e,r)}function g(e,r){r=r||{};r.gzip=true;return m(e,r)}t.Deflate=p;t.deflate=m;t.deflateRaw=b;t.gzip=g},{"./utils/common":27,"./utils/strings":28,"./zlib/deflate.js":32,"./zlib/messages":37,"./zlib/zstream":39}],26:[function(e,r,t){"use strict";var a=e("./zlib/inflate.js");var n=e("./utils/common");var i=e("./utils/strings");var s=e("./zlib/constants");var f=e("./zlib/messages");var l=e("./zlib/zstream");var o=e("./zlib/gzheader");var c=function(e){this.options=n.assign({chunkSize:16384,windowBits:0,to:""},e||{});var r=this.options;if(r.raw&&r.windowBits>=0&&r.windowBits<16){r.windowBits=-r.windowBits;if(r.windowBits===0){r.windowBits=-15}}if(r.windowBits>=0&&r.windowBits<16&&!(e&&e.windowBits)){r.windowBits+=32}if(r.windowBits>15&&r.windowBits<48){if((r.windowBits&15)===0){r.windowBits|=15}}this.err=0;this.msg="";this.ended=false;this.chunks=[];this.strm=new l;this.strm.avail_out=0;var t=a.inflateInit2(this.strm,r.windowBits);if(t!==s.Z_OK){throw new Error(f[t])}this.header=new o;a.inflateGetHeader(this.strm,this.header)};c.prototype.push=function(e,r){var t=this.strm;var f=this.options.chunkSize;var l,o;var c,u,h;if(this.ended){return false}o=r===~~r?r:r===true?s.Z_FINISH:s.Z_NO_FLUSH;if(typeof e==="string"){t.input=i.binstring2buf(e)}else{t.input=e}t.next_in=0;t.avail_in=t.input.length;do{if(t.avail_out===0){t.output=new n.Buf8(f);t.next_out=0;t.avail_out=f}l=a.inflate(t,s.Z_NO_FLUSH);if(l!==s.Z_STREAM_END&&l!==s.Z_OK){this.onEnd(l);this.ended=true;return false}if(t.next_out){if(t.avail_out===0||l===s.Z_STREAM_END||t.avail_in===0&&o===s.Z_FINISH){if(this.options.to==="string"){c=i.utf8border(t.output,t.next_out);u=t.next_out-c;h=i.buf2string(t.output,c);t.next_out=u;t.avail_out=f-u;if(u){n.arraySet(t.output,t.output,c,u,0)}this.onData(h)}else{this.onData(n.shrinkBuf(t.output,t.next_out))}}}}while(t.avail_in>0&&l!==s.Z_STREAM_END);if(l===s.Z_STREAM_END){o=s.Z_FINISH}if(o===s.Z_FINISH){l=a.inflateEnd(this.strm);this.onEnd(l);this.ended=true;return l===s.Z_OK}return true};c.prototype.onData=function(e){this.chunks.push(e)};c.prototype.onEnd=function(e){if(e===s.Z_OK){if(this.options.to==="string"){this.result=this.chunks.join("")}else{this.result=n.flattenChunks(this.chunks)}}this.chunks=[];this.err=e;this.msg=this.strm.msg};function u(e,r){var t=new c(r);t.push(e,true);if(t.err){throw t.msg}return t.result}function h(e,r){r=r||{};r.raw=true;return u(e,r)}t.Inflate=c;t.inflate=u;t.inflateRaw=h;t.ungzip=u},{"./utils/common":27,"./utils/strings":28,"./zlib/constants":30,"./zlib/gzheader":33,"./zlib/inflate.js":35,"./zlib/messages":37,"./zlib/zstream":39}],27:[function(e,r,t){"use strict";var a=typeof Uint8Array!=="undefined"&&typeof Uint16Array!=="undefined"&&typeof Int32Array!=="undefined";t.assign=function(e){var r=Array.prototype.slice.call(arguments,1);while(r.length){var t=r.shift();if(!t){continue}if(typeof t!=="object"){throw new TypeError(t+"must be non-object")}for(var a in t){if(t.hasOwnProperty(a)){e[a]=t[a]}}}return e};t.shrinkBuf=function(e,r){if(e.length===r){return e}if(e.subarray){return e.subarray(0,r)}e.length=r;return e};var n={arraySet:function(e,r,t,a,n){if(r.subarray&&e.subarray){e.set(r.subarray(t,t+a),n);return}for(var i=0;i<a;i++){e[n+i]=r[t+i]}},flattenChunks:function(e){var r,t,a,n,i,s;a=0;for(r=0,t=e.length;r<t;r++){a+=e[r].length}s=new Uint8Array(a);n=0;for(r=0,t=e.length;r<t;r++){i=e[r];s.set(i,n);n+=i.length}return s}};var i={arraySet:function(e,r,t,a,n){for(var i=0;i<a;i++){e[n+i]=r[t+i]}},flattenChunks:function(e){return[].concat.apply([],e)}};t.setTyped=function(e){if(e){t.Buf8=Uint8Array;t.Buf16=Uint16Array;t.Buf32=Int32Array;t.assign(t,n)}else{t.Buf8=Array;t.Buf16=Array;t.Buf32=Array;t.assign(t,i)}};t.setTyped(a)},{}],28:[function(e,r,t){"use strict";var a=e("./common");var n=true;var i=true;try{String.fromCharCode.apply(null,[0])}catch(s){n=false}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(s){i=false}var f=new a.Buf8(256);for(var l=0;l<256;l++){f[l]=l>=252?6:l>=248?5:l>=240?4:l>=224?3:l>=192?2:1}f[254]=f[254]=1;t.string2buf=function(e){var r,t,n,i,s,f=e.length,l=0;for(i=0;i<f;i++){t=e.charCodeAt(i);if((t&64512)===55296&&i+1<f){n=e.charCodeAt(i+1);if((n&64512)===56320){t=65536+(t-55296<<10)+(n-56320);i++}}l+=t<128?1:t<2048?2:t<65536?3:4}r=new a.Buf8(l);for(s=0,i=0;s<l;i++){t=e.charCodeAt(i);if((t&64512)===55296&&i+1<f){n=e.charCodeAt(i+1);if((n&64512)===56320){t=65536+(t-55296<<10)+(n-56320);i++}}if(t<128){r[s++]=t}else if(t<2048){r[s++]=192|t>>>6;r[s++]=128|t&63}else if(t<65536){r[s++]=224|t>>>12;r[s++]=128|t>>>6&63;r[s++]=128|t&63}else{r[s++]=240|t>>>18;r[s++]=128|t>>>12&63;r[s++]=128|t>>>6&63;r[s++]=128|t&63}}return r};function o(e,r){if(r<65537){if(e.subarray&&i||!e.subarray&&n){return String.fromCharCode.apply(null,a.shrinkBuf(e,r))}}var t="";for(var s=0;s<r;s++){t+=String.fromCharCode(e[s])}return t}t.buf2binstring=function(e){return o(e,e.length)};t.binstring2buf=function(e){var r=new a.Buf8(e.length);for(var t=0,n=r.length;t<n;t++){r[t]=e.charCodeAt(t)}return r};t.buf2string=function(e,r){var t,a,n,i;var s=r||e.length;var l=new Array(s*2);for(a=0,t=0;t<s;){n=e[t++];if(n<128){l[a++]=n;continue}i=f[n];if(i>4){l[a++]=65533;t+=i-1;continue}n&=i===2?31:i===3?15:7;while(i>1&&t<s){n=n<<6|e[t++]&63;i--}if(i>1){l[a++]=65533;continue}if(n<65536){l[a++]=n}else{n-=65536;l[a++]=55296|n>>10&1023;l[a++]=56320|n&1023}}return o(l,a)};t.utf8border=function(e,r){var t;r=r||e.length;if(r>e.length){r=e.length}t=r-1;while(t>=0&&(e[t]&192)===128){t--}if(t<0){return r}if(t===0){return r}return t+f[e[t]]>r?t:r}},{"./common":27}],29:[function(e,r,t){"use strict";function a(e,r,t,a){var n=e&65535|0,i=e>>>16&65535|0,s=0;while(t!==0){s=t>2e3?2e3:t;t-=s;do{n=n+r[a++]|0;i=i+n|0}while(--s);n%=65521;i%=65521}return n|i<<16|0}r.exports=a},{}],30:[function(e,r,t){r.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],31:[function(e,r,t){"use strict";function a(){var e,r=[];for(var t=0;t<256;t++){e=t;for(var a=0;a<8;a++){e=e&1?3988292384^e>>>1:e>>>1}r[t]=e}return r}var n=a();function i(e,r,t,a){var i=n,s=a+t;e=e^-1;for(var f=a;f<s;f++){e=e>>>8^i[(e^r[f])&255]}return e^-1}r.exports=i},{}],32:[function(e,r,t){"use strict";var a=e("../utils/common");var n=e("./trees");var i=e("./adler32");var s=e("./crc32");var f=e("./messages");var l=0;var o=1;var c=3;var u=4;var h=5;var d=0;var v=1;var p=-2;var m=-3;var b=-5;var g=-1;var w=1;var k=2;var E=3;var S=4;var _=0;var C=2;var B=8;var T=9;var y=15;var x=8;var A=29;var I=256;var R=I+1+A;var D=30;var F=19;var O=2*R+1;var P=15;var N=3;var L=258;var M=L+N+1;var U=32;var H=42;var W=69;var z=73;var V=91;var X=103;var G=113;var j=666;var K=1;var Y=2;var $=3;var Z=4;var Q=3;function J(e,r){e.msg=f[r];return r}function q(e){return(e<<1)-(e>4?9:0)}function ee(e){var r=e.length;while(--r>=0){e[r]=0}}function re(e){var r=e.state;var t=r.pending;if(t>e.avail_out){t=e.avail_out}if(t===0){return}a.arraySet(e.output,r.pending_buf,r.pending_out,t,e.next_out);e.next_out+=t;r.pending_out+=t;e.total_out+=t;e.avail_out-=t;r.pending-=t;if(r.pending===0){r.pending_out=0}}function te(e,r){n._tr_flush_block(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,r);e.block_start=e.strstart;re(e.strm)}function ae(e,r){e.pending_buf[e.pending++]=r}function ne(e,r){e.pending_buf[e.pending++]=r>>>8&255;e.pending_buf[e.pending++]=r&255}function ie(e,r,t,n){var f=e.avail_in;if(f>n){f=n}if(f===0){return 0}e.avail_in-=f;a.arraySet(r,e.input,e.next_in,f,t);if(e.state.wrap===1){e.adler=i(e.adler,r,f,t)}else if(e.state.wrap===2){e.adler=s(e.adler,r,f,t)}e.next_in+=f;e.total_in+=f;return f}function se(e,r){var t=e.max_chain_length;var a=e.strstart;var n;var i;var s=e.prev_length;var f=e.nice_match;var l=e.strstart>e.w_size-M?e.strstart-(e.w_size-M):0;var o=e.window;var c=e.w_mask;var u=e.prev;var h=e.strstart+L;var d=o[a+s-1];var v=o[a+s];if(e.prev_length>=e.good_match){t>>=2}if(f>e.lookahead){f=e.lookahead}do{n=r;if(o[n+s]!==v||o[n+s-1]!==d||o[n]!==o[a]||o[++n]!==o[a+1]){continue}a+=2;n++;do{}while(o[++a]===o[++n]&&o[++a]===o[++n]&&o[++a]===o[++n]&&o[++a]===o[++n]&&o[++a]===o[++n]&&o[++a]===o[++n]&&o[++a]===o[++n]&&o[++a]===o[++n]&&a<h);i=L-(h-a);a=h-L;if(i>s){e.match_start=r;s=i;if(i>=f){break}d=o[a+s-1];v=o[a+s]}}while((r=u[r&c])>l&&--t!==0);if(s<=e.lookahead){return s}return e.lookahead}function fe(e){var r=e.w_size;var t,n,i,s,f;do{s=e.window_size-e.lookahead-e.strstart;if(e.strstart>=r+(r-M)){a.arraySet(e.window,e.window,r,r,0);e.match_start-=r;e.strstart-=r;e.block_start-=r;n=e.hash_size;t=n;do{i=e.head[--t];e.head[t]=i>=r?i-r:0}while(--n);n=r;t=n;do{i=e.prev[--t];e.prev[t]=i>=r?i-r:0}while(--n);s+=r}if(e.strm.avail_in===0){break}n=ie(e.strm,e.window,e.strstart+e.lookahead,s);e.lookahead+=n;if(e.lookahead+e.insert>=N){f=e.strstart-e.insert;e.ins_h=e.window[f];e.ins_h=(e.ins_h<<e.hash_shift^e.window[f+1])&e.hash_mask;while(e.insert){e.ins_h=(e.ins_h<<e.hash_shift^e.window[f+N-1])&e.hash_mask;e.prev[f&e.w_mask]=e.head[e.ins_h];e.head[e.ins_h]=f;f++;e.insert--;if(e.lookahead+e.insert<N){break}}}}while(e.lookahead<M&&e.strm.avail_in!==0)}function le(e,r){var t=65535;if(t>e.pending_buf_size-5){t=e.pending_buf_size-5}for(;;){if(e.lookahead<=1){fe(e);if(e.lookahead===0&&r===l){return K}if(e.lookahead===0){break}}e.strstart+=e.lookahead;e.lookahead=0;var a=e.block_start+t;if(e.strstart===0||e.strstart>=a){e.lookahead=e.strstart-a;e.strstart=a;te(e,false);if(e.strm.avail_out===0){return K}}if(e.strstart-e.block_start>=e.w_size-M){te(e,false);if(e.strm.avail_out===0){return K}}}e.insert=0;if(r===u){te(e,true);if(e.strm.avail_out===0){return $}return Z}if(e.strstart>e.block_start){te(e,false);if(e.strm.avail_out===0){return K}}return K}function oe(e,r){var t;var a;for(;;){if(e.lookahead<M){fe(e);if(e.lookahead<M&&r===l){return K}if(e.lookahead===0){break}}t=0;if(e.lookahead>=N){e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+N-1])&e.hash_mask;t=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h];e.head[e.ins_h]=e.strstart}if(t!==0&&e.strstart-t<=e.w_size-M){e.match_length=se(e,t)}if(e.match_length>=N){a=n._tr_tally(e,e.strstart-e.match_start,e.match_length-N);e.lookahead-=e.match_length;if(e.match_length<=e.max_lazy_match&&e.lookahead>=N){e.match_length--;do{e.strstart++;e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+N-1])&e.hash_mask;t=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h];e.head[e.ins_h]=e.strstart}while(--e.match_length!==0);e.strstart++}else{e.strstart+=e.match_length;e.match_length=0;e.ins_h=e.window[e.strstart];e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask}}else{a=n._tr_tally(e,0,e.window[e.strstart]);e.lookahead--;e.strstart++}if(a){te(e,false);if(e.strm.avail_out===0){return K}}}e.insert=e.strstart<N-1?e.strstart:N-1;if(r===u){te(e,true);if(e.strm.avail_out===0){return $}return Z}if(e.last_lit){te(e,false);if(e.strm.avail_out===0){return K}}return Y}function ce(e,r){var t;var a;var i;for(;;){if(e.lookahead<M){fe(e);if(e.lookahead<M&&r===l){return K}if(e.lookahead===0){break}}t=0;if(e.lookahead>=N){e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+N-1])&e.hash_mask;t=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h];e.head[e.ins_h]=e.strstart}e.prev_length=e.match_length;e.prev_match=e.match_start;e.match_length=N-1;if(t!==0&&e.prev_length<e.max_lazy_match&&e.strstart-t<=e.w_size-M){e.match_length=se(e,t);if(e.match_length<=5&&(e.strategy===w||e.match_length===N&&e.strstart-e.match_start>4096)){e.match_length=N-1}}if(e.prev_length>=N&&e.match_length<=e.prev_length){i=e.strstart+e.lookahead-N;a=n._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-N);e.lookahead-=e.prev_length-1;e.prev_length-=2;do{if(++e.strstart<=i){e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+N-1])&e.hash_mask;t=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h];e.head[e.ins_h]=e.strstart}}while(--e.prev_length!==0);e.match_available=0;e.match_length=N-1;e.strstart++;if(a){te(e,false);if(e.strm.avail_out===0){return K}}}else if(e.match_available){a=n._tr_tally(e,0,e.window[e.strstart-1]);if(a){te(e,false)}e.strstart++;e.lookahead--;if(e.strm.avail_out===0){return K}}else{e.match_available=1;e.strstart++;e.lookahead--}}if(e.match_available){a=n._tr_tally(e,0,e.window[e.strstart-1]);e.match_available=0}e.insert=e.strstart<N-1?e.strstart:N-1;if(r===u){te(e,true);if(e.strm.avail_out===0){return $}return Z}if(e.last_lit){te(e,false);if(e.strm.avail_out===0){return K}}return Y}function ue(e,r){var t;var a;var i,s;var f=e.window;for(;;){if(e.lookahead<=L){fe(e);if(e.lookahead<=L&&r===l){return K}if(e.lookahead===0){break}}e.match_length=0;if(e.lookahead>=N&&e.strstart>0){i=e.strstart-1;a=f[i];if(a===f[++i]&&a===f[++i]&&a===f[++i]){s=e.strstart+L;do{}while(a===f[++i]&&a===f[++i]&&a===f[++i]&&a===f[++i]&&a===f[++i]&&a===f[++i]&&a===f[++i]&&a===f[++i]&&i<s);e.match_length=L-(s-i);if(e.match_length>e.lookahead){e.match_length=e.lookahead}}}if(e.match_length>=N){t=n._tr_tally(e,1,e.match_length-N);e.lookahead-=e.match_length;e.strstart+=e.match_length;e.match_length=0}else{t=n._tr_tally(e,0,e.window[e.strstart]);e.lookahead--;e.strstart++}if(t){te(e,false);if(e.strm.avail_out===0){return K}}}e.insert=0;if(r===u){te(e,true);if(e.strm.avail_out===0){return $}return Z}if(e.last_lit){te(e,false);if(e.strm.avail_out===0){return K}}return Y}function he(e,r){var t;for(;;){if(e.lookahead===0){fe(e);if(e.lookahead===0){if(r===l){return K}break}}e.match_length=0;t=n._tr_tally(e,0,e.window[e.strstart]);e.lookahead--;e.strstart++;if(t){te(e,false);if(e.strm.avail_out===0){return K}}}e.insert=0;if(r===u){te(e,true);if(e.strm.avail_out===0){return $}return Z}if(e.last_lit){te(e,false);if(e.strm.avail_out===0){return K}}return Y}var de=function(e,r,t,a,n){this.good_length=e;this.max_lazy=r;this.nice_length=t;this.max_chain=a;this.func=n};var ve;ve=[new de(0,0,0,0,le),new de(4,4,8,4,oe),new de(4,5,16,8,oe),new de(4,6,32,32,oe),new de(4,4,16,16,ce),new de(8,16,32,32,ce),new de(8,16,128,128,ce),new de(8,32,128,256,ce),new de(32,128,258,1024,ce),new de(32,258,258,4096,ce)];function pe(e){e.window_size=2*e.w_size;ee(e.head);e.max_lazy_match=ve[e.level].max_lazy;e.good_match=ve[e.level].good_length;e.nice_match=ve[e.level].nice_length;e.max_chain_length=ve[e.level].max_chain;e.strstart=0;e.block_start=0;e.lookahead=0;e.insert=0;e.match_length=e.prev_length=N-1;e.match_available=0;e.ins_h=0}function me(){this.strm=null;this.status=0;this.pending_buf=null;this.pending_buf_size=0;this.pending_out=0;this.pending=0;this.wrap=0;this.gzhead=null;this.gzindex=0;this.method=B;this.last_flush=-1;this.w_size=0;this.w_bits=0;this.w_mask=0;this.window=null;this.window_size=0;this.prev=null;this.head=null;this.ins_h=0;this.hash_size=0;this.hash_bits=0;this.hash_mask=0;this.hash_shift=0;this.block_start=0;this.match_length=0;this.prev_match=0;this.match_available=0;this.strstart=0;this.match_start=0;this.lookahead=0;this.prev_length=0;this.max_chain_length=0;this.max_lazy_match=0;this.level=0;this.strategy=0;this.good_match=0;this.nice_match=0;this.dyn_ltree=new a.Buf16(O*2);this.dyn_dtree=new a.Buf16((2*D+1)*2);this.bl_tree=new a.Buf16((2*F+1)*2);ee(this.dyn_ltree);ee(this.dyn_dtree);ee(this.bl_tree);this.l_desc=null;this.d_desc=null;this.bl_desc=null;this.bl_count=new a.Buf16(P+1);this.heap=new a.Buf16(2*R+1);ee(this.heap);this.heap_len=0;this.heap_max=0;this.depth=new a.Buf16(2*R+1);ee(this.depth);this.l_buf=0;this.lit_bufsize=0;this.last_lit=0;this.d_buf=0;this.opt_len=0;this.static_len=0;this.matches=0;this.insert=0;this.bi_buf=0;this.bi_valid=0}function be(e){var r;if(!e||!e.state){return J(e,p)}e.total_in=e.total_out=0;e.data_type=C;r=e.state;r.pending=0;r.pending_out=0;if(r.wrap<0){r.wrap=-r.wrap}r.status=r.wrap?H:G;e.adler=r.wrap===2?0:1;r.last_flush=l;n._tr_init(r);return d}function ge(e){var r=be(e);if(r===d){pe(e.state)}return r}function we(e,r){if(!e||!e.state){return p}if(e.state.wrap!==2){return p}e.state.gzhead=r;return d}function ke(e,r,t,n,i,s){if(!e){return p}var f=1;if(r===g){r=6}if(n<0){f=0;n=-n}else if(n>15){f=2;n-=16}if(i<1||i>T||t!==B||n<8||n>15||r<0||r>9||s<0||s>S){return J(e,p)}if(n===8){n=9}var l=new me;e.state=l;l.strm=e;l.wrap=f;l.gzhead=null;l.w_bits=n;l.w_size=1<<l.w_bits;l.w_mask=l.w_size-1;l.hash_bits=i+7;l.hash_size=1<<l.hash_bits;l.hash_mask=l.hash_size-1;l.hash_shift=~~((l.hash_bits+N-1)/N);l.window=new a.Buf8(l.w_size*2);l.head=new a.Buf16(l.hash_size);l.prev=new a.Buf16(l.w_size);l.lit_bufsize=1<<i+6;l.pending_buf_size=l.lit_bufsize*4;l.pending_buf=new a.Buf8(l.pending_buf_size);l.d_buf=l.lit_bufsize>>1;l.l_buf=(1+2)*l.lit_bufsize;l.level=r;l.strategy=s;l.method=t;return ge(e)}function Ee(e,r){return ke(e,r,B,y,x,_)}function Se(e,r){var t,a;var i,f;if(!e||!e.state||r>h||r<0){return e?J(e,p):p}a=e.state;if(!e.output||!e.input&&e.avail_in!==0||a.status===j&&r!==u){return J(e,e.avail_out===0?b:p)}a.strm=e;t=a.last_flush;a.last_flush=r;if(a.status===H){if(a.wrap===2){e.adler=0;ae(a,31);ae(a,139);ae(a,8);if(!a.gzhead){ae(a,0);ae(a,0);ae(a,0);ae(a,0);ae(a,0);ae(a,a.level===9?2:a.strategy>=k||a.level<2?4:0);ae(a,Q);a.status=G}else{ae(a,(a.gzhead.text?1:0)+(a.gzhead.hcrc?2:0)+(!a.gzhead.extra?0:4)+(!a.gzhead.name?0:8)+(!a.gzhead.comment?0:16));ae(a,a.gzhead.time&255);ae(a,a.gzhead.time>>8&255);ae(a,a.gzhead.time>>16&255);ae(a,a.gzhead.time>>24&255);ae(a,a.level===9?2:a.strategy>=k||a.level<2?4:0);ae(a,a.gzhead.os&255);if(a.gzhead.extra&&a.gzhead.extra.length){ae(a,a.gzhead.extra.length&255);ae(a,a.gzhead.extra.length>>8&255)}if(a.gzhead.hcrc){e.adler=s(e.adler,a.pending_buf,a.pending,0)}a.gzindex=0;a.status=W}}else{var m=B+(a.w_bits-8<<4)<<8;var g=-1;if(a.strategy>=k||a.level<2){g=0}else if(a.level<6){g=1}else if(a.level===6){g=2}else{g=3}m|=g<<6;if(a.strstart!==0){m|=U}m+=31-m%31;a.status=G;ne(a,m);if(a.strstart!==0){ne(a,e.adler>>>16);ne(a,e.adler&65535)}e.adler=1}}if(a.status===W){if(a.gzhead.extra){i=a.pending;while(a.gzindex<(a.gzhead.extra.length&65535)){if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>i){e.adler=s(e.adler,a.pending_buf,a.pending-i,i)}re(e);i=a.pending;if(a.pending===a.pending_buf_size){break}}ae(a,a.gzhead.extra[a.gzindex]&255);a.gzindex++}if(a.gzhead.hcrc&&a.pending>i){e.adler=s(e.adler,a.pending_buf,a.pending-i,i)}if(a.gzindex===a.gzhead.extra.length){a.gzindex=0;a.status=z}}else{a.status=z}}if(a.status===z){if(a.gzhead.name){i=a.pending;do{if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>i){e.adler=s(e.adler,a.pending_buf,a.pending-i,i)}re(e);i=a.pending;if(a.pending===a.pending_buf_size){f=1;break}}if(a.gzindex<a.gzhead.name.length){f=a.gzhead.name.charCodeAt(a.gzindex++)&255}else{f=0}ae(a,f)}while(f!==0);if(a.gzhead.hcrc&&a.pending>i){e.adler=s(e.adler,a.pending_buf,a.pending-i,i)}if(f===0){a.gzindex=0;a.status=V}}else{a.status=V}}if(a.status===V){if(a.gzhead.comment){i=a.pending;do{if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>i){e.adler=s(e.adler,a.pending_buf,a.pending-i,i)}re(e);i=a.pending;if(a.pending===a.pending_buf_size){f=1;break}}if(a.gzindex<a.gzhead.comment.length){f=a.gzhead.comment.charCodeAt(a.gzindex++)&255}else{f=0}ae(a,f)}while(f!==0);if(a.gzhead.hcrc&&a.pending>i){e.adler=s(e.adler,a.pending_buf,a.pending-i,i)}if(f===0){a.status=X}}else{a.status=X}}if(a.status===X){if(a.gzhead.hcrc){if(a.pending+2>a.pending_buf_size){re(e)}if(a.pending+2<=a.pending_buf_size){ae(a,e.adler&255);ae(a,e.adler>>8&255);e.adler=0;a.status=G}}else{a.status=G}}if(a.pending!==0){re(e);if(e.avail_out===0){a.last_flush=-1;return d}}else if(e.avail_in===0&&q(r)<=q(t)&&r!==u){return J(e,b)}if(a.status===j&&e.avail_in!==0){return J(e,b)}if(e.avail_in!==0||a.lookahead!==0||r!==l&&a.status!==j){var w=a.strategy===k?he(a,r):a.strategy===E?ue(a,r):ve[a.level].func(a,r);if(w===$||w===Z){a.status=j}if(w===K||w===$){if(e.avail_out===0){a.last_flush=-1}return d}if(w===Y){if(r===o){n._tr_align(a)}else if(r!==h){n._tr_stored_block(a,0,0,false);if(r===c){ee(a.head);if(a.lookahead===0){a.strstart=0;a.block_start=0;a.insert=0}}}re(e);if(e.avail_out===0){a.last_flush=-1;return d}}}if(r!==u){return d}if(a.wrap<=0){return v}if(a.wrap===2){ae(a,e.adler&255);ae(a,e.adler>>8&255);ae(a,e.adler>>16&255);ae(a,e.adler>>24&255);ae(a,e.total_in&255);ae(a,e.total_in>>8&255);ae(a,e.total_in>>16&255);ae(a,e.total_in>>24&255)}else{ne(a,e.adler>>>16);ne(a,e.adler&65535)}re(e);if(a.wrap>0){a.wrap=-a.wrap}return a.pending!==0?d:v}function _e(e){var r;if(!e||!e.state){return p}r=e.state.status;if(r!==H&&r!==W&&r!==z&&r!==V&&r!==X&&r!==G&&r!==j){return J(e,p)}e.state=null;return r===G?J(e,m):d}t.deflateInit=Ee;t.deflateInit2=ke;t.deflateReset=ge;t.deflateResetKeep=be;t.deflateSetHeader=we;t.deflate=Se;t.deflateEnd=_e;t.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./messages":37,"./trees":38}],33:[function(e,r,t){"use strict";function a(){this.text=0;this.time=0;this.xflags=0;this.os=0;this.extra=null;this.extra_len=0;this.name="";this.comment="";this.hcrc=0;this.done=false}r.exports=a},{}],34:[function(e,r,t){"use strict";var a=30;var n=12;r.exports=function i(e,r){var t;var i;var s;var f;var l;var o;var c;var u;var h;var d;var v;var p;var m;var b;var g;var w;var k;var E;var S;var _;var C;var B;var T;var y,x;t=e.state;i=e.next_in;y=e.input;s=i+(e.avail_in-5);f=e.next_out;x=e.output;l=f-(r-e.avail_out);o=f+(e.avail_out-257);c=t.dmax;u=t.wsize;h=t.whave;d=t.wnext;v=t.window;p=t.hold;m=t.bits;b=t.lencode;g=t.distcode;w=(1<<t.lenbits)-1;k=(1<<t.distbits)-1;e:do{if(m<15){p+=y[i++]<<m;m+=8;p+=y[i++]<<m;m+=8}E=b[p&w];r:for(;;){S=E>>>24;p>>>=S;m-=S;S=E>>>16&255;if(S===0){x[f++]=E&65535}else if(S&16){_=E&65535;S&=15;if(S){if(m<S){p+=y[i++]<<m;m+=8}_+=p&(1<<S)-1;p>>>=S;m-=S}if(m<15){p+=y[i++]<<m;m+=8;p+=y[i++]<<m;m+=8}E=g[p&k];t:for(;;){S=E>>>24;p>>>=S;m-=S;S=E>>>16&255;if(S&16){C=E&65535;S&=15;if(m<S){p+=y[i++]<<m;m+=8;if(m<S){p+=y[i++]<<m;m+=8}}C+=p&(1<<S)-1;if(C>c){e.msg="invalid distance too far back";t.mode=a;break e}p>>>=S;m-=S;S=f-l;if(C>S){S=C-S;if(S>h){if(t.sane){e.msg="invalid distance too far back";t.mode=a;break e}}B=0;T=v;if(d===0){B+=u-S;if(S<_){_-=S;do{x[f++]=v[B++]}while(--S);B=f-C;T=x}}else if(d<S){B+=u+d-S;S-=d;if(S<_){_-=S;do{x[f++]=v[B++]}while(--S);B=0;if(d<_){S=d;_-=S;do{x[f++]=v[B++]}while(--S);B=f-C;T=x}}}else{B+=d-S;if(S<_){_-=S;do{x[f++]=v[B++]}while(--S);B=f-C;T=x}}while(_>2){x[f++]=T[B++];x[f++]=T[B++];x[f++]=T[B++];_-=3}if(_){x[f++]=T[B++];if(_>1){x[f++]=T[B++]}}}else{B=f-C;do{x[f++]=x[B++];x[f++]=x[B++];x[f++]=x[B++];_-=3}while(_>2);if(_){x[f++]=x[B++];if(_>1){x[f++]=x[B++]}}}}else if((S&64)===0){E=g[(E&65535)+(p&(1<<S)-1)];continue t}else{e.msg="invalid distance code";t.mode=a;break e}break}}else if((S&64)===0){E=b[(E&65535)+(p&(1<<S)-1)];continue r}else if(S&32){t.mode=n;break e}else{e.msg="invalid literal/length code";t.mode=a;break e}break}}while(i<s&&f<o);_=m>>3;i-=_;m-=_<<3;p&=(1<<m)-1;e.next_in=i;e.next_out=f;e.avail_in=i<s?5+(s-i):5-(i-s);e.avail_out=f<o?257+(o-f):257-(f-o);t.hold=p;t.bits=m;return}},{}],35:[function(e,r,t){"use strict";var a=e("../utils/common");var n=e("./adler32");var i=e("./crc32");var s=e("./inffast");var f=e("./inftrees");var l=0;var o=1;var c=2;var u=4;var h=5;var d=6;var v=0;var p=1;var m=2;var b=-2;var g=-3;var w=-4;var k=-5;var E=8;var S=1;var _=2;var C=3;var B=4;var T=5;var y=6;var x=7;var A=8;var I=9;var R=10;var D=11;var F=12;var O=13;var P=14;var N=15;var L=16;var M=17;var U=18;var H=19;var W=20;var z=21;var V=22;var X=23;var G=24;var j=25;var K=26;var Y=27;var $=28;var Z=29;var Q=30;var J=31;var q=32;var ee=852;var re=592;var te=15;var ae=te;function ne(e){return(e>>>24&255)+(e>>>8&65280)+((e&65280)<<8)+((e&255)<<24)}function ie(){this.mode=0;this.last=false;this.wrap=0;this.havedict=false;this.flags=0;this.dmax=0;this.check=0;this.total=0;this.head=null;this.wbits=0;this.wsize=0;this.whave=0;this.wnext=0;this.window=null;this.hold=0;this.bits=0;this.length=0;this.offset=0;this.extra=0;this.lencode=null;this.distcode=null;this.lenbits=0;this.distbits=0;this.ncode=0;this.nlen=0;this.ndist=0;this.have=0;this.next=null;this.lens=new a.Buf16(320);this.work=new a.Buf16(288);this.lendyn=null;this.distdyn=null;this.sane=0;this.back=0;this.was=0}function se(e){var r;if(!e||!e.state){return b}r=e.state;e.total_in=e.total_out=r.total=0;e.msg="";if(r.wrap){e.adler=r.wrap&1}r.mode=S;r.last=0;r.havedict=0;r.dmax=32768;r.head=null;r.hold=0;r.bits=0;r.lencode=r.lendyn=new a.Buf32(ee);r.distcode=r.distdyn=new a.Buf32(re);r.sane=1;r.back=-1;return v}function fe(e){var r;if(!e||!e.state){return b}r=e.state;r.wsize=0;r.whave=0;r.wnext=0;return se(e)}function le(e,r){var t;var a;if(!e||!e.state){return b}a=e.state;if(r<0){t=0;r=-r}else{t=(r>>4)+1;if(r<48){r&=15}}if(r&&(r<8||r>15)){return b}if(a.window!==null&&a.wbits!==r){a.window=null}a.wrap=t;a.wbits=r;return fe(e)}function oe(e,r){var t;var a;if(!e){return b}a=new ie;e.state=a;a.window=null;t=le(e,r);if(t!==v){e.state=null}return t}function ce(e){return oe(e,ae)}var ue=true;var he,de;function ve(e){if(ue){var r;he=new a.Buf32(512);de=new a.Buf32(32);r=0;while(r<144){e.lens[r++]=8}while(r<256){e.lens[r++]=9}while(r<280){e.lens[r++]=7}while(r<288){e.lens[r++]=8}f(o,e.lens,0,288,he,0,e.work,{bits:9});r=0;while(r<32){e.lens[r++]=5}f(c,e.lens,0,32,de,0,e.work,{bits:5});ue=false}e.lencode=he;e.lenbits=9;e.distcode=de;e.distbits=5}function pe(e,r,t,n){var i;var s=e.state;if(s.window===null){s.wsize=1<<s.wbits;s.wnext=0;s.whave=0;s.window=new a.Buf8(s.wsize)}if(n>=s.wsize){a.arraySet(s.window,r,t-s.wsize,s.wsize,0);s.wnext=0;s.whave=s.wsize}else{i=s.wsize-s.wnext;if(i>n){i=n}a.arraySet(s.window,r,t-n,i,s.wnext);n-=i;if(n){a.arraySet(s.window,r,t-n,n,0);s.wnext=n;s.whave=s.wsize}else{s.wnext+=i;if(s.wnext===s.wsize){s.wnext=0}if(s.whave<s.wsize){s.whave+=i}}}return 0}function me(e,r){var t;var ee,re;var te;var ae;var ie,se;var fe;var le;var oe,ce;var ue;var he;var de;var me=0;var be,ge,we;var ke,Ee,Se;var _e;var Ce;var Be=new a.Buf8(4);var Te;var ye;var xe=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&e.avail_in!==0){return b}t=e.state;if(t.mode===F){t.mode=O}ae=e.next_out;re=e.output;se=e.avail_out;te=e.next_in;ee=e.input;ie=e.avail_in;fe=t.hold;le=t.bits;oe=ie;ce=se;Ce=v;e:for(;;){switch(t.mode){case S:if(t.wrap===0){t.mode=O;break}while(le<16){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if(t.wrap&2&&fe===35615){t.check=0;Be[0]=fe&255;Be[1]=fe>>>8&255;t.check=i(t.check,Be,2,0);fe=0;le=0;t.mode=_;break}t.flags=0;if(t.head){t.head.done=false}if(!(t.wrap&1)||(((fe&255)<<8)+(fe>>8))%31){e.msg="incorrect header check";t.mode=Q;break}if((fe&15)!==E){e.msg="unknown compression method";t.mode=Q;break}fe>>>=4;le-=4;_e=(fe&15)+8;if(t.wbits===0){t.wbits=_e}else if(_e>t.wbits){e.msg="invalid window size";t.mode=Q;break}t.dmax=1<<_e;e.adler=t.check=1;t.mode=fe&512?R:F;fe=0;le=0;break;case _:while(le<16){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}t.flags=fe;if((t.flags&255)!==E){e.msg="unknown compression method";t.mode=Q;break}if(t.flags&57344){e.msg="unknown header flags set";t.mode=Q;break}if(t.head){t.head.text=fe>>8&1}if(t.flags&512){Be[0]=fe&255;Be[1]=fe>>>8&255;t.check=i(t.check,Be,2,0)}fe=0;le=0;t.mode=C;case C:while(le<32){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if(t.head){t.head.time=fe}if(t.flags&512){Be[0]=fe&255;Be[1]=fe>>>8&255;Be[2]=fe>>>16&255;Be[3]=fe>>>24&255;t.check=i(t.check,Be,4,0)}fe=0;le=0;t.mode=B;case B:while(le<16){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if(t.head){t.head.xflags=fe&255;t.head.os=fe>>8}if(t.flags&512){Be[0]=fe&255;Be[1]=fe>>>8&255;t.check=i(t.check,Be,2,0)}fe=0;le=0;t.mode=T;case T:if(t.flags&1024){while(le<16){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}t.length=fe;if(t.head){t.head.extra_len=fe}if(t.flags&512){Be[0]=fe&255;Be[1]=fe>>>8&255;t.check=i(t.check,Be,2,0)}fe=0;le=0}else if(t.head){t.head.extra=null}t.mode=y;case y:if(t.flags&1024){ue=t.length;if(ue>ie){ue=ie}if(ue){if(t.head){_e=t.head.extra_len-t.length;if(!t.head.extra){t.head.extra=new Array(t.head.extra_len)}a.arraySet(t.head.extra,ee,te,ue,_e)}if(t.flags&512){t.check=i(t.check,ee,ue,te)}ie-=ue;te+=ue;t.length-=ue}if(t.length){break e}}t.length=0;t.mode=x;case x:if(t.flags&2048){if(ie===0){break e}ue=0;do{_e=ee[te+ue++];if(t.head&&_e&&t.length<65536){t.head.name+=String.fromCharCode(_e)}}while(_e&&ue<ie);if(t.flags&512){t.check=i(t.check,ee,ue,te)}ie-=ue;te+=ue;if(_e){break e}}else if(t.head){t.head.name=null}t.length=0;t.mode=A;case A:if(t.flags&4096){if(ie===0){break e}ue=0;do{_e=ee[te+ue++];if(t.head&&_e&&t.length<65536){t.head.comment+=String.fromCharCode(_e)}}while(_e&&ue<ie);if(t.flags&512){t.check=i(t.check,ee,ue,te)}ie-=ue;te+=ue;if(_e){break e}}else if(t.head){t.head.comment=null}t.mode=I;case I:if(t.flags&512){while(le<16){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if(fe!==(t.check&65535)){e.msg="header crc mismatch";t.mode=Q;break}fe=0;le=0}if(t.head){t.head.hcrc=t.flags>>9&1;t.head.done=true}e.adler=t.check=0;t.mode=F;break;case R:while(le<32){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}e.adler=t.check=ne(fe);fe=0;le=0;t.mode=D;case D:if(t.havedict===0){e.next_out=ae;e.avail_out=se;e.next_in=te;e.avail_in=ie;t.hold=fe;t.bits=le;return m}e.adler=t.check=1;t.mode=F;case F:if(r===h||r===d){break e};case O:if(t.last){fe>>>=le&7;
le-=le&7;t.mode=Y;break}while(le<3){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}t.last=fe&1;fe>>>=1;le-=1;switch(fe&3){case 0:t.mode=P;break;case 1:ve(t);t.mode=W;if(r===d){fe>>>=2;le-=2;break e}break;case 2:t.mode=M;break;case 3:e.msg="invalid block type";t.mode=Q;}fe>>>=2;le-=2;break;case P:fe>>>=le&7;le-=le&7;while(le<32){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if((fe&65535)!==(fe>>>16^65535)){e.msg="invalid stored block lengths";t.mode=Q;break}t.length=fe&65535;fe=0;le=0;t.mode=N;if(r===d){break e};case N:t.mode=L;case L:ue=t.length;if(ue){if(ue>ie){ue=ie}if(ue>se){ue=se}if(ue===0){break e}a.arraySet(re,ee,te,ue,ae);ie-=ue;te+=ue;se-=ue;ae+=ue;t.length-=ue;break}t.mode=F;break;case M:while(le<14){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}t.nlen=(fe&31)+257;fe>>>=5;le-=5;t.ndist=(fe&31)+1;fe>>>=5;le-=5;t.ncode=(fe&15)+4;fe>>>=4;le-=4;if(t.nlen>286||t.ndist>30){e.msg="too many length or distance symbols";t.mode=Q;break}t.have=0;t.mode=U;case U:while(t.have<t.ncode){while(le<3){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}t.lens[xe[t.have++]]=fe&7;fe>>>=3;le-=3}while(t.have<19){t.lens[xe[t.have++]]=0}t.lencode=t.lendyn;t.lenbits=7;Te={bits:t.lenbits};Ce=f(l,t.lens,0,19,t.lencode,0,t.work,Te);t.lenbits=Te.bits;if(Ce){e.msg="invalid code lengths set";t.mode=Q;break}t.have=0;t.mode=H;case H:while(t.have<t.nlen+t.ndist){for(;;){me=t.lencode[fe&(1<<t.lenbits)-1];be=me>>>24;ge=me>>>16&255;we=me&65535;if(be<=le){break}if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if(we<16){fe>>>=be;le-=be;t.lens[t.have++]=we}else{if(we===16){ye=be+2;while(le<ye){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}fe>>>=be;le-=be;if(t.have===0){e.msg="invalid bit length repeat";t.mode=Q;break}_e=t.lens[t.have-1];ue=3+(fe&3);fe>>>=2;le-=2}else if(we===17){ye=be+3;while(le<ye){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}fe>>>=be;le-=be;_e=0;ue=3+(fe&7);fe>>>=3;le-=3}else{ye=be+7;while(le<ye){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}fe>>>=be;le-=be;_e=0;ue=11+(fe&127);fe>>>=7;le-=7}if(t.have+ue>t.nlen+t.ndist){e.msg="invalid bit length repeat";t.mode=Q;break}while(ue--){t.lens[t.have++]=_e}}}if(t.mode===Q){break}if(t.lens[256]===0){e.msg="invalid code -- missing end-of-block";t.mode=Q;break}t.lenbits=9;Te={bits:t.lenbits};Ce=f(o,t.lens,0,t.nlen,t.lencode,0,t.work,Te);t.lenbits=Te.bits;if(Ce){e.msg="invalid literal/lengths set";t.mode=Q;break}t.distbits=6;t.distcode=t.distdyn;Te={bits:t.distbits};Ce=f(c,t.lens,t.nlen,t.ndist,t.distcode,0,t.work,Te);t.distbits=Te.bits;if(Ce){e.msg="invalid distances set";t.mode=Q;break}t.mode=W;if(r===d){break e};case W:t.mode=z;case z:if(ie>=6&&se>=258){e.next_out=ae;e.avail_out=se;e.next_in=te;e.avail_in=ie;t.hold=fe;t.bits=le;s(e,ce);ae=e.next_out;re=e.output;se=e.avail_out;te=e.next_in;ee=e.input;ie=e.avail_in;fe=t.hold;le=t.bits;if(t.mode===F){t.back=-1}break}t.back=0;for(;;){me=t.lencode[fe&(1<<t.lenbits)-1];be=me>>>24;ge=me>>>16&255;we=me&65535;if(be<=le){break}if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if(ge&&(ge&240)===0){ke=be;Ee=ge;Se=we;for(;;){me=t.lencode[Se+((fe&(1<<ke+Ee)-1)>>ke)];be=me>>>24;ge=me>>>16&255;we=me&65535;if(ke+be<=le){break}if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}fe>>>=ke;le-=ke;t.back+=ke}fe>>>=be;le-=be;t.back+=be;t.length=we;if(ge===0){t.mode=K;break}if(ge&32){t.back=-1;t.mode=F;break}if(ge&64){e.msg="invalid literal/length code";t.mode=Q;break}t.extra=ge&15;t.mode=V;case V:if(t.extra){ye=t.extra;while(le<ye){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}t.length+=fe&(1<<t.extra)-1;fe>>>=t.extra;le-=t.extra;t.back+=t.extra}t.was=t.length;t.mode=X;case X:for(;;){me=t.distcode[fe&(1<<t.distbits)-1];be=me>>>24;ge=me>>>16&255;we=me&65535;if(be<=le){break}if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if((ge&240)===0){ke=be;Ee=ge;Se=we;for(;;){me=t.distcode[Se+((fe&(1<<ke+Ee)-1)>>ke)];be=me>>>24;ge=me>>>16&255;we=me&65535;if(ke+be<=le){break}if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}fe>>>=ke;le-=ke;t.back+=ke}fe>>>=be;le-=be;t.back+=be;if(ge&64){e.msg="invalid distance code";t.mode=Q;break}t.offset=we;t.extra=ge&15;t.mode=G;case G:if(t.extra){ye=t.extra;while(le<ye){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}t.offset+=fe&(1<<t.extra)-1;fe>>>=t.extra;le-=t.extra;t.back+=t.extra}if(t.offset>t.dmax){e.msg="invalid distance too far back";t.mode=Q;break}t.mode=j;case j:if(se===0){break e}ue=ce-se;if(t.offset>ue){ue=t.offset-ue;if(ue>t.whave){if(t.sane){e.msg="invalid distance too far back";t.mode=Q;break}}if(ue>t.wnext){ue-=t.wnext;he=t.wsize-ue}else{he=t.wnext-ue}if(ue>t.length){ue=t.length}de=t.window}else{de=re;he=ae-t.offset;ue=t.length}if(ue>se){ue=se}se-=ue;t.length-=ue;do{re[ae++]=de[he++]}while(--ue);if(t.length===0){t.mode=z}break;case K:if(se===0){break e}re[ae++]=t.length;se--;t.mode=z;break;case Y:if(t.wrap){while(le<32){if(ie===0){break e}ie--;fe|=ee[te++]<<le;le+=8}ce-=se;e.total_out+=ce;t.total+=ce;if(ce){e.adler=t.check=t.flags?i(t.check,re,ce,ae-ce):n(t.check,re,ce,ae-ce)}ce=se;if((t.flags?fe:ne(fe))!==t.check){e.msg="incorrect data check";t.mode=Q;break}fe=0;le=0}t.mode=$;case $:if(t.wrap&&t.flags){while(le<32){if(ie===0){break e}ie--;fe+=ee[te++]<<le;le+=8}if(fe!==(t.total&4294967295)){e.msg="incorrect length check";t.mode=Q;break}fe=0;le=0}t.mode=Z;case Z:Ce=p;break e;case Q:Ce=g;break e;case J:return w;case q:;default:return b;}}e.next_out=ae;e.avail_out=se;e.next_in=te;e.avail_in=ie;t.hold=fe;t.bits=le;if(t.wsize||ce!==e.avail_out&&t.mode<Q&&(t.mode<Y||r!==u)){if(pe(e,e.output,e.next_out,ce-e.avail_out)){t.mode=J;return w}}oe-=e.avail_in;ce-=e.avail_out;e.total_in+=oe;e.total_out+=ce;t.total+=ce;if(t.wrap&&ce){e.adler=t.check=t.flags?i(t.check,re,ce,e.next_out-ce):n(t.check,re,ce,e.next_out-ce)}e.data_type=t.bits+(t.last?64:0)+(t.mode===F?128:0)+(t.mode===W||t.mode===N?256:0);if((oe===0&&ce===0||r===u)&&Ce===v){Ce=k}return Ce}function be(e){if(!e||!e.state){return b}var r=e.state;if(r.window){r.window=null}e.state=null;return v}function ge(e,r){var t;if(!e||!e.state){return b}t=e.state;if((t.wrap&2)===0){return b}t.head=r;r.done=false;return v}t.inflateReset=fe;t.inflateReset2=le;t.inflateResetKeep=se;t.inflateInit=ce;t.inflateInit2=oe;t.inflate=me;t.inflateEnd=be;t.inflateGetHeader=ge;t.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./inffast":34,"./inftrees":36}],36:[function(e,r,t){"use strict";var a=e("../utils/common");var n=15;var i=852;var s=592;var f=0;var l=1;var o=2;var c=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0];var u=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78];var h=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0];var d=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];r.exports=function v(e,r,t,p,m,b,g,w){var k=w.bits;var E=0;var S=0;var _=0,C=0;var B=0;var T=0;var y=0;var x=0;var A=0;var I=0;var R;var D;var F;var O;var P;var N=null;var L=0;var M;var U=new a.Buf16(n+1);var H=new a.Buf16(n+1);var W=null;var z=0;var V,X,G;for(E=0;E<=n;E++){U[E]=0}for(S=0;S<p;S++){U[r[t+S]]++}B=k;for(C=n;C>=1;C--){if(U[C]!==0){break}}if(B>C){B=C}if(C===0){m[b++]=1<<24|64<<16|0;m[b++]=1<<24|64<<16|0;w.bits=1;return 0}for(_=1;_<C;_++){if(U[_]!==0){break}}if(B<_){B=_}x=1;for(E=1;E<=n;E++){x<<=1;x-=U[E];if(x<0){return-1}}if(x>0&&(e===f||C!==1)){return-1}H[1]=0;for(E=1;E<n;E++){H[E+1]=H[E]+U[E]}for(S=0;S<p;S++){if(r[t+S]!==0){g[H[r[t+S]]++]=S}}if(e===f){N=W=g;M=19}else if(e===l){N=c;L-=257;W=u;z-=257;M=256}else{N=h;W=d;M=-1}I=0;S=0;E=_;P=b;T=B;y=0;F=-1;A=1<<B;O=A-1;if(e===l&&A>i||e===o&&A>s){return 1}var j=0;for(;;){j++;V=E-y;if(g[S]<M){X=0;G=g[S]}else if(g[S]>M){X=W[z+g[S]];G=N[L+g[S]]}else{X=32+64;G=0}R=1<<E-y;D=1<<T;_=D;do{D-=R;m[P+(I>>y)+D]=V<<24|X<<16|G|0}while(D!==0);R=1<<E-1;while(I&R){R>>=1}if(R!==0){I&=R-1;I+=R}else{I=0}S++;if(--U[E]===0){if(E===C){break}E=r[t+g[S]]}if(E>B&&(I&O)!==F){if(y===0){y=B}P+=_;T=E-y;x=1<<T;while(T+y<C){x-=U[T+y];if(x<=0){break}T++;x<<=1}A+=1<<T;if(e===l&&A>i||e===o&&A>s){return 1}F=I&O;m[F]=B<<24|T<<16|P-b|0}}if(I!==0){m[P+I]=E-y<<24|64<<16|0}w.bits=B;return 0}},{"../utils/common":27}],37:[function(e,r,t){"use strict";r.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],38:[function(e,r,t){"use strict";var a=e("../utils/common");var n=4;var i=0;var s=1;var f=2;function l(e){var r=e.length;while(--r>=0){e[r]=0}}var o=0;var c=1;var u=2;var h=3;var d=258;var v=29;var p=256;var m=p+1+v;var b=30;var g=19;var w=2*m+1;var k=15;var E=16;var S=7;var _=256;var C=16;var B=17;var T=18;var y=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];var x=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];var A=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];var I=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];var R=512;var D=new Array((m+2)*2);l(D);var F=new Array(b*2);l(F);var O=new Array(R);l(O);var P=new Array(d-h+1);l(P);var N=new Array(v);l(N);var L=new Array(b);l(L);var M=function(e,r,t,a,n){this.static_tree=e;this.extra_bits=r;this.extra_base=t;this.elems=a;this.max_length=n;this.has_stree=e&&e.length};var U;var H;var W;var z=function(e,r){this.dyn_tree=e;this.max_code=0;this.stat_desc=r};function V(e){return e<256?O[e]:O[256+(e>>>7)]}function X(e,r){e.pending_buf[e.pending++]=r&255;e.pending_buf[e.pending++]=r>>>8&255}function G(e,r,t){if(e.bi_valid>E-t){e.bi_buf|=r<<e.bi_valid&65535;X(e,e.bi_buf);e.bi_buf=r>>E-e.bi_valid;e.bi_valid+=t-E}else{e.bi_buf|=r<<e.bi_valid&65535;e.bi_valid+=t}}function j(e,r,t){G(e,t[r*2],t[r*2+1])}function K(e,r){var t=0;do{t|=e&1;e>>>=1;t<<=1}while(--r>0);return t>>>1}function Y(e){if(e.bi_valid===16){X(e,e.bi_buf);e.bi_buf=0;e.bi_valid=0}else if(e.bi_valid>=8){e.pending_buf[e.pending++]=e.bi_buf&255;e.bi_buf>>=8;e.bi_valid-=8}}function $(e,r){var t=r.dyn_tree;var a=r.max_code;var n=r.stat_desc.static_tree;var i=r.stat_desc.has_stree;var s=r.stat_desc.extra_bits;var f=r.stat_desc.extra_base;var l=r.stat_desc.max_length;var o;var c,u;var h;var d;var v;var p=0;for(h=0;h<=k;h++){e.bl_count[h]=0}t[e.heap[e.heap_max]*2+1]=0;for(o=e.heap_max+1;o<w;o++){c=e.heap[o];h=t[t[c*2+1]*2+1]+1;if(h>l){h=l;p++}t[c*2+1]=h;if(c>a){continue}e.bl_count[h]++;d=0;if(c>=f){d=s[c-f]}v=t[c*2];e.opt_len+=v*(h+d);if(i){e.static_len+=v*(n[c*2+1]+d)}}if(p===0){return}do{h=l-1;while(e.bl_count[h]===0){h--}e.bl_count[h]--;e.bl_count[h+1]+=2;e.bl_count[l]--;p-=2}while(p>0);for(h=l;h!==0;h--){c=e.bl_count[h];while(c!==0){u=e.heap[--o];if(u>a){continue}if(t[u*2+1]!==h){e.opt_len+=(h-t[u*2+1])*t[u*2];t[u*2+1]=h}c--}}}function Z(e,r,t){var a=new Array(k+1);var n=0;var i;var s;for(i=1;i<=k;i++){a[i]=n=n+t[i-1]<<1}for(s=0;s<=r;s++){var f=e[s*2+1];if(f===0){continue}e[s*2]=K(a[f]++,f)}}function Q(){var e;var r;var t;var a;var n;var i=new Array(k+1);t=0;for(a=0;a<v-1;a++){N[a]=t;for(e=0;e<1<<y[a];e++){P[t++]=a}}P[t-1]=a;n=0;for(a=0;a<16;a++){L[a]=n;for(e=0;e<1<<x[a];e++){O[n++]=a}}n>>=7;for(;a<b;a++){L[a]=n<<7;for(e=0;e<1<<x[a]-7;e++){O[256+n++]=a}}for(r=0;r<=k;r++){i[r]=0}e=0;while(e<=143){D[e*2+1]=8;e++;i[8]++}while(e<=255){D[e*2+1]=9;e++;i[9]++}while(e<=279){D[e*2+1]=7;e++;i[7]++}while(e<=287){D[e*2+1]=8;e++;i[8]++}Z(D,m+1,i);for(e=0;e<b;e++){F[e*2+1]=5;F[e*2]=K(e,5)}U=new M(D,y,p+1,m,k);H=new M(F,x,0,b,k);W=new M(new Array(0),A,0,g,S)}function J(e){var r;for(r=0;r<m;r++){e.dyn_ltree[r*2]=0}for(r=0;r<b;r++){e.dyn_dtree[r*2]=0}for(r=0;r<g;r++){e.bl_tree[r*2]=0}e.dyn_ltree[_*2]=1;e.opt_len=e.static_len=0;e.last_lit=e.matches=0}function q(e){if(e.bi_valid>8){X(e,e.bi_buf)}else if(e.bi_valid>0){e.pending_buf[e.pending++]=e.bi_buf}e.bi_buf=0;e.bi_valid=0}function ee(e,r,t,n){q(e);if(n){X(e,t);X(e,~t)}a.arraySet(e.pending_buf,e.window,r,t,e.pending);e.pending+=t}function re(e,r,t,a){var n=r*2;var i=t*2;return e[n]<e[i]||e[n]===e[i]&&a[r]<=a[t]}function te(e,r,t){var a=e.heap[t];var n=t<<1;while(n<=e.heap_len){if(n<e.heap_len&&re(r,e.heap[n+1],e.heap[n],e.depth)){n++}if(re(r,a,e.heap[n],e.depth)){break}e.heap[t]=e.heap[n];t=n;n<<=1}e.heap[t]=a}function ae(e,r,t){var a;var n;var i=0;var s;var f;if(e.last_lit!==0){do{a=e.pending_buf[e.d_buf+i*2]<<8|e.pending_buf[e.d_buf+i*2+1];n=e.pending_buf[e.l_buf+i];i++;if(a===0){j(e,n,r)}else{s=P[n];j(e,s+p+1,r);f=y[s];if(f!==0){n-=N[s];G(e,n,f)}a--;s=V(a);j(e,s,t);f=x[s];if(f!==0){a-=L[s];G(e,a,f)}}}while(i<e.last_lit)}j(e,_,r)}function ne(e,r){var t=r.dyn_tree;var a=r.stat_desc.static_tree;var n=r.stat_desc.has_stree;var i=r.stat_desc.elems;var s,f;var l=-1;var o;e.heap_len=0;e.heap_max=w;for(s=0;s<i;s++){if(t[s*2]!==0){e.heap[++e.heap_len]=l=s;e.depth[s]=0}else{t[s*2+1]=0}}while(e.heap_len<2){o=e.heap[++e.heap_len]=l<2?++l:0;t[o*2]=1;e.depth[o]=0;e.opt_len--;if(n){e.static_len-=a[o*2+1]}}r.max_code=l;for(s=e.heap_len>>1;s>=1;s--){te(e,t,s)}o=i;do{s=e.heap[1];e.heap[1]=e.heap[e.heap_len--];te(e,t,1);f=e.heap[1];e.heap[--e.heap_max]=s;e.heap[--e.heap_max]=f;t[o*2]=t[s*2]+t[f*2];e.depth[o]=(e.depth[s]>=e.depth[f]?e.depth[s]:e.depth[f])+1;t[s*2+1]=t[f*2+1]=o;e.heap[1]=o++;te(e,t,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1];$(e,r);Z(t,l,e.bl_count)}function ie(e,r,t){var a;var n=-1;var i;var s=r[0*2+1];var f=0;var l=7;var o=4;if(s===0){l=138;o=3}r[(t+1)*2+1]=65535;for(a=0;a<=t;a++){i=s;s=r[(a+1)*2+1];if(++f<l&&i===s){continue}else if(f<o){e.bl_tree[i*2]+=f}else if(i!==0){if(i!==n){e.bl_tree[i*2]++}e.bl_tree[C*2]++}else if(f<=10){e.bl_tree[B*2]++}else{e.bl_tree[T*2]++}f=0;n=i;if(s===0){l=138;o=3}else if(i===s){l=6;o=3}else{l=7;o=4}}}function se(e,r,t){var a;var n=-1;var i;var s=r[0*2+1];var f=0;var l=7;var o=4;if(s===0){l=138;o=3}for(a=0;a<=t;a++){i=s;s=r[(a+1)*2+1];if(++f<l&&i===s){continue}else if(f<o){do{j(e,i,e.bl_tree)}while(--f!==0)}else if(i!==0){if(i!==n){j(e,i,e.bl_tree);f--}j(e,C,e.bl_tree);G(e,f-3,2)}else if(f<=10){j(e,B,e.bl_tree);G(e,f-3,3)}else{j(e,T,e.bl_tree);G(e,f-11,7)}f=0;n=i;if(s===0){l=138;o=3}else if(i===s){l=6;o=3}else{l=7;o=4}}}function fe(e){var r;ie(e,e.dyn_ltree,e.l_desc.max_code);ie(e,e.dyn_dtree,e.d_desc.max_code);ne(e,e.bl_desc);for(r=g-1;r>=3;r--){if(e.bl_tree[I[r]*2+1]!==0){break}}e.opt_len+=3*(r+1)+5+5+4;return r}function le(e,r,t,a){var n;G(e,r-257,5);G(e,t-1,5);G(e,a-4,4);for(n=0;n<a;n++){G(e,e.bl_tree[I[n]*2+1],3)}se(e,e.dyn_ltree,r-1);se(e,e.dyn_dtree,t-1)}function oe(e){var r=4093624447;var t;for(t=0;t<=31;t++,r>>>=1){if(r&1&&e.dyn_ltree[t*2]!==0){return i}}if(e.dyn_ltree[9*2]!==0||e.dyn_ltree[10*2]!==0||e.dyn_ltree[13*2]!==0){return s}for(t=32;t<p;t++){if(e.dyn_ltree[t*2]!==0){return s}}return i}var ce=false;function ue(e){if(!ce){Q();ce=true}e.l_desc=new z(e.dyn_ltree,U);e.d_desc=new z(e.dyn_dtree,H);e.bl_desc=new z(e.bl_tree,W);e.bi_buf=0;e.bi_valid=0;J(e)}function he(e,r,t,a){G(e,(o<<1)+(a?1:0),3);ee(e,r,t,true)}function de(e){G(e,c<<1,3);j(e,_,D);Y(e)}function ve(e,r,t,a){var i,s;var l=0;if(e.level>0){if(e.strm.data_type===f){e.strm.data_type=oe(e)}ne(e,e.l_desc);ne(e,e.d_desc);l=fe(e);i=e.opt_len+3+7>>>3;s=e.static_len+3+7>>>3;if(s<=i){i=s}}else{i=s=t+5}if(t+4<=i&&r!==-1){he(e,r,t,a)}else if(e.strategy===n||s===i){G(e,(c<<1)+(a?1:0),3);ae(e,D,F)}else{G(e,(u<<1)+(a?1:0),3);le(e,e.l_desc.max_code+1,e.d_desc.max_code+1,l+1);ae(e,e.dyn_ltree,e.dyn_dtree)}J(e);if(a){q(e)}}function pe(e,r,t){e.pending_buf[e.d_buf+e.last_lit*2]=r>>>8&255;e.pending_buf[e.d_buf+e.last_lit*2+1]=r&255;e.pending_buf[e.l_buf+e.last_lit]=t&255;e.last_lit++;if(r===0){e.dyn_ltree[t*2]++}else{e.matches++;r--;e.dyn_ltree[(P[t]+p+1)*2]++;e.dyn_dtree[V(r)*2]++}return e.last_lit===e.lit_bufsize-1}t._tr_init=ue;t._tr_stored_block=he;t._tr_flush_block=ve;t._tr_tally=pe;t._tr_align=de},{"../utils/common":27}],39:[function(e,r,t){"use strict";function a(){this.input=null;this.next_in=0;this.avail_in=0;this.total_in=0;this.output=null;this.next_out=0;this.avail_out=0;this.total_out=0;this.msg="";this.state=null;this.data_type=2;this.adler=0}r.exports=a},{}]},{},[9])(9)});var XLSX={};function make_xlsx_lib(e){e.version="0.15.5";var r=1200,t=1252;if(typeof module!=="undefined"&&typeof require!=="undefined"){if(typeof cptable==="undefined"){if(typeof global!=="undefined")global.cptable=undefined;else if(typeof window!=="undefined")window.cptable=undefined}}var a=[874,932,936,949,950];for(var n=0;n<=8;++n)a.push(1250+n);var i={0:1252,1:65001,2:65001,77:1e4,128:932,129:949,130:1361,134:936,136:950,161:1253,162:1254,163:1258,177:1255,178:1256,186:1257,204:1251,222:874,238:1250,255:1252,69:6969};var s=function(e){if(a.indexOf(e)==-1)return;t=i[0]=e};function f(){s(1252)}var l=function(e){r=e;s(e)};function o(){l(1200);f()}function c(e){var r=[];for(var t=0,a=e.length;t<a;++t)r[t]=e.charCodeAt(t);return r}function u(e){var r=[];for(var t=0;t<e.length>>1;++t)r[t]=String.fromCharCode(e.charCodeAt(2*t)+(e.charCodeAt(2*t+1)<<8));return r.join("")}function h(e){var r=[];for(var t=0;t<e.length>>1;++t)r[t]=String.fromCharCode(e.charCodeAt(2*t+1)+(e.charCodeAt(2*t)<<8));return r.join("")}var d=function(e){var r=e.charCodeAt(0),t=e.charCodeAt(1);if(r==255&&t==254)return u(e.slice(2));if(r==254&&t==255)return h(e.slice(2));if(r==65279)return e.slice(1);return e};var v=function rb(e){return String.fromCharCode(e)};var p=function tb(e){return String.fromCharCode(e)};if(typeof cptable!=="undefined"){l=function(e){r=e;s(e)};d=function(e){if(e.charCodeAt(0)===255&&e.charCodeAt(1)===254){return cptable.utils.decode(1200,c(e.slice(2)))}return e};v=function ab(e){if(r===1200)return String.fromCharCode(e);return cptable.utils.decode(r,[e&255,e>>8])[0]};p=function nb(e){return cptable.utils.decode(t,[e])[0]}}var m=null;var b=true;var g=function ib(){var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";return{encode:function(r){var t="";var a=0,n=0,i=0,s=0,f=0,l=0,o=0;for(var c=0;c<r.length;){a=r.charCodeAt(c++);s=a>>2;n=r.charCodeAt(c++);f=(a&3)<<4|n>>4;i=r.charCodeAt(c++);l=(n&15)<<2|i>>6;o=i&63;if(isNaN(n)){l=o=64}else if(isNaN(i)){o=64}t+=e.charAt(s)+e.charAt(f)+e.charAt(l)+e.charAt(o)}return t},decode:function r(t){var a="";var n=0,i=0,s=0,f=0,l=0,o=0,c=0;t=t.replace(/[^\w\+\/\=]/g,"");for(var u=0;u<t.length;){f=e.indexOf(t.charAt(u++));l=e.indexOf(t.charAt(u++));n=f<<2|l>>4;a+=String.fromCharCode(n);o=e.indexOf(t.charAt(u++));i=(l&15)<<4|o>>2;if(o!==64){a+=String.fromCharCode(i)}c=e.indexOf(t.charAt(u++));s=(o&3)<<6|c;if(c!==64){a+=String.fromCharCode(s)}}return a}}}();var w=typeof Buffer!=="undefined"&&typeof process!=="undefined"&&typeof process.versions!=="undefined"&&!!process.versions.node;var k=function(){};if(typeof Buffer!=="undefined"){var E=!Buffer.from;if(!E)try{Buffer.from("foo","utf8")}catch(S){E=true}k=E?function(e,r){return r?new Buffer(e,r):new Buffer(e)}:Buffer.from.bind(Buffer);if(!Buffer.alloc)Buffer.alloc=function(e){return new Buffer(e)};if(!Buffer.allocUnsafe)Buffer.allocUnsafe=function(e){return new Buffer(e)}}function _(e){return w?Buffer.alloc(e):new Array(e)}function C(e){return w?Buffer.allocUnsafe(e):new Array(e)}var B=function sb(e){if(w)return k(e,"binary");return e.split("").map(function(e){return e.charCodeAt(0)&255})};function T(e){if(typeof ArrayBuffer==="undefined")return B(e);var r=new ArrayBuffer(e.length),t=new Uint8Array(r);for(var a=0;a!=e.length;++a)t[a]=e.charCodeAt(a)&255;return r}function y(e){if(Array.isArray(e))return e.map(function(e){return String.fromCharCode(e)}).join("");var r=[];for(var t=0;t<e.length;++t)r[t]=String.fromCharCode(e[t]);return r.join("")}function x(e){if(typeof Uint8Array==="undefined")throw new Error("Unsupported");return new Uint8Array(e)}function A(e){if(typeof ArrayBuffer=="undefined")throw new Error("Unsupported");if(e instanceof ArrayBuffer)return A(new Uint8Array(e));var r=new Array(e.length);for(var t=0;t<e.length;++t)r[t]=e[t];return r}var I=function(e){return[].concat.apply([],e)};var R=/\u0000/g,D=/[\u0001-\u0006]/g;var F={};var O=function fb(e){e.version="0.10.2";function r(e){var r="",t=e.length-1;while(t>=0)r+=e.charAt(t--);return r}function t(e,r){var t="";while(t.length<r)t+=e;return t}function a(e,r){var a=""+e;return a.length>=r?a:t("0",r-a.length)+a}function n(e,r){var a=""+e;return a.length>=r?a:t(" ",r-a.length)+a}function i(e,r){var a=""+e;return a.length>=r?a:a+t(" ",r-a.length)}function s(e,r){var a=""+Math.round(e);return a.length>=r?a:t("0",r-a.length)+a}function f(e,r){var a=""+e;return a.length>=r?a:t("0",r-a.length)+a}var l=Math.pow(2,32);function o(e,r){if(e>l||e<-l)return s(e,r);var t=Math.round(e);return f(t,r)}function c(e,r){r=r||0;return e.length>=7+r&&(e.charCodeAt(r)|32)===103&&(e.charCodeAt(r+1)|32)===101&&(e.charCodeAt(r+2)|32)===110&&(e.charCodeAt(r+3)|32)===101&&(e.charCodeAt(r+4)|32)===114&&(e.charCodeAt(r+5)|32)===97&&(e.charCodeAt(r+6)|32)===108}var u=[["Sun","Sunday"],["Mon","Monday"],["Tue","Tuesday"],["Wed","Wednesday"],["Thu","Thursday"],["Fri","Friday"],["Sat","Saturday"]];var h=[["J","Jan","January"],["F","Feb","February"],["M","Mar","March"],["A","Apr","April"],["M","May","May"],["J","Jun","June"],["J","Jul","July"],["A","Aug","August"],["S","Sep","September"],["O","Oct","October"],["N","Nov","November"],["D","Dec","December"]];function d(e){e[0]="General";e[1]="0";e[2]="0.00";e[3]="#,##0";e[4]="#,##0.00";e[9]="0%";e[10]="0.00%";e[11]="0.00E+00";e[12]="# ?/?";e[13]="# ??/??";e[14]="m/d/yy";e[15]="d-mmm-yy";e[16]="d-mmm";e[17]="mmm-yy";e[18]="h:mm AM/PM";e[19]="h:mm:ss AM/PM";e[20]="h:mm";e[21]="h:mm:ss";e[22]="m/d/yy h:mm";e[37]="#,##0 ;(#,##0)";e[38]="#,##0 ;[Red](#,##0)";e[39]="#,##0.00;(#,##0.00)";e[40]="#,##0.00;[Red](#,##0.00)";e[45]="mm:ss";e[46]="[h]:mm:ss";e[47]="mmss.0";e[48]="##0.0E+0";e[49]="@";e[56]='"/ "hh""mm""ss" "';e[65535]="General"}var v={};d(v);function p(e,r,t){var a=e<0?-1:1;var n=e*a;var i=0,s=1,f=0;var l=1,o=0,c=0;var u=Math.floor(n);while(o<r){u=Math.floor(n);f=u*s+i;c=u*o+l;if(n-u<5e-8)break;n=1/(n-u);i=s;s=f;l=o;o=c}if(c>r){if(o>r){c=l;f=i}else{c=o;f=s}}if(!t)return[0,a*f,c];var h=Math.floor(a*f/c);return[h,a*f-h*c,c]}function m(e,r,t){if(e>2958465||e<0)return null;var a=e|0,n=Math.floor(86400*(e-a)),i=0;var s=[];var f={D:a,T:n,u:86400*(e-a)-n,y:0,m:0,d:0,H:0,M:0,S:0,q:0};if(Math.abs(f.u)<1e-6)f.u=0;if(r&&r.date1904)a+=1462;if(f.u>.9999){f.u=0;if(++n==86400){f.T=n=0;++a;++f.D}}if(a===60){s=t?[1317,10,29]:[1900,2,29];i=3}else if(a===0){s=t?[1317,8,29]:[1900,1,0];i=6}else{if(a>60)--a;var l=new Date(1900,0,1);l.setDate(l.getDate()+a-1);s=[l.getFullYear(),l.getMonth()+1,l.getDate()];i=l.getDay();if(a<60)i=(i+6)%7;if(t)i=C(l,s)}f.y=s[0];f.m=s[1];f.d=s[2];f.S=n%60;n=Math.floor(n/60);f.M=n%60;n=Math.floor(n/60);f.H=n;f.q=i;return f}e.parse_date_code=m;var b=new Date(1899,11,31,0,0,0);var g=b.getTime();var w=new Date(1900,2,1,0,0,0);function k(e,r){var t=e.getTime();if(r)t-=1461*24*60*60*1e3;else if(e>=w)t+=24*60*60*1e3;return(t-(g+(e.getTimezoneOffset()-b.getTimezoneOffset())*6e4))/(24*60*60*1e3)}function E(e){return e.toString(10)}e._general_int=E;var S=function M(){var e=/\.(\d*[1-9])0+$/,r=/\.0*$/,t=/\.(\d*[1-9])0+/,a=/\.0*[Ee]/,n=/(E[+-])(\d)$/;function i(e){var r=e<0?12:11;var t=l(e.toFixed(12));if(t.length<=r)return t;t=e.toPrecision(10);if(t.length<=r)return t;return e.toExponential(5)}function s(r){var t=r.toFixed(11).replace(e,".$1");if(t.length>(r<0?12:11))t=r.toPrecision(6);return t}function f(e){for(var r=0;r!=e.length;++r)if((e.charCodeAt(r)|32)===101)return e.replace(t,".$1").replace(a,"E").replace("e","E").replace(n,"$10$2");return e}function l(t){return t.indexOf(".")>-1?t.replace(r,"").replace(e,".$1"):t}return function o(e){var r=Math.floor(Math.log(Math.abs(e))*Math.LOG10E),t;if(r>=-4&&r<=-1)t=e.toPrecision(10+r);else if(Math.abs(r)<=9)t=i(e);else if(r===10)t=e.toFixed(10).substr(0,12);else t=s(e);return l(f(t))}}();e._general_num=S;function _(e,r){switch(typeof e){case"string":return e;case"boolean":return e?"TRUE":"FALSE";case"number":return(e|0)===e?E(e):S(e);case"undefined":return"";case"object":if(e==null)return"";if(e instanceof Date)return N(14,k(e,r&&r.date1904),r);}throw new Error("unsupported value in General format: "+e)}e._general=_;function C(){return 0}function B(e,r,t,n){var i="",s=0,f=0,l=t.y,o,c=0;switch(e){case 98:l=t.y+543;case 121:switch(r.length){case 1:;case 2:o=l%100;c=2;break;default:o=l%1e4;c=4;break;}break;case 109:switch(r.length){case 1:;case 2:o=t.m;c=r.length;break;case 3:return h[t.m-1][1];case 5:return h[t.m-1][0];default:return h[t.m-1][2];}break;case 100:switch(r.length){case 1:;case 2:o=t.d;c=r.length;break;case 3:return u[t.q][0];default:return u[t.q][1];}break;case 104:switch(r.length){case 1:;case 2:o=1+(t.H+11)%12;c=r.length;break;default:throw"bad hour format: "+r;}break;case 72:switch(r.length){case 1:;case 2:o=t.H;c=r.length;break;default:throw"bad hour format: "+r;}break;case 77:switch(r.length){case 1:;case 2:o=t.M;c=r.length;break;default:throw"bad minute format: "+r;}break;case 115:if(r!="s"&&r!="ss"&&r!=".0"&&r!=".00"&&r!=".000")throw"bad second format: "+r;if(t.u===0&&(r=="s"||r=="ss"))return a(t.S,r.length);if(n>=2)f=n===3?1e3:100;else f=n===1?10:1;s=Math.round(f*(t.S+t.u));if(s>=60*f)s=0;if(r==="s")return s===0?"0":""+s/f;i=a(s,2+n);if(r==="ss")return i.substr(0,2);return"."+i.substr(2,r.length-1);case 90:switch(r){case"[h]":;case"[hh]":o=t.D*24+t.H;break;case"[m]":;case"[mm]":o=(t.D*24+t.H)*60+t.M;break;case"[s]":;case"[ss]":o=((t.D*24+t.H)*60+t.M)*60+Math.round(t.S+t.u);break;default:throw"bad abstime format: "+r;}c=r.length===3?1:2;break;case 101:o=l;c=1;}if(c>0)return a(o,c);else return""}function T(e){var r=3;if(e.length<=r)return e;var t=e.length%r,a=e.substr(0,t);for(;t!=e.length;t+=r)a+=(a.length>0?",":"")+e.substr(t,r);return a}var y=function U(){var e=/%/g;function s(r,a,n){var i=a.replace(e,""),s=a.length-i.length;return y(r,i,n*Math.pow(10,2*s))+t("%",s)}function f(e,r,t){var a=r.length-1;while(r.charCodeAt(a-1)===44)--a;return y(e,r.substr(0,a),t/Math.pow(10,3*(r.length-a)))}function l(e,r){var t;var a=e.indexOf("E")-e.indexOf(".")-1;if(e.match(/^#+0.0E\+0$/)){if(r==0)return"0.0E+0";else if(r<0)return"-"+l(e,-r);var n=e.indexOf(".");if(n===-1)n=e.indexOf("E");var i=Math.floor(Math.log(r)*Math.LOG10E)%n;if(i<0)i+=n;t=(r/Math.pow(10,i)).toPrecision(a+1+(n+i)%n);if(t.indexOf("e")===-1){var s=Math.floor(Math.log(r)*Math.LOG10E);if(t.indexOf(".")===-1)t=t.charAt(0)+"."+t.substr(1)+"E+"+(s-t.length+i);else t+="E+"+(s-i);while(t.substr(0,2)==="0."){t=t.charAt(0)+t.substr(2,n)+"."+t.substr(2+n);t=t.replace(/^0+([1-9])/,"$1").replace(/^0+\./,"0.")}t=t.replace(/\+-/,"-")}t=t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function(e,r,t,a){return r+t+a.substr(0,(n+i)%n)+"."+a.substr(i)+"E"})}else t=r.toExponential(a);if(e.match(/E\+00$/)&&t.match(/e[+-]\d$/))t=t.substr(0,t.length-1)+"0"+t.charAt(t.length-1);if(e.match(/E\-/)&&t.match(/e\+/))t=t.replace(/e\+/,"e");return t.replace("e","E")}var c=/# (\?+)( ?)\/( ?)(\d+)/;function u(e,r,i){var s=parseInt(e[4],10),f=Math.round(r*s),l=Math.floor(f/s);var o=f-l*s,c=s;return i+(l===0?"":""+l)+" "+(o===0?t(" ",e[1].length+1+e[4].length):n(o,e[1].length)+e[2]+"/"+e[3]+a(c,e[4].length))}function h(e,r,a){return a+(r===0?"":""+r)+t(" ",e[1].length+2+e[4].length)}var d=/^#*0*\.([0#]+)/;var v=/\).*[0#]/;var m=/\(###\) ###\\?-####/;function b(e){var r="",t;for(var a=0;a!=e.length;++a)switch(t=e.charCodeAt(a)){case 35:break;case 63:r+=" ";break;case 48:r+="0";break;default:r+=String.fromCharCode(t);}return r}function g(e,r){var t=Math.pow(10,r);return""+Math.round(e*t)/t}function w(e,r){if(r<(""+Math.round((e-Math.floor(e))*Math.pow(10,r))).length){return 0}return Math.round((e-Math.floor(e))*Math.pow(10,r))}function k(e,r){if(r<(""+Math.round((e-Math.floor(e))*Math.pow(10,r))).length){return 1}return 0}function E(e){if(e<2147483647&&e>-2147483648)return""+(e>=0?e|0:e-1|0);return""+Math.floor(e)}function S(e,h,_){if(e.charCodeAt(0)===40&&!h.match(v)){var C=h.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");if(_>=0)return S("n",C,_);return"("+S("n",C,-_)+")"}if(h.charCodeAt(h.length-1)===44)return f(e,h,_);if(h.indexOf("%")!==-1)return s(e,h,_);if(h.indexOf("E")!==-1)return l(h,_);if(h.charCodeAt(0)===36)return"$"+S(e,h.substr(h.charAt(1)==" "?2:1),_);var B;var x,A,I,R=Math.abs(_),D=_<0?"-":"";if(h.match(/^00+$/))return D+o(R,h.length);if(h.match(/^[#?]+$/)){B=o(_,0);if(B==="0")B="";return B.length>h.length?B:b(h.substr(0,h.length-B.length))+B}if(x=h.match(c))return u(x,R,D);if(h.match(/^#+0+$/))return D+o(R,h.length-h.indexOf("0"));if(x=h.match(d)){B=g(_,x[1].length).replace(/^([^\.]+)$/,"$1."+b(x[1])).replace(/\.$/,"."+b(x[1])).replace(/\.(\d*)$/,function(e,r){return"."+r+t("0",b(x[1]).length-r.length)});return h.indexOf("0.")!==-1?B:B.replace(/^0\./,".")}h=h.replace(/^#+([0.])/,"$1");if(x=h.match(/^(0*)\.(#*)$/)){return D+g(R,x[2].length).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,x[1].length?"0.":".")}if(x=h.match(/^#{1,3},##0(\.?)$/))return D+T(o(R,0));if(x=h.match(/^#,##0\.([#0]*0)$/)){return _<0?"-"+S(e,h,-_):T(""+(Math.floor(_)+k(_,x[1].length)))+"."+a(w(_,x[1].length),x[1].length)}if(x=h.match(/^#,#*,#0/))return S(e,h.replace(/^#,#*,/,""),_);if(x=h.match(/^([0#]+)(\\?-([0#]+))+$/)){B=r(S(e,h.replace(/[\\-]/g,""),_));A=0;return r(r(h.replace(/\\/g,"")).replace(/[0#]/g,function(e){return A<B.length?B.charAt(A++):e==="0"?"0":""}))}if(h.match(m)){B=S(e,"##########",_);return"("+B.substr(0,3)+") "+B.substr(3,3)+"-"+B.substr(6)}var F="";if(x=h.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)){A=Math.min(x[4].length,7);I=p(R,Math.pow(10,A)-1,false);B=""+D;F=y("n",x[1],I[1]);if(F.charAt(F.length-1)==" ")F=F.substr(0,F.length-1)+"0";B+=F+x[2]+"/"+x[3];F=i(I[2],A);if(F.length<x[4].length)F=b(x[4].substr(x[4].length-F.length))+F;B+=F;return B}if(x=h.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)){A=Math.min(Math.max(x[1].length,x[4].length),7);I=p(R,Math.pow(10,A)-1,true);return D+(I[0]||(I[1]?"":"0"))+" "+(I[1]?n(I[1],A)+x[2]+"/"+x[3]+i(I[2],A):t(" ",2*A+1+x[2].length+x[3].length))}if(x=h.match(/^[#0?]+$/)){B=o(_,0);if(h.length<=B.length)return B;return b(h.substr(0,h.length-B.length))+B}if(x=h.match(/^([#0?]+)\.([#0]+)$/)){B=""+_.toFixed(Math.min(x[2].length,10)).replace(/([^0])0+$/,"$1");A=B.indexOf(".");var O=h.indexOf(".")-A,P=h.length-B.length-O;return b(h.substr(0,O)+B+h.substr(h.length-P))}if(x=h.match(/^00,000\.([#0]*0)$/)){A=w(_,x[1].length);return _<0?"-"+S(e,h,-_):T(E(_)).replace(/^\d,\d{3}$/,"0$&").replace(/^\d*$/,function(e){return"00,"+(e.length<3?a(0,3-e.length):"")+e})+"."+a(A,x[1].length)}switch(h){case"###,##0.00":return S(e,"#,##0.00",_);case"###,###":;case"##,###":;case"#,###":var N=T(o(R,0));return N!=="0"?D+N:"";case"###,###.00":return S(e,"###,##0.00",_).replace(/^0\./,".");case"#,###.00":return S(e,"#,##0.00",_).replace(/^0\./,".");default:;}throw new Error("unsupported format |"+h+"|")}function _(e,r,t){var a=r.length-1;while(r.charCodeAt(a-1)===44)--a;return y(e,r.substr(0,a),t/Math.pow(10,3*(r.length-a)))}function C(r,a,n){var i=a.replace(e,""),s=a.length-i.length;return y(r,i,n*Math.pow(10,2*s))+t("%",s)}function B(e,r){var t;var a=e.indexOf("E")-e.indexOf(".")-1;if(e.match(/^#+0.0E\+0$/)){if(r==0)return"0.0E+0";else if(r<0)return"-"+B(e,-r);var n=e.indexOf(".");if(n===-1)n=e.indexOf("E");var i=Math.floor(Math.log(r)*Math.LOG10E)%n;if(i<0)i+=n;t=(r/Math.pow(10,i)).toPrecision(a+1+(n+i)%n);if(!t.match(/[Ee]/)){var s=Math.floor(Math.log(r)*Math.LOG10E);if(t.indexOf(".")===-1)t=t.charAt(0)+"."+t.substr(1)+"E+"+(s-t.length+i);else t+="E+"+(s-i);t=t.replace(/\+-/,"-")}t=t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function(e,r,t,a){return r+t+a.substr(0,(n+i)%n)+"."+a.substr(i)+"E"})}else t=r.toExponential(a);if(e.match(/E\+00$/)&&t.match(/e[+-]\d$/))t=t.substr(0,t.length-1)+"0"+t.charAt(t.length-1);if(e.match(/E\-/)&&t.match(/e\+/))t=t.replace(/e\+/,"e");return t.replace("e","E")}function x(e,s,f){if(e.charCodeAt(0)===40&&!s.match(v)){var l=s.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");if(f>=0)return x("n",l,f);return"("+x("n",l,-f)+")"}if(s.charCodeAt(s.length-1)===44)return _(e,s,f);
if(s.indexOf("%")!==-1)return C(e,s,f);if(s.indexOf("E")!==-1)return B(s,f);if(s.charCodeAt(0)===36)return"$"+x(e,s.substr(s.charAt(1)==" "?2:1),f);var o;var u,g,w,k=Math.abs(f),E=f<0?"-":"";if(s.match(/^00+$/))return E+a(k,s.length);if(s.match(/^[#?]+$/)){o=""+f;if(f===0)o="";return o.length>s.length?o:b(s.substr(0,s.length-o.length))+o}if(u=s.match(c))return h(u,k,E);if(s.match(/^#+0+$/))return E+a(k,s.length-s.indexOf("0"));if(u=s.match(d)){o=(""+f).replace(/^([^\.]+)$/,"$1."+b(u[1])).replace(/\.$/,"."+b(u[1]));o=o.replace(/\.(\d*)$/,function(e,r){return"."+r+t("0",b(u[1]).length-r.length)});return s.indexOf("0.")!==-1?o:o.replace(/^0\./,".")}s=s.replace(/^#+([0.])/,"$1");if(u=s.match(/^(0*)\.(#*)$/)){return E+(""+k).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,u[1].length?"0.":".")}if(u=s.match(/^#{1,3},##0(\.?)$/))return E+T(""+k);if(u=s.match(/^#,##0\.([#0]*0)$/)){return f<0?"-"+x(e,s,-f):T(""+f)+"."+t("0",u[1].length)}if(u=s.match(/^#,#*,#0/))return x(e,s.replace(/^#,#*,/,""),f);if(u=s.match(/^([0#]+)(\\?-([0#]+))+$/)){o=r(x(e,s.replace(/[\\-]/g,""),f));g=0;return r(r(s.replace(/\\/g,"")).replace(/[0#]/g,function(e){return g<o.length?o.charAt(g++):e==="0"?"0":""}))}if(s.match(m)){o=x(e,"##########",f);return"("+o.substr(0,3)+") "+o.substr(3,3)+"-"+o.substr(6)}var S="";if(u=s.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)){g=Math.min(u[4].length,7);w=p(k,Math.pow(10,g)-1,false);o=""+E;S=y("n",u[1],w[1]);if(S.charAt(S.length-1)==" ")S=S.substr(0,S.length-1)+"0";o+=S+u[2]+"/"+u[3];S=i(w[2],g);if(S.length<u[4].length)S=b(u[4].substr(u[4].length-S.length))+S;o+=S;return o}if(u=s.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)){g=Math.min(Math.max(u[1].length,u[4].length),7);w=p(k,Math.pow(10,g)-1,true);return E+(w[0]||(w[1]?"":"0"))+" "+(w[1]?n(w[1],g)+u[2]+"/"+u[3]+i(w[2],g):t(" ",2*g+1+u[2].length+u[3].length))}if(u=s.match(/^[#0?]+$/)){o=""+f;if(s.length<=o.length)return o;return b(s.substr(0,s.length-o.length))+o}if(u=s.match(/^([#0]+)\.([#0]+)$/)){o=""+f.toFixed(Math.min(u[2].length,10)).replace(/([^0])0+$/,"$1");g=o.indexOf(".");var A=s.indexOf(".")-g,I=s.length-o.length-A;return b(s.substr(0,A)+o+s.substr(s.length-I))}if(u=s.match(/^00,000\.([#0]*0)$/)){return f<0?"-"+x(e,s,-f):T(""+f).replace(/^\d,\d{3}$/,"0$&").replace(/^\d*$/,function(e){return"00,"+(e.length<3?a(0,3-e.length):"")+e})+"."+a(0,u[1].length)}switch(s){case"###,###":;case"##,###":;case"#,###":var R=T(""+k);return R!=="0"?E+R:"";default:if(s.match(/\.[0#?]*$/))return x(e,s.slice(0,s.lastIndexOf(".")),f)+b(s.slice(s.lastIndexOf(".")));}throw new Error("unsupported format |"+s+"|")}return function A(e,r,t){return(t|0)===t?x(e,r,t):S(e,r,t)}}();function x(e){var r=[];var t=false;for(var a=0,n=0;a<e.length;++a)switch(e.charCodeAt(a)){case 34:t=!t;break;case 95:;case 42:;case 92:++a;break;case 59:r[r.length]=e.substr(n,a-n);n=a+1;}r[r.length]=e.substr(n);if(t===true)throw new Error("Format |"+e+"| unterminated string ");return r}e._split=x;var A=/\[[HhMmSs]*\]/;function I(e){var r=0,t="",a="";while(r<e.length){switch(t=e.charAt(r)){case"G":if(c(e,r))r+=6;r++;break;case'"':for(;e.charCodeAt(++r)!==34&&r<e.length;)++r;++r;break;case"\\":r+=2;break;case"_":r+=2;break;case"@":++r;break;case"B":;case"b":if(e.charAt(r+1)==="1"||e.charAt(r+1)==="2")return true;case"M":;case"D":;case"Y":;case"H":;case"S":;case"E":;case"m":;case"d":;case"y":;case"h":;case"s":;case"e":;case"g":return true;case"A":;case"a":if(e.substr(r,3).toUpperCase()==="A/P")return true;if(e.substr(r,5).toUpperCase()==="AM/PM")return true;++r;break;case"[":a=t;while(e.charAt(r++)!=="]"&&r<e.length)a+=e.charAt(r);if(a.match(A))return true;break;case".":;case"0":;case"#":while(r<e.length&&("0#?.,E+-%".indexOf(t=e.charAt(++r))>-1||t=="\\"&&e.charAt(r+1)=="-"&&"0#".indexOf(e.charAt(r+2))>-1)){}break;case"?":while(e.charAt(++r)===t){}break;case"*":++r;if(e.charAt(r)==" "||e.charAt(r)=="*")++r;break;case"(":;case")":++r;break;case"1":;case"2":;case"3":;case"4":;case"5":;case"6":;case"7":;case"8":;case"9":while(r<e.length&&"0123456789".indexOf(e.charAt(++r))>-1){}break;case" ":++r;break;default:++r;break;}}return false}e.is_date=I;function R(e,r,t,a){var n=[],i="",s=0,f="",l="t",o,u,h;var d="H";while(s<e.length){switch(f=e.charAt(s)){case"G":if(!c(e,s))throw new Error("unrecognized character "+f+" in "+e);n[n.length]={t:"G",v:"General"};s+=7;break;case'"':for(i="";(h=e.charCodeAt(++s))!==34&&s<e.length;)i+=String.fromCharCode(h);n[n.length]={t:"t",v:i};++s;break;case"\\":var v=e.charAt(++s),p=v==="("||v===")"?v:"t";n[n.length]={t:p,v:v};++s;break;case"_":n[n.length]={t:"t",v:" "};s+=2;break;case"@":n[n.length]={t:"T",v:r};++s;break;case"B":;case"b":if(e.charAt(s+1)==="1"||e.charAt(s+1)==="2"){if(o==null){o=m(r,t,e.charAt(s+1)==="2");if(o==null)return""}n[n.length]={t:"X",v:e.substr(s,2)};l=f;s+=2;break};case"M":;case"D":;case"Y":;case"H":;case"S":;case"E":f=f.toLowerCase();case"m":;case"d":;case"y":;case"h":;case"s":;case"e":;case"g":if(r<0)return"";if(o==null){o=m(r,t);if(o==null)return""}i=f;while(++s<e.length&&e.charAt(s).toLowerCase()===f)i+=f;if(f==="m"&&l.toLowerCase()==="h")f="M";if(f==="h")f=d;n[n.length]={t:f,v:i};l=f;break;case"A":;case"a":var b={t:f,v:f};if(o==null)o=m(r,t);if(e.substr(s,3).toUpperCase()==="A/P"){if(o!=null)b.v=o.H>=12?"P":"A";b.t="T";d="h";s+=3}else if(e.substr(s,5).toUpperCase()==="AM/PM"){if(o!=null)b.v=o.H>=12?"PM":"AM";b.t="T";s+=5;d="h"}else{b.t="t";++s}if(o==null&&b.t==="T")return"";n[n.length]=b;l=f;break;case"[":i=f;while(e.charAt(s++)!=="]"&&s<e.length)i+=e.charAt(s);if(i.slice(-1)!=="]")throw'unterminated "[" block: |'+i+"|";if(i.match(A)){if(o==null){o=m(r,t);if(o==null)return""}n[n.length]={t:"Z",v:i.toLowerCase()};l=i.charAt(1)}else if(i.indexOf("$")>-1){i=(i.match(/\$([^-\[\]]*)/)||[])[1]||"$";if(!I(e))n[n.length]={t:"t",v:i}}break;case".":if(o!=null){i=f;while(++s<e.length&&(f=e.charAt(s))==="0")i+=f;n[n.length]={t:"s",v:i};break};case"0":;case"#":i=f;while(++s<e.length&&"0#?.,E+-%".indexOf(f=e.charAt(s))>-1||f=="\\"&&e.charAt(s+1)=="-"&&s<e.length-2&&"0#".indexOf(e.charAt(s+2))>-1)i+=f;n[n.length]={t:"n",v:i};break;case"?":i=f;while(e.charAt(++s)===f)i+=f;n[n.length]={t:f,v:i};l=f;break;case"*":++s;if(e.charAt(s)==" "||e.charAt(s)=="*")++s;break;case"(":;case")":n[n.length]={t:a===1?"t":f,v:f};++s;break;case"1":;case"2":;case"3":;case"4":;case"5":;case"6":;case"7":;case"8":;case"9":i=f;while(s<e.length&&"0123456789".indexOf(e.charAt(++s))>-1)i+=e.charAt(s);n[n.length]={t:"D",v:i};break;case" ":n[n.length]={t:f,v:f};++s;break;default:if(",$-+/():!^&'~{}<>=acfijklopqrtuvwxzP".indexOf(f)===-1)throw new Error("unrecognized character "+f+" in "+e);n[n.length]={t:"t",v:f};++s;break;}}var g=0,w=0,k;for(s=n.length-1,l="t";s>=0;--s){switch(n[s].t){case"h":;case"H":n[s].t=d;l="h";if(g<1)g=1;break;case"s":if(k=n[s].v.match(/\.0+$/))w=Math.max(w,k[0].length-1);if(g<3)g=3;case"d":;case"y":;case"M":;case"e":l=n[s].t;break;case"m":if(l==="s"){n[s].t="M";if(g<2)g=2}break;case"X":break;case"Z":if(g<1&&n[s].v.match(/[Hh]/))g=1;if(g<2&&n[s].v.match(/[Mm]/))g=2;if(g<3&&n[s].v.match(/[Ss]/))g=3;}}switch(g){case 0:break;case 1:if(o.u>=.5){o.u=0;++o.S}if(o.S>=60){o.S=0;++o.M}if(o.M>=60){o.M=0;++o.H}break;case 2:if(o.u>=.5){o.u=0;++o.S}if(o.S>=60){o.S=0;++o.M}break;}var E="",S;for(s=0;s<n.length;++s){switch(n[s].t){case"t":;case"T":;case" ":;case"D":break;case"X":n[s].v="";n[s].t=";";break;case"d":;case"m":;case"y":;case"h":;case"H":;case"M":;case"s":;case"e":;case"b":;case"Z":n[s].v=B(n[s].t.charCodeAt(0),n[s].v,o,w);n[s].t="t";break;case"n":;case"(":;case"?":S=s+1;while(n[S]!=null&&((f=n[S].t)==="?"||f==="D"||(f===" "||f==="t")&&n[S+1]!=null&&(n[S+1].t==="?"||n[S+1].t==="t"&&n[S+1].v==="/")||n[s].t==="("&&(f===" "||f==="n"||f===")")||f==="t"&&(n[S].v==="/"||n[S].v===" "&&n[S+1]!=null&&n[S+1].t=="?"))){n[s].v+=n[S].v;n[S]={v:"",t:";"};++S}E+=n[s].v;s=S-1;break;case"G":n[s].t="t";n[s].v=_(r,t);break;}}var C="",T,x;if(E.length>0){if(E.charCodeAt(0)==40){T=r<0&&E.charCodeAt(0)===45?-r:r;x=y("(",E,T)}else{T=r<0&&a>1?-r:r;x=y("n",E,T);if(T<0&&n[0]&&n[0].t=="t"){x=x.substr(1);n[0].v="-"+n[0].v}}S=x.length-1;var R=n.length;for(s=0;s<n.length;++s)if(n[s]!=null&&n[s].t!="t"&&n[s].v.indexOf(".")>-1){R=s;break}var D=n.length;if(R===n.length&&x.indexOf("E")===-1){for(s=n.length-1;s>=0;--s){if(n[s]==null||"n?(".indexOf(n[s].t)===-1)continue;if(S>=n[s].v.length-1){S-=n[s].v.length;n[s].v=x.substr(S+1,n[s].v.length)}else if(S<0)n[s].v="";else{n[s].v=x.substr(0,S+1);S=-1}n[s].t="t";D=s}if(S>=0&&D<n.length)n[D].v=x.substr(0,S+1)+n[D].v}else if(R!==n.length&&x.indexOf("E")===-1){S=x.indexOf(".")-1;for(s=R;s>=0;--s){if(n[s]==null||"n?(".indexOf(n[s].t)===-1)continue;u=n[s].v.indexOf(".")>-1&&s===R?n[s].v.indexOf(".")-1:n[s].v.length-1;C=n[s].v.substr(u+1);for(;u>=0;--u){if(S>=0&&(n[s].v.charAt(u)==="0"||n[s].v.charAt(u)==="#"))C=x.charAt(S--)+C}n[s].v=C;n[s].t="t";D=s}if(S>=0&&D<n.length)n[D].v=x.substr(0,S+1)+n[D].v;S=x.indexOf(".")+1;for(s=R;s<n.length;++s){if(n[s]==null||"n?(".indexOf(n[s].t)===-1&&s!==R)continue;u=n[s].v.indexOf(".")>-1&&s===R?n[s].v.indexOf(".")+1:0;C=n[s].v.substr(0,u);for(;u<n[s].v.length;++u){if(S<x.length)C+=x.charAt(S++)}n[s].v=C;n[s].t="t";D=s}}}for(s=0;s<n.length;++s)if(n[s]!=null&&"n(?".indexOf(n[s].t)>-1){T=a>1&&r<0&&s>0&&n[s-1].v==="-"?-r:r;n[s].v=y(n[s].t,n[s].v,T);n[s].t="t"}var F="";for(s=0;s!==n.length;++s)if(n[s]!=null)F+=n[s].v;return F}e._eval=R;var D=/\[[=<>]/;var F=/\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;function O(e,r){if(r==null)return false;var t=parseFloat(r[2]);switch(r[1]){case"=":if(e==t)return true;break;case">":if(e>t)return true;break;case"<":if(e<t)return true;break;case"<>":if(e!=t)return true;break;case">=":if(e>=t)return true;break;case"<=":if(e<=t)return true;break;}return false}function P(e,r){var t=x(e);var a=t.length,n=t[a-1].indexOf("@");if(a<4&&n>-1)--a;if(t.length>4)throw new Error("cannot find right format for |"+t.join("|")+"|");if(typeof r!=="number")return[4,t.length===4||n>-1?t[t.length-1]:"@"];switch(t.length){case 1:t=n>-1?["General","General","General",t[0]]:[t[0],t[0],t[0],"@"];break;case 2:t=n>-1?[t[0],t[0],t[0],t[1]]:[t[0],t[1],t[0],"@"];break;case 3:t=n>-1?[t[0],t[1],t[0],t[2]]:[t[0],t[1],t[2],"@"];break;case 4:break;}var i=r>0?t[0]:r<0?t[1]:t[2];if(t[0].indexOf("[")===-1&&t[1].indexOf("[")===-1)return[a,i];if(t[0].match(D)!=null||t[1].match(D)!=null){var s=t[0].match(F);var f=t[1].match(F);return O(r,s)?[a,t[0]]:O(r,f)?[a,t[1]]:[a,t[s!=null&&f!=null?2:1]]}return[a,i]}function N(e,r,t){if(t==null)t={};var a="";switch(typeof e){case"string":if(e=="m/d/yy"&&t.dateNF)a=t.dateNF;else a=e;break;case"number":if(e==14&&t.dateNF)a=t.dateNF;else a=(t.table!=null?t.table:v)[e];break;}if(c(a,0))return _(r,t);if(r instanceof Date)r=k(r,t.date1904);var n=P(a,r);if(c(n[1]))return _(r,t);if(r===true)r="TRUE";else if(r===false)r="FALSE";else if(r===""||r==null)return"";return R(n[1],r,t,n[0])}function L(e,r){if(typeof r!="number"){r=+r||-1;for(var t=0;t<392;++t){if(v[t]==undefined){if(r<0)r=t;continue}if(v[t]==e){r=t;break}}if(r<0)r=391}v[r]=e;return r}e.load=L;e._table=v;e.get_table=function H(){return v};e.load_table=function W(e){for(var r=0;r!=392;++r)if(e[r]!==undefined)L(e[r],r)};e.init_table=d;e.format=N};O(F);var P={"General Number":"General","General Date":F._table[22],"Long Date":"dddd, mmmm dd, yyyy","Medium Date":F._table[15],"Short Date":F._table[14],"Long Time":F._table[19],"Medium Time":F._table[18],"Short Time":F._table[20],Currency:'"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',Fixed:F._table[2],Standard:F._table[4],Percent:F._table[10],Scientific:F._table[11],"Yes/No":'"Yes";"Yes";"No";@',"True/False":'"True";"True";"False";@',"On/Off":'"Yes";"Yes";"No";@'};var N={5:'"$"#,##0_);\\("$"#,##0\\)',6:'"$"#,##0_);[Red]\\("$"#,##0\\)',7:'"$"#,##0.00_);\\("$"#,##0.00\\)',8:'"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',23:"General",24:"General",25:"General",26:"General",27:"m/d/yy",28:"m/d/yy",29:"m/d/yy",30:"m/d/yy",31:"m/d/yy",32:"h:mm:ss",33:"h:mm:ss",34:"h:mm:ss",35:"h:mm:ss",36:"m/d/yy",41:'_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',42:'_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',43:'_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',44:'_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',50:"m/d/yy",51:"m/d/yy",52:"m/d/yy",53:"m/d/yy",54:"m/d/yy",55:"m/d/yy",56:"m/d/yy",57:"m/d/yy",58:"m/d/yy",59:"0",60:"0.00",61:"#,##0",62:"#,##0.00",63:'"$"#,##0_);\\("$"#,##0\\)',64:'"$"#,##0_);[Red]\\("$"#,##0\\)',65:'"$"#,##0.00_);\\("$"#,##0.00\\)',66:'"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',67:"0%",68:"0.00%",69:"# ?/?",70:"# ??/??",71:"m/d/yy",72:"m/d/yy",73:"d-mmm-yy",74:"d-mmm",75:"mmm-yy",76:"h:mm",77:"h:mm:ss",78:"m/d/yy h:mm",79:"mm:ss",80:"[h]:mm:ss",81:"mmss.0"};var L=/[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;function M(e){var r=typeof e=="number"?F._table[e]:e;r=r.replace(L,"(\\d+)");return new RegExp("^"+r+"$")}function U(e,r,t){var a=-1,n=-1,i=-1,s=-1,f=-1,l=-1;(r.match(L)||[]).forEach(function(e,r){var o=parseInt(t[r+1],10);switch(e.toLowerCase().charAt(0)){case"y":a=o;break;case"d":i=o;break;case"h":s=o;break;case"s":l=o;break;case"m":if(s>=0)f=o;else n=o;break;}});if(l>=0&&f==-1&&n>=0){f=n;n=-1}var o=(""+(a>=0?a:(new Date).getFullYear())).slice(-4)+"-"+("00"+(n>=1?n:1)).slice(-2)+"-"+("00"+(i>=1?i:1)).slice(-2);if(o.length==7)o="0"+o;if(o.length==8)o="20"+o;var c=("00"+(s>=0?s:0)).slice(-2)+":"+("00"+(f>=0?f:0)).slice(-2)+":"+("00"+(l>=0?l:0)).slice(-2);if(s==-1&&f==-1&&l==-1)return o;if(a==-1&&n==-1&&i==-1)return c;return o+"T"+c}var H=true;var W;(function(e){e(W={})})(function(e){e.version="1.2.0";function r(){var e=0,r=new Array(256);for(var t=0;t!=256;++t){e=t;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;e=e&1?-306674912^e>>>1:e>>>1;r[t]=e}return typeof Int32Array!=="undefined"?new Int32Array(r):r}var t=r();function a(e,r){var a=r^-1,n=e.length-1;for(var i=0;i<n;){a=a>>>8^t[(a^e.charCodeAt(i++))&255];a=a>>>8^t[(a^e.charCodeAt(i++))&255]}if(i===n)a=a>>>8^t[(a^e.charCodeAt(i))&255];return a^-1}function n(e,r){if(e.length>1e4)return i(e,r);var a=r^-1,n=e.length-3;for(var s=0;s<n;){a=a>>>8^t[(a^e[s++])&255];a=a>>>8^t[(a^e[s++])&255];a=a>>>8^t[(a^e[s++])&255];a=a>>>8^t[(a^e[s++])&255]}while(s<n+3)a=a>>>8^t[(a^e[s++])&255];return a^-1}function i(e,r){var a=r^-1,n=e.length-7;for(var i=0;i<n;){a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255];a=a>>>8^t[(a^e[i++])&255]}while(i<n+7)a=a>>>8^t[(a^e[i++])&255];return a^-1}function s(e,r){var a=r^-1;for(var n=0,i=e.length,s,f;n<i;){s=e.charCodeAt(n++);if(s<128){a=a>>>8^t[(a^s)&255]}else if(s<2048){a=a>>>8^t[(a^(192|s>>6&31))&255];a=a>>>8^t[(a^(128|s&63))&255]}else if(s>=55296&&s<57344){s=(s&1023)+64;f=e.charCodeAt(n++)&1023;a=a>>>8^t[(a^(240|s>>8&7))&255];a=a>>>8^t[(a^(128|s>>2&63))&255];a=a>>>8^t[(a^(128|f>>6&15|(s&3)<<4))&255];a=a>>>8^t[(a^(128|f&63))&255]}else{a=a>>>8^t[(a^(224|s>>12&15))&255];a=a>>>8^t[(a^(128|s>>6&63))&255];a=a>>>8^t[(a^(128|s&63))&255]}}return a^-1}e.table=t;e.bstr=a;e.buf=n;e.str=s});var z=function lb(){var e={};e.version="1.1.3";function r(e,r){var t=e.split("/"),a=r.split("/");for(var n=0,i=0,s=Math.min(t.length,a.length);n<s;++n){if(i=t[n].length-a[n].length)return i;if(t[n]!=a[n])return t[n]<a[n]?-1:1}return t.length-a.length}function t(e){if(e.charAt(e.length-1)=="/")return e.slice(0,-1).indexOf("/")===-1?e:t(e.slice(0,-1));var r=e.lastIndexOf("/");return r===-1?e:e.slice(0,r+1)}function a(e){if(e.charAt(e.length-1)=="/")return a(e.slice(0,-1));var r=e.lastIndexOf("/");return r===-1?e:e.slice(r+1)}function n(e,r){if(typeof r==="string")r=new Date(r);var t=r.getHours();t=t<<6|r.getMinutes();t=t<<5|r.getSeconds()>>>1;e._W(2,t);var a=r.getFullYear()-1980;a=a<<4|r.getMonth()+1;a=a<<5|r.getDate();e._W(2,a)}function i(e){var r=e._R(2)&65535;var t=e._R(2)&65535;var a=new Date;var n=t&31;t>>>=5;var i=t&15;t>>>=4;a.setMilliseconds(0);a.setFullYear(t+1980);a.setMonth(i-1);a.setDate(n);var s=r&31;r>>>=5;var f=r&63;r>>>=6;a.setHours(r);a.setMinutes(f);a.setSeconds(s<<1);return a}function s(e){Kr(e,0);var r={};var t=0;while(e.l<=e.length-4){var a=e._R(2);var n=e._R(2),i=e.l+n;var s={};switch(a){case 21589:{t=e._R(1);if(t&1)s.mtime=e._R(4);if(n>5){if(t&2)s.atime=e._R(4);if(t&4)s.ctime=e._R(4)}if(s.mtime)s.mt=new Date(s.mtime*1e3)}break;}e.l=i;r[a]=s}return r}var f;function l(){return f||(f=require("fs"))}function o(e,r){if(e[0]==80&&e[1]==75)return Te(e,r);if(e.length<512)throw new Error("CFB file size "+e.length+" < 512");var t=3;var a=512;var n=0;var i=0;var s=0;var f=0;var l=0;var o=[];var v=e.slice(0,512);Kr(v,0);var m=c(v);t=m[0];switch(t){case 3:a=512;break;case 4:a=4096;break;case 0:if(m[1]==0)return Te(e,r);default:throw new Error("Major Version: Expected 3 or 4 saw "+t);}if(a!==512){v=e.slice(0,a);Kr(v,28)}var g=e.slice(0,a);u(v,t);var w=v._R(4,"i");if(t===3&&w!==0)throw new Error("# Directory Sectors: Expected 0 saw "+w);v.l+=4;s=v._R(4,"i");v.l+=4;v.chk("00100000","Mini Stream Cutoff Size: ");f=v._R(4,"i");n=v._R(4,"i");l=v._R(4,"i");i=v._R(4,"i");for(var E=-1,S=0;S<109;++S){E=v._R(4,"i");if(E<0)break;o[S]=E}var _=h(e,a);p(l,i,_,a,o);var C=b(_,s,o,a);C[s].name="!Directory";if(n>0&&f!==N)C[f].name="!MiniFAT";C[o[0]].name="!FAT";C.fat_addrs=o;C.ssz=a;var B={},T=[],y=[],x=[];k(s,C,_,T,n,B,y,f);d(y,x,T);T.shift();var A={FileIndex:y,FullPaths:x};if(r&&r.raw)A.raw={header:g,sectors:_};return A}function c(e){if(e[e.l]==80&&e[e.l+1]==75)return[0,0];e.chk(L,"Header Signature: ");e.l+=16;var r=e._R(2,"u");return[e._R(2,"u"),r]}function u(e,r){var t=9;e.l+=2;switch(t=e._R(2)){case 9:if(r!=3)throw new Error("Sector Shift: Expected 9 saw "+t);break;case 12:if(r!=4)throw new Error("Sector Shift: Expected 12 saw "+t);break;default:throw new Error("Sector Shift: Expected 9 or 12 saw "+t);}e.chk("0600","Mini Sector Shift: ");e.chk("000000000000","Reserved: ")}function h(e,r){var t=Math.ceil(e.length/r)-1;var a=[];for(var n=1;n<t;++n)a[n-1]=e.slice(n*r,(n+1)*r);a[t-1]=e.slice(t*r);return a}function d(e,r,t){var a=0,n=0,i=0,s=0,f=0,l=t.length;var o=[],c=[];for(;a<l;++a){o[a]=c[a]=a;r[a]=t[a]}for(;f<c.length;++f){a=c[f];n=e[a].L;i=e[a].R;s=e[a].C;if(o[a]===a){if(n!==-1&&o[n]!==n)o[a]=o[n];if(i!==-1&&o[i]!==i)o[a]=o[i]}if(s!==-1)o[s]=a;if(n!==-1&&a!=o[a]){o[n]=o[a];if(c.lastIndexOf(n)<f)c.push(n)}if(i!==-1&&a!=o[a]){o[i]=o[a];if(c.lastIndexOf(i)<f)c.push(i)}}for(a=1;a<l;++a)if(o[a]===a){if(i!==-1&&o[i]!==i)o[a]=o[i];else if(n!==-1&&o[n]!==n)o[a]=o[n]}for(a=1;a<l;++a){if(e[a].type===0)continue;f=a;if(f!=o[f])do{f=o[f];r[a]=r[f]+"/"+r[a]}while(f!==0&&-1!==o[f]&&f!=o[f]);o[a]=-1}r[0]+="/";for(a=1;a<l;++a){if(e[a].type!==2)r[a]+="/"}}function v(e,r,t){var a=e.start,n=e.size;var i=[];var s=a;while(t&&n>0&&s>=0){i.push(r.slice(s*P,s*P+P));n-=P;s=Ur(t,s*4)}if(i.length===0)return $r(0);return I(i).slice(0,e.size)}function p(e,r,t,a,n){var i=N;if(e===N){if(r!==0)throw new Error("DIFAT chain shorter than expected")}else if(e!==-1){var s=t[e],f=(a>>>2)-1;if(!s)return;for(var l=0;l<f;++l){if((i=Ur(s,l*4))===N)break;n.push(i)}p(Ur(s,a-4),r-1,t,a,n)}}function m(e,r,t,a,n){var i=[],s=[];if(!n)n=[];var f=a-1,l=0,o=0;for(l=r;l>=0;){n[l]=true;i[i.length]=l;s.push(e[l]);var c=t[Math.floor(l*4/a)];o=l*4&f;if(a<4+o)throw new Error("FAT boundary crossed: "+l+" 4 "+a);if(!e[c])break;l=Ur(e[c],o)}return{nodes:i,data:vr([s])}}function b(e,r,t,a){var n=e.length,i=[];var s=[],f=[],l=[];var o=a-1,c=0,u=0,h=0,d=0;for(c=0;c<n;++c){f=[];h=c+r;if(h>=n)h-=n;if(s[h])continue;l=[];for(u=h;u>=0;){s[u]=true;f[f.length]=u;l.push(e[u]);var v=t[Math.floor(u*4/a)];d=u*4&o;if(a<4+d)throw new Error("FAT boundary crossed: "+u+" 4 "+a);if(!e[v])break;u=Ur(e[v],d)}i[h]={nodes:f,data:vr([l])}}return i}function k(e,r,t,a,n,i,s,f){var l=0,o=a.length?2:0;var c=r[e].data;var u=0,h=0,d;for(;u<c.length;u+=128){var p=c.slice(u,u+128);Kr(p,64);h=p._R(2);d=mr(p,0,h-o);a.push(d);var b={name:d,type:p._R(1),color:p._R(1),L:p._R(4,"i"),R:p._R(4,"i"),C:p._R(4,"i"),clsid:p._R(16),state:p._R(4,"i"),start:0,size:0};var g=p._R(2)+p._R(2)+p._R(2)+p._R(2);if(g!==0)b.ct=E(p,p.l-8);var w=p._R(2)+p._R(2)+p._R(2)+p._R(2);if(w!==0)b.mt=E(p,p.l-8);b.start=p._R(4,"i");b.size=p._R(4,"i");if(b.size<0&&b.start<0){b.size=b.type=0;b.start=N;b.name=""}if(b.type===5){l=b.start;if(n>0&&l!==N)r[l].name="!StreamData"}else if(b.size>=4096){b.storage="fat";if(r[b.start]===undefined)r[b.start]=m(t,b.start,r.fat_addrs,r.ssz);r[b.start].name=b.name;b.content=r[b.start].data.slice(0,b.size)}else{b.storage="minifat";if(b.size<0)b.size=0;else if(l!==N&&b.start!==N&&r[l]){b.content=v(b,r[l].data,(r[f]||{}).data)}}if(b.content)Kr(b.content,0);i[d]=b;s.push(b)}}function E(e,r){return new Date((Mr(e,r+4)/1e7*Math.pow(2,32)+Mr(e,r)/1e7-11644473600)*1e3)}function S(e,r){l();return o(f.readFileSync(e),r)}function T(e,r){switch(r&&r.type||"base64"){case"file":return S(e,r);case"base64":return o(B(g.decode(e)),r);case"binary":return o(B(e),r);}return o(e,r)}function y(e,r){var t=r||{},a=t.root||"Root Entry";if(!e.FullPaths)e.FullPaths=[];if(!e.FileIndex)e.FileIndex=[];if(e.FullPaths.length!==e.FileIndex.length)throw new Error("inconsistent CFB structure");if(e.FullPaths.length===0){e.FullPaths[0]=a+"/";e.FileIndex[0]={name:a,type:5}}if(t.CLSID)e.FileIndex[0].clsid=t.CLSID;x(e)}function x(e){var r="Sh33tJ5";if(z.find(e,"/"+r))return;var t=$r(4);t[0]=55;t[1]=t[3]=50;t[2]=54;e.FileIndex.push({name:r,type:2,content:t,size:4,L:69,R:69,C:69});e.FullPaths.push(e.FullPaths[0]+r);A(e)}function A(e,n){y(e);var i=false,s=false;for(var f=e.FullPaths.length-1;f>=0;--f){var l=e.FileIndex[f];switch(l.type){case 0:if(s)i=true;else{e.FileIndex.pop();e.FullPaths.pop()}break;case 1:;case 2:;case 5:s=true;if(isNaN(l.R*l.L*l.C))i=true;if(l.R>-1&&l.L>-1&&l.R==l.L)i=true;break;default:i=true;break;}}if(!i&&!n)return;var o=new Date(1987,1,19),c=0;var u=[];for(f=0;f<e.FullPaths.length;++f){if(e.FileIndex[f].type===0)continue;u.push([e.FullPaths[f],e.FileIndex[f]])}for(f=0;f<u.length;++f){var h=t(u[f][0]);s=false;for(c=0;c<u.length;++c)if(u[c][0]===h)s=true;if(!s)u.push([h,{name:a(h).replace("/",""),type:1,clsid:U,ct:o,mt:o,content:null}])}u.sort(function(e,t){return r(e[0],t[0])});e.FullPaths=[];e.FileIndex=[];for(f=0;f<u.length;++f){e.FullPaths[f]=u[f][0];e.FileIndex[f]=u[f][1]}for(f=0;f<u.length;++f){var d=e.FileIndex[f];var v=e.FullPaths[f];d.name=a(v).replace("/","");d.L=d.R=d.C=-(d.color=1);d.size=d.content?d.content.length:0;d.start=0;d.clsid=d.clsid||U;if(f===0){d.C=u.length>1?1:-1;d.size=0;d.type=5}else if(v.slice(-1)=="/"){for(c=f+1;c<u.length;++c)if(t(e.FullPaths[c])==v)break;d.C=c>=u.length?-1:c;for(c=f+1;c<u.length;++c)if(t(e.FullPaths[c])==t(v))break;d.R=c>=u.length?-1:c;d.type=1}else{if(t(e.FullPaths[f+1]||"")==t(v))d.R=f+1;d.type=2}}}function F(e,r){var t=r||{};A(e);if(t.fileType=="zip")return xe(e,t);var a=function(e){var r=0,t=0;for(var a=0;a<e.FileIndex.length;++a){var n=e.FileIndex[a];if(!n.content)continue;var i=n.content.length;if(i>0){if(i<4096)r+=i+63>>6;else t+=i+511>>9}}var s=e.FullPaths.length+3>>2;var f=r+7>>3;var l=r+127>>7;var o=f+t+s+l;var c=o+127>>7;var u=c<=109?0:Math.ceil((c-109)/127);while(o+c+u+127>>7>c)u=++c<=109?0:Math.ceil((c-109)/127);var h=[1,u,c,l,s,t,r,0];e.FileIndex[0].size=r<<6;h[7]=(e.FileIndex[0].start=h[0]+h[1]+h[2]+h[3]+h[4]+h[5])+(h[6]+7>>3);return h}(e);var n=$r(a[7]<<9);var i=0,s=0;{for(i=0;i<8;++i)n._W(1,M[i]);for(i=0;i<8;++i)n._W(2,0);n._W(2,62);n._W(2,3);n._W(2,65534);n._W(2,9);n._W(2,6);for(i=0;i<3;++i)n._W(2,0);n._W(4,0);n._W(4,a[2]);n._W(4,a[0]+a[1]+a[2]+a[3]-1);n._W(4,0);n._W(4,1<<12);n._W(4,a[3]?a[0]+a[1]+a[2]-1:N);n._W(4,a[3]);n._W(-4,a[1]?a[0]-1:N);n._W(4,a[1]);for(i=0;i<109;++i)n._W(-4,i<a[2]?a[1]+i:-1)}if(a[1]){for(s=0;s<a[1];++s){for(;i<236+s*127;++i)n._W(-4,i<a[2]?a[1]+i:-1);n._W(-4,s===a[1]-1?N:s+1)}}var f=function(e){for(s+=e;i<s-1;++i)n._W(-4,i+1);if(e){++i;n._W(-4,N)}};s=i=0;for(s+=a[1];i<s;++i)n._W(-4,H.DIFSECT);for(s+=a[2];i<s;++i)n._W(-4,H.FATSECT);f(a[3]);f(a[4]);var l=0,o=0;var c=e.FileIndex[0];for(;l<e.FileIndex.length;++l){c=e.FileIndex[l];if(!c.content)continue;o=c.content.length;if(o<4096)continue;c.start=s;f(o+511>>9)}f(a[6]+7>>3);while(n.l&511)n._W(-4,H.ENDOFCHAIN);s=i=0;for(l=0;l<e.FileIndex.length;++l){c=e.FileIndex[l];if(!c.content)continue;o=c.content.length;if(!o||o>=4096)continue;c.start=s;f(o+63>>6)}while(n.l&511)n._W(-4,H.ENDOFCHAIN);for(i=0;i<a[4]<<2;++i){var u=e.FullPaths[i];if(!u||u.length===0){for(l=0;l<17;++l)n._W(4,0);for(l=0;l<3;++l)n._W(4,-1);for(l=0;l<12;++l)n._W(4,0);continue}c=e.FileIndex[i];if(i===0)c.start=c.size?c.start-1:N;var h=i===0&&t.root||c.name;o=2*(h.length+1);n._W(64,h,"utf16le");n._W(2,o);n._W(1,c.type);n._W(1,c.color);n._W(-4,c.L);n._W(-4,c.R);n._W(-4,c.C);if(!c.clsid)for(l=0;l<4;++l)n._W(4,0);else n._W(16,c.clsid,"hex");n._W(4,c.state||0);n._W(4,0);n._W(4,0);n._W(4,0);n._W(4,0);n._W(4,c.start);n._W(4,c.size);n._W(4,0)}for(i=1;i<e.FileIndex.length;++i){c=e.FileIndex[i];if(c.size>=4096){n.l=c.start+1<<9;for(l=0;l<c.size;++l)n._W(1,c.content[l]);for(;l&511;++l)n._W(1,0)}}for(i=1;i<e.FileIndex.length;++i){c=e.FileIndex[i];if(c.size>0&&c.size<4096){for(l=0;l<c.size;++l)n._W(1,c.content[l]);for(;l&63;++l)n._W(1,0)}}while(n.l<n.length)n._W(1,0);return n}function O(e,r){var t=e.FullPaths.map(function(e){return e.toUpperCase()});var a=t.map(function(e){var r=e.split("/");return r[r.length-(e.slice(-1)=="/"?2:1)]});var n=false;if(r.charCodeAt(0)===47){n=true;r=t[0].slice(0,-1)+r}else n=r.indexOf("/")!==-1;var i=r.toUpperCase();var s=n===true?t.indexOf(i):a.indexOf(i);if(s!==-1)return e.FileIndex[s];var f=!i.match(D);i=i.replace(R,"");if(f)i=i.replace(D,"!");for(s=0;s<t.length;++s){if((f?t[s].replace(D,"!"):t[s]).replace(R,"")==i)return e.FileIndex[s];if((f?a[s].replace(D,"!"):a[s]).replace(R,"")==i)return e.FileIndex[s]}return null}var P=64;var N=-2;var L="d0cf11e0a1b11ae1";var M=[208,207,17,224,161,177,26,225];var U="00000000000000000000000000000000";var H={MAXREGSECT:-6,DIFSECT:-4,FATSECT:-3,ENDOFCHAIN:N,FREESECT:-1,HEADER_SIGNATURE:L,HEADER_MINOR_VERSION:"3e00",MAXREGSID:-6,NOSTREAM:-1,HEADER_CLSID:U,EntryTypes:["unknown","storage","stream","lockbytes","property","root"]};function V(e,r,t){l();var a=F(e,t);f.writeFileSync(r,a)}function X(e){var r=new Array(e.length);for(var t=0;t<e.length;++t)r[t]=String.fromCharCode(e[t]);return r.join("")}function G(e,r){var t=F(e,r);switch(r&&r.type){case"file":l();f.writeFileSync(r.filename,t);return t;case"binary":return X(t);case"base64":return g.encode(X(t));}return t}var j;function K(e){try{var r=e.InflateRaw;var t=new r;t._processChunk(new Uint8Array([3,0]),t._finishFlushFlag);if(t.bytesRead)j=e;else throw new Error("zlib does not expose bytesRead")}catch(a){console.error("cannot use native zlib: "+(a.message||a))}}function Y(e,r){if(!j)return Ce(e,r);var t=j.InflateRaw;var a=new t;var n=a._processChunk(e.slice(e.l),a._finishFlushFlag);e.l+=a.bytesRead;return n}function $(e){return j?j.deflateRawSync(e):he(e)}var Z=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];var Q=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];var J=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];function q(e){var r=(e<<1|e<<11)&139536|(e<<5|e<<15)&558144;return(r>>16|r>>8|r)&255}var ee=typeof Uint8Array!=="undefined";var re=ee?new Uint8Array(1<<8):[];for(var te=0;te<1<<8;++te)re[te]=q(te);function ae(e,r){var t=re[e&255];if(r<=8)return t>>>8-r;t=t<<8|re[e>>8&255];if(r<=16)return t>>>16-r;t=t<<8|re[e>>16&255];return t>>>24-r}function ne(e,r){var t=r&7,a=r>>>3;return(e[a]|(t<=6?0:e[a+1]<<8))>>>t&3}function ie(e,r){var t=r&7,a=r>>>3;return(e[a]|(t<=5?0:e[a+1]<<8))>>>t&7}function se(e,r){var t=r&7,a=r>>>3;return(e[a]|(t<=4?0:e[a+1]<<8))>>>t&15}function fe(e,r){var t=r&7,a=r>>>3;return(e[a]|(t<=3?0:e[a+1]<<8))>>>t&31}function le(e,r){var t=r&7,a=r>>>3;return(e[a]|(t<=1?0:e[a+1]<<8))>>>t&127}function oe(e,r,t){var a=r&7,n=r>>>3,i=(1<<t)-1;var s=e[n]>>>a;if(t<8-a)return s&i;s|=e[n+1]<<8-a;if(t<16-a)return s&i;s|=e[n+2]<<16-a;if(t<24-a)return s&i;s|=e[n+3]<<24-a;return s&i}function ce(e,r){var t=e.length,a=2*t>r?2*t:r+5,n=0;if(t>=r)return e;if(w){var i=C(a);if(e.copy)e.copy(i);else for(;n<e.length;++n)i[n]=e[n];return i}else if(ee){var s=new Uint8Array(a);if(s.set)s.set(e);else for(;n<e.length;++n)s[n]=e[n];return s}e.length=a;return e}function ue(e){var r=new Array(e);for(var t=0;t<e;++t)r[t]=0;return r}var he=function(){var e=function(){return function e(r,t){var a=0;while(a<r.length){var n=Math.min(65535,r.length-a);var i=a+n==r.length;t._W(1,+i);t._W(2,n);t._W(2,~n&65535);while(n-- >0)t[t.l++]=r[a++]}return t.l}}();return function(r){var t=$r(50+Math.floor(r.length*1.1));var a=e(r,t);return t.slice(0,a)}}();function de(e,r,t){var a=1,n=0,i=0,s=0,f=0,l=e.length;var o=ee?new Uint16Array(32):ue(32);for(i=0;i<32;++i)o[i]=0;for(i=l;i<t;++i)e[i]=0;l=e.length;var c=ee?new Uint16Array(l):ue(l);for(i=0;i<l;++i){o[n=e[i]]++;if(a<n)a=n;c[i]=0}o[0]=0;for(i=1;i<=a;++i)o[i+16]=f=f+o[i-1]<<1;for(i=0;i<l;++i){f=e[i];if(f!=0)c[i]=o[f+16]++}var u=0;for(i=0;i<l;++i){u=e[i];if(u!=0){f=ae(c[i],a)>>a-u;for(s=(1<<a+4-u)-1;s>=0;--s)r[f|s<<u]=u&15|i<<4}}return a}var ve=ee?new Uint16Array(512):ue(512);var pe=ee?new Uint16Array(32):ue(32);if(!ee){for(var me=0;me<512;++me)ve[me]=0;for(me=0;me<32;++me)pe[me]=0}(function(){var e=[];var r=0;for(;r<32;r++)e.push(5);de(e,pe,32);var t=[];r=0;for(;r<=143;r++)t.push(8);for(;r<=255;r++)t.push(9);for(;r<=279;r++)t.push(7);for(;r<=287;r++)t.push(8);de(t,ve,288)})();var be=ee?new Uint16Array(32768):ue(32768);var ge=ee?new Uint16Array(32768):ue(32768);var we=ee?new Uint16Array(128):ue(128);var ke=1,Ee=1;function Se(e,r){var t=fe(e,r)+257;r+=5;var a=fe(e,r)+1;r+=5;var n=se(e,r)+4;r+=4;var i=0;var s=ee?new Uint8Array(19):ue(19);var f=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];var l=1;var o=ee?new Uint8Array(8):ue(8);var c=ee?new Uint8Array(8):ue(8);var u=s.length;for(var h=0;h<n;++h){s[Z[h]]=i=ie(e,r);if(l<i)l=i;o[i]++;r+=3}var d=0;o[0]=0;for(h=1;h<=l;++h)c[h]=d=d+o[h-1]<<1;for(h=0;h<u;++h)if((d=s[h])!=0)f[h]=c[d]++;var v=0;for(h=0;h<u;++h){v=s[h];if(v!=0){d=re[f[h]]>>8-v;for(var p=(1<<7-v)-1;p>=0;--p)we[d|p<<v]=v&7|h<<3}}var m=[];l=1;for(;m.length<t+a;){d=we[le(e,r)];r+=d&7;switch(d>>>=3){case 16:i=3+ne(e,r);r+=2;d=m[m.length-1];while(i-- >0)m.push(d);break;case 17:i=3+ie(e,r);r+=3;while(i-- >0)m.push(0);break;case 18:i=11+le(e,r);r+=7;while(i-- >0)m.push(0);break;default:m.push(d);if(l<d)l=d;break;}}var b=m.slice(0,t),g=m.slice(t);for(h=t;h<286;++h)b[h]=0;for(h=a;h<30;++h)g[h]=0;ke=de(b,be,286);Ee=de(g,ge,30);return r}function _e(e,r){if(e[0]==3&&!(e[1]&3)){return[_(r),2]}var t=0;var a=0;var n=C(r?r:1<<18);var i=0;var s=n.length>>>0;var f=0,l=0;while((a&1)==0){a=ie(e,t);t+=3;if(a>>>1==0){if(t&7)t+=8-(t&7);var o=e[t>>>3]|e[(t>>>3)+1]<<8;t+=32;if(!r&&s<i+o){n=ce(n,i+o);s=n.length}if(typeof e.copy==="function"){e.copy(n,i,t>>>3,(t>>>3)+o);i+=o;t+=8*o}else while(o-- >0){n[i++]=e[t>>>3];t+=8}continue}else if(a>>>1==1){f=9;l=5}else{t=Se(e,t);f=ke;l=Ee}if(!r&&s<i+32767){n=ce(n,i+32767);
s=n.length}for(;;){var c=oe(e,t,f);var u=a>>>1==1?ve[c]:be[c];t+=u&15;u>>>=4;if((u>>>8&255)===0)n[i++]=u;else if(u==256)break;else{u-=257;var h=u<8?0:u-4>>2;if(h>5)h=0;var d=i+Q[u];if(h>0){d+=oe(e,t,h);t+=h}c=oe(e,t,l);u=a>>>1==1?pe[c]:ge[c];t+=u&15;u>>>=4;var v=u<4?0:u-2>>1;var p=J[u];if(v>0){p+=oe(e,t,v);t+=v}if(!r&&s<d){n=ce(n,d);s=n.length}while(i<d){n[i]=n[i-p];++i}}}}return[r?n:n.slice(0,i),t+7>>>3]}function Ce(e,r){var t=e.slice(e.l||0);var a=_e(t,r);e.l+=a[1];return a[0]}function Be(e,r){if(e){if(typeof console!=="undefined")console.error(r)}else throw new Error(r)}function Te(e,r){var t=e;Kr(t,0);var a=[],n=[];var i={FileIndex:a,FullPaths:n};y(i,{root:r.root});var f=t.length-4;while((t[f]!=80||t[f+1]!=75||t[f+2]!=5||t[f+3]!=6)&&f>=0)--f;t.l=f+4;t.l+=4;var l=t._R(2);t.l+=6;var o=t._R(4);t.l=o;for(f=0;f<l;++f){t.l+=20;var c=t._R(4);var u=t._R(4);var h=t._R(2);var d=t._R(2);var v=t._R(2);t.l+=8;var p=t._R(4);var m=s(t.slice(t.l+h,t.l+h+d));t.l+=h+d+v;var b=t.l;t.l=p+4;ye(t,c,u,i,m);t.l=b}return i}function ye(e,r,t,a,n){e.l+=2;var f=e._R(2);var l=e._R(2);var o=i(e);if(f&8257)throw new Error("Unsupported ZIP encryption");var c=e._R(4);var u=e._R(4);var h=e._R(4);var d=e._R(2);var v=e._R(2);var p="";for(var m=0;m<d;++m)p+=String.fromCharCode(e[e.l++]);if(v){var b=s(e.slice(e.l,e.l+v));if((b[21589]||{}).mt)o=b[21589].mt;if(((n||{})[21589]||{}).mt)o=n[21589].mt}e.l+=v;var g=e.slice(e.l,e.l+u);switch(l){case 8:g=Y(e,h);break;case 0:break;default:throw new Error("Unsupported ZIP Compression method "+l);}var w=false;if(f&8){c=e._R(4);if(c==134695760){c=e._R(4);w=true}u=e._R(4);h=e._R(4)}if(u!=r)Be(w,"Bad compressed size: "+r+" != "+u);if(h!=t)Be(w,"Bad uncompressed size: "+t+" != "+h);var k=W.buf(g,0);if(c>>0!=k>>0)Be(w,"Bad CRC32 checksum: "+c+" != "+k);Ie(a,p,g,{unsafe:true,mt:o})}function xe(e,r){var t=r||{};var a=[],i=[];var s=$r(1);var f=t.compression?8:0,l=0;var o=false;if(o)l|=8;var c=0,u=0;var h=0,d=0;var v=e.FullPaths[0],p=v,m=e.FileIndex[0];var b=[];var g=0;for(c=1;c<e.FullPaths.length;++c){p=e.FullPaths[c].slice(v.length);m=e.FileIndex[c];if(!m.size||!m.content||p=="Sh33tJ5")continue;var w=h;var k=$r(p.length);for(u=0;u<p.length;++u)k._W(1,p.charCodeAt(u)&127);k=k.slice(0,k.l);b[d]=W.buf(m.content,0);var E=m.content;if(f==8)E=$(E);s=$r(30);s._W(4,67324752);s._W(2,20);s._W(2,l);s._W(2,f);if(m.mt)n(s,m.mt);else s._W(4,0);s._W(-4,l&8?0:b[d]);s._W(4,l&8?0:E.length);s._W(4,l&8?0:m.content.length);s._W(2,k.length);s._W(2,0);h+=s.length;a.push(s);h+=k.length;a.push(k);h+=E.length;a.push(E);if(l&8){s=$r(12);s._W(-4,b[d]);s._W(4,E.length);s._W(4,m.content.length);h+=s.l;a.push(s)}s=$r(46);s._W(4,33639248);s._W(2,0);s._W(2,20);s._W(2,l);s._W(2,f);s._W(4,0);s._W(-4,b[d]);s._W(4,E.length);s._W(4,m.content.length);s._W(2,k.length);s._W(2,0);s._W(2,0);s._W(2,0);s._W(2,0);s._W(4,0);s._W(4,w);g+=s.l;i.push(s);g+=k.length;i.push(k);++d}s=$r(22);s._W(4,101010256);s._W(2,0);s._W(2,0);s._W(2,d);s._W(2,d);s._W(4,g);s._W(4,h);s._W(2,0);return I([I(a),I(i),s])}function Ae(e){var r={};y(r,e);return r}function Ie(e,r,t,n){var i=n&&n.unsafe;if(!i)y(e);var s=!i&&z.find(e,r);if(!s){var f=e.FullPaths[0];if(r.slice(0,f.length)==f)f=r;else{if(f.slice(-1)!="/")f+="/";f=(f+r).replace("//","/")}s={name:a(r),type:2};e.FileIndex.push(s);e.FullPaths.push(f);if(!i)z.utils.cfb_gc(e)}s.content=t;s.size=t?t.length:0;if(n){if(n.CLSID)s.clsid=n.CLSID;if(n.mt)s.mt=n.mt;if(n.ct)s.ct=n.ct}return s}function Re(e,r){y(e);var t=z.find(e,r);if(t)for(var a=0;a<e.FileIndex.length;++a)if(e.FileIndex[a]==t){e.FileIndex.splice(a,1);e.FullPaths.splice(a,1);return true}return false}function De(e,r,t){y(e);var n=z.find(e,r);if(n)for(var i=0;i<e.FileIndex.length;++i)if(e.FileIndex[i]==n){e.FileIndex[i].name=a(t);e.FullPaths[i]=t;return true}return false}function Fe(e){A(e,true)}e.find=O;e.read=T;e.parse=o;e.write=G;e.writeFile=V;e.utils={cfb_new:Ae,cfb_add:Ie,cfb_del:Re,cfb_mov:De,cfb_gc:Fe,ReadShift:Wr,CheckField:jr,prep_blob:Kr,bconcat:I,use_zlib:K,_deflateRaw:he,_inflateRaw:Ce,consts:H};return e}();if(typeof require!=="undefined"&&typeof module!=="undefined"&&typeof H==="undefined"){module.exports=z}var V;if(typeof require!=="undefined")try{V=require("fs")}catch(S){}function X(e){if(typeof e==="string")return T(e);if(Array.isArray(e))return x(e);return e}function G(e,r,t){if(typeof V!=="undefined"&&V.writeFileSync)return t?V.writeFileSync(e,r,t):V.writeFileSync(e,r);var a=t=="utf8"?Ye(r):r;if(typeof IE_SaveFile!=="undefined")return IE_SaveFile(a,e);if(typeof Blob!=="undefined"){var n=new Blob([X(a)],{type:"application/octet-stream"});if(typeof navigator!=="undefined"&&navigator.msSaveBlob)return navigator.msSaveBlob(n,e);if(typeof saveAs!=="undefined")return saveAs(n,e);if(typeof URL!=="undefined"&&typeof document!=="undefined"&&document.createElement&&URL.createObjectURL){var i=URL.createObjectURL(n);if(typeof chrome==="object"&&typeof(chrome.downloads||{}).download=="function"){if(URL.revokeObjectURL&&typeof setTimeout!=="undefined")setTimeout(function(){URL.revokeObjectURL(i)},6e4);return chrome.downloads.download({url:i,filename:e,saveAs:true})}var s=document.createElement("a");if(s.download!=null){s.download=e;s.href=i;document.body.appendChild(s);s.click();document.body.removeChild(s);if(URL.revokeObjectURL&&typeof setTimeout!=="undefined")setTimeout(function(){URL.revokeObjectURL(i)},6e4);return i}}}if(typeof $!=="undefined"&&typeof File!=="undefined"&&typeof Folder!=="undefined")try{var f=File(e);f.open("w");f.encoding="binary";if(Array.isArray(r))r=y(r);f.write(r);f.close();return r}catch(l){if(!l.message||!l.message.match(/onstruct/))throw l}throw new Error("cannot save file "+e)}function j(e){if(typeof V!=="undefined")return V.readFileSync(e);if(typeof $!=="undefined"&&typeof File!=="undefined"&&typeof Folder!=="undefined")try{var r=File(e);r.open("r");r.encoding="binary";var t=r.read();r.close();return t}catch(a){if(!a.message||!a.message.match(/onstruct/))throw a}throw new Error("Cannot access file "+e)}function K(e){var r=Object.keys(e),t=[];for(var a=0;a<r.length;++a)if(e.hasOwnProperty(r[a]))t.push(r[a]);return t}function Y(e,r){var t=[],a=K(e);for(var n=0;n!==a.length;++n)if(t[e[a[n]][r]]==null)t[e[a[n]][r]]=a[n];return t}function Z(e){var r=[],t=K(e);for(var a=0;a!==t.length;++a)r[e[t[a]]]=t[a];return r}function Q(e){var r=[],t=K(e);for(var a=0;a!==t.length;++a)r[e[t[a]]]=parseInt(t[a],10);return r}function J(e){var r=[],t=K(e);for(var a=0;a!==t.length;++a){if(r[e[t[a]]]==null)r[e[t[a]]]=[];r[e[t[a]]].push(t[a])}return r}var q=new Date(1899,11,30,0,0,0);var ee=q.getTime()+((new Date).getTimezoneOffset()-q.getTimezoneOffset())*6e4;function re(e,r){var t=e.getTime();if(r)t-=1462*24*60*60*1e3;return(t-ee)/(24*60*60*1e3)}function te(e){var r=new Date;r.setTime(e*24*60*60*1e3+ee);return r}function ae(e){var r=0,t=0,a=false;var n=e.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);if(!n)throw new Error("|"+e+"| is not an ISO8601 Duration");for(var i=1;i!=n.length;++i){if(!n[i])continue;t=1;if(i>3)a=true;switch(n[i].slice(n[i].length-1)){case"Y":throw new Error("Unsupported ISO Duration Field: "+n[i].slice(n[i].length-1));case"D":t*=24;case"H":t*=60;case"M":if(!a)throw new Error("Unsupported ISO Duration Field: M");else t*=60;case"S":break;}r+=t*parseInt(n[i],10)}return r}var ne=new Date("2017-02-19T19:06:09.000Z");if(isNaN(ne.getFullYear()))ne=new Date("2/19/17");var ie=ne.getFullYear()==2017;function se(e,r){var t=new Date(e);if(ie){if(r>0)t.setTime(t.getTime()+t.getTimezoneOffset()*60*1e3);else if(r<0)t.setTime(t.getTime()-t.getTimezoneOffset()*60*1e3);return t}if(e instanceof Date)return e;if(ne.getFullYear()==1917&&!isNaN(t.getFullYear())){var a=t.getFullYear();if(e.indexOf(""+a)>-1)return t;t.setFullYear(t.getFullYear()+100);return t}var n=e.match(/\d+/g)||["2017","2","19","0","0","0"];var i=new Date(+n[0],+n[1]-1,+n[2],+n[3]||0,+n[4]||0,+n[5]||0);if(e.indexOf("Z")>-1)i=new Date(i.getTime()-i.getTimezoneOffset()*60*1e3);return i}function fe(e){var r="";for(var t=0;t!=e.length;++t)r+=String.fromCharCode(e[t]);return r}function le(e){if(typeof JSON!="undefined"&&!Array.isArray(e))return JSON.parse(JSON.stringify(e));if(typeof e!="object"||e==null)return e;if(e instanceof Date)return new Date(e.getTime());var r={};for(var t in e)if(e.hasOwnProperty(t))r[t]=le(e[t]);return r}function oe(e,r){var t="";while(t.length<r)t+=e;return t}function ce(e){var r=Number(e);if(!isNaN(r))return r;var t=1;var a=e.replace(/([\d]),([\d])/g,"$1$2").replace(/[$]/g,"").replace(/[%]/g,function(){t*=100;return""});if(!isNaN(r=Number(a)))return r/t;a=a.replace(/[(](.*)[)]/,function(e,r){t=-t;return r});if(!isNaN(r=Number(a)))return r/t;return r}function ue(e){var r=new Date(e),t=new Date(NaN);var a=r.getYear(),n=r.getMonth(),i=r.getDate();if(isNaN(i))return t;if(a<0||a>8099)return t;if((n>0||i>1)&&a!=101)return r;if(e.toLowerCase().match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/))return r;if(e.match(/[^-0-9:,\/\\]/))return t;return r}var he="abacaba".split(/(:?b)/i).length==5;function de(e,r,t){if(he||typeof r=="string")return e.split(r);var a=e.split(r),n=[a[0]];for(var i=1;i<a.length;++i){n.push(t);n.push(a[i])}return n}function ve(e){if(!e)return null;if(e.data)return d(e.data);if(e.asNodeBuffer&&w)return d(e.asNodeBuffer().toString("binary"));if(e.asBinary)return d(e.asBinary());if(e._data&&e._data.getContent)return d(fe(Array.prototype.slice.call(e._data.getContent(),0)));if(e.content&&e.type)return d(fe(e.content));return null}function pe(e){if(!e)return null;if(e.data)return c(e.data);if(e.asNodeBuffer&&w)return e.asNodeBuffer();if(e._data&&e._data.getContent){var r=e._data.getContent();if(typeof r=="string")return c(r);return Array.prototype.slice.call(r)}if(e.content&&e.type)return e.content;return null}function me(e){return e&&e.name.slice(-4)===".bin"?pe(e):ve(e)}function be(e,r){var t=e.FullPaths||K(e.files);var a=r.toLowerCase(),n=a.replace(/\//g,"\\");for(var i=0;i<t.length;++i){var s=t[i].toLowerCase();if(a==s||n==s)return e.files[t[i]]}return null}function ge(e,r){var t=be(e,r);if(t==null)throw new Error("Cannot find file "+r+" in zip");return t}function we(e,r,t){if(!t)return me(ge(e,r));if(!r)return null;try{return we(e,r)}catch(a){return null}}function ke(e,r,t){if(!t)return ve(ge(e,r));if(!r)return null;try{return ke(e,r)}catch(a){return null}}function Ee(e){var r=e.FullPaths||K(e.files),t=[];for(var a=0;a<r.length;++a)if(r[a].slice(-1)!="/")t.push(r[a]);return t.sort()}function Se(e,r,t){if(e.FullPaths)z.utils.cfb_add(e,r,t);else e.file(r,t)}var _e;if(typeof JSZipSync!=="undefined")_e=JSZipSync;if(typeof exports!=="undefined"){if(typeof module!=="undefined"&&module.exports){if(typeof _e==="undefined")_e=undefined}}function Ce(){if(!_e)return z.utils.cfb_new();return new _e}function Be(e,r){var t;if(_e)switch(r.type){case"base64":t=new _e(e,{base64:true});break;case"binary":;case"array":t=new _e(e,{base64:false});break;case"buffer":t=new _e(e);break;default:throw new Error("Unrecognized type "+r.type);}else switch(r.type){case"base64":t=z.read(e,{type:"base64"});break;case"binary":t=z.read(e,{type:"binary"});break;case"buffer":;case"array":t=z.read(e,{type:"buffer"});break;default:throw new Error("Unrecognized type "+r.type);}return t}function Te(e,r){if(e.charAt(0)=="/")return e.slice(1);var t=r.split("/");if(r.slice(-1)!="/")t.pop();var a=e.split("/");while(a.length!==0){var n=a.shift();if(n==="..")t.pop();else if(n!==".")t.push(n)}return t.join("/")}var ye='<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';var xe=/([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;var Ae=/<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s?[\/\?]?>/g;if(!ye.match(Ae))Ae=/<[^>]*>/g;var Ie=/<\w*:/,Re=/<(\/?)\w+:/;function De(e,r,t){var a={};var n=0,i=0;for(;n!==e.length;++n)if((i=e.charCodeAt(n))===32||i===10||i===13)break;if(!r)a[0]=e.slice(0,n);if(n===e.length)return a;var s=e.match(xe),f=0,l="",o=0,c="",u="",h=1;if(s)for(o=0;o!=s.length;++o){u=s[o];for(i=0;i!=u.length;++i)if(u.charCodeAt(i)===61)break;c=u.slice(0,i).trim();while(u.charCodeAt(i+1)==32)++i;h=(n=u.charCodeAt(i+1))==34||n==39?1:0;l=u.slice(i+1+h,u.length-h);for(f=0;f!=c.length;++f)if(c.charCodeAt(f)===58)break;if(f===c.length){if(c.indexOf("_")>0)c=c.slice(0,c.indexOf("_"));a[c]=l;if(!t)a[c.toLowerCase()]=l}else{var d=(f===5&&c.slice(0,5)==="xmlns"?"xmlns":"")+c.slice(f+1);if(a[d]&&c.slice(f-3,f)=="ext")continue;a[d]=l;if(!t)a[d.toLowerCase()]=l}}return a}function Fe(e){return e.replace(Re,"<$1")}var Oe={"&quot;":'"',"&apos;":"'","&gt;":">","&lt;":"<","&amp;":"&"};var Pe=Z(Oe);var Ne=function(){var e=/&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/g,r=/_x([\da-fA-F]{4})_/g;return function t(a){var n=a+"",i=n.indexOf("<![CDATA[");if(i==-1)return n.replace(e,function(e,r){return Oe[e]||String.fromCharCode(parseInt(r,e.indexOf("x")>-1?16:10))||e}).replace(r,function(e,r){return String.fromCharCode(parseInt(r,16))});var s=n.indexOf("]]>");return t(n.slice(0,i))+n.slice(i+9,s)+t(n.slice(s+3))}}();var Le=/[&<>'"]/g,Me=/[\u0000-\u0008\u000b-\u001f]/g;function Ue(e){var r=e+"";return r.replace(Le,function(e){return Pe[e]}).replace(Me,function(e){return"_x"+("000"+e.charCodeAt(0).toString(16)).slice(-4)+"_"})}function He(e){return Ue(e).replace(/ /g,"_x0020_")}var We=/[\u0000-\u001f]/g;function ze(e){var r=e+"";return r.replace(Le,function(e){return Pe[e]}).replace(/\n/g,"<br/>").replace(We,function(e){return"&#x"+("000"+e.charCodeAt(0).toString(16)).slice(-4)+";"})}function Ve(e){var r=e+"";return r.replace(Le,function(e){return Pe[e]}).replace(We,function(e){return"&#x"+e.charCodeAt(0).toString(16).toUpperCase()+";"})}var Xe=function(){var e=/&#(\d+);/g;function r(e,r){return String.fromCharCode(parseInt(r,10))}return function t(a){return a.replace(e,r)}}();var Ge=function(){return function e(r){return r.replace(/(\r\n|[\r\n])/g,"&#10;")}}();function je(e){switch(e){case 1:;case true:;case"1":;case"true":;case"TRUE":return true;default:return false;}}var Ke=function ob(e){var r="",t=0,a=0,n=0,i=0,s=0,f=0;while(t<e.length){a=e.charCodeAt(t++);if(a<128){r+=String.fromCharCode(a);continue}n=e.charCodeAt(t++);if(a>191&&a<224){s=(a&31)<<6;s|=n&63;r+=String.fromCharCode(s);continue}i=e.charCodeAt(t++);if(a<240){r+=String.fromCharCode((a&15)<<12|(n&63)<<6|i&63);continue}s=e.charCodeAt(t++);f=((a&7)<<18|(n&63)<<12|(i&63)<<6|s&63)-65536;r+=String.fromCharCode(55296+(f>>>10&1023));r+=String.fromCharCode(56320+(f&1023))}return r};var Ye=function(e){var r=[],t=0,a=0,n=0;while(t<e.length){a=e.charCodeAt(t++);switch(true){case a<128:r.push(String.fromCharCode(a));break;case a<2048:r.push(String.fromCharCode(192+(a>>6)));r.push(String.fromCharCode(128+(a&63)));break;case a>=55296&&a<57344:a-=55296;n=e.charCodeAt(t++)-56320+(a<<10);r.push(String.fromCharCode(240+(n>>18&7)));r.push(String.fromCharCode(144+(n>>12&63)));r.push(String.fromCharCode(128+(n>>6&63)));r.push(String.fromCharCode(128+(n&63)));break;default:r.push(String.fromCharCode(224+(a>>12)));r.push(String.fromCharCode(128+(a>>6&63)));r.push(String.fromCharCode(128+(a&63)));}}return r.join("")};if(w){var $e=function cb(e){var r=Buffer.alloc(2*e.length),t,a,n=1,i=0,s=0,f;for(a=0;a<e.length;a+=n){n=1;if((f=e.charCodeAt(a))<128)t=f;else if(f<224){t=(f&31)*64+(e.charCodeAt(a+1)&63);n=2}else if(f<240){t=(f&15)*4096+(e.charCodeAt(a+1)&63)*64+(e.charCodeAt(a+2)&63);n=3}else{n=4;t=(f&7)*262144+(e.charCodeAt(a+1)&63)*4096+(e.charCodeAt(a+2)&63)*64+(e.charCodeAt(a+3)&63);t-=65536;s=55296+(t>>>10&1023);t=56320+(t&1023)}if(s!==0){r[i++]=s&255;r[i++]=s>>>8;s=0}r[i++]=t%256;r[i++]=t>>>8}return r.slice(0,i).toString("ucs2")};var Ze="foo bar baz";if(Ke(Ze)==$e(Ze))Ke=$e;var Qe=function ub(e){return k(e,"binary").toString("utf8")};if(Ke(Ze)==Qe(Ze))Ke=Qe;Ye=function(e){return k(e,"utf8").toString("binary")}}var Je=function(){var e={};return function r(t,a){var n=t+"|"+(a||"");if(e[n])return e[n];return e[n]=new RegExp("<(?:\\w+:)?"+t+'(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?'+t+">",a||"")}}();var qe=function(){var e=[["nbsp"," "],["middot",""],["quot",'"'],["apos","'"],["gt",">"],["lt","<"],["amp","&"]].map(function(e){return[new RegExp("&"+e[0]+";","g"),e[1]]});return function r(t){var a=t.replace(/^[\t\n\r ]+/,"").replace(/[\t\n\r ]+$/,"").replace(/>\s+/g,">").replace(/\s+</g,"<").replace(/[\t\n\r ]+/g," ").replace(/<\s*[bB][rR]\s*\/?>/g,"\n").replace(/<[^>]*>/g,"");for(var n=0;n<e.length;++n)a=a.replace(e[n][0],e[n][1]);return a}}();var er=function(){var e={};return function r(t){if(e[t]!==undefined)return e[t];return e[t]=new RegExp("<(?:vt:)?"+t+">([\\s\\S]*?)</(?:vt:)?"+t+">","g")}}();var rr=/<\/?(?:vt:)?variant>/g,tr=/<(?:vt:)([^>]*)>([\s\S]*)</;function ar(e,r){var t=De(e);var a=e.match(er(t.baseType))||[];var n=[];if(a.length!=t.size){if(r.WTF)throw new Error("unexpected vector length "+a.length+" != "+t.size);return n}a.forEach(function(e){var r=e.replace(rr,"").match(tr);if(r)n.push({v:Ke(r[2]),t:r[1]})});return n}var nr=/(^\s|\s$|\n)/;function ir(e,r){return"<"+e+(r.match(nr)?' xml:space="preserve"':"")+">"+r+"</"+e+">"}function sr(e){return K(e).map(function(r){return" "+r+'="'+e[r]+'"'}).join("")}function fr(e,r,t){return"<"+e+(t!=null?sr(t):"")+(r!=null?(r.match(nr)?' xml:space="preserve"':"")+">"+r+"</"+e:"/")+">"}function lr(e,r){try{return e.toISOString().replace(/\.\d*/,"")}catch(t){if(r)throw t}return""}function or(e){switch(typeof e){case"string":return fr("vt:lpwstr",Ue(e));case"number":return fr((e|0)==e?"vt:i4":"vt:r8",Ue(String(e)));case"boolean":return fr("vt:bool",e?"true":"false");}if(e instanceof Date)return fr("vt:filetime",lr(e));throw new Error("Unable to serialize "+e)}var cr={dc:"http://purl.org/dc/elements/1.1/",dcterms:"http://purl.org/dc/terms/",dcmitype:"http://purl.org/dc/dcmitype/",mx:"http://schemas.microsoft.com/office/mac/excel/2008/main",r:"http://schemas.openxmlformats.org/officeDocument/2006/relationships",sjs:"http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",vt:"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",xsi:"http://www.w3.org/2001/XMLSchema-instance",xsd:"http://www.w3.org/2001/XMLSchema"};cr.main=["http://schemas.openxmlformats.org/spreadsheetml/2006/main","http://purl.oclc.org/ooxml/spreadsheetml/main","http://schemas.microsoft.com/office/excel/2006/main","http://schemas.microsoft.com/office/excel/2006/2"];var ur={o:"urn:schemas-microsoft-com:office:office",x:"urn:schemas-microsoft-com:office:excel",ss:"urn:schemas-microsoft-com:office:spreadsheet",dt:"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",mv:"http://macVmlSchemaUri",v:"urn:schemas-microsoft-com:vml",html:"http://www.w3.org/TR/REC-html40"};function hr(e,r){var t=1-2*(e[r+7]>>>7);var a=((e[r+7]&127)<<4)+(e[r+6]>>>4&15);var n=e[r+6]&15;for(var i=5;i>=0;--i)n=n*256+e[r+i];if(a==2047)return n==0?t*Infinity:NaN;if(a==0)a=-1022;else{a-=1023;n+=Math.pow(2,52)}return t*Math.pow(2,a-52)*n}function dr(e,r,t){var a=(r<0||1/r==-Infinity?1:0)<<7,n=0,i=0;var s=a?-r:r;if(!isFinite(s)){n=2047;i=isNaN(r)?26985:0}else if(s==0)n=i=0;else{n=Math.floor(Math.log(s)/Math.LN2);i=s*Math.pow(2,52-n);if(n<=-1023&&(!isFinite(i)||i<Math.pow(2,52))){n=-1022}else{i-=Math.pow(2,52);n+=1023}}for(var f=0;f<=5;++f,i/=256)e[t+f]=i&255;e[t+6]=(n&15)<<4|i&15;e[t+7]=n>>4|a}var vr=function(e){var r=[],t=10240;for(var a=0;a<e[0].length;++a)if(e[0][a])for(var n=0,i=e[0][a].length;n<i;n+=t)r.push.apply(r,e[0][a].slice(n,n+t));return r};var pr=vr;var mr=function(e,r,t){var a=[];for(var n=r;n<t;n+=2)a.push(String.fromCharCode(Nr(e,n)));return a.join("").replace(R,"")};var br=mr;var gr=function(e,r,t){var a=[];for(var n=r;n<r+t;++n)a.push(("0"+e[n].toString(16)).slice(-2));return a.join("")};var wr=gr;var kr=function(e,r,t){var a=[];for(var n=r;n<t;n++)a.push(String.fromCharCode(Pr(e,n)));return a.join("")};var Er=kr;var Sr=function(e,r){var t=Mr(e,r);return t>0?kr(e,r+4,r+4+t-1):""};var _r=Sr;var Cr=function(e,r){var t=Mr(e,r);return t>0?kr(e,r+4,r+4+t-1):""};var Br=Cr;var Tr=function(e,r){var t=2*Mr(e,r);return t>0?kr(e,r+4,r+4+t-1):""};var yr=Tr;var xr,Ar;xr=Ar=function hb(e,r){var t=Mr(e,r);return t>0?mr(e,r+4,r+4+t):""};var Ir=function(e,r){var t=Mr(e,r);return t>0?kr(e,r+4,r+4+t):""};var Rr=Ir;var Dr,Fr;Dr=Fr=function(e,r){return hr(e,r)};var Or=function db(e){return Array.isArray(e)};if(w){mr=function(e,r,t){if(!Buffer.isBuffer(e))return br(e,r,t);return e.toString("utf16le",r,t).replace(R,"")};gr=function(e,r,t){return Buffer.isBuffer(e)?e.toString("hex",r,r+t):wr(e,r,t)};Sr=function vb(e,r){if(!Buffer.isBuffer(e))return _r(e,r);var t=e.readUInt32LE(r);return t>0?e.toString("utf8",r+4,r+4+t-1):""};Cr=function pb(e,r){if(!Buffer.isBuffer(e))return Br(e,r);var t=e.readUInt32LE(r);return t>0?e.toString("utf8",r+4,r+4+t-1):""};Tr=function mb(e,r){if(!Buffer.isBuffer(e))return yr(e,r);var t=2*e.readUInt32LE(r);return e.toString("utf16le",r+4,r+4+t-1)};xr=function bb(e,r){if(!Buffer.isBuffer(e))return Ar(e,r);var t=e.readUInt32LE(r);return e.toString("utf16le",r+4,r+4+t)};Ir=function gb(e,r){if(!Buffer.isBuffer(e))return Rr(e,r);var t=e.readUInt32LE(r);return e.toString("utf8",r+4,r+4+t)};kr=function wb(e,r,t){return Buffer.isBuffer(e)?e.toString("utf8",r,t):Er(e,r,t)};vr=function(e){return e[0].length>0&&Buffer.isBuffer(e[0][0])?Buffer.concat(e[0]):pr(e)};I=function(e){return Buffer.isBuffer(e[0])?Buffer.concat(e):[].concat.apply([],e)};Dr=function kb(e,r){if(Buffer.isBuffer(e))return e.readDoubleLE(r);return Fr(e,r)};Or=function Eb(e){return Buffer.isBuffer(e)||Array.isArray(e)}}if(typeof cptable!=="undefined"){mr=function(e,r,t){return cptable.utils.decode(1200,e.slice(r,t)).replace(R,"")};kr=function(e,r,t){return cptable.utils.decode(65001,e.slice(r,t))};Sr=function(e,r){var a=Mr(e,r);return a>0?cptable.utils.decode(t,e.slice(r+4,r+4+a-1)):""};Cr=function(e,t){var a=Mr(e,t);return a>0?cptable.utils.decode(r,e.slice(t+4,t+4+a-1)):""};Tr=function(e,r){var t=2*Mr(e,r);return t>0?cptable.utils.decode(1200,e.slice(r+4,r+4+t-1)):""};xr=function(e,r){var t=Mr(e,r);return t>0?cptable.utils.decode(1200,e.slice(r+4,r+4+t)):""};Ir=function(e,r){var t=Mr(e,r);return t>0?cptable.utils.decode(65001,e.slice(r+4,r+4+t)):""}}var Pr=function(e,r){return e[r]};var Nr=function(e,r){return e[r+1]*(1<<8)+e[r]};var Lr=function(e,r){var t=e[r+1]*(1<<8)+e[r];return t<32768?t:(65535-t+1)*-1};var Mr=function(e,r){return e[r+3]*(1<<24)+(e[r+2]<<16)+(e[r+1]<<8)+e[r]};var Ur=function(e,r){return e[r+3]<<24|e[r+2]<<16|e[r+1]<<8|e[r]};var Hr=function(e,r){return e[r]<<24|e[r+1]<<16|e[r+2]<<8|e[r+3]};function Wr(e,t){var a="",n,i,s=[],f,l,o,c;switch(t){case"dbcs":c=this.l;if(w&&Buffer.isBuffer(this))a=this.slice(this.l,this.l+2*e).toString("utf16le");else for(o=0;o<e;++o){a+=String.fromCharCode(Nr(this,c));c+=2}e*=2;break;case"utf8":a=kr(this,this.l,this.l+e);break;case"utf16le":e*=2;a=mr(this,this.l,this.l+e);break;case"wstr":if(typeof cptable!=="undefined")a=cptable.utils.decode(r,this.slice(this.l,this.l+2*e));else return Wr.call(this,e,"dbcs");e=2*e;break;case"lpstr-ansi":a=Sr(this,this.l);e=4+Mr(this,this.l);break;case"lpstr-cp":a=Cr(this,this.l);e=4+Mr(this,this.l);break;case"lpwstr":a=Tr(this,this.l);e=4+2*Mr(this,this.l);break;case"lpp4":e=4+Mr(this,this.l);a=xr(this,this.l);if(e&2)e+=2;break;case"8lpp4":e=4+Mr(this,this.l);a=Ir(this,this.l);if(e&3)e+=4-(e&3);break;case"cstr":e=0;a="";while((f=Pr(this,this.l+e++))!==0)s.push(v(f));a=s.join("");break;case"_wstr":e=0;a="";while((f=Nr(this,this.l+e))!==0){s.push(v(f));e+=2}e+=2;a=s.join("");break;case"dbcs-cont":a="";c=this.l;for(o=0;o<e;++o){if(this.lens&&this.lens.indexOf(c)!==-1){f=Pr(this,c);this.l=c+1;l=Wr.call(this,e-o,f?"dbcs-cont":"sbcs-cont");return s.join("")+l}s.push(v(Nr(this,c)));c+=2}a=s.join("");e*=2;break;case"cpstr":if(typeof cptable!=="undefined"){a=cptable.utils.decode(r,this.slice(this.l,this.l+e));break};case"sbcs-cont":a="";c=this.l;for(o=0;o!=e;++o){if(this.lens&&this.lens.indexOf(c)!==-1){f=Pr(this,c);this.l=c+1;l=Wr.call(this,e-o,f?"dbcs-cont":"sbcs-cont");return s.join("")+l}s.push(v(Pr(this,c)));c+=1}a=s.join("");break;default:switch(e){case 1:n=Pr(this,this.l);this.l++;return n;case 2:n=(t==="i"?Lr:Nr)(this,this.l);this.l+=2;return n;case 4:;case-4:if(t==="i"||(this[this.l+3]&128)===0){n=(e>0?Ur:Hr)(this,this.l);this.l+=4;return n}else{i=Mr(this,this.l);this.l+=4}return i;case 8:;case-8:if(t==="f"){if(e==8)i=Dr(this,this.l);else i=Dr([this[this.l+7],this[this.l+6],this[this.l+5],this[this.l+4],this[this.l+3],this[this.l+2],this[this.l+1],this[this.l+0]],0);this.l+=8;return i}else e=8;case 16:a=gr(this,this.l,e);break;};}this.l+=e;return a}var zr=function(e,r,t){e[t]=r&255;e[t+1]=r>>>8&255;e[t+2]=r>>>16&255;e[t+3]=r>>>24&255};var Vr=function(e,r,t){e[t]=r&255;e[t+1]=r>>8&255;e[t+2]=r>>16&255;e[t+3]=r>>24&255};var Xr=function(e,r,t){e[t]=r&255;e[t+1]=r>>>8&255};function Gr(e,r,a){var n=0,i=0;if(a==="dbcs"){for(i=0;i!=r.length;++i)Xr(this,r.charCodeAt(i),this.l+2*i);n=2*r.length}else if(a==="sbcs"){if(typeof cptable!=="undefined"&&t==874){for(i=0;i!=r.length;++i){var s=cptable.utils.encode(t,r.charAt(i));this[this.l+i]=s[0]}}else{r=r.replace(/[^\x00-\x7F]/g,"_");for(i=0;i!=r.length;++i)this[this.l+i]=r.charCodeAt(i)&255}n=r.length}else if(a==="hex"){for(;i<e;++i){this[this.l++]=parseInt(r.slice(2*i,2*i+2),16)||0}return this}else if(a==="utf16le"){var f=Math.min(this.l+e,this.length);for(i=0;i<Math.min(r.length,e);++i){var l=r.charCodeAt(i);this[this.l++]=l&255;this[this.l++]=l>>8}while(this.l<f)this[this.l++]=0;return this}else switch(e){case 1:n=1;this[this.l]=r&255;break;case 2:n=2;this[this.l]=r&255;r>>>=8;this[this.l+1]=r&255;break;case 3:n=3;this[this.l]=r&255;r>>>=8;this[this.l+1]=r&255;r>>>=8;this[this.l+2]=r&255;break;case 4:n=4;zr(this,r,this.l);break;case 8:n=8;if(a==="f"){dr(this,r,this.l);break};case 16:break;case-4:n=4;Vr(this,r,this.l);break;}this.l+=n;return this}function jr(e,r){var t=gr(this,this.l,e.length>>1);if(t!==e)throw new Error(r+"Expected "+e+" saw "+t);this.l+=e.length>>1}function Kr(e,r){e.l=r;e._R=Wr;e.chk=jr;e._W=Gr}function Yr(e,r){e.l+=r}function $r(e){var r=_(e);Kr(r,0);return r}function Zr(e,r,t){if(!e)return;var a,n,i;Kr(e,e.l||0);var s=e.length,f=0,l=0;while(e.l<s){f=e._R(1);if(f&128)f=(f&127)+((e._R(1)&127)<<7);var o=Tp[f]||Tp[65535];a=e._R(1);i=a&127;for(n=1;n<4&&a&128;++n)i+=((a=e._R(1))&127)<<7*n;l=e.l+i;var c=(o.f||Yr)(e,i,t);e.l=l;if(r(c,o.n,f))return}}function Qr(){var e=[],r=w?256:2048;var t=function l(e){var r=$r(e);Kr(r,0);return r};var a=t(r);var n=function o(){if(!a)return;if(a.length>a.l){a=a.slice(0,a.l);a.l=a.length}if(a.length>0)e.push(a);a=null};var i=function c(e){if(a&&e<a.length-a.l)return a;n();return a=t(Math.max(e+1,r))};var s=function u(){n();return vr([e])};var f=function h(e){n();a=e;if(a.l==null)a.l=a.length;i(r)};return{next:i,push:f,end:s,_bufs:e}}function Jr(e,r,t,a){var n=+yp[r],i;if(isNaN(n))return;if(!a)a=Tp[n].p||(t||[]).length||0;i=1+(n>=128?1:0)+1;if(a>=128)++i;if(a>=16384)++i;if(a>=2097152)++i;var s=e.next(i);if(n<=127)s._W(1,n);else{s._W(1,(n&127)+128);s._W(1,n>>7)}for(var f=0;f!=4;++f){if(a>=128){s._W(1,(a&127)+128);a>>=7}else{s._W(1,a);break}}if(a>0&&Or(t))e.push(t)}function qr(e,r,t){var a=le(e);if(r.s){if(a.cRel)a.c+=r.s.c;if(a.rRel)a.r+=r.s.r}else{if(a.cRel)a.c+=r.c;if(a.rRel)a.r+=r.r}if(!t||t.biff<12){while(a.c>=256)a.c-=256;while(a.r>=65536)a.r-=65536}return a}function et(e,r,t){var a=le(e);a.s=qr(a.s,r.s,t);a.e=qr(a.e,r.s,t);return a}function rt(e,r){if(e.cRel&&e.c<0){e=le(e);while(e.c<0)e.c+=r>8?16384:256}if(e.rRel&&e.r<0){e=le(e);while(e.r<0)e.r+=r>8?1048576:r>5?65536:16384}var t=pt(e);if(!e.cRel&&e.cRel!=null)t=ut(t);if(!e.rRel&&e.rRel!=null)t=ft(t);return t}function tt(e,r){if(e.s.r==0&&!e.s.rRel){if(e.e.r==(r.biff>=12?1048575:r.biff>=8?65536:16384)&&!e.e.rRel){return(e.s.cRel?"":"$")+ct(e.s.c)+":"+(e.e.cRel?"":"$")+ct(e.e.c)}}if(e.s.c==0&&!e.s.cRel){if(e.e.c==(r.biff>=12?65535:255)&&!e.e.cRel){return(e.s.rRel?"":"$")+st(e.s.r)+":"+(e.e.rRel?"":"$")+st(e.e.r)}}return rt(e.s,r.biff)+":"+rt(e.e,r.biff)}var at={};var nt=function(e,r){var t;if(typeof r!=="undefined")t=r;else if(typeof require!=="undefined"){try{t=undefined}catch(a){t=null}}e.rc4=function(e,r){var t=new Array(256);var a=0,n=0,i=0,s=0;for(n=0;n!=256;++n)t[n]=n;for(n=0;n!=256;++n){i=i+t[n]+e[n%e.length].charCodeAt(0)&255;s=t[n];t[n]=t[i];t[i]=s}n=i=0;var f=Buffer(r.length);for(a=0;a!=r.length;++a){n=n+1&255;i=(i+t[n])%256;s=t[n];t[n]=t[i];t[i]=s;f[a]=r[a]^t[t[n]+t[i]&255]}return f};e.md5=function(e){if(!t)throw new Error("Unsupported crypto");return t.createHash("md5").update(e).digest("hex")}};nt(at,typeof crypto!=="undefined"?crypto:undefined);function it(e){return parseInt(lt(e),10)-1}function st(e){return""+(e+1)}function ft(e){return e.replace(/([A-Z]|^)(\d+)$/,"$1$$$2")}function lt(e){return e.replace(/\$(\d+)$/,"$1")}function ot(e){var r=ht(e),t=0,a=0;for(;a!==r.length;++a)t=26*t+r.charCodeAt(a)-64;return t-1}function ct(e){if(e<0)throw new Error("invalid column "+e);var r="";for(++e;e;e=Math.floor((e-1)/26))r=String.fromCharCode((e-1)%26+65)+r;return r}function ut(e){return e.replace(/^([A-Z])/,"$$$1")}function ht(e){return e.replace(/^\$([A-Z])/,"$1")}function dt(e){return e.replace(/(\$?[A-Z]*)(\$?\d*)/,"$1,$2").split(",")}function vt(e){var r=dt(e);return{c:ot(r[0]),r:it(r[1])}}function pt(e){return ct(e.c)+st(e.r)}function mt(e){var r=e.split(":").map(vt);return{s:r[0],e:r[r.length-1]}}function bt(e,r){if(typeof r==="undefined"||typeof r==="number"){return bt(e.s,e.e)}if(typeof e!=="string")e=pt(e);if(typeof r!=="string")r=pt(r);return e==r?e:e+":"+r}function gt(e){var r={s:{c:0,r:0},e:{c:0,r:0}};var t=0,a=0,n=0;var i=e.length;for(t=0;a<i;++a){if((n=e.charCodeAt(a)-64)<1||n>26)break;t=26*t+n}r.s.c=--t;for(t=0;a<i;++a){if((n=e.charCodeAt(a)-48)<0||n>9)break;t=10*t+n}r.s.r=--t;if(a===i||e.charCodeAt(++a)===58){r.e.c=r.s.c;r.e.r=r.s.r;return r}for(t=0;a!=i;++a){if((n=e.charCodeAt(a)-64)<1||n>26)break;t=26*t+n}r.e.c=--t;for(t=0;a!=i;++a){if((n=e.charCodeAt(a)-48)<0||n>9)break;t=10*t+n}r.e.r=--t;return r}function wt(e,r){var t=e.t=="d"&&r instanceof Date;if(e.z!=null)try{return e.w=F.format(e.z,t?re(r):r)}catch(a){}try{return e.w=F.format((e.XF||{}).numFmtId||(t?14:0),t?re(r):r)}catch(a){return""+r}}function kt(e,r,t){if(e==null||e.t==null||e.t=="z")return"";if(e.w!==undefined)return e.w;if(e.t=="d"&&!e.z&&t&&t.dateNF)e.z=t.dateNF;if(r==undefined)return wt(e,e.v);return wt(e,r)}function Et(e,r){var t=r&&r.sheet?r.sheet:"Sheet1";var a={};a[t]=e;return{SheetNames:[t],Sheets:a}}function St(e,r,t){var a=t||{};var n=e?Array.isArray(e):a.dense;if(m!=null&&n==null)n=m;var i=e||(n?[]:{});var s=0,f=0;if(i&&a.origin!=null){if(typeof a.origin=="number")s=a.origin;else{var l=typeof a.origin=="string"?vt(a.origin):a.origin;s=l.r;f=l.c}}var o={s:{c:1e7,r:1e7},e:{c:0,r:0}};if(i["!ref"]){var c=gt(i["!ref"]);o.s.c=c.s.c;o.s.r=c.s.r;o.e.c=Math.max(o.e.c,c.e.c);o.e.r=Math.max(o.e.r,c.e.r);if(s==-1)o.e.r=s=c.e.r+1}for(var u=0;u!=r.length;++u){if(!r[u])continue;if(!Array.isArray(r[u]))throw new Error("aoa_to_sheet expects an array of arrays");for(var h=0;h!=r[u].length;++h){if(typeof r[u][h]==="undefined")continue;var d={v:r[u][h]};var v=s+u,p=f+h;if(o.s.r>v)o.s.r=v;if(o.s.c>p)o.s.c=p;if(o.e.r<v)o.e.r=v;if(o.e.c<p)o.e.c=p;if(r[u][h]&&typeof r[u][h]==="object"&&!Array.isArray(r[u][h])&&!(r[u][h]instanceof Date))d=r[u][h];else{if(Array.isArray(d.v)){d.f=r[u][h][1];
d.v=d.v[0]}if(d.v===null){if(d.f)d.t="n";else if(!a.sheetStubs)continue;else d.t="z"}else if(typeof d.v==="number")d.t="n";else if(typeof d.v==="boolean")d.t="b";else if(d.v instanceof Date){d.z=a.dateNF||F._table[14];if(a.cellDates){d.t="d";d.w=F.format(d.z,re(d.v))}else{d.t="n";d.v=re(d.v);d.w=F.format(d.z,d.v)}}else d.t="s"}if(n){if(!i[v])i[v]=[];if(i[v][p]&&i[v][p].z)d.z=i[v][p].z;i[v][p]=d}else{var b=pt({c:p,r:v});if(i[b]&&i[b].z)d.z=i[b].z;i[b]=d}}}if(o.s.c<1e7)i["!ref"]=bt(o);return i}function _t(e,r){return St(null,e,r)}function Ct(e,r){if(!r)r=$r(4);r._W(4,e);return r}function Bt(e){var r=e._R(4);return r===0?"":e._R(r,"dbcs")}function Tt(e,r){var t=false;if(r==null){t=true;r=$r(4+2*e.length)}r._W(4,e.length);if(e.length>0)r._W(0,e,"dbcs");return t?r.slice(0,r.l):r}function yt(e){return{ich:e._R(2),ifnt:e._R(2)}}function xt(e,r){if(!r)r=$r(4);r._W(2,e.ich||0);r._W(2,e.ifnt||0);return r}function At(e,r){var t=e.l;var a=e._R(1);var n=Bt(e);var i=[];var s={t:n,h:n};if((a&1)!==0){var f=e._R(4);for(var l=0;l!=f;++l)i.push(yt(e));s.r=i}else s.r=[{ich:0,ifnt:0}];e.l=t+r;return s}function It(e,r){var t=false;if(r==null){t=true;r=$r(15+4*e.t.length)}r._W(1,0);Tt(e.t,r);return t?r.slice(0,r.l):r}var Rt=At;function Dt(e,r){var t=false;if(r==null){t=true;r=$r(23+4*e.t.length)}r._W(1,1);Tt(e.t,r);r._W(4,1);xt({ich:0,ifnt:0},r);return t?r.slice(0,r.l):r}function Ft(e){var r=e._R(4);var t=e._R(2);t+=e._R(1)<<16;e.l++;return{c:r,iStyleRef:t}}function Ot(e,r){if(r==null)r=$r(8);r._W(-4,e.c);r._W(3,e.iStyleRef||e.s);r._W(1,0);return r}var Pt=Bt;var Nt=Tt;function Lt(e){var r=e._R(4);return r===0||r===4294967295?"":e._R(r,"dbcs")}function Mt(e,r){var t=false;if(r==null){t=true;r=$r(127)}r._W(4,e.length>0?e.length:4294967295);if(e.length>0)r._W(0,e,"dbcs");return t?r.slice(0,r.l):r}var Ut=Bt;var Ht=Lt;var Wt=Mt;function zt(e){var r=e.slice(e.l,e.l+4);var t=r[0]&1,a=r[0]&2;e.l+=4;r[0]&=252;var n=a===0?Dr([0,0,0,0,r[0],r[1],r[2],r[3]],0):Ur(r,0)>>2;return t?n/100:n}function Vt(e,r){if(r==null)r=$r(4);var t=0,a=0,n=e*100;if(e==(e|0)&&e>=-(1<<29)&&e<1<<29){a=1}else if(n==(n|0)&&n>=-(1<<29)&&n<1<<29){a=1;t=1}if(a)r._W(-4,((t?n:e)<<2)+(t+2));else throw new Error("unsupported RkNumber "+e)}function Xt(e){var r={s:{},e:{}};r.s.r=e._R(4);r.e.r=e._R(4);r.s.c=e._R(4);r.e.c=e._R(4);return r}function Gt(e,r){if(!r)r=$r(16);r._W(4,e.s.r);r._W(4,e.e.r);r._W(4,e.s.c);r._W(4,e.e.c);return r}var jt=Xt;var Kt=Gt;function Yt(e){return e._R(8,"f")}function $t(e,r){return(r||$r(8))._W(8,e,"f")}var Zt={0:"#NULL!",7:"#DIV/0!",15:"#VALUE!",23:"#REF!",29:"#NAME?",36:"#NUM!",42:"#N/A",43:"#GETTING_DATA",255:"#WTF?"};var Qt=Q(Zt);function Jt(e){var r={};var t=e._R(1);var a=t>>>1;var n=e._R(1);var i=e._R(2,"i");var s=e._R(1);var f=e._R(1);var l=e._R(1);e.l++;switch(a){case 0:r.auto=1;break;case 1:r.index=n;var o=ya[n];if(o)r.rgb=al(o);break;case 2:r.rgb=al([s,f,l]);break;case 3:r.theme=n;break;}if(i!=0)r.tint=i>0?i/32767:i/32768;return r}function qt(e,r){if(!r)r=$r(8);if(!e||e.auto){r._W(4,0);r._W(4,0);return r}if(e.index!=null){r._W(1,2);r._W(1,e.index)}else if(e.theme!=null){r._W(1,6);r._W(1,e.theme)}else{r._W(1,5);r._W(1,0)}var t=e.tint||0;if(t>0)t*=32767;else if(t<0)t*=32768;r._W(2,t);if(!e.rgb||e.theme!=null){r._W(2,0);r._W(1,0);r._W(1,0)}else{var a=e.rgb||"FFFFFF";if(typeof a=="number")a=("000000"+a.toString(16)).slice(-6);r._W(1,parseInt(a.slice(0,2),16));r._W(1,parseInt(a.slice(2,4),16));r._W(1,parseInt(a.slice(4,6),16));r._W(1,255)}return r}function ea(e){var r=e._R(1);e.l++;var t={fBold:r&1,fItalic:r&2,fUnderline:r&4,fStrikeout:r&8,fOutline:r&16,fShadow:r&32,fCondense:r&64,fExtend:r&128};return t}function ra(e,r){if(!r)r=$r(2);var t=(e.italic?2:0)|(e.strike?8:0)|(e.outline?16:0)|(e.shadow?32:0)|(e.condense?64:0)|(e.extend?128:0);r._W(1,t);r._W(1,0);return r}function ta(e,r){var t={2:"BITMAP",3:"METAFILEPICT",8:"DIB",14:"ENHMETAFILE"};var a=e._R(4);switch(a){case 0:return"";case 4294967295:;case 4294967294:return t[e._R(4)]||"";}if(a>400)throw new Error("Unsupported Clipboard: "+a.toString(16));e.l-=4;return e._R(0,r==1?"lpstr":"lpwstr")}function aa(e){return ta(e,1)}function na(e){return ta(e,2)}var ia=2;var sa=3;var fa=11;var la=12;var oa=19;var ca=30;var ua=64;var ha=65;var da=71;var va=4096;var pa=80;var ma=81;var ba=[pa,ma];var ga={1:{n:"CodePage",t:ia},2:{n:"Category",t:pa},3:{n:"PresentationFormat",t:pa},4:{n:"ByteCount",t:sa},5:{n:"LineCount",t:sa},6:{n:"ParagraphCount",t:sa},7:{n:"SlideCount",t:sa},8:{n:"NoteCount",t:sa},9:{n:"HiddenCount",t:sa},10:{n:"MultimediaClipCount",t:sa},11:{n:"ScaleCrop",t:fa},12:{n:"HeadingPairs",t:va|la},13:{n:"TitlesOfParts",t:va|ca},14:{n:"Manager",t:pa},15:{n:"Company",t:pa},16:{n:"LinksUpToDate",t:fa},17:{n:"CharacterCount",t:sa},19:{n:"SharedDoc",t:fa},22:{n:"HyperlinksChanged",t:fa},23:{n:"AppVersion",t:sa,p:"version"},24:{n:"DigSig",t:ha},26:{n:"ContentType",t:pa},27:{n:"ContentStatus",t:pa},28:{n:"Language",t:pa},29:{n:"Version",t:pa},255:{}};var wa={1:{n:"CodePage",t:ia},2:{n:"Title",t:pa},3:{n:"Subject",t:pa},4:{n:"Author",t:pa},5:{n:"Keywords",t:pa},6:{n:"Comments",t:pa},7:{n:"Template",t:pa},8:{n:"LastAuthor",t:pa},9:{n:"RevNumber",t:pa},10:{n:"EditTime",t:ua},11:{n:"LastPrinted",t:ua},12:{n:"CreatedDate",t:ua},13:{n:"ModifiedDate",t:ua},14:{n:"PageCount",t:sa},15:{n:"WordCount",t:sa},16:{n:"CharCount",t:sa},17:{n:"Thumbnail",t:da},18:{n:"Application",t:pa},19:{n:"DocSecurity",t:sa},255:{}};var ka={2147483648:{n:"Locale",t:oa},2147483651:{n:"Behavior",t:oa},1919054434:{}};(function(){for(var e in ka)if(ka.hasOwnProperty(e))ga[e]=wa[e]=ka[e]})();var Ea=Y(ga,"n");var Sa=Y(wa,"n");var _a={1:"US",2:"CA",3:"",7:"RU",20:"EG",30:"GR",31:"NL",32:"BE",33:"FR",34:"ES",36:"HU",39:"IT",41:"CH",43:"AT",44:"GB",45:"DK",46:"SE",47:"NO",48:"PL",49:"DE",52:"MX",55:"BR",61:"AU",64:"NZ",66:"TH",81:"JP",82:"KR",84:"VN",86:"CN",90:"TR",105:"JS",213:"DZ",216:"MA",218:"LY",351:"PT",354:"IS",358:"FI",420:"CZ",886:"TW",961:"LB",962:"JO",963:"SY",964:"IQ",965:"KW",966:"SA",971:"AE",972:"IL",974:"QA",981:"IR",65535:"US"};var Ca=[null,"solid","mediumGray","darkGray","lightGray","darkHorizontal","darkVertical","darkDown","darkUp","darkGrid","darkTrellis","lightHorizontal","lightVertical","lightDown","lightUp","lightGrid","lightTrellis","gray125","gray0625"];function Ba(e){return e.map(function(e){return[e>>16&255,e>>8&255,e&255]})}var Ta=Ba([0,16777215,16711680,65280,255,16776960,16711935,65535,0,16777215,16711680,65280,255,16776960,16711935,65535,8388608,32768,128,8421376,8388736,32896,12632256,8421504,10066431,10040166,16777164,13434879,6684774,16744576,26316,13421823,128,16711935,16776960,65535,8388736,8388608,32896,255,52479,13434879,13434828,16777113,10079487,16751052,13408767,16764057,3368703,3394764,10079232,16763904,16750848,16737792,6710937,9868950,13158,3381606,13056,3355392,10040064,10040166,3355545,3355443,16777215,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);var ya=le(Ta);var xa={"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":"workbooks","application/vnd.ms-excel.binIndexWs":"TODO","application/vnd.ms-excel.intlmacrosheet":"TODO","application/vnd.ms-excel.binIndexMs":"TODO","application/vnd.openxmlformats-package.core-properties+xml":"coreprops","application/vnd.openxmlformats-officedocument.custom-properties+xml":"custprops","application/vnd.openxmlformats-officedocument.extended-properties+xml":"extprops","application/vnd.openxmlformats-officedocument.customXmlProperties+xml":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty":"TODO","application/vnd.ms-excel.pivotTable":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.chart+xml":"TODO","application/vnd.ms-office.chartcolorstyle+xml":"TODO","application/vnd.ms-office.chartstyle+xml":"TODO","application/vnd.ms-office.chartex+xml":"TODO","application/vnd.ms-excel.calcChain":"calcchains","application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml":"calcchains","application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings":"TODO","application/vnd.ms-office.activeX":"TODO","application/vnd.ms-office.activeX+xml":"TODO","application/vnd.ms-excel.attachedToolbars":"TODO","application/vnd.ms-excel.connections":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":"TODO","application/vnd.ms-excel.externalLink":"links","application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml":"links","application/vnd.ms-excel.sheetMetadata":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml":"TODO","application/vnd.ms-excel.pivotCacheDefinition":"TODO","application/vnd.ms-excel.pivotCacheRecords":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml":"TODO","application/vnd.ms-excel.queryTable":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml":"TODO","application/vnd.ms-excel.userNames":"TODO","application/vnd.ms-excel.revisionHeaders":"TODO","application/vnd.ms-excel.revisionLog":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml":"TODO","application/vnd.ms-excel.tableSingleCells":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml":"TODO","application/vnd.ms-excel.slicer":"TODO","application/vnd.ms-excel.slicerCache":"TODO","application/vnd.ms-excel.slicer+xml":"TODO","application/vnd.ms-excel.slicerCache+xml":"TODO","application/vnd.ms-excel.wsSortMap":"TODO","application/vnd.ms-excel.table":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":"TODO","application/vnd.openxmlformats-officedocument.theme+xml":"themes","application/vnd.openxmlformats-officedocument.themeOverride+xml":"TODO","application/vnd.ms-excel.Timeline+xml":"TODO","application/vnd.ms-excel.TimelineCache+xml":"TODO","application/vnd.ms-office.vbaProject":"vba","application/vnd.ms-office.vbaProjectSignature":"vba","application/vnd.ms-office.volatileDependencies":"TODO","application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml":"TODO","application/vnd.ms-excel.controlproperties+xml":"TODO","application/vnd.openxmlformats-officedocument.model+data":"TODO","application/vnd.ms-excel.Survey+xml":"TODO","application/vnd.openxmlformats-officedocument.drawing+xml":"drawings","application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml":"TODO","application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml":"TODO","application/vnd.openxmlformats-officedocument.vmlDrawing":"TODO","application/vnd.openxmlformats-package.relationships+xml":"rels","application/vnd.openxmlformats-officedocument.oleObject":"TODO","image/png":"TODO",sheet:"js"};var Aa=function(){var e={workbooks:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",xlsm:"application/vnd.ms-excel.sheet.macroEnabled.main+xml",xlsb:"application/vnd.ms-excel.sheet.binary.macroEnabled.main",xlam:"application/vnd.ms-excel.addin.macroEnabled.main+xml",xltx:"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"},strs:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",xlsb:"application/vnd.ms-excel.sharedStrings"},comments:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",xlsb:"application/vnd.ms-excel.comments"},sheets:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",xlsb:"application/vnd.ms-excel.worksheet"},charts:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",xlsb:"application/vnd.ms-excel.chartsheet"},dialogs:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",xlsb:"application/vnd.ms-excel.dialogsheet"},macros:{xlsx:"application/vnd.ms-excel.macrosheet+xml",xlsb:"application/vnd.ms-excel.macrosheet"},styles:{xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",xlsb:"application/vnd.ms-excel.styles"}};K(e).forEach(function(r){["xlsm","xlam"].forEach(function(t){if(!e[r][t])e[r][t]=e[r].xlsx})});K(e).forEach(function(r){K(e[r]).forEach(function(t){xa[e[r][t]]=r})});return e}();var Ia=J(xa);cr.CT="http://schemas.openxmlformats.org/package/2006/content-types";function Ra(){return{workbooks:[],sheets:[],charts:[],dialogs:[],macros:[],rels:[],strs:[],comments:[],links:[],coreprops:[],extprops:[],custprops:[],themes:[],styles:[],calcchains:[],vba:[],drawings:[],TODO:[],xmlns:""}}function Da(e){var r=Ra();if(!e||!e.match)return r;var t={};(e.match(Ae)||[]).forEach(function(e){var a=De(e);switch(a[0].replace(Ie,"<")){case"<?xml":break;case"<Types":r.xmlns=a["xmlns"+(a[0].match(/<(\w+):/)||["",""])[1]];break;case"<Default":t[a.Extension]=a.ContentType;break;case"<Override":if(r[xa[a.ContentType]]!==undefined)r[xa[a.ContentType]].push(a.PartName);break;}});if(r.xmlns!==cr.CT)throw new Error("Unknown Namespace: "+r.xmlns);r.calcchain=r.calcchains.length>0?r.calcchains[0]:"";r.sst=r.strs.length>0?r.strs[0]:"";r.style=r.styles.length>0?r.styles[0]:"";r.defaults=t;delete r.calcchains;return r}var Fa=fr("Types",null,{xmlns:cr.CT,"xmlns:xsd":cr.xsd,"xmlns:xsi":cr.xsi});var Oa=[["xml","application/xml"],["bin","application/vnd.ms-excel.sheet.binary.macroEnabled.main"],["vml","application/vnd.openxmlformats-officedocument.vmlDrawing"],["data","application/vnd.openxmlformats-officedocument.model+data"],["bmp","image/bmp"],["png","image/png"],["gif","image/gif"],["emf","image/x-emf"],["wmf","image/x-wmf"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["tif","image/tiff"],["tiff","image/tiff"],["pdf","application/pdf"],["rels",Ia.rels[0]]].map(function(e){return fr("Default",null,{Extension:e[0],ContentType:e[1]})});function Pa(e,r){var t=[],a;t[t.length]=ye;t[t.length]=Fa;t=t.concat(Oa);var n=function(n){if(e[n]&&e[n].length>0){a=e[n][0];t[t.length]=fr("Override",null,{PartName:(a[0]=="/"?"":"/")+a,ContentType:Aa[n][r.bookType||"xlsx"]})}};var i=function(a){(e[a]||[]).forEach(function(e){t[t.length]=fr("Override",null,{PartName:(e[0]=="/"?"":"/")+e,ContentType:Aa[a][r.bookType||"xlsx"]})})};var s=function(r){(e[r]||[]).forEach(function(e){t[t.length]=fr("Override",null,{PartName:(e[0]=="/"?"":"/")+e,ContentType:Ia[r][0]})})};n("workbooks");i("sheets");i("charts");s("themes");["strs","styles"].forEach(n);["coreprops","extprops","custprops"].forEach(s);s("vba");s("comments");s("drawings");if(t.length>2){t[t.length]="</Types>";t[1]=t[1].replace("/>",">")}return t.join("")}var Na={WB:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",SHEET:"http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",HLINK:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",VML:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",XPATH:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",XMISS:"http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",XLINK:"http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",VBA:"http://schemas.microsoft.com/office/2006/relationships/vbaProject"};function La(e){var r=e.lastIndexOf("/");return e.slice(0,r+1)+"_rels/"+e.slice(r+1)+".rels"}function Ma(e,r){var t={"!id":{}};if(!e)return t;if(r.charAt(0)!=="/"){r="/"+r}var a={};(e.match(Ae)||[]).forEach(function(e){var n=De(e);if(n[0]==="<Relationship"){var i={};i.Type=n.Type;i.Target=n.Target;i.Id=n.Id;i.TargetMode=n.TargetMode;var s=n.TargetMode==="External"?n.Target:Te(n.Target,r);t[s]=i;a[n.Id]=i}});t["!id"]=a;return t}cr.RELS="http://schemas.openxmlformats.org/package/2006/relationships";var Ua=fr("Relationships",null,{xmlns:cr.RELS});function Ha(e){var r=[ye,Ua];K(e["!id"]).forEach(function(t){r[r.length]=fr("Relationship",null,e["!id"][t])});if(r.length>2){r[r.length]="</Relationships>";r[1]=r[1].replace("/>",">")}return r.join("")}var Wa=[Na.HLINK,Na.XPATH,Na.XMISS];function za(e,r,t,a,n,i){if(!n)n={};if(!e["!id"])e["!id"]={};if(r<0)for(r=1;e["!id"]["rId"+r];++r){}n.Id="rId"+r;n.Type=a;n.Target=t;if(i)n.TargetMode=i;else if(Wa.indexOf(n.Type)>-1)n.TargetMode="External";if(e["!id"][n.Id])throw new Error("Cannot rewrite rId "+r);e["!id"][n.Id]=n;e[("/"+n.Target).replace("//","/")]=n;return r}var Va="application/vnd.oasis.opendocument.spreadsheet";function Xa(e,r){var t=qv(e);var a;var n;while(a=ep.exec(t))switch(a[3]){case"manifest":break;case"file-entry":n=De(a[0],false);if(n.path=="/"&&n.type!==Va)throw new Error("This OpenDocument is not a spreadsheet");break;case"encryption-data":;case"algorithm":;case"start-key-generation":;case"key-derivation":throw new Error("Unsupported ODS Encryption");default:if(r&&r.WTF)throw a;}}function Ga(e){var r=[ye];r.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');r.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');for(var t=0;t<e.length;++t)r.push('  <manifest:file-entry manifest:full-path="'+e[t][0]+'" manifest:media-type="'+e[t][1]+'"/>\n');r.push("</manifest:manifest>");return r.join("")}function ja(e,r,t){return['  <rdf:Description rdf:about="'+e+'">\n','    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/'+(t||"odf")+"#"+r+'"/>\n',"  </rdf:Description>\n"].join("")}function Ka(e,r){return['  <rdf:Description rdf:about="'+e+'">\n','    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="'+r+'"/>\n',"  </rdf:Description>\n"].join("")}function Ya(e){var r=[ye];r.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');for(var t=0;t!=e.length;++t){r.push(ja(e[t][0],e[t][1]));r.push(Ka("",e[t][0]))}r.push(ja("","Document","pkg"));r.push("</rdf:RDF>");return r.join("")}var $a=function(){var r='<?xml version="1.0" encoding="UTF-8" standalone="yes"?><office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>Sheet'+"JS "+e.version+"</meta:generator></office:meta></office:document-meta>";return function t(){return r}}();var Za=[["cp:category","Category"],["cp:contentStatus","ContentStatus"],["cp:keywords","Keywords"],["cp:lastModifiedBy","LastAuthor"],["cp:lastPrinted","LastPrinted"],["cp:revision","RevNumber"],["cp:version","Version"],["dc:creator","Author"],["dc:description","Comments"],["dc:identifier","Identifier"],["dc:language","Language"],["dc:subject","Subject"],["dc:title","Title"],["dcterms:created","CreatedDate","date"],["dcterms:modified","ModifiedDate","date"]];cr.CORE_PROPS="http://schemas.openxmlformats.org/package/2006/metadata/core-properties";Na.CORE_PROPS="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";var Qa=function(){var e=new Array(Za.length);for(var r=0;r<Za.length;++r){var t=Za[r];var a="(?:"+t[0].slice(0,t[0].indexOf(":"))+":)"+t[0].slice(t[0].indexOf(":")+1);e[r]=new RegExp("<"+a+"[^>]*>([\\s\\S]*?)</"+a+">")}return e}();function Ja(e){var r={};e=Ke(e);for(var t=0;t<Za.length;++t){var a=Za[t],n=e.match(Qa[t]);if(n!=null&&n.length>0)r[a[1]]=Ne(n[1]);if(a[2]==="date"&&r[a[1]])r[a[1]]=se(r[a[1]])}return r}var qa=fr("cp:coreProperties",null,{"xmlns:cp":cr.CORE_PROPS,"xmlns:dc":cr.dc,"xmlns:dcterms":cr.dcterms,"xmlns:dcmitype":cr.dcmitype,"xmlns:xsi":cr.xsi});function en(e,r,t,a,n){if(n[e]!=null||r==null||r==="")return;n[e]=r;r=Ue(r);a[a.length]=t?fr(e,r,t):ir(e,r)}function rn(e,r){var t=r||{};var a=[ye,qa],n={};if(!e&&!t.Props)return a.join("");if(e){if(e.CreatedDate!=null)en("dcterms:created",typeof e.CreatedDate==="string"?e.CreatedDate:lr(e.CreatedDate,t.WTF),{"xsi:type":"dcterms:W3CDTF"},a,n);if(e.ModifiedDate!=null)en("dcterms:modified",typeof e.ModifiedDate==="string"?e.ModifiedDate:lr(e.ModifiedDate,t.WTF),{"xsi:type":"dcterms:W3CDTF"},a,n)}for(var i=0;i!=Za.length;++i){var s=Za[i];var f=t.Props&&t.Props[s[1]]!=null?t.Props[s[1]]:e?e[s[1]]:null;if(f===true)f="1";else if(f===false)f="0";else if(typeof f=="number")f=String(f);if(f!=null)en(s[0],f,null,a,n)}if(a.length>2){a[a.length]="</cp:coreProperties>";a[1]=a[1].replace("/>",">")}return a.join("")}var tn=[["Application","Application","string"],["AppVersion","AppVersion","string"],["Company","Company","string"],["DocSecurity","DocSecurity","string"],["Manager","Manager","string"],["HyperlinksChanged","HyperlinksChanged","bool"],["SharedDoc","SharedDoc","bool"],["LinksUpToDate","LinksUpToDate","bool"],["ScaleCrop","ScaleCrop","bool"],["HeadingPairs","HeadingPairs","raw"],["TitlesOfParts","TitlesOfParts","raw"]];cr.EXT_PROPS="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties";Na.EXT_PROPS="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties";var an=["Worksheets","SheetNames","NamedRanges","DefinedNames","Chartsheets","ChartNames"];function nn(e,r,t,a){var n=[];if(typeof e=="string")n=ar(e,a);else for(var i=0;i<e.length;++i)n=n.concat(e[i].map(function(e){return{v:e}}));var s=typeof r=="string"?ar(r,a).map(function(e){return e.v}):r;var f=0,l=0;if(s.length>0)for(var o=0;o!==n.length;o+=2){l=+n[o+1].v;switch(n[o].v){case"Worksheets":;case"":;case"":;case" ":;case"":;case" ":;case"Arbeitsbltter":;case"alma Sayfalar":;case"Feuilles de calcul":;case"Fogli di lavoro":;case"Folhas de clculo":;case"Planilhas":;case"Regneark":;case"Hojas de clculo":;case"Werkbladen":t.Worksheets=l;t.SheetNames=s.slice(f,f+l);break;case"Named Ranges":;case"Rangos con nombre":;case"":;case"Benannte Bereiche":;case"Navngivne omrder":t.NamedRanges=l;t.DefinedNames=s.slice(f,f+l);break;case"Charts":;case"Diagramme":t.Chartsheets=l;t.ChartNames=s.slice(f,f+l);break;}f+=l}}function sn(e,r,t){var a={};if(!r)r={};e=Ke(e);tn.forEach(function(t){var n=(e.match(Je(t[0]))||[])[1];switch(t[2]){case"string":r[t[1]]=Ne(n||"");break;case"bool":r[t[1]]=n==="true";break;case"raw":var i=e.match(new RegExp("<"+t[0]+"[^>]*>([\\s\\S]*?)</"+t[0]+">"));if(i&&i.length>0)a[t[1]]=i[1];break;}});if(a.HeadingPairs&&a.TitlesOfParts)nn(a.HeadingPairs,a.TitlesOfParts,r,t);return r}var fn=fr("Properties",null,{xmlns:cr.EXT_PROPS,"xmlns:vt":cr.vt});function ln(e){var r=[],t=fr;if(!e)e={};e.Application="SheetJS";r[r.length]=ye;r[r.length]=fn;tn.forEach(function(a){if(e[a[1]]===undefined)return;var n;switch(a[2]){case"string":n=Ue(String(e[a[1]]));break;case"bool":n=e[a[1]]?"true":"false";break;}if(n!==undefined)r[r.length]=t(a[0],n)});r[r.length]=t("HeadingPairs",t("vt:vector",t("vt:variant","<vt:lpstr>Worksheets</vt:lpstr>")+t("vt:variant",t("vt:i4",String(e.Worksheets))),{size:2,baseType:"variant"}));r[r.length]=t("TitlesOfParts",t("vt:vector",e.SheetNames.map(function(e){return"<vt:lpstr>"+Ue(e)+"</vt:lpstr>"}).join(""),{size:e.Worksheets,baseType:"lpstr"}));if(r.length>2){r[r.length]="</Properties>";r[1]=r[1].replace("/>",">")}return r.join("")}cr.CUST_PROPS="http://schemas.openxmlformats.org/officeDocument/2006/custom-properties";Na.CUST_PROPS="http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties";var on=/<[^>]+>[^<]*/g;function cn(e,r){var t={},a="";var n=e.match(on);if(n)for(var i=0;i!=n.length;++i){var s=n[i],f=De(s);switch(f[0]){case"<?xml":break;case"<Properties":break;case"<property":a=Ne(f.name);break;case"</property>":a=null;break;default:if(s.indexOf("<vt:")===0){var l=s.split(">");var o=l[0].slice(4),c=l[1];switch(o){case"lpstr":;case"bstr":;case"lpwstr":t[a]=Ne(c);break;case"bool":t[a]=je(c);break;case"i1":;case"i2":;case"i4":;case"i8":;case"int":;case"uint":t[a]=parseInt(c,10);break;case"r4":;case"r8":;case"decimal":t[a]=parseFloat(c);break;case"filetime":;case"date":t[a]=se(c);break;case"cy":;case"error":t[a]=Ne(c);break;default:if(o.slice(-1)=="/")break;if(r.WTF&&typeof console!=="undefined")console.warn("Unexpected",s,o,l);}}else if(s.slice(0,2)==="</"){}else if(r.WTF)throw new Error(s);}}return t}var un=fr("Properties",null,{xmlns:cr.CUST_PROPS,"xmlns:vt":cr.vt});function hn(e){var r=[ye,un];if(!e)return r.join("");var t=1;K(e).forEach(function a(n){++t;r[r.length]=fr("property",or(e[n]),{fmtid:"{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",pid:t,name:Ue(n)})});if(r.length>2){r[r.length]="</Properties>";r[1]=r[1].replace("/>",">")}return r.join("")}var dn={Title:"Title",Subject:"Subject",Author:"Author",Keywords:"Keywords",Comments:"Description",LastAuthor:"LastAuthor",RevNumber:"Revision",Application:"AppName",LastPrinted:"LastPrinted",CreatedDate:"Created",ModifiedDate:"LastSaved",Category:"Category",Manager:"Manager",Company:"Company",AppVersion:"Version",ContentStatus:"ContentStatus",Identifier:"Identifier",Language:"Language"};var vn=Z(dn);function pn(e,r,t){r=vn[r]||r;e[r]=t}function mn(e,r){var t=[];K(dn).map(function(e){for(var r=0;r<Za.length;++r)if(Za[r][1]==e)return Za[r];for(r=0;r<tn.length;++r)if(tn[r][1]==e)return tn[r];throw e}).forEach(function(a){if(e[a[1]]==null)return;var n=r&&r.Props&&r.Props[a[1]]!=null?r.Props[a[1]]:e[a[1]];switch(a[2]){case"date":n=new Date(n).toISOString().replace(/\.\d*Z/,"Z");break;}if(typeof n=="number")n=String(n);else if(n===true||n===false){n=n?"1":"0"}else if(n instanceof Date)n=new Date(n).toISOString().replace(/\.\d*Z/,"");t.push(ir(dn[a[1]]||a[1],n))});return fr("DocumentProperties",t.join(""),{xmlns:ur.o})}function bn(e,r){var t=["Worksheets","SheetNames"];var a="CustomDocumentProperties";var n=[];if(e)K(e).forEach(function(r){if(!e.hasOwnProperty(r))return;for(var a=0;a<Za.length;++a)if(r==Za[a][1])return;for(a=0;a<tn.length;++a)if(r==tn[a][1])return;for(a=0;a<t.length;++a)if(r==t[a])return;var i=e[r];var s="string";if(typeof i=="number"){s="float";i=String(i)}else if(i===true||i===false){s="boolean";i=i?"1":"0"}else i=String(i);n.push(fr(He(r),i,{"dt:dt":s}))});if(r)K(r).forEach(function(t){if(!r.hasOwnProperty(t))return;if(e&&e.hasOwnProperty(t))return;var a=r[t];var i="string";if(typeof a=="number"){i="float";a=String(a)}else if(a===true||a===false){i="boolean";a=a?"1":"0"}else if(a instanceof Date){i="dateTime.tz";a=a.toISOString()}else a=String(a);n.push(fr(He(t),a,{"dt:dt":i}))});return"<"+a+' xmlns="'+ur.o+'">'+n.join("")+"</"+a+">"}function gn(e){var r=e._R(4),t=e._R(4);return new Date((t/1e7*Math.pow(2,32)+r/1e7-11644473600)*1e3).toISOString().replace(/\.000/,"")}function wn(e){var r=typeof e=="string"?new Date(Date.parse(e)):e;var t=r.getTime()/1e3+11644473600;var a=t%Math.pow(2,32),n=(t-a)/Math.pow(2,32);a*=1e7;n*=1e7;var i=a/Math.pow(2,32)|0;if(i>0){a=a%Math.pow(2,32);n+=i}var s=$r(8);s._W(4,a);s._W(4,n);return s}function kn(e,r,t){var a=e.l;var n=e._R(0,"lpstr-cp");if(t)while(e.l-a&3)++e.l;return n}function En(e,r,t){var a=e._R(0,"lpwstr");if(t)e.l+=4-(a.length+1&3)&3;return a}function Sn(e,r,t){if(r===31)return En(e);return kn(e,r,t)}function _n(e,r,t){return Sn(e,r,t===false?0:4)}function Cn(e,r){if(!r)throw new Error("VtUnalignedString must have positive length");return Sn(e,r,0)}function Bn(e){var r=e._R(4);var t=[];for(var a=0;a!=r;++a)t[a]=e._R(0,"lpstr-cp").replace(R,"");return t}function Tn(e){return Bn(e)}function yn(e){var r=Fn(e,ma);var t=Fn(e,sa);return[r,t]}function xn(e){var r=e._R(4);var t=[];for(var a=0;a!=r/2;++a)t.push(yn(e));return t}function An(e){return xn(e)}function In(e,r){var t=e._R(4);var a={};for(var n=0;n!=t;++n){var i=e._R(4);var s=e._R(4);a[i]=e._R(s,r===1200?"utf16le":"utf8").replace(R,"").replace(D,"!");if(r===1200&&s%2)e.l+=2}if(e.l&3)e.l=e.l>>2+1<<2;return a}function Rn(e){var r=e._R(4);var t=e.slice(e.l,e.l+r);e.l+=r;if((r&3)>0)e.l+=4-(r&3)&3;return t}function Dn(e){var r={};r.Size=e._R(4);e.l+=r.Size+3-(r.Size-1)%4;return r}function Fn(e,r,t){var a=e._R(2),n,i=t||{};e.l+=2;if(r!==la)if(a!==r&&ba.indexOf(r)===-1)throw new Error("Expected type "+r+" saw "+a);switch(r===la?a:r){case 2:n=e._R(2,"i");if(!i.raw)e.l+=2;return n;case 3:n=e._R(4,"i");return n;case 11:return e._R(4)!==0;case 19:n=e._R(4);return n;case 30:return kn(e,a,4).replace(R,"");case 31:return En(e);case 64:return gn(e);case 65:return Rn(e);case 71:return Dn(e);case 80:return _n(e,a,!i.raw).replace(R,"");case 81:return Cn(e,a).replace(R,"");case 4108:return An(e);case 4126:return Tn(e);default:throw new Error("TypedPropertyValue unrecognized type "+r+" "+a);}}function On(e,r){var t=$r(4),a=$r(4);t._W(4,e==80?31:e);switch(e){case 3:a._W(-4,r);break;case 5:a=$r(8);a._W(8,r,"f");break;case 11:a._W(4,r?1:0);break;case 64:a=wn(r);break;case 31:;case 80:a=$r(4+2*(r.length+1)+(r.length%2?0:2));a._W(4,r.length+1);a._W(0,r,"dbcs");while(a.l!=a.length)a._W(1,0);break;default:throw new Error("TypedPropertyValue unrecognized type "+e+" "+r);}return I([t,a])}function Pn(e,r){var t=e.l;var a=e._R(4);var n=e._R(4);var i=[],s=0;var f=0;var o=-1,c={};for(s=0;s!=n;++s){var u=e._R(4);var h=e._R(4);i[s]=[u,h+t]}i.sort(function(e,r){return e[1]-r[1]});var d={};for(s=0;s!=n;++s){if(e.l!==i[s][1]){var v=true;if(s>0&&r)switch(r[i[s-1][0]].t){case 2:if(e.l+2===i[s][1]){e.l+=2;v=false}break;case 80:if(e.l<=i[s][1]){e.l=i[s][1];v=false}break;case 4108:if(e.l<=i[s][1]){e.l=i[s][1];v=false}break;}if((!r||s==0)&&e.l<=i[s][1]){v=false;e.l=i[s][1]}if(v)throw new Error("Read Error: Expected address "+i[s][1]+" at "+e.l+" :"+s)}if(r){var p=r[i[s][0]];d[p.n]=Fn(e,p.t,{raw:true});if(p.p==="version")d[p.n]=String(d[p.n]>>16)+"."+("0000"+String(d[p.n]&65535)).slice(-4);if(p.n=="CodePage")switch(d[p.n]){case 0:d[p.n]=1252;case 874:;case 932:;case 936:;case 949:;case 950:;case 1250:;case 1251:;case 1253:;case 1254:;case 1255:;case 1256:;case 1257:;case 1258:;case 1e4:;case 1200:;case 1201:;case 1252:;case 65e3:;case-536:;case 65001:;case-535:l(f=d[p.n]>>>0&65535);break;default:throw new Error("Unsupported CodePage: "+d[p.n]);}}else{if(i[s][0]===1){f=d.CodePage=Fn(e,ia);l(f);if(o!==-1){var m=e.l;e.l=i[o][1];c=In(e,f);e.l=m}}else if(i[s][0]===0){if(f===0){o=s;e.l=i[s+1][1];continue}c=In(e,f)}else{var b=c[i[s][0]];var g;switch(e[e.l]){case 65:e.l+=4;g=Rn(e);break;case 30:e.l+=4;g=_n(e,e[e.l-4]).replace(/\u0000+$/,"");break;case 31:e.l+=4;g=_n(e,e[e.l-4]).replace(/\u0000+$/,"");break;case 3:e.l+=4;g=e._R(4,"i");break;case 19:e.l+=4;g=e._R(4);break;case 5:e.l+=4;g=e._R(8,"f");break;case 11:e.l+=4;g=Xn(e,4);break;case 64:e.l+=4;g=se(gn(e));break;default:throw new Error("unparsed value: "+e[e.l]);}d[b]=g}}}e.l=t+a;return d}var Nn=["CodePage","Thumbnail","_PID_LINKBASE","_PID_HLINKS","SystemIdentifier","FMTID"].concat(an);
function Ln(e){switch(typeof e){case"boolean":return 11;case"number":return(e|0)==e?3:5;case"string":return 31;case"object":if(e instanceof Date)return 64;break;}return-1}function Mn(e,r,t){var a=$r(8),n=[],i=[];var s=8,f=0;var l=$r(8),o=$r(8);l._W(4,2);l._W(4,1200);o._W(4,1);i.push(l);n.push(o);s+=8+l.length;if(!r){o=$r(8);o._W(4,0);n.unshift(o);var c=[$r(4)];c[0]._W(4,e.length);for(f=0;f<e.length;++f){var u=e[f][0];l=$r(4+4+2*(u.length+1)+(u.length%2?0:2));l._W(4,f+2);l._W(4,u.length+1);l._W(0,u,"dbcs");while(l.l!=l.length)l._W(1,0);c.push(l)}l=I(c);i.unshift(l);s+=8+l.length}for(f=0;f<e.length;++f){if(r&&!r[e[f][0]])continue;if(Nn.indexOf(e[f][0])>-1)continue;if(e[f][1]==null)continue;var h=e[f][1],d=0;if(r){d=+r[e[f][0]];var v=t[d];if(v.p=="version"&&typeof h=="string"){var p=h.split(".");h=(+p[0]<<16)+(+p[1]||0)}l=On(v.t,h)}else{var m=Ln(h);if(m==-1){m=31;h=String(h)}l=On(m,h)}i.push(l);o=$r(8);o._W(4,!r?2+f:d);n.push(o);s+=8+l.length}var b=8*(i.length+1);for(f=0;f<i.length;++f){n[f]._W(4,b);b+=i[f].length}a._W(4,s);a._W(4,i.length);return I([a].concat(n).concat(i))}function Un(e,r,t){var a=e.content;if(!a)return{};Kr(a,0);var n,i,s,f,l=0;a.chk("feff","Byte Order: ");a._R(2);var o=a._R(4);var c=a._R(16);if(c!==z.utils.consts.HEADER_CLSID&&c!==t)throw new Error("Bad PropertySet CLSID "+c);n=a._R(4);if(n!==1&&n!==2)throw new Error("Unrecognized #Sets: "+n);i=a._R(16);f=a._R(4);if(n===1&&f!==a.l)throw new Error("Length mismatch: "+f+" !== "+a.l);else if(n===2){s=a._R(16);l=a._R(4)}var u=Pn(a,r);var h={SystemIdentifier:o};for(var d in u)h[d]=u[d];h.FMTID=i;if(n===1)return h;if(l-a.l==2)a.l+=2;if(a.l!==l)throw new Error("Length mismatch 2: "+a.l+" !== "+l);var v;try{v=Pn(a,null)}catch(p){}for(d in v)h[d]=v[d];h.FMTID=[i,s];return h}function Hn(e,r,t,a,n,i){var s=$r(n?68:48);var f=[s];s._W(2,65534);s._W(2,0);s._W(4,842412599);s._W(16,z.utils.consts.HEADER_CLSID,"hex");s._W(4,n?2:1);s._W(16,r,"hex");s._W(4,n?68:48);var l=Mn(e,t,a);f.push(l);if(n){var o=Mn(n,null,null);s._W(16,i,"hex");s._W(4,68+l.length);f.push(o)}return I(f)}function Wn(e,r){e._R(r);return null}function zn(e,r){if(!r)r=$r(e);for(var t=0;t<e;++t)r._W(1,0);return r}function Vn(e,r,t){var a=[],n=e.l+r;while(e.l<n)a.push(t(e,n-e.l));if(n!==e.l)throw new Error("Slurp error");return a}function Xn(e,r){return e._R(r)===1}function Gn(e,r){if(!r)r=$r(2);r._W(2,+!!e);return r}function jn(e){return e._R(2,"u")}function Kn(e,r){if(!r)r=$r(2);r._W(2,e);return r}function Yn(e,r){return Vn(e,r,jn)}function $n(e){var r=e._R(1),t=e._R(1);return t===1?r:r===1}function Zn(e,r,t){if(!t)t=$r(2);t._W(1,+e);t._W(1,r=="e"?1:0);return t}function Qn(e,t,a){var n=e._R(a&&a.biff>=12?2:1);var i="sbcs-cont";var s=r;if(a&&a.biff>=8)r=1200;if(!a||a.biff==8){var f=e._R(1);if(f){i="dbcs-cont"}}else if(a.biff==12){i="wstr"}if(a.biff>=2&&a.biff<=5)i="cpstr";var l=n?e._R(n,i):"";r=s;return l}function Jn(e){var t=r;r=1200;var a=e._R(2),n=e._R(1);var i=n&4,s=n&8;var f=1+(n&1);var l=0,o;var c={};if(s)l=e._R(2);if(i)o=e._R(4);var u=f==2?"dbcs-cont":"sbcs-cont";var h=a===0?"":e._R(a,u);if(s)e.l+=4*l;if(i)e.l+=o;c.t=h;if(!s){c.raw="<t>"+c.t+"</t>";c.r=c.t}r=t;return c}function qn(e,r,t){var a;if(t){if(t.biff>=2&&t.biff<=5)return e._R(r,"cpstr");if(t.biff>=12)return e._R(r,"dbcs-cont")}var n=e._R(1);if(n===0){a=e._R(r,"sbcs-cont")}else{a=e._R(r,"dbcs-cont")}return a}function ei(e,r,t){var a=e._R(t&&t.biff==2?1:2);if(a===0){e.l++;return""}return qn(e,a,t)}function ri(e,r,t){if(t.biff>5)return ei(e,r,t);var a=e._R(1);if(a===0){e.l++;return""}return e._R(a,t.biff<=4||!e.lens?"cpstr":"sbcs-cont")}function ti(e,r,t){if(!t)t=$r(3+2*e.length);t._W(2,e.length);t._W(1,1);t._W(31,e,"utf16le");return t}function ai(e){var r=e._R(1);e.l++;var t=e._R(2);e.l+=2;return[r,t]}function ni(e){var r=e._R(4),t=e.l;var a=false;if(r>24){e.l+=r-24;if(e._R(16)==="795881f43b1d7f48af2c825dc4852763")a=true;e.l=t}var n=e._R((a?r-24:r)>>1,"utf16le").replace(R,"");if(a)e.l+=24;return n}function ii(e){e.l+=2;var r=e._R(0,"lpstr-ansi");e.l+=2;if(e._R(2)!=57005)throw new Error("Bad FileMoniker");var t=e._R(4);if(t===0)return r.replace(/\\/g,"/");var a=e._R(4);if(e._R(2)!=3)throw new Error("Bad FileMoniker");var n=e._R(a>>1,"utf16le").replace(R,"");return n}function si(e,r){var t=e._R(16);r-=16;switch(t){case"e0c9ea79f9bace118c8200aa004ba90b":return ni(e,r);case"0303000000000000c000000000000046":return ii(e,r);default:throw new Error("Unsupported Moniker "+t);}}function fi(e){var r=e._R(4);var t=r>0?e._R(r,"utf16le").replace(R,""):"";return t}function li(e,r){var t=e.l+r;var a=e._R(4);if(a!==2)throw new Error("Unrecognized streamVersion: "+a);var n=e._R(2);e.l+=2;var i,s,f,l,o="",c,u;if(n&16)i=fi(e,t-e.l);if(n&128)s=fi(e,t-e.l);if((n&257)===257)f=fi(e,t-e.l);if((n&257)===1)l=si(e,t-e.l);if(n&8)o=fi(e,t-e.l);if(n&32)c=e._R(16);if(n&64)u=gn(e);e.l=t;var h=s||f||l||"";if(h&&o)h+="#"+o;if(!h)h="#"+o;var d={Target:h};if(c)d.guid=c;if(u)d.time=u;if(i)d.Tooltip=i;return d}function oi(e){var r=$r(512),t=0;var a=e.Target;var n=a.indexOf("#")>-1?31:23;switch(a.charAt(0)){case"#":n=28;break;case".":n&=~2;break;}r._W(4,2);r._W(4,n);var i=[8,6815827,6619237,4849780,83];for(t=0;t<i.length;++t)r._W(4,i[t]);if(n==28){a=a.slice(1);r._W(4,a.length+1);for(t=0;t<a.length;++t)r._W(2,a.charCodeAt(t));r._W(2,0)}else if(n&2){i="e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");for(t=0;t<i.length;++t)r._W(1,parseInt(i[t],16));r._W(4,2*(a.length+1));for(t=0;t<a.length;++t)r._W(2,a.charCodeAt(t));r._W(2,0)}else{i="03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");for(t=0;t<i.length;++t)r._W(1,parseInt(i[t],16));var s=0;while(a.slice(s*3,s*3+3)=="../"||a.slice(s*3,s*3+3)=="..\\")++s;r._W(2,s);r._W(4,a.length+1);for(t=0;t<a.length;++t)r._W(1,a.charCodeAt(t)&255);r._W(1,0);r._W(2,65535);r._W(2,57005);for(t=0;t<6;++t)r._W(4,0)}return r.slice(0,r.l)}function ci(e){var r=e._R(1),t=e._R(1),a=e._R(1),n=e._R(1);return[r,t,a,n]}function ui(e,r){var t=ci(e,r);t[3]=0;return t}function hi(e){var r=e._R(2);var t=e._R(2);var a=e._R(2);return{r:r,c:t,ixfe:a}}function di(e,r,t,a){if(!a)a=$r(6);a._W(2,e);a._W(2,r);a._W(2,t||0);return a}function vi(e){var r=e._R(2);var t=e._R(2);e.l+=8;return{type:r,flags:t}}function pi(e,r,t){return r===0?"":ri(e,r,t)}function mi(e,r,t){var a=t.biff>8?4:2;var n=e._R(a),i=e._R(a,"i"),s=e._R(a,"i");return[n,i,s]}function bi(e){var r=e._R(2);var t=zt(e);return[r,t]}function gi(e,r,t){e.l+=4;r-=4;var a=e.l+r;var n=Qn(e,r,t);var i=e._R(2);a-=e.l;if(i!==a)throw new Error("Malformed AddinUdf: padding = "+a+" != "+i);e.l+=i;return n}function wi(e){var r=e._R(2);var t=e._R(2);var a=e._R(2);var n=e._R(2);return{s:{c:a,r:r},e:{c:n,r:t}}}function ki(e,r){if(!r)r=$r(8);r._W(2,e.s.r);r._W(2,e.e.r);r._W(2,e.s.c);r._W(2,e.e.c);return r}function Ei(e){var r=e._R(2);var t=e._R(2);var a=e._R(1);var n=e._R(1);return{s:{c:a,r:r},e:{c:n,r:t}}}var Si=Ei;function _i(e){e.l+=4;var r=e._R(2);var t=e._R(2);var a=e._R(2);e.l+=12;return[t,r,a]}function Ci(e){var r={};e.l+=4;e.l+=16;r.fSharedNote=e._R(2);e.l+=4;return r}function Bi(e){var r={};e.l+=4;e.cf=e._R(2);return r}function Ti(e){e.l+=2;e.l+=e._R(2)}var yi={0:Ti,4:Ti,5:Ti,6:Ti,7:Bi,8:Ti,9:Ti,10:Ti,11:Ti,12:Ti,13:Ci,14:Ti,15:Ti,16:Ti,17:Ti,18:Ti,19:Ti,20:Ti,21:_i};function xi(e,r){var t=e.l+r;var a=[];while(e.l<t){var n=e._R(2);e.l-=2;try{a.push(yi[n](e,t-e.l))}catch(i){e.l=t;return a}}if(e.l!=t)e.l=t;return a}function Ai(e,r){var t={BIFFVer:0,dt:0};t.BIFFVer=e._R(2);r-=2;if(r>=2){t.dt=e._R(2);e.l-=2}switch(t.BIFFVer){case 1536:;case 1280:;case 1024:;case 768:;case 512:;case 2:;case 7:break;default:if(r>6)throw new Error("Unexpected BIFF Ver "+t.BIFFVer);}e._R(r);return t}function Ii(e,r,t){var a=1536,n=16;switch(t.bookType){case"biff8":break;case"biff5":a=1280;n=8;break;case"biff4":a=4;n=6;break;case"biff3":a=3;n=6;break;case"biff2":a=2;n=4;break;case"xla":break;default:throw new Error("unsupported BIFF version");}var i=$r(n);i._W(2,a);i._W(2,r);if(n>4)i._W(2,29282);if(n>6)i._W(2,1997);if(n>8){i._W(2,49161);i._W(2,1);i._W(2,1798);i._W(2,0)}return i}function Ri(e,r){if(r===0)return 1200;if(e._R(2)!==1200){}return 1200}function Di(e,r,t){if(t.enc){e.l+=r;return""}var a=e.l;var n=ri(e,0,t);e._R(r+a-e.l);return n}function Fi(e,r){var t=!r||r.biff==8;var a=$r(t?112:54);a._W(r.biff==8?2:1,7);if(t)a._W(1,0);a._W(4,859007059);a._W(4,5458548|(t?0:536870912));while(a.l<a.length)a._W(1,t?0:32);return a}function Oi(e,r,t){var a=t&&t.biff==8||r==2?e._R(2):(e.l+=r,0);return{fDialog:a&16}}function Pi(e,r,t){var a=e._R(4);var n=e._R(1)&3;var i=e._R(1);switch(i){case 0:i="Worksheet";break;case 1:i="Macrosheet";break;case 2:i="Chartsheet";break;case 6:i="VBAModule";break;}var s=Qn(e,0,t);if(s.length===0)s="Sheet1";return{pos:a,hs:n,dt:i,name:s}}function Ni(e,r){var t=!r||r.biff>=8?2:1;var a=$r(8+t*e.name.length);a._W(4,e.pos);a._W(1,e.hs||0);a._W(1,e.dt);a._W(1,e.name.length);if(r.biff>=8)a._W(1,1);a._W(t*e.name.length,e.name,r.biff<8?"sbcs":"utf16le");var n=a.slice(0,a.l);n.l=a.l;return n}function Li(e,r){var t=e.l+r;var a=e._R(4);var n=e._R(4);var i=[];for(var s=0;s!=n&&e.l<t;++s){i.push(Jn(e))}i.Count=a;i.Unique=n;return i}function Mi(e,r){var t={};t.dsst=e._R(2);e.l+=r-2;return t}function Ui(e){var r={};r.r=e._R(2);r.c=e._R(2);r.cnt=e._R(2)-r.c;var t=e._R(2);e.l+=4;var a=e._R(1);e.l+=3;if(a&7)r.level=a&7;if(a&32)r.hidden=true;if(a&64)r.hpt=t/20;return r}function Hi(e){var r=vi(e);if(r.type!=2211)throw new Error("Invalid Future Record "+r.type);var t=e._R(4);return t!==0}function Wi(e){e._R(2);return e._R(4)}function zi(e,r,t){var a=0;if(!(t&&t.biff==2)){a=e._R(2)}var n=e._R(2);if(t&&t.biff==2){a=1-(n>>15);n&=32767}var i={Unsynced:a&1,DyZero:(a&2)>>1,ExAsc:(a&4)>>2,ExDsc:(a&8)>>3};return[i,n]}function Vi(e){var r=e._R(2),t=e._R(2),a=e._R(2),n=e._R(2);var i=e._R(2),s=e._R(2),f=e._R(2);var l=e._R(2),o=e._R(2);return{Pos:[r,t],Dim:[a,n],Flags:i,CurTab:s,FirstTab:f,Selected:l,TabRatio:o}}function Xi(){var e=$r(18);e._W(2,0);e._W(2,0);e._W(2,29280);e._W(2,17600);e._W(2,56);e._W(2,0);e._W(2,0);e._W(2,1);e._W(2,500);return e}function Gi(e,r,t){if(t&&t.biff>=2&&t.biff<8)return{};var a=e._R(2);return{RTL:a&64}}function ji(e){var r=$r(18),t=1718;if(e&&e.RTL)t|=64;r._W(2,t);r._W(4,0);r._W(4,64);r._W(4,0);r._W(4,0);return r}function Ki(){}function Yi(e,r,t){var a={dyHeight:e._R(2),fl:e._R(2)};switch(t&&t.biff||8){case 2:break;case 3:;case 4:e.l+=2;break;default:e.l+=10;break;}a.name=Qn(e,0,t);return a}function $i(e,r){var t=e.name||"Arial";var a=r&&r.biff==5,n=a?15+t.length:16+2*t.length;var i=$r(n);i._W(2,(e.sz||12)*20);i._W(4,0);i._W(2,400);i._W(4,0);i._W(2,0);i._W(1,t.length);if(!a)i._W(1,1);i._W((a?1:2)*t.length,t,a?"sbcs":"utf16le");return i}function Zi(e){var r=hi(e);r.isst=e._R(4);return r}function Qi(e,r,t){var a=e.l+r;var n=hi(e,6);if(t.biff==2)e.l++;var i=ei(e,a-e.l,t);n.val=i;return n}function Ji(e,r,t,a,n){var i=!n||n.biff==8;var s=$r(6+2+ +i+(1+i)*t.length);di(e,r,a,s);s._W(2,t.length);if(i)s._W(1,1);s._W((1+i)*t.length,t,i?"utf16le":"sbcs");return s}function qi(e,r,t){var a=e._R(2);var n=ri(e,0,t);return[a,n]}function es(e,r,t,a){var n=t&&t.biff==5;if(!a)a=$r(n?3+r.length:5+2*r.length);a._W(2,e);a._W(n?1:2,r.length);if(!n)a._W(1,1);a._W((n?1:2)*r.length,r,n?"sbcs":"utf16le");var i=a.length>a.l?a.slice(0,a.l):a;if(i.l==null)i.l=i.length;return i}var rs=ri;function ts(e,r,t){var a=e.l+r;var n=t.biff==8||!t.biff?4:2;var i=e._R(n),s=e._R(n);var f=e._R(2),l=e._R(2);e.l=a;return{s:{r:i,c:f},e:{r:s,c:l}}}function as(e,r){var t=r.biff==8||!r.biff?4:2;var a=$r(2*t+6);a._W(t,e.s.r);a._W(t,e.e.r+1);a._W(2,e.s.c);a._W(2,e.e.c+1);a._W(2,0);return a}function ns(e){var r=e._R(2),t=e._R(2);var a=bi(e);return{r:r,c:t,ixfe:a[0],rknum:a[1]}}function is(e,r){var t=e.l+r-2;var a=e._R(2),n=e._R(2);var i=[];while(e.l<t)i.push(bi(e));if(e.l!==t)throw new Error("MulRK read error");var s=e._R(2);if(i.length!=s-n+1)throw new Error("MulRK length mismatch");return{r:a,c:n,C:s,rkrec:i}}function ss(e,r){var t=e.l+r-2;var a=e._R(2),n=e._R(2);var i=[];while(e.l<t)i.push(e._R(2));if(e.l!==t)throw new Error("MulBlank read error");var s=e._R(2);if(i.length!=s-n+1)throw new Error("MulBlank length mismatch");return{r:a,c:n,C:s,ixfe:i}}function fs(e,r,t,a){var n={};var i=e._R(4),s=e._R(4);var f=e._R(4),l=e._R(2);n.patternType=Ca[f>>26];if(!a.cellStyles)return n;n.alc=i&7;n.fWrap=i>>3&1;n.alcV=i>>4&7;n.fJustLast=i>>7&1;n.trot=i>>8&255;n.cIndent=i>>16&15;n.fShrinkToFit=i>>20&1;n.iReadOrder=i>>22&2;n.fAtrNum=i>>26&1;n.fAtrFnt=i>>27&1;n.fAtrAlc=i>>28&1;n.fAtrBdr=i>>29&1;n.fAtrPat=i>>30&1;n.fAtrProt=i>>31&1;n.dgLeft=s&15;n.dgRight=s>>4&15;n.dgTop=s>>8&15;n.dgBottom=s>>12&15;n.icvLeft=s>>16&127;n.icvRight=s>>23&127;n.grbitDiag=s>>30&3;n.icvTop=f&127;n.icvBottom=f>>7&127;n.icvDiag=f>>14&127;n.dgDiag=f>>21&15;n.icvFore=l&127;n.icvBack=l>>7&127;n.fsxButton=l>>14&1;return n}function ls(e,r,t){var a={};a.ifnt=e._R(2);a.numFmtId=e._R(2);a.flags=e._R(2);a.fStyle=a.flags>>2&1;r-=6;a.data=fs(e,r,a.fStyle,t);return a}function os(e,r,t,a){var n=t&&t.biff==5;if(!a)a=$r(n?16:20);a._W(2,0);if(e.style){a._W(2,e.numFmtId||0);a._W(2,65524)}else{a._W(2,e.numFmtId||0);a._W(2,r<<4)}a._W(4,0);a._W(4,0);if(!n)a._W(4,0);a._W(2,0);return a}function cs(e){e.l+=4;var r=[e._R(2),e._R(2)];if(r[0]!==0)r[0]--;if(r[1]!==0)r[1]--;if(r[0]>7||r[1]>7)throw new Error("Bad Gutters: "+r.join("|"));return r}function us(e){var r=$r(8);r._W(4,0);r._W(2,e[0]?e[0]+1:0);r._W(2,e[1]?e[1]+1:0);return r}function hs(e,r,t){var a=hi(e,6);if(t.biff==2)++e.l;var n=$n(e,2);a.val=n;a.t=n===true||n===false?"b":"e";return a}function ds(e,r,t,a,n,i){var s=$r(8);di(e,r,a,s);Zn(t,i,s);return s}function vs(e){var r=hi(e,6);var t=Yt(e,8);r.val=t;return r}function ps(e,r,t,a){var n=$r(14);di(e,r,a,n);$t(t,n);return n}var ms=pi;function bs(e,r,t){var a=e.l+r;var n=e._R(2);var i=e._R(2);t.sbcch=i;if(i==1025||i==14849)return[i,n];if(i<1||i>255)throw new Error("Unexpected SupBook type: "+i);var s=qn(e,i);var f=[];while(a>e.l)f.push(ei(e));return[i,n,s,f]}function gs(e,r,t){var a=e._R(2);var n;var i={fBuiltIn:a&1,fWantAdvise:a>>>1&1,fWantPict:a>>>2&1,fOle:a>>>3&1,fOleLink:a>>>4&1,cf:a>>>5&1023,fIcon:a>>>15&1};if(t.sbcch===14849)n=gi(e,r-2,t);i.body=n||e._R(r-2);if(typeof n==="string")i.Name=n;return i}var ws=["_xlnm.Consolidate_Area","_xlnm.Auto_Open","_xlnm.Auto_Close","_xlnm.Extract","_xlnm.Database","_xlnm.Criteria","_xlnm.Print_Area","_xlnm.Print_Titles","_xlnm.Recorder","_xlnm.Data_Form","_xlnm.Auto_Activate","_xlnm.Auto_Deactivate","_xlnm.Sheet_Title","_xlnm._FilterDatabase"];function ks(e,r,t){var a=e.l+r;var n=e._R(2);var i=e._R(1);var s=e._R(1);var f=e._R(t&&t.biff==2?1:2);var l=0;if(!t||t.biff>=5){if(t.biff!=5)e.l+=2;l=e._R(2);if(t.biff==5)e.l+=2;e.l+=4}var o=qn(e,s,t);if(n&32)o=ws[o.charCodeAt(0)];var c=a-e.l;if(t&&t.biff==2)--c;var u=a==e.l||f===0?[]:Nu(e,c,t,f);return{chKey:i,Name:o,itab:l,rgce:u}}function Es(e,r,t){if(t.biff<8)return Ss(e,r,t);var a=[],n=e.l+r,i=e._R(t.biff>8?4:2);while(i--!==0)a.push(mi(e,t.biff>8?12:6,t));if(e.l!=n)throw new Error("Bad ExternSheet: "+e.l+" != "+n);return a}function Ss(e,r,t){if(e[e.l+1]==3)e[e.l]++;var a=Qn(e,r,t);return a.charCodeAt(0)==3?a.slice(1):a}function _s(e,r,t){if(t.biff<8){e.l+=r;return}var a=e._R(2);var n=e._R(2);var i=qn(e,a,t);var s=qn(e,n,t);return[i,s]}function Cs(e,r,t){var a=Ei(e,6);e.l++;var n=e._R(1);r-=8;return[Lu(e,r,t),n,a]}function Bs(e,r,t){var a=Si(e,6);switch(t.biff){case 2:e.l++;r-=7;break;case 3:;case 4:e.l+=2;r-=8;break;default:e.l+=6;r-=12;}return[a,Ou(e,r,t,a)]}function Ts(e){var r=e._R(4)!==0;var t=e._R(4)!==0;var a=e._R(4);return[r,t,a]}function ys(e,r,t){if(t.biff<8)return;var a=e._R(2),n=e._R(2);var i=e._R(2),s=e._R(2);var f=ri(e,0,t);if(t.biff<8)e._R(1);return[{r:a,c:n},f,s,i]}function xs(e,r,t){return ys(e,r,t)}function As(e,r){var t=[];var a=e._R(2);while(a--)t.push(wi(e,r));return t}function Is(e){var r=$r(2+e.length*8);r._W(2,e.length);for(var t=0;t<e.length;++t)ki(e[t],r);return r}function Rs(e,r,t){if(t&&t.biff<8)return Fs(e,r,t);var a=_i(e,22);var n=xi(e,r-22,a[1]);return{cmo:a,ft:n}}var Ds=[];Ds[8]=function(e,r){var t=e.l+r;e.l+=10;var a=e._R(2);e.l+=4;e.l+=2;e.l+=2;e.l+=2;e.l+=4;var n=e._R(1);e.l+=n;e.l=t;return{fmt:a}};function Fs(e,r,t){e.l+=4;var a=e._R(2);var n=e._R(2);var i=e._R(2);e.l+=2;e.l+=2;e.l+=2;e.l+=2;e.l+=2;e.l+=2;e.l+=2;e.l+=2;e.l+=2;e.l+=6;r-=36;var s=[];s.push((Ds[a]||Yr)(e,r,t));return{cmo:[n,a,i],ft:s}}function Os(e,r,t){var a=e.l;var n="";try{e.l+=4;var i=(t.lastobj||{cmo:[0,0]}).cmo[1];var s;if([0,5,7,11,12,14].indexOf(i)==-1)e.l+=6;else s=ai(e,6,t);var f=e._R(2);e._R(2);jn(e,2);var l=e._R(2);e.l+=l;for(var o=1;o<e.lens.length-1;++o){if(e.l-a!=e.lens[o])throw new Error("TxO: bad continue record");var c=e[e.l];var u=qn(e,e.lens[o+1]-e.lens[o]-1);n+=u;if(n.length>=(c?f:2*f))break}if(n.length!==f&&n.length!==f*2){throw new Error("cchText: "+f+" != "+n.length)}e.l=a+r;return{t:n}}catch(h){e.l=a+r;return{t:n}}}function Ps(e,r){var t=wi(e,8);e.l+=16;var a=li(e,r-24);return[t,a]}function Ns(e){var r=$r(24);var t=vt(e[0]);r._W(2,t.r);r._W(2,t.r);r._W(2,t.c);r._W(2,t.c);var a="d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");for(var n=0;n<16;++n)r._W(1,parseInt(a[n],16));return I([r,oi(e[1])])}function Ls(e,r){e._R(2);var t=wi(e,8);var a=e._R((r-10)/2,"dbcs-cont");a=a.replace(R,"");return[t,a]}function Ms(e){var r=e[1].Tooltip;var t=$r(10+2*(r.length+1));t._W(2,2048);var a=vt(e[0]);t._W(2,a.r);t._W(2,a.r);t._W(2,a.c);t._W(2,a.c);for(var n=0;n<r.length;++n)t._W(2,r.charCodeAt(n));t._W(2,0);return t}function Us(e){var r=[0,0],t;t=e._R(2);r[0]=_a[t]||t;t=e._R(2);r[1]=_a[t]||t;return r}function Hs(e){if(!e)e=$r(4);e._W(2,1);e._W(2,1);return e}function Ws(e){var r=e._R(2);var t=[];while(r-- >0)t.push(ui(e,8));return t}function zs(e){var r=e._R(2);var t=[];while(r-- >0)t.push(ui(e,8));return t}function Vs(e){e.l+=2;var r={cxfs:0,crc:0};r.cxfs=e._R(2);r.crc=e._R(4);return r}function Xs(e,r,t){if(!t.cellStyles)return Yr(e,r);var a=t&&t.biff>=12?4:2;var n=e._R(a);var i=e._R(a);var s=e._R(a);var f=e._R(a);var l=e._R(2);if(a==2)e.l+=2;var o={s:n,e:i,w:s,ixfe:f,flags:l};if(t.biff>=5||!t.biff)o.level=l>>8&7;return o}function Gs(e,r){var t={};if(r<32)return t;e.l+=16;t.header=Yt(e,8);t.footer=Yt(e,8);e.l+=2;return t}function js(e,r,t){var a={area:false};if(t.biff!=5){e.l+=r;return a}var n=e._R(1);e.l+=3;if(n&16)a.area=true;return a}function Ks(e){var r=$r(2*e);for(var t=0;t<e;++t)r._W(2,t+1);return r}var Ys=hi;var $s=Yn;var Zs=ei;function Qs(e){var r=e._R(2);var t=e._R(2);var a=e._R(4);var n={fmt:r,env:t,len:a,data:e.slice(e.l,e.l+a)};e.l+=a;return n}function Js(e,r,t){var a=hi(e,6);++e.l;var n=ri(e,r-7,t);a.t="str";a.val=n;return a}function qs(e){var r=hi(e,6);++e.l;var t=Yt(e,8);r.t="n";r.val=t;return r}function ef(e,r,t){var a=$r(15);Rp(a,e,r);a._W(8,t,"f");return a}function rf(e){var r=hi(e,6);++e.l;var t=e._R(2);r.t="n";r.val=t;return r}function tf(e,r,t){var a=$r(9);Rp(a,e,r);a._W(2,t);return a}function af(e){var r=e._R(1);if(r===0){e.l++;return""}return e._R(r,"sbcs-cont")}function nf(e,r){e.l+=6;e.l+=2;e.l+=1;e.l+=3;e.l+=1;e.l+=r-13}function sf(e,r,t){var a=e.l+r;var n=hi(e,6);var i=e._R(2);var s=qn(e,i,t);e.l=a;n.t="str";n.val=s;return n}var ff=function(){var e={1:437,2:850,3:1252,4:1e4,100:852,101:866,102:865,103:861,104:895,105:620,106:737,107:857,120:950,121:949,122:936,123:932,124:874,125:1255,126:1256,150:10007,151:10029,152:10006,200:1250,201:1251,202:1254,203:1253,0:20127,8:865,9:437,10:850,11:437,13:437,14:850,15:437,16:850,17:437,18:850,19:932,20:850,21:437,22:850,23:865,24:437,25:437,26:850,27:437,28:863,29:850,31:852,34:852,35:852,36:860,37:850,38:866,55:850,64:852,77:936,78:949,79:950,80:874,87:1252,88:1252,89:1252,255:16969};var r=Z({1:437,2:850,3:1252,4:1e4,100:852,101:866,102:865,103:861,104:895,105:620,106:737,107:857,120:950,121:949,122:936,123:932,124:874,125:1255,126:1256,150:10007,151:10029,152:10006,200:1250,201:1251,202:1254,203:1253,0:20127});function a(r,t){var a=[];var n=_(1);switch(t.type){case"base64":n=B(g.decode(r));break;case"binary":n=B(r);break;case"buffer":;case"array":n=r;break;}Kr(n,0);var i=n._R(1);var s=false;var f=false,l=false;switch(i){case 2:;case 3:break;case 48:f=true;s=true;break;case 49:f=true;break;case 131:s=true;break;case 139:s=true;break;case 140:s=true;l=true;break;case 245:s=true;break;default:throw new Error("DBF Unsupported Version: "+i.toString(16));}var o=0,c=0;if(i==2)o=n._R(2);n.l+=3;if(i!=2)o=n._R(4);if(i!=2)c=n._R(2);var u=n._R(2);var h=1252;if(i!=2){n.l+=16;n._R(1);if(n[n.l]!==0)h=e[n[n.l]];n.l+=1;n.l+=2}if(l)n.l+=36;var d=[],v={};var p=c-10-(f?264:0),m=l?32:11;while(i==2?n.l<n.length&&n[n.l]!=13:n.l<p){v={};v.name=cptable.utils.decode(h,n.slice(n.l,n.l+m)).replace(/[\u0000\r\n].*$/g,"");n.l+=m;v.type=String.fromCharCode(n._R(1));if(i!=2&&!l)v.offset=n._R(4);v.len=n._R(1);if(i==2)v.offset=n._R(2);v.dec=n._R(1);if(v.name.length)d.push(v);if(i!=2)n.l+=l?13:14;switch(v.type){case"B":if((!f||v.len!=8)&&t.WTF)console.log("Skipping "+v.name+":"+v.type);break;case"G":;case"P":if(t.WTF)console.log("Skipping "+v.name+":"+v.type);break;case"C":;case"D":;case"F":;case"I":;case"L":;case"M":;case"N":;case"O":;case"T":;case"Y":;case"0":;case"@":;case"+":break;default:throw new Error("Unknown Field Type: "+v.type);}}if(n[n.l]!==13)n.l=c-1;else if(i==2)n.l=521;if(i!=2){if(n._R(1)!==13)throw new Error("DBF Terminator not found "+n.l+" "+n[n.l]);n.l=c}var b=0,w=0;a[0]=[];for(w=0;w!=d.length;++w)a[0][w]=d[w].name;while(o-- >0){if(n[n.l]===42){n.l+=u;continue}++n.l;a[++b]=[];w=0;for(w=0;w!=d.length;++w){var k=n.slice(n.l,n.l+d[w].len);n.l+=d[w].len;Kr(k,0);var E=cptable.utils.decode(h,k);switch(d[w].type){case"C":a[b][w]=cptable.utils.decode(h,k);a[b][w]=a[b][w].trim();break;case"D":if(E.length===8)a[b][w]=new Date(+E.slice(0,4),+E.slice(4,6)-1,+E.slice(6,8));else a[b][w]=E;break;case"F":a[b][w]=parseFloat(E.trim());break;case"+":;case"I":a[b][w]=l?k._R(-4,"i")^2147483648:k._R(4,"i");break;case"L":switch(E.toUpperCase()){case"Y":;case"T":a[b][w]=true;break;case"N":;case"F":a[b][w]=false;break;case" ":;case"?":a[b][w]=false;break;default:throw new Error("DBF Unrecognized L:|"+E+"|");}break;case"M":if(!s)throw new Error("DBF Unexpected MEMO for type "+i.toString(16));a[b][w]="##MEMO##"+(l?parseInt(E.trim(),10):k._R(4));break;case"N":a[b][w]=+E.replace(/\u0000/g,"").trim();break;case"@":a[b][w]=new Date(k._R(-8,"f")-621356832e5);break;case"T":a[b][w]=new Date((k._R(4)-2440588)*864e5+k._R(4));break;case"Y":a[b][w]=k._R(4,"i")/1e4;break;case"O":a[b][w]=-k._R(-8,"f");break;case"B":if(f&&d[w].len==8){a[b][w]=k._R(8,"f");break};case"G":;case"P":k.l+=d[w].len;break;case"0":if(d[w].name==="_NullFlags")break;default:throw new Error("DBF Unsupported data type "+d[w].type);}}}if(i!=2)if(n.l<n.length&&n[n.l++]!=26)throw new Error("DBF EOF Marker missing "+(n.l-1)+" of "+n.length+" "+n[n.l-1].toString(16));if(t&&t.sheetRows)a=a.slice(0,t.sheetRows);return a}function n(e,r){var t=r||{};if(!t.dateNF)t.dateNF="yyyymmdd";return _t(a(e,t),t)}function i(e,r){try{return Et(n(e,r),r)}catch(t){if(r&&r.WTF)throw t}return{SheetNames:[],Sheets:{}}}var s={B:8,C:250,L:1,D:8,"?":0,"":0};function f(e,a){var n=a||{};if(+n.codepage>=0)l(+n.codepage);if(n.type=="string")throw new Error("Cannot write DBF to JS string");var i=Qr();var f=jm(e,{header:1,raw:true,cellDates:true});var o=f[0],c=f.slice(1);var u=0,h=0,d=0,v=1;for(u=0;u<o.length;++u){if(u==null)continue;++d;if(typeof o[u]==="number")o[u]=o[u].toString(10);if(typeof o[u]!=="string")throw new Error("DBF Invalid column name "+o[u]+" |"+typeof o[u]+"|");if(o.indexOf(o[u])!==u)for(h=0;h<1024;++h)if(o.indexOf(o[u]+"_"+h)==-1){o[u]+="_"+h;break}}var p=gt(e["!ref"]);var m=[];for(u=0;u<=p.e.c-p.s.c;++u){var b=[];for(h=0;h<c.length;++h){if(c[h][u]!=null)b.push(c[h][u])}if(b.length==0||o[u]==null){m[u]="?";continue}var g="",w="";for(h=0;h<b.length;++h){switch(typeof b[h]){case"number":w="B";break;case"string":w="C";break;case"boolean":w="L";break;case"object":w=b[h]instanceof Date?"D":"C";break;default:w="C";}g=g&&g!=w?"C":w;if(g=="C")break}v+=s[g]||0;m[u]=g}var k=i.next(32);k._W(4,318902576);k._W(4,c.length);k._W(2,296+32*d);k._W(2,v);for(u=0;u<4;++u)k._W(4,0);k._W(4,0|(+r[t]||3)<<8);for(u=0,h=0;u<o.length;++u){if(o[u]==null)continue;var E=i.next(32);var S=(o[u].slice(-10)+"\0\0\0\0\0\0\0\0\0\0\0").slice(0,11);E._W(1,S,"sbcs");E._W(1,m[u]=="?"?"C":m[u],"sbcs");E._W(4,h);E._W(1,s[m[u]]||0);E._W(1,0);E._W(1,2);E._W(4,0);E._W(1,0);E._W(4,0);E._W(4,0);h+=s[m[u]]||0}var _=i.next(264);_._W(4,13);for(u=0;u<65;++u)_._W(4,0);for(u=0;u<c.length;++u){var C=i.next(v);C._W(1,0);for(h=0;h<o.length;++h){if(o[h]==null)continue;switch(m[h]){case"L":C._W(1,c[u][h]==null?63:c[u][h]?84:70);break;case"B":C._W(8,c[u][h]||0,"f");break;case"D":if(!c[u][h])C._W(8,"00000000","sbcs");else{C._W(4,("0000"+c[u][h].getFullYear()).slice(-4),"sbcs");C._W(2,("00"+(c[u][h].getMonth()+1)).slice(-2),"sbcs");C._W(2,("00"+c[u][h].getDate()).slice(-2),"sbcs")}break;case"C":var B=String(c[u][h]||"");C._W(1,B,"sbcs");for(d=0;d<250-B.length;++d)C._W(1,32);break;}}}i.next(1)._W(1,26);return i.end()}return{to_workbook:i,to_sheet:n,from_sheet:f}}();var lf=function(){var e={AA:"",BA:"",CA:"",DA:195,HA:"",JA:197,AE:"",BE:"",CE:"",HE:"",AI:"",BI:"",CI:"",HI:"",AO:"",BO:"",CO:"",DO:213,HO:"",AU:"",BU:"",CU:"",HU:"",Aa:"",Ba:"",Ca:"",Da:227,Ha:"",Ja:229,Ae:"",Be:"",Ce:"",He:"",Ai:"",Bi:"",Ci:"",Hi:"",Ao:"",Bo:"",Co:"",Do:245,Ho:"",Au:"",Bu:"",Cu:"",Hu:"",KC:"",Kc:"",q:"",z:"",a:"",j:"",DN:209,Dn:241,Hy:255,S:169,c:170,R:174,B:180,0:176,1:177,2:178,3:179,5:181,6:182,7:183,Q:185,k:186,b:208,i:216,l:222,s:240,y:248,"!":161,'"':162,"#":163,"(":164,"%":165,"'":167,"H ":168,"+":171,";":187,"<":188,"=":189,">":190,"?":191,"{":223};var r=new RegExp("N("+K(e).join("|").replace(/\|\|\|/,"|\\||").replace(/([?()+])/g,"\\$1")+"|\\|)","gm");var t=function(r,t){var a=e[t];return typeof a=="number"?p(a):a};var a=function(e,r,t){var a=r.charCodeAt(0)-32<<4|t.charCodeAt(0)-48;return a==59?e:p(a)};e["|"]=254;function n(e,r){switch(r.type){case"base64":return i(g.decode(e),r);case"binary":return i(e,r);case"buffer":return i(e.toString("binary"),r);case"array":return i(fe(e),r);}throw new Error("Unrecognized type "+r.type)}function i(e,n){var i=e.split(/[\n\r]+/),s=-1,f=-1,o=0,c=0,u=[];var h=[];var d=null;var v={},p=[],m=[],b=[];var g=0,w;if(+n.codepage>=0)l(+n.codepage);for(;o!==i.length;++o){g=0;var k=i[o].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g,a).replace(r,t);var E=k.replace(/;;/g,"\0").split(";").map(function(e){return e.replace(/\u0000/g,";")});var S=E[0],_;if(k.length>0)switch(S){case"ID":break;case"E":break;case"B":break;case"O":break;case"P":if(E[1].charAt(0)=="P")h.push(k.slice(3).replace(/;;/g,";"));break;case"C":var C=false,B=false;for(c=1;c<E.length;++c)switch(E[c].charAt(0)){case"X":f=parseInt(E[c].slice(1))-1;B=true;break;case"Y":s=parseInt(E[c].slice(1))-1;if(!B)f=0;for(w=u.length;w<=s;++w)u[w]=[];break;case"K":_=E[c].slice(1);if(_.charAt(0)==='"')_=_.slice(1,_.length-1);else if(_==="TRUE")_=true;else if(_==="FALSE")_=false;else if(!isNaN(ce(_))){_=ce(_);if(d!==null&&F.is_date(d))_=te(_)}else if(!isNaN(ue(_).getDate())){_=se(_)}if(typeof cptable!=="undefined"&&typeof _=="string"&&(n||{}).type!="string"&&(n||{}).codepage)_=cptable.utils.decode(n.codepage,_);C=true;break;case"E":var T=Jo(E[c].slice(1),{r:s,c:f});u[s][f]=[u[s][f],T];break;default:if(n&&n.WTF)throw new Error("SYLK bad record "+k);}if(C){u[s][f]=_;d=null}break;case"F":var y=0;for(c=1;c<E.length;++c)switch(E[c].charAt(0)){case"X":f=parseInt(E[c].slice(1))-1;++y;break;case"Y":s=parseInt(E[c].slice(1))-1;for(w=u.length;w<=s;++w)u[w]=[];break;case"M":g=parseInt(E[c].slice(1))/20;break;case"F":break;case"G":break;case"P":d=h[parseInt(E[c].slice(1))];break;case"S":break;case"D":break;case"N":break;case"W":b=E[c].slice(1).split(" ");for(w=parseInt(b[0],10);w<=parseInt(b[1],10);++w){g=parseInt(b[2],10);m[w-1]=g===0?{hidden:true}:{wch:g};ml(m[w-1])}break;case"C":f=parseInt(E[c].slice(1))-1;if(!m[f])m[f]={};break;case"R":s=parseInt(E[c].slice(1))-1;if(!p[s])p[s]={};if(g>0){p[s].hpt=g;p[s].hpx=kl(g)}else if(g===0)p[s].hidden=true;break;default:if(n&&n.WTF)throw new Error("SYLK bad record "+k);}if(y<1)d=null;break;default:if(n&&n.WTF)throw new Error("SYLK bad record "+k);}}if(p.length>0)v["!rows"]=p;if(m.length>0)v["!cols"]=m;if(n&&n.sheetRows)u=u.slice(0,n.sheetRows);return[u,v]}function s(e,r){var t=n(e,r);var a=t[0],i=t[1];var s=_t(a,r);K(i).forEach(function(e){s[e]=i[e]});return s}function f(e,r){return Et(s(e,r),r)}function o(e,r,t,a){var n="C;Y"+(t+1)+";X"+(a+1)+";K";switch(e.t){case"n":n+=e.v||0;if(e.f&&!e.F)n+=";E"+ec(e.f,{r:t,c:a});break;case"b":n+=e.v?"TRUE":"FALSE";break;case"e":n+=e.w||e.v;break;case"d":n+='"'+(e.w||e.v)+'"';break;case"s":n+='"'+e.v.replace(/"/g,"")+'"';break;}return n}function c(e,r){r.forEach(function(r,t){var a="F;W"+(t+1)+" "+(t+1)+" ";if(r.hidden)a+="0";else{
if(typeof r.width=="number")r.wpx=ul(r.width);if(typeof r.wpx=="number")r.wch=hl(r.wpx);if(typeof r.wch=="number")a+=Math.round(r.wch)}if(a.charAt(a.length-1)!=" ")e.push(a)})}function u(e,r){r.forEach(function(r,t){var a="F;";if(r.hidden)a+="M0;";else if(r.hpt)a+="M"+20*r.hpt+";";else if(r.hpx)a+="M"+20*wl(r.hpx)+";";if(a.length>2)e.push(a+"R"+(t+1))})}function h(e,r){var t=["ID;PWXL;N;E"],a=[];var n=gt(e["!ref"]),i;var s=Array.isArray(e);var f="\r\n";t.push("P;PGeneral");t.push("F;P0;DG0G8;M255");if(e["!cols"])c(t,e["!cols"]);if(e["!rows"])u(t,e["!rows"]);t.push("B;Y"+(n.e.r-n.s.r+1)+";X"+(n.e.c-n.s.c+1)+";D"+[n.s.c,n.s.r,n.e.c,n.e.r].join(" "));for(var l=n.s.r;l<=n.e.r;++l){for(var h=n.s.c;h<=n.e.c;++h){var d=pt({r:l,c:h});i=s?(e[l]||[])[h]:e[d];if(!i||i.v==null&&(!i.f||i.F))continue;a.push(o(i,e,l,h,r))}}return t.join(f)+f+a.join(f)+f+"E"+f}return{to_workbook:f,to_sheet:s,from_sheet:h}}();var of=function(){function e(e,t){switch(t.type){case"base64":return r(g.decode(e),t);case"binary":return r(e,t);case"buffer":return r(e.toString("binary"),t);case"array":return r(fe(e),t);}throw new Error("Unrecognized type "+t.type)}function r(e,r){var t=e.split("\n"),a=-1,n=-1,i=0,s=[];for(;i!==t.length;++i){if(t[i].trim()==="BOT"){s[++a]=[];n=0;continue}if(a<0)continue;var f=t[i].trim().split(",");var l=f[0],o=f[1];++i;var c=t[i].trim();switch(+l){case-1:if(c==="BOT"){s[++a]=[];n=0;continue}else if(c!=="EOD")throw new Error("Unrecognized DIF special command "+c);break;case 0:if(c==="TRUE")s[a][n]=true;else if(c==="FALSE")s[a][n]=false;else if(!isNaN(ce(o)))s[a][n]=ce(o);else if(!isNaN(ue(o).getDate()))s[a][n]=se(o);else s[a][n]=o;++n;break;case 1:c=c.slice(1,c.length-1);s[a][n++]=c!==""?c:null;break;}if(c==="EOD")break}if(r&&r.sheetRows)s=s.slice(0,r.sheetRows);return s}function t(r,t){return _t(e(r,t),t)}function a(e,r){return Et(t(e,r),r)}var n=function(){var e=function t(e,r,a,n,i){e.push(r);e.push(a+","+n);e.push('"'+i.replace(/"/g,'""')+'"')};var r=function a(e,r,t,n){e.push(r+","+t);e.push(r==1?'"'+n.replace(/"/g,'""')+'"':n)};return function n(t){var a=[];var n=gt(t["!ref"]),i;var s=Array.isArray(t);e(a,"TABLE",0,1,"sheetjs");e(a,"VECTORS",0,n.e.r-n.s.r+1,"");e(a,"TUPLES",0,n.e.c-n.s.c+1,"");e(a,"DATA",0,0,"");for(var f=n.s.r;f<=n.e.r;++f){r(a,-1,0,"BOT");for(var l=n.s.c;l<=n.e.c;++l){var o=pt({r:f,c:l});i=s?(t[f]||[])[l]:t[o];if(!i){r(a,1,0,"");continue}switch(i.t){case"n":var c=b?i.w:i.v;if(!c&&i.v!=null)c=i.v;if(c==null){if(b&&i.f&&!i.F)r(a,1,0,"="+i.f);else r(a,1,0,"")}else r(a,0,c,"V");break;case"b":r(a,0,i.v?1:0,i.v?"TRUE":"FALSE");break;case"s":r(a,1,0,!b||isNaN(i.v)?i.v:'="'+i.v+'"');break;case"d":if(!i.w)i.w=F.format(i.z||F._table[14],re(se(i.v)));if(b)r(a,0,i.w,"V");else r(a,1,0,i.w);break;default:r(a,1,0,"");}}}r(a,-1,0,"EOD");var u="\r\n";var h=a.join(u);return h}}();return{to_workbook:a,to_sheet:t,from_sheet:n}}();var cf=function(){function e(e){return e.replace(/\\b/g,"\\").replace(/\\c/g,":").replace(/\\n/g,"\n")}function r(e){return e.replace(/\\/g,"\\b").replace(/:/g,"\\c").replace(/\n/g,"\\n")}function t(r,t){var a=r.split("\n"),n=-1,i=-1,s=0,f=[];for(;s!==a.length;++s){var l=a[s].trim().split(":");if(l[0]!=="cell")continue;var o=vt(l[1]);if(f.length<=o.r)for(n=f.length;n<=o.r;++n)if(!f[n])f[n]=[];n=o.r;i=o.c;switch(l[2]){case"t":f[n][i]=e(l[3]);break;case"v":f[n][i]=+l[3];break;case"vtf":var c=l[l.length-1];case"vtc":switch(l[3]){case"nl":f[n][i]=+l[4]?true:false;break;default:f[n][i]=+l[4];break;}if(l[2]=="vtf")f[n][i]=[f[n][i],c];}}if(t&&t.sheetRows)f=f.slice(0,t.sheetRows);return f}function a(e,r){return _t(t(e,r),r)}function n(e,r){return Et(a(e,r),r)}var i=["socialcalc:version:1.5","MIME-Version: 1.0","Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"].join("\n");var s=["--SocialCalcSpreadsheetControlSave","Content-type: text/plain; charset=UTF-8"].join("\n")+"\n";var f=["# SocialCalc Spreadsheet Control Save","part:sheet"].join("\n");var l="--SocialCalcSpreadsheetControlSave--";function o(e){if(!e||!e["!ref"])return"";var t=[],a=[],n,i="";var s=mt(e["!ref"]);var f=Array.isArray(e);for(var l=s.s.r;l<=s.e.r;++l){for(var o=s.s.c;o<=s.e.c;++o){i=pt({r:l,c:o});n=f?(e[l]||[])[o]:e[i];if(!n||n.v==null||n.t==="z")continue;a=["cell",i,"t"];switch(n.t){case"s":;case"str":a.push(r(n.v));break;case"n":if(!n.f){a[2]="v";a[3]=n.v}else{a[2]="vtf";a[3]="n";a[4]=n.v;a[5]=r(n.f)}break;case"b":a[2]="vt"+(n.f?"f":"c");a[3]="nl";a[4]=n.v?"1":"0";a[5]=r(n.f||(n.v?"TRUE":"FALSE"));break;case"d":var c=re(se(n.v));a[2]="vtc";a[3]="nd";a[4]=""+c;a[5]=n.w||F.format(n.z||F._table[14],c);break;case"e":continue;}t.push(a.join(":"))}}t.push("sheet:c:"+(s.e.c-s.s.c+1)+":r:"+(s.e.r-s.s.r+1)+":tvf:1");t.push("valueformat:1:text-wiki");return t.join("\n")}function c(e){return[i,s,f,s,o(e),l].join("\n")}return{to_workbook:n,to_sheet:a,from_sheet:c}}();var uf=function(){function e(e,r,t,a,n){if(n.raw)r[t][a]=e;else if(e==="TRUE")r[t][a]=true;else if(e==="FALSE")r[t][a]=false;else if(e===""){}else if(!isNaN(ce(e)))r[t][a]=ce(e);else if(!isNaN(ue(e).getDate()))r[t][a]=se(e);else r[t][a]=e}function r(r,t){var a=t||{};var n=[];if(!r||r.length===0)return n;var i=r.split(/[\r\n]/);var s=i.length-1;while(s>=0&&i[s].length===0)--s;var f=10,l=0;var o=0;for(;o<=s;++o){l=i[o].indexOf(" ");if(l==-1)l=i[o].length;else l++;f=Math.max(f,l)}for(o=0;o<=s;++o){n[o]=[];var c=0;e(i[o].slice(0,f).trim(),n,o,c,a);for(c=1;c<=(i[o].length-f)/10+1;++c)e(i[o].slice(f+(c-1)*10,f+c*10).trim(),n,o,c,a)}if(a.sheetRows)n=n.slice(0,a.sheetRows);return n}var t={44:",",9:"\t",59:";"};var a={44:3,9:2,59:1};function n(e){var r={},n=false,i=0,s=0;for(;i<e.length;++i){if((s=e.charCodeAt(i))==34)n=!n;else if(!n&&s in t)r[s]=(r[s]||0)+1}s=[];for(i in r)if(r.hasOwnProperty(i)){s.push([r[i],i])}if(!s.length){r=a;for(i in r)if(r.hasOwnProperty(i)){s.push([r[i],i])}}s.sort(function(e,r){return e[0]-r[0]||a[e[1]]-a[r[1]]});return t[s.pop()[1]]}function i(e,r){var t=r||{};var a="";if(m!=null&&t.dense==null)t.dense=m;var i=t.dense?[]:{};var s={s:{c:0,r:0},e:{c:0,r:0}};if(e.slice(0,4)=="sep="&&e.charCodeAt(5)==10){a=e.charAt(4);e=e.slice(6)}else a=n(e.slice(0,1024));var f=0,l=0,o=0;var c=0,u=0,h=a.charCodeAt(0),d=false,v=0;e=e.replace(/\r\n/gm,"\n");var p=t.dateNF!=null?M(t.dateNF):null;function b(){var r=e.slice(c,u);var a={};if(r.charAt(0)=='"'&&r.charAt(r.length-1)=='"')r=r.slice(1,-1).replace(/""/g,'"');if(r.length===0)a.t="z";else if(t.raw){a.t="s";a.v=r}else if(r.trim().length===0){a.t="s";a.v=r}else if(r.charCodeAt(0)==61){if(r.charCodeAt(1)==34&&r.charCodeAt(r.length-1)==34){a.t="s";a.v=r.slice(2,-1).replace(/""/g,'"')}else if(ac(r)){a.t="n";a.f=r.slice(1)}else{a.t="s";a.v=r}}else if(r=="TRUE"){a.t="b";a.v=true}else if(r=="FALSE"){a.t="b";a.v=false}else if(!isNaN(o=ce(r))){a.t="n";if(t.cellText!==false)a.w=r;a.v=o}else if(!isNaN(ue(r).getDate())||p&&r.match(p)){a.z=t.dateNF||F._table[14];var n=0;if(p&&r.match(p)){r=U(r,t.dateNF,r.match(p)||[]);n=1}if(t.cellDates){a.t="d";a.v=se(r,n)}else{a.t="n";a.v=re(se(r,n))}if(t.cellText!==false)a.w=F.format(a.z,a.v instanceof Date?re(a.v):a.v);if(!t.cellNF)delete a.z}else{a.t="s";a.v=r}if(a.t=="z"){}else if(t.dense){if(!i[f])i[f]=[];i[f][l]=a}else i[pt({c:l,r:f})]=a;c=u+1;if(s.e.c<l)s.e.c=l;if(s.e.r<f)s.e.r=f;if(v==h)++l;else{l=0;++f;if(t.sheetRows&&t.sheetRows<=f)return true}}e:for(;u<e.length;++u)switch(v=e.charCodeAt(u)){case 34:d=!d;break;case h:;case 10:;case 13:if(!d&&b())break e;break;default:break;}if(u-c>0)b();i["!ref"]=bt(s);return i}function s(e,t){if(e.slice(0,4)=="sep=")return i(e,t);if(e.indexOf("\t")>=0||e.indexOf(",")>=0||e.indexOf(";")>=0)return i(e,t);return _t(r(e,t),t)}function f(e,r){var t="",a=r.type=="string"?[0,0,0,0]:Bm(e,r);switch(r.type){case"base64":t=g.decode(e);break;case"binary":t=e;break;case"buffer":if(r.codepage==65001)t=e.toString("utf8");else if(r.codepage&&typeof cptable!=="undefined")t=cptable.utils.decode(r.codepage,e);else t=e.toString("binary");break;case"array":t=fe(e);break;case"string":t=e;break;default:throw new Error("Unrecognized type "+r.type);}if(a[0]==239&&a[1]==187&&a[2]==191)t=Ke(t.slice(3));else if(r.type=="binary"&&typeof cptable!=="undefined"&&r.codepage)t=cptable.utils.decode(r.codepage,cptable.utils.encode(1252,t));if(t.slice(0,19)=="socialcalc:version:")return cf.to_sheet(r.type=="string"?t:Ke(t),r);return s(t,r)}function l(e,r){return Et(f(e,r),r)}function o(e){var r=[];var t=gt(e["!ref"]),a;var n=Array.isArray(e);for(var i=t.s.r;i<=t.e.r;++i){var s=[];for(var f=t.s.c;f<=t.e.c;++f){var l=pt({r:i,c:f});a=n?(e[i]||[])[f]:e[l];if(!a||a.v==null){s.push("          ");continue}var o=(a.w||(kt(a),a.w)||"").slice(0,10);while(o.length<10)o+=" ";s.push(o+(f===0?" ":""))}r.push(s.join(""))}return r.join("\n")}return{to_workbook:l,to_sheet:f,from_sheet:o}}();function hf(e,r){var t=r||{},a=!!t.WTF;t.WTF=true;try{var n=lf.to_workbook(e,t);t.WTF=a;return n}catch(i){t.WTF=a;if(!i.message.match(/SYLK bad record ID/)&&a)throw i;return uf.to_workbook(e,r)}}var df=function(){function e(e,r,t){if(!e)return;Kr(e,e.l||0);var a=t.Enum||w;while(e.l<e.length){var n=e._R(2);var i=a[n]||a[255];var s=e._R(2);var f=e.l+s;var l=(i.f||Yr)(e,s,t);e.l=f;if(r(l,i.n,n))return}}function r(e,r){switch(r.type){case"base64":return t(B(g.decode(e)),r);case"binary":return t(B(e),r);case"buffer":;case"array":return t(e,r);}throw"Unsupported type "+r.type}function t(r,t){if(!r)return r;var a=t||{};if(m!=null&&a.dense==null)a.dense=m;var n=a.dense?[]:{},i="Sheet1",s=0;var f={},l=[i];var o={s:{r:0,c:0},e:{r:0,c:0}};var c=a.sheetRows||0;if(r[2]==2)a.Enum=w;else if(r[2]==26)a.Enum=k;else if(r[2]==14){a.Enum=k;a.qpro=true;r.l=0}else throw new Error("Unrecognized LOTUS BOF "+r[2]);e(r,function(e,t,u){if(r[2]==2)switch(u){case 0:a.vers=e;if(e>=4096)a.qpro=true;break;case 6:o=e;break;case 15:if(!a.qpro)e[1].v=e[1].v.slice(1);case 13:;case 14:;case 16:;case 51:if(u==14&&(e[2]&112)==112&&(e[2]&15)>1&&(e[2]&15)<15){e[1].z=a.dateNF||F._table[14];if(a.cellDates){e[1].t="d";e[1].v=te(e[1].v)}}if(a.dense){if(!n[e[0].r])n[e[0].r]=[];n[e[0].r][e[0].c]=e[1]}else n[pt(e[0])]=e[1];break;}else switch(u){case 22:e[1].v=e[1].v.slice(1);case 23:;case 24:;case 25:;case 37:;case 39:;case 40:if(e[3]>s){n["!ref"]=bt(o);f[i]=n;n=a.dense?[]:{};o={s:{r:0,c:0},e:{r:0,c:0}};s=e[3];i="Sheet"+(s+1);l.push(i)}if(c>0&&e[0].r>=c)break;if(a.dense){if(!n[e[0].r])n[e[0].r]=[];n[e[0].r][e[0].c]=e[1]}else n[pt(e[0])]=e[1];if(o.e.c<e[0].c)o.e.c=e[0].c;if(o.e.r<e[0].r)o.e.r=e[0].r;break;default:break;}},a);n["!ref"]=bt(o);f[i]=n;return{SheetNames:l,Sheets:f}}function a(e){var r={s:{c:0,r:0},e:{c:0,r:0}};r.s.c=e._R(2);r.s.r=e._R(2);r.e.c=e._R(2);r.e.r=e._R(2);if(r.s.c==65535)r.s.c=r.e.c=r.s.r=r.e.r=0;return r}function n(e,r,t){var a=[{c:0,r:0},{t:"n",v:0},0];if(t.qpro&&t.vers!=20768){a[0].c=e._R(1);e.l++;a[0].r=e._R(2);e.l+=2}else{a[2]=e._R(1);a[0].c=e._R(2);a[0].r=e._R(2)}return a}function i(e,r,t){var a=e.l+r;var i=n(e,r,t);i[1].t="s";if(t.vers==20768){e.l++;var s=e._R(1);i[1].v=e._R(s,"utf8");return i}if(t.qpro)e.l++;i[1].v=e._R(a-e.l,"cstr");return i}function s(e,r,t){var a=n(e,r,t);a[1].v=e._R(2,"i");return a}function f(e,r,t){var a=n(e,r,t);a[1].v=e._R(8,"f");return a}function l(e,r,t){var a=e.l+r;var i=n(e,r,t);i[1].v=e._R(8,"f");if(t.qpro)e.l=a;else{var s=e._R(2);e.l+=s}return i}function o(e){var r=[{c:0,r:0},{t:"n",v:0},0];r[0].r=e._R(2);r[3]=e[e.l++];r[0].c=e[e.l++];return r}function c(e,r){var t=o(e,r);t[1].t="s";t[1].v=e._R(r-4,"cstr");return t}function u(e,r){var t=o(e,r);t[1].v=e._R(2);var a=t[1].v>>1;if(t[1].v&1){switch(a&7){case 1:a=(a>>3)*500;break;case 2:a=(a>>3)/20;break;case 4:a=(a>>3)/2e3;break;case 6:a=(a>>3)/16;break;case 7:a=(a>>3)/64;break;default:throw"unknown NUMBER_18 encoding "+(a&7);}}t[1].v=a;return t}function h(e,r){var t=o(e,r);var a=e._R(4);var n=e._R(4);var i=e._R(2);if(i==65535){t[1].v=0;return t}var s=i&32768;i=(i&32767)-16446;t[1].v=(s*2-1)*((i>0?n<<i:n>>>-i)+(i>-32?a<<i+32:a>>>-(i+32)));return t}function d(e,r){var t=h(e,14);e.l+=r-14;return t}function v(e,r){var t=o(e,r);var a=e._R(4);t[1].v=a>>6;return t}function p(e,r){var t=o(e,r);var a=e._R(8,"f");t[1].v=a;return t}function b(e,r){var t=p(e,14);e.l+=r-10;return t}var w={0:{n:"BOF",f:jn},1:{n:"EOF"},2:{n:"CALCMODE"},3:{n:"CALCORDER"},4:{n:"SPLIT"},5:{n:"SYNC"},6:{n:"RANGE",f:a},7:{n:"WINDOW1"},8:{n:"COLW1"},9:{n:"WINTWO"},10:{n:"COLW2"},11:{n:"NAME"},12:{n:"BLANK"},13:{n:"INTEGER",f:s},14:{n:"NUMBER",f:f},15:{n:"LABEL",f:i},16:{n:"FORMULA",f:l},24:{n:"TABLE"},25:{n:"ORANGE"},26:{n:"PRANGE"},27:{n:"SRANGE"},28:{n:"FRANGE"},29:{n:"KRANGE1"},32:{n:"HRANGE"},35:{n:"KRANGE2"},36:{n:"PROTEC"},37:{n:"FOOTER"},38:{n:"HEADER"},39:{n:"SETUP"},40:{n:"MARGINS"},41:{n:"LABELFMT"},42:{n:"TITLES"},43:{n:"SHEETJS"},45:{n:"GRAPH"},46:{n:"NGRAPH"},47:{n:"CALCCOUNT"},48:{n:"UNFORMATTED"},49:{n:"CURSORW12"},50:{n:"WINDOW"},51:{n:"STRING",f:i},55:{n:"PASSWORD"},56:{n:"LOCKED"},60:{n:"QUERY"},61:{n:"QUERYNAME"},62:{n:"PRINT"},63:{n:"PRINTNAME"},64:{n:"GRAPH2"},65:{n:"GRAPHNAME"},66:{n:"ZOOM"},67:{n:"SYMSPLIT"},68:{n:"NSROWS"},69:{n:"NSCOLS"},70:{n:"RULER"},71:{n:"NNAME"},72:{n:"ACOMM"},73:{n:"AMACRO"},74:{n:"PARSE"},255:{n:"",f:Yr}};var k={0:{n:"BOF"},1:{n:"EOF"},3:{n:"??"},4:{n:"??"},5:{n:"??"},6:{n:"??"},7:{n:"??"},9:{n:"??"},10:{n:"??"},11:{n:"??"},12:{n:"??"},14:{n:"??"},15:{n:"??"},16:{n:"??"},17:{n:"??"},18:{n:"??"},19:{n:"??"},21:{n:"??"},22:{n:"LABEL16",f:c},23:{n:"NUMBER17",f:h},24:{n:"NUMBER18",f:u},25:{n:"FORMULA19",f:d},26:{n:"??"},27:{n:"??"},28:{n:"??"},29:{n:"??"},30:{n:"??"},31:{n:"??"},33:{n:"??"},37:{n:"NUMBER25",f:v},39:{n:"NUMBER27",f:p},40:{n:"FORMULA28",f:b},255:{n:"",f:Yr}};return{to_workbook:r}}();function vf(e){var r={},t=e.match(Ae),a=0;var n=false;if(t)for(;a!=t.length;++a){var s=De(t[a]);switch(s[0].replace(/\w*:/g,"")){case"<condense":break;case"<extend":break;case"<shadow":if(!s.val)break;case"<shadow>":;case"<shadow/>":r.shadow=1;break;case"</shadow>":break;case"<charset":if(s.val=="1")break;r.cp=i[parseInt(s.val,10)];break;case"<outline":if(!s.val)break;case"<outline>":;case"<outline/>":r.outline=1;break;case"</outline>":break;case"<rFont":r.name=s.val;break;case"<sz":r.sz=s.val;break;case"<strike":if(!s.val)break;case"<strike>":;case"<strike/>":r.strike=1;break;case"</strike>":break;case"<u":if(!s.val)break;switch(s.val){case"double":r.uval="double";break;case"singleAccounting":r.uval="single-accounting";break;case"doubleAccounting":r.uval="double-accounting";break;};case"<u>":;case"<u/>":r.u=1;break;case"</u>":break;case"<b":if(s.val=="0")break;case"<b>":;case"<b/>":r.b=1;break;case"</b>":break;case"<i":if(s.val=="0")break;case"<i>":;case"<i/>":r.i=1;break;case"</i>":break;case"<color":if(s.rgb)r.color=s.rgb.slice(2,8);break;case"<family":r.family=s.val;break;case"<vertAlign":r.valign=s.val;break;case"<scheme":break;case"<extLst":;case"<extLst>":;case"</extLst>":break;case"<ext":n=true;break;case"</ext>":n=false;break;default:if(s[0].charCodeAt(1)!==47&&!n)throw new Error("Unrecognized rich format "+s[0]);}}return r}var pf=function(){var e=Je("t"),r=Je("rPr");function t(t){var a=t.match(e);if(!a)return{t:"s",v:""};var n={t:"s",v:Ne(a[1])};var i=t.match(r);if(i)n.s=vf(i[1]);return n}var a=/<(?:\w+:)?r>/g,n=/<\/(?:\w+:)?r>/;return function i(e){return e.replace(a,"").split(n).map(t).filter(function(e){return e.v})}}();var mf=function Sb(){var e=/(\r\n|\n)/g;function r(e,r,t){var a=[];if(e.u)a.push("text-decoration: underline;");if(e.uval)a.push("text-underline-style:"+e.uval+";");if(e.sz)a.push("font-size:"+e.sz+"pt;");if(e.outline)a.push("text-effect: outline;");if(e.shadow)a.push("text-shadow: auto;");r.push('<span style="'+a.join("")+'">');if(e.b){r.push("<b>");t.push("</b>")}if(e.i){r.push("<i>");t.push("</i>")}if(e.strike){r.push("<s>");t.push("</s>")}var n=e.valign||"";if(n=="superscript"||n=="super")n="sup";else if(n=="subscript")n="sub";if(n!=""){r.push("<"+n+">");t.push("</"+n+">")}t.push("</span>");return e}function t(t){var a=[[],t.v,[]];if(!t.v)return"";if(t.s)r(t.s,a[0],a[2]);return a[0].join("")+a[1].replace(e,"<br/>")+a[2].join("")}return function a(e){return e.map(t).join("")}}();var bf=/<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g,gf=/<(?:\w+:)?r>/;var wf=/<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;function kf(e,r){var t=r?r.cellHTML:true;var a={};if(!e)return null;if(e.match(/^\s*<(?:\w+:)?t[^>]*>/)){a.t=Ne(Ke(e.slice(e.indexOf(">")+1).split(/<\/(?:\w+:)?t>/)[0]||""));a.r=Ke(e);if(t)a.h=ze(a.t)}else if(e.match(gf)){a.r=Ke(e);a.t=Ne(Ke((e.replace(wf,"").match(bf)||[]).join("").replace(Ae,"")));if(t)a.h=mf(pf(a.r))}return a}var Ef=/<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/;var Sf=/<(?:\w+:)?(?:si|sstItem)>/g;var _f=/<\/(?:\w+:)?(?:si|sstItem)>/;function Cf(e,r){var t=[],a="";if(!e)return t;var n=e.match(Ef);if(n){a=n[2].replace(Sf,"").split(_f);for(var i=0;i!=a.length;++i){var s=kf(a[i].trim(),r);if(s!=null)t[t.length]=s}n=De(n[1]);t.Count=n.count;t.Unique=n.uniqueCount}return t}Na.SST="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings";var Bf=/^\s|\s$|[\t\n\r]/;function Tf(e,r){if(!r.bookSST)return"";var t=[ye];t[t.length]=fr("sst",null,{xmlns:cr.main[0],count:e.Count,uniqueCount:e.Unique});for(var a=0;a!=e.length;++a){if(e[a]==null)continue;var n=e[a];var i="<si>";if(n.r)i+=n.r;else{i+="<t";if(!n.t)n.t="";if(n.t.match(Bf))i+=' xml:space="preserve"';i+=">"+Ue(n.t)+"</t>"}i+="</si>";t[t.length]=i}if(t.length>2){t[t.length]="</sst>";t[1]=t[1].replace("/>",">")}return t.join("")}function yf(e){return[e._R(4),e._R(4)]}function xf(e,r){var t=[];var a=false;Zr(e,function n(e,i,s){switch(s){case 159:t.Count=e[0];t.Unique=e[1];break;case 19:t.push(e);break;case 160:return true;case 35:a=true;break;case 36:a=false;break;default:if(i.indexOf("Begin")>0){}else if(i.indexOf("End")>0){}if(!a||r.WTF)throw new Error("Unexpected record "+s+" "+i);}});return t}function Af(e,r){if(!r)r=$r(8);r._W(4,e.Count);r._W(4,e.Unique);return r}var If=It;function Rf(e){var r=Qr();Jr(r,"BrtBeginSst",Af(e));for(var t=0;t<e.length;++t)Jr(r,"BrtSSTItem",If(e[t]));Jr(r,"BrtEndSst");return r.end()}function Df(e){if(typeof cptable!=="undefined")return cptable.utils.encode(t,e);var r=[],a=e.split("");for(var n=0;n<a.length;++n)r[n]=a[n].charCodeAt(0);return r}function Ff(e,r){var t={};t.Major=e._R(2);t.Minor=e._R(2);if(r>=4)e.l+=r-4;return t}function Of(e){var r={};r.id=e._R(0,"lpp4");r.R=Ff(e,4);r.U=Ff(e,4);r.W=Ff(e,4);return r}function Pf(e){var r=e._R(4);var t=e.l+r-4;var a={};var n=e._R(4);var i=[];while(n-- >0)i.push({t:e._R(4),v:e._R(0,"lpp4")});a.name=e._R(0,"lpp4");a.comps=i;if(e.l!=t)throw new Error("Bad DataSpaceMapEntry: "+e.l+" != "+t);return a}function Nf(e){var r=[];e.l+=4;var t=e._R(4);while(t-- >0)r.push(Pf(e));return r}function Lf(e){var r=[];e.l+=4;var t=e._R(4);while(t-- >0)r.push(e._R(0,"lpp4"));return r}function Mf(e){var r={};e._R(4);e.l+=4;r.id=e._R(0,"lpp4");r.name=e._R(0,"lpp4");r.R=Ff(e,4);r.U=Ff(e,4);r.W=Ff(e,4);return r}function Uf(e){var r=Mf(e);r.ename=e._R(0,"8lpp4");r.blksz=e._R(4);r.cmode=e._R(4);if(e._R(4)!=4)throw new Error("Bad !Primary record");return r}function Hf(e,r){var t=e.l+r;var a={};a.Flags=e._R(4)&63;e.l+=4;a.AlgID=e._R(4);var n=false;switch(a.AlgID){case 26126:;case 26127:;case 26128:n=a.Flags==36;break;case 26625:n=a.Flags==4;break;case 0:n=a.Flags==16||a.Flags==4||a.Flags==36;break;default:throw"Unrecognized encryption algorithm: "+a.AlgID;}if(!n)throw new Error("Encryption Flags/AlgID mismatch");a.AlgIDHash=e._R(4);a.KeySize=e._R(4);a.ProviderType=e._R(4);e.l+=8;a.CSPName=e._R(t-e.l>>1,"utf16le");e.l=t;return a}function Wf(e,r){var t={},a=e.l+r;e.l+=4;t.Salt=e.slice(e.l,e.l+16);e.l+=16;t.Verifier=e.slice(e.l,e.l+16);e.l+=16;e._R(4);t.VerifierHash=e.slice(e.l,a);e.l=a;return t}function zf(e){var r=Ff(e);switch(r.Minor){case 2:return[r.Minor,Vf(e,r)];case 3:return[r.Minor,Xf(e,r)];case 4:return[r.Minor,Gf(e,r)];}throw new Error("ECMA-376 Encrypted file unrecognized Version: "+r.Minor)}function Vf(e){var r=e._R(4);if((r&63)!=36)throw new Error("EncryptionInfo mismatch");var t=e._R(4);var a=Hf(e,t);var n=Wf(e,e.length-e.l);return{t:"Std",h:a,v:n}}function Xf(){throw new Error("File is password-protected: ECMA-376 Extensible")}function Gf(e){var r=["saltSize","blockSize","keyBits","hashSize","cipherAlgorithm","cipherChaining","hashAlgorithm","saltValue"];e.l+=4;var t=e._R(e.length-e.l,"utf8");var a={};t.replace(Ae,function n(e){var t=De(e);switch(Fe(t[0])){case"<?xml":break;case"<encryption":;case"</encryption>":break;case"<keyData":r.forEach(function(e){a[e]=t[e]});break;case"<dataIntegrity":a.encryptedHmacKey=t.encryptedHmacKey;a.encryptedHmacValue=t.encryptedHmacValue;break;case"<keyEncryptors>":;case"<keyEncryptors":a.encs=[];break;case"</keyEncryptors>":break;case"<keyEncryptor":a.uri=t.uri;break;case"</keyEncryptor>":break;case"<encryptedKey":a.encs.push(t);break;default:throw t[0];}});return a}function jf(e,r){var t={};var a=t.EncryptionVersionInfo=Ff(e,4);r-=4;if(a.Minor!=2)throw new Error("unrecognized minor version code: "+a.Minor);if(a.Major>4||a.Major<2)throw new Error("unrecognized major version code: "+a.Major);t.Flags=e._R(4);r-=4;var n=e._R(4);r-=4;t.EncryptionHeader=Hf(e,n);r-=n;t.EncryptionVerifier=Wf(e,r);return t}function Kf(e){var r={};var t=r.EncryptionVersionInfo=Ff(e,4);if(t.Major!=1||t.Minor!=1)throw"unrecognized version code "+t.Major+" : "+t.Minor;r.Salt=e._R(16);r.EncryptedVerifier=e._R(16);r.EncryptedVerifierHash=e._R(16);return r}function Yf(e){var r=0,t;var a=Df(e);var n=a.length+1,i,s;var f,l,o;t=_(n);t[0]=a.length;for(i=1;i!=n;++i)t[i]=a[i-1];for(i=n-1;i>=0;--i){s=t[i];f=(r&16384)===0?0:1;l=r<<1&32767;o=f|l;r=o^s}return r^52811}var $f=function(){var e=[187,255,255,186,255,255,185,128,0,190,15,0,191,15,0];var r=[57840,7439,52380,33984,4364,3600,61902,12606,6258,57657,54287,34041,10252,43370,20163];var t=[44796,19929,39858,10053,20106,40212,10761,31585,63170,64933,60267,50935,40399,11199,17763,35526,1453,2906,5812,11624,23248,885,1770,3540,7080,14160,28320,56640,55369,41139,20807,41614,21821,43642,17621,28485,56970,44341,19019,38038,14605,29210,60195,50791,40175,10751,21502,43004,24537,18387,36774,3949,7898,15796,31592,63184,47201,24803,49606,37805,14203,28406,56812,17824,35648,1697,3394,6788,13576,27152,43601,17539,35078,557,1114,2228,4456,30388,60776,51953,34243,7079,14158,28316,14128,28256,56512,43425,17251,34502,7597,13105,26210,52420,35241,883,1766,3532,4129,8258,16516,33032,4657,9314,18628];var a=function(e){return(e/2|e*128)&255};var n=function(e,r){return a(e^r)};var i=function(e){var a=r[e.length-1];var n=104;for(var i=e.length-1;i>=0;--i){var s=e[i];for(var f=0;f!=7;++f){if(s&64)a^=t[n];s*=2;--n}}return a};return function(r){var t=Df(r);var a=i(t);var s=t.length;var f=_(16);for(var l=0;l!=16;++l)f[l]=0;var o,c,u;if((s&1)===1){o=a>>8;f[s]=n(e[0],o);--s;o=a&255;c=t[t.length-1];f[s]=n(c,o)}while(s>0){--s;o=a>>8;f[s]=n(t[s],o);--s;o=a&255;f[s]=n(t[s],o)}s=15;u=15-t.length;while(u>0){o=a>>8;f[s]=n(e[u],o);--s;--u;o=a&255;f[s]=n(t[s],o);--s;--u}return f}}();var Zf=function(e,r,t,a,n){if(!n)n=r;if(!a)a=$f(e);var i,s;for(i=0;i!=r.length;++i){s=r[i];s^=a[t];s=(s>>5|s<<3)&255;n[i]=s;++t}return[n,t,a]};var Qf=function(e){var r=0,t=$f(e);return function(e){var a=Zf("",e,r,t);r=a[1];return a[0]}};function Jf(e,r,t,a){var n={key:jn(e),verificationBytes:jn(e)};if(t.password)n.verifier=Yf(t.password);a.valid=n.verificationBytes===n.verifier;if(a.valid)a.insitu=Qf(t.password);return n}function qf(e,r,t){var a=t||{};a.Info=e._R(2);e.l-=2;if(a.Info===1)a.Data=Kf(e,r);else a.Data=jf(e,r);return a}function el(e,r,t){var a={Type:t.biff>=8?e._R(2):0};if(a.Type)qf(e,r-2,a);else Jf(e,t.biff>=8?r:r-2,t,a);return a}var rl=function(){function e(e,t){switch(t.type){case"base64":return r(g.decode(e),t);case"binary":return r(e,t);case"buffer":return r(e.toString("binary"),t);case"array":return r(fe(e),t);}throw new Error("Unrecognized type "+t.type)}function r(e,r){var t=r||{};var a=t.dense?[]:{};var n={s:{c:0,r:0},e:{c:0,r:0}};if(!e.match(/\\trowd/))throw new Error("RTF missing table");a["!ref"]=bt(n);return a}function t(r,t){return Et(e(r,t),t)}function a(e){var r=["{\\rtf1\\ansi"];var t=gt(e["!ref"]),a;var n=Array.isArray(e);for(var i=t.s.r;i<=t.e.r;++i){r.push("\\trowd\\trautofit1");for(var s=t.s.c;s<=t.e.c;++s)r.push("\\cellx"+(s+1));r.push("\\pard\\intbl");for(s=t.s.c;s<=t.e.c;++s){var f=pt({r:i,c:s});a=n?(e[i]||[])[s]:e[f];if(!a||a.v==null&&(!a.f||a.F))continue;r.push(" "+(a.w||(kt(a),a.w)));r.push("\\cell")}r.push("\\pard\\intbl\\row")}return r.join("")+"}"}return{to_workbook:t,to_sheet:e,from_sheet:a}}();function tl(e){var r=e.slice(e[0]==="#"?1:0).slice(0,6);return[parseInt(r.slice(0,2),16),parseInt(r.slice(2,4),16),parseInt(r.slice(4,6),16)]}function al(e){for(var r=0,t=1;r!=3;++r)t=t*256+(e[r]>255?255:e[r]<0?0:e[r]);return t.toString(16).toUpperCase().slice(1)}function nl(e){var r=e[0]/255,t=e[1]/255,a=e[2]/255;var n=Math.max(r,t,a),i=Math.min(r,t,a),s=n-i;if(s===0)return[0,0,r];var f=0,l=0,o=n+i;l=s/(o>1?2-o:o);switch(n){case r:f=((t-a)/s+6)%6;break;case t:f=(a-r)/s+2;break;case a:f=(r-t)/s+4;break;}return[f/6,l,o/2]}function il(e){var r=e[0],t=e[1],a=e[2];var n=t*2*(a<.5?a:1-a),i=a-n/2;var s=[i,i,i],f=6*r;var l;if(t!==0)switch(f|0){case 0:;case 6:l=n*f;s[0]+=n;s[1]+=l;break;case 1:l=n*(2-f);s[0]+=l;s[1]+=n;break;case 2:l=n*(f-2);s[1]+=n;s[2]+=l;break;case 3:l=n*(4-f);s[1]+=l;s[2]+=n;break;case 4:l=n*(f-4);s[2]+=n;s[0]+=l;break;case 5:l=n*(6-f);s[2]+=l;s[0]+=n;break;}for(var o=0;o!=3;++o)s[o]=Math.round(s[o]*255);return s}function sl(e,r){if(r===0)return e;var t=nl(tl(e));if(r<0)t[2]=t[2]*(1+r);else t[2]=1-(1-t[2])*(1-r);return al(il(t))}var fl=6,ll=15,ol=1,cl=fl;function ul(e){return Math.floor((e+Math.round(128/cl)/256)*cl)}function hl(e){return Math.floor((e-5)/cl*100+.5)/100}function dl(e){return Math.round((e*cl+5)/cl*256)/256}function vl(e){return dl(hl(ul(e)))}function pl(e){var r=Math.abs(e-vl(e)),t=cl;if(r>.005)for(cl=ol;cl<ll;++cl)if(Math.abs(e-vl(e))<=r){r=Math.abs(e-vl(e));t=cl}cl=t}function ml(e){if(e.width){e.wpx=ul(e.width);e.wch=hl(e.wpx);e.MDW=cl}else if(e.wpx){e.wch=hl(e.wpx);e.width=dl(e.wch);e.MDW=cl}else if(typeof e.wch=="number"){e.width=dl(e.wch);e.wpx=ul(e.width);e.MDW=cl}if(e.customWidth)delete e.customWidth}var bl=96,gl=bl;function wl(e){return e*96/gl}function kl(e){return e*gl/96}var El={None:"none",Solid:"solid",Gray50:"mediumGray",Gray75:"darkGray",Gray25:"lightGray",HorzStripe:"darkHorizontal",VertStripe:"darkVertical",ReverseDiagStripe:"darkDown",DiagStripe:"darkUp",DiagCross:"darkGrid",ThickDiagCross:"darkTrellis",ThinHorzStripe:"lightHorizontal",ThinVertStripe:"lightVertical",ThinReverseDiagStripe:"lightDown",ThinHorzCross:"lightGrid"};function Sl(e,r,t,a){r.Borders=[];var n={};var i=false;(e[0].match(Ae)||[]).forEach(function(e){var t=De(e);switch(Fe(t[0])){case"<borders":;case"<borders>":;case"</borders>":break;case"<border":;case"<border>":;case"<border/>":n={};if(t.diagonalUp)n.diagonalUp=je(t.diagonalUp);if(t.diagonalDown)n.diagonalDown=je(t.diagonalDown);r.Borders.push(n);break;case"</border>":break;case"<left/>":break;case"<left":;case"<left>":break;case"</left>":break;case"<right/>":break;case"<right":;case"<right>":break;case"</right>":break;case"<top/>":break;case"<top":;case"<top>":break;case"</top>":break;case"<bottom/>":break;case"<bottom":;case"<bottom>":break;case"</bottom>":break;case"<diagonal":;case"<diagonal>":;case"<diagonal/>":break;case"</diagonal>":break;case"<horizontal":;case"<horizontal>":;case"<horizontal/>":break;case"</horizontal>":break;case"<vertical":;case"<vertical>":;case"<vertical/>":break;case"</vertical>":break;case"<start":;case"<start>":;case"<start/>":break;case"</start>":break;case"<end":;case"<end>":;case"<end/>":break;case"</end>":break;case"<color":;case"<color>":break;case"<color/>":;case"</color>":break;case"<extLst":;case"<extLst>":;case"</extLst>":break;case"<ext":i=true;break;case"</ext>":i=false;break;default:if(a&&a.WTF){if(!i)throw new Error("unrecognized "+t[0]+" in borders")};}})}function _l(e,r,t,a){r.Fills=[];var n={};var i=false;(e[0].match(Ae)||[]).forEach(function(e){var t=De(e);switch(Fe(t[0])){case"<fills":;case"<fills>":;case"</fills>":break;case"<fill>":;case"<fill":;case"<fill/>":n={};r.Fills.push(n);break;case"</fill>":break;case"<gradientFill>":break;case"<gradientFill":;case"</gradientFill>":r.Fills.push(n);n={};break;case"<patternFill":;case"<patternFill>":if(t.patternType)n.patternType=t.patternType;break;case"<patternFill/>":;case"</patternFill>":break;case"<bgColor":if(!n.bgColor)n.bgColor={};if(t.indexed)n.bgColor.indexed=parseInt(t.indexed,10);if(t.theme)n.bgColor.theme=parseInt(t.theme,10);if(t.tint)n.bgColor.tint=parseFloat(t.tint);if(t.rgb)n.bgColor.rgb=t.rgb.slice(-6);break;case"<bgColor/>":;case"</bgColor>":break;case"<fgColor":if(!n.fgColor)n.fgColor={};if(t.theme)n.fgColor.theme=parseInt(t.theme,10);if(t.tint)n.fgColor.tint=parseFloat(t.tint);if(t.rgb!=null)n.fgColor.rgb=t.rgb.slice(-6);break;case"<fgColor/>":;case"</fgColor>":break;case"<stop":;case"<stop/>":break;case"</stop>":break;case"<color":;case"<color/>":break;case"</color>":break;case"<extLst":;case"<extLst>":;case"</extLst>":break;case"<ext":i=true;break;case"</ext>":i=false;break;default:if(a&&a.WTF){if(!i)throw new Error("unrecognized "+t[0]+" in fills")};}})}function Cl(e,r,t,a){r.Fonts=[];var n={};var s=false;(e[0].match(Ae)||[]).forEach(function(e){var f=De(e);switch(Fe(f[0])){case"<fonts":;case"<fonts>":;case"</fonts>":break;case"<font":;case"<font>":break;case"</font>":;case"<font/>":r.Fonts.push(n);n={};break;case"<name":if(f.val)n.name=f.val;break;case"<name/>":;case"</name>":break;case"<b":n.bold=f.val?je(f.val):1;break;case"<b/>":n.bold=1;break;case"<i":n.italic=f.val?je(f.val):1;break;case"<i/>":n.italic=1;break;case"<u":switch(f.val){case"none":n.underline=0;break;case"single":n.underline=1;break;case"double":n.underline=2;break;case"singleAccounting":n.underline=33;break;case"doubleAccounting":n.underline=34;break;}break;case"<u/>":n.underline=1;break;case"<strike":n.strike=f.val?je(f.val):1;break;case"<strike/>":n.strike=1;break;case"<outline":n.outline=f.val?je(f.val):1;break;case"<outline/>":n.outline=1;break;case"<shadow":n.shadow=f.val?je(f.val):1;break;case"<shadow/>":n.shadow=1;break;case"<condense":n.condense=f.val?je(f.val):1;break;case"<condense/>":n.condense=1;break;case"<extend":n.extend=f.val?je(f.val):1;break;case"<extend/>":n.extend=1;break;case"<sz":if(f.val)n.sz=+f.val;break;case"<sz/>":;case"</sz>":break;case"<vertAlign":if(f.val)n.vertAlign=f.val;break;case"<vertAlign/>":;case"</vertAlign>":break;case"<family":if(f.val)n.family=parseInt(f.val,10);break;case"<family/>":;case"</family>":break;case"<scheme":if(f.val)n.scheme=f.val;break;case"<scheme/>":;case"</scheme>":break;case"<charset":if(f.val=="1")break;f.codepage=i[parseInt(f.val,10)];break;case"<color":if(!n.color)n.color={};if(f.auto)n.color.auto=je(f.auto);if(f.rgb)n.color.rgb=f.rgb.slice(-6);else if(f.indexed){n.color.index=parseInt(f.indexed,10);var l=ya[n.color.index];if(n.color.index==81)l=ya[1];if(!l)throw new Error(e);n.color.rgb=l[0].toString(16)+l[1].toString(16)+l[2].toString(16)}else if(f.theme){n.color.theme=parseInt(f.theme,10);if(f.tint)n.color.tint=parseFloat(f.tint);if(f.theme&&t.themeElements&&t.themeElements.clrScheme){n.color.rgb=sl(t.themeElements.clrScheme[n.color.theme].rgb,n.color.tint||0)}}break;case"<color/>":;case"</color>":break;case"<AlternateContent":s=true;break;case"</AlternateContent>":s=false;break;case"<extLst":;case"<extLst>":;case"</extLst>":
break;case"<ext":s=true;break;case"</ext>":s=false;break;default:if(a&&a.WTF){if(!s)throw new Error("unrecognized "+f[0]+" in fonts")};}})}function Bl(e,r,t){r.NumberFmt=[];var a=K(F._table);for(var n=0;n<a.length;++n)r.NumberFmt[a[n]]=F._table[a[n]];var i=e[0].match(Ae);if(!i)return;for(n=0;n<i.length;++n){var s=De(i[n]);switch(Fe(s[0])){case"<numFmts":;case"</numFmts>":;case"<numFmts/>":;case"<numFmts>":break;case"<numFmt":{var f=Ne(Ke(s.formatCode)),l=parseInt(s.numFmtId,10);r.NumberFmt[l]=f;if(l>0){if(l>392){for(l=392;l>60;--l)if(r.NumberFmt[l]==null)break;r.NumberFmt[l]=f}F.load(f,l)}}break;case"</numFmt>":break;default:if(t.WTF)throw new Error("unrecognized "+s[0]+" in numFmts");}}}function Tl(e){var r=["<numFmts>"];[[5,8],[23,26],[41,44],[50,392]].forEach(function(t){for(var a=t[0];a<=t[1];++a)if(e[a]!=null)r[r.length]=fr("numFmt",null,{numFmtId:a,formatCode:Ue(e[a])})});if(r.length===1)return"";r[r.length]="</numFmts>";r[0]=fr("numFmts",null,{count:r.length-2}).replace("/>",">");return r.join("")}var yl=["numFmtId","fillId","fontId","borderId","xfId"];var xl=["applyAlignment","applyBorder","applyFill","applyFont","applyNumberFormat","applyProtection","pivotButton","quotePrefix"];function Al(e,r,t){r.CellXf=[];var a;var n=false;(e[0].match(Ae)||[]).forEach(function(e){var i=De(e),s=0;switch(Fe(i[0])){case"<cellXfs":;case"<cellXfs>":;case"<cellXfs/>":;case"</cellXfs>":break;case"<xf":;case"<xf/>":a=i;delete a[0];for(s=0;s<yl.length;++s)if(a[yl[s]])a[yl[s]]=parseInt(a[yl[s]],10);for(s=0;s<xl.length;++s)if(a[xl[s]])a[xl[s]]=je(a[xl[s]]);if(a.numFmtId>392){for(s=392;s>60;--s)if(r.NumberFmt[a.numFmtId]==r.NumberFmt[s]){a.numFmtId=s;break}}r.CellXf.push(a);break;case"</xf>":break;case"<alignment":;case"<alignment/>":var f={};if(i.vertical)f.vertical=i.vertical;if(i.horizontal)f.horizontal=i.horizontal;if(i.textRotation!=null)f.textRotation=i.textRotation;if(i.indent)f.indent=i.indent;if(i.wrapText)f.wrapText=je(i.wrapText);a.alignment=f;break;case"</alignment>":break;case"<protection":break;case"</protection>":;case"<protection/>":break;case"<AlternateContent":n=true;break;case"</AlternateContent>":n=false;break;case"<extLst":;case"<extLst>":;case"</extLst>":break;case"<ext":n=true;break;case"</ext>":n=false;break;default:if(t&&t.WTF){if(!n)throw new Error("unrecognized "+i[0]+" in cellXfs")};}})}function Il(e){var r=[];r[r.length]=fr("cellXfs",null);e.forEach(function(e){r[r.length]=fr("xf",null,e)});r[r.length]="</cellXfs>";if(r.length===2)return"";r[0]=fr("cellXfs",null,{count:r.length-2}).replace("/>",">");return r.join("")}var Rl=function _b(){var e=/<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/;var r=/<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/;var t=/<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/;var a=/<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/;var n=/<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;return function i(s,f,l){var o={};if(!s)return o;s=s.replace(/<!--([\s\S]*?)-->/gm,"").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm,"");var c;if(c=s.match(e))Bl(c,o,l);if(c=s.match(a))Cl(c,o,f,l);if(c=s.match(t))_l(c,o,f,l);if(c=s.match(n))Sl(c,o,f,l);if(c=s.match(r))Al(c,o,l);return o}}();var Dl=fr("styleSheet",null,{xmlns:cr.main[0],"xmlns:vt":cr.vt});Na.STY="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles";function Fl(e,r){var t=[ye,Dl],a;if(e.SSF&&(a=Tl(e.SSF))!=null)t[t.length]=a;t[t.length]='<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';t[t.length]='<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';t[t.length]='<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';t[t.length]='<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';if(a=Il(r.cellXfs))t[t.length]=a;t[t.length]='<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';t[t.length]='<dxfs count="0"/>';t[t.length]='<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';if(t.length>2){t[t.length]="</styleSheet>";t[1]=t[1].replace("/>",">")}return t.join("")}function Ol(e,r){var t=e._R(2);var a=Bt(e,r-2);return[t,a]}function Pl(e,r,t){if(!t)t=$r(6+4*r.length);t._W(2,e);Tt(r,t);var a=t.length>t.l?t.slice(0,t.l):t;if(t.l==null)t.l=t.length;return a}function Nl(e,r,t){var a={};a.sz=e._R(2)/20;var n=ea(e,2,t);if(n.fItalic)a.italic=1;if(n.fCondense)a.condense=1;if(n.fExtend)a.extend=1;if(n.fShadow)a.shadow=1;if(n.fOutline)a.outline=1;if(n.fStrikeout)a.strike=1;var i=e._R(2);if(i===700)a.bold=1;switch(e._R(2)){case 1:a.vertAlign="superscript";break;case 2:a.vertAlign="subscript";break;}var s=e._R(1);if(s!=0)a.underline=s;var f=e._R(1);if(f>0)a.family=f;var l=e._R(1);if(l>0)a.charset=l;e.l++;a.color=Jt(e,8);switch(e._R(1)){case 1:a.scheme="major";break;case 2:a.scheme="minor";break;}a.name=Bt(e,r-21);return a}function Ll(e,r){if(!r)r=$r(25+4*32);r._W(2,e.sz*20);ra(e,r);r._W(2,e.bold?700:400);var t=0;if(e.vertAlign=="superscript")t=1;else if(e.vertAlign=="subscript")t=2;r._W(2,t);r._W(1,e.underline||0);r._W(1,e.family||0);r._W(1,e.charset||0);r._W(1,0);qt(e.color,r);var a=0;if(e.scheme=="major")a=1;if(e.scheme=="minor")a=2;r._W(1,a);Tt(e.name,r);return r.length>r.l?r.slice(0,r.l):r}var Ml=["none","solid","mediumGray","darkGray","lightGray","darkHorizontal","darkVertical","darkDown","darkUp","darkGrid","darkTrellis","lightHorizontal","lightVertical","lightDown","lightUp","lightGrid","lightTrellis","gray125","gray0625"];var Ul=Z(Ml);var Hl=Yr;function Wl(e,r){if(!r)r=$r(4*3+8*7+16*1);var t=Ul[e.patternType];if(t==null)t=40;r._W(4,t);var a=0;if(t!=40){qt({auto:1},r);qt({auto:1},r);for(;a<12;++a)r._W(4,0)}else{for(;a<4;++a)r._W(4,0);for(;a<12;++a)r._W(4,0)}return r.length>r.l?r.slice(0,r.l):r}function zl(e,r){var t=e.l+r;var a=e._R(2);var n=e._R(2);e.l=t;return{ixfe:a,numFmtId:n}}function Vl(e,r,t){if(!t)t=$r(16);t._W(2,r||0);t._W(2,e.numFmtId||0);t._W(2,0);t._W(2,0);t._W(2,0);t._W(1,0);t._W(1,0);var a=0;t._W(1,a);t._W(1,0);t._W(1,0);t._W(1,0);return t}function Xl(e,r){if(!r)r=$r(10);r._W(1,0);r._W(1,0);r._W(4,0);r._W(4,0);return r}var Gl=Yr;function jl(e,r){if(!r)r=$r(51);r._W(1,0);Xl(null,r);Xl(null,r);Xl(null,r);Xl(null,r);Xl(null,r);return r.length>r.l?r.slice(0,r.l):r}function Kl(e,r){if(!r)r=$r(12+4*10);r._W(4,e.xfId);r._W(2,1);r._W(1,+e.builtinId);r._W(1,0);Mt(e.name||"",r);return r.length>r.l?r.slice(0,r.l):r}function Yl(e,r,t){var a=$r(4+256*2*4);a._W(4,e);Mt(r,a);Mt(t,a);return a.length>a.l?a.slice(0,a.l):a}function $l(e,r,t){var a={};a.NumberFmt=[];for(var n in F._table)a.NumberFmt[n]=F._table[n];a.CellXf=[];a.Fonts=[];var i=[];var s=false;Zr(e,function f(e,n,l){switch(l){case 44:a.NumberFmt[e[0]]=e[1];F.load(e[1],e[0]);break;case 43:a.Fonts.push(e);if(e.color.theme!=null&&r&&r.themeElements&&r.themeElements.clrScheme){e.color.rgb=sl(r.themeElements.clrScheme[e.color.theme].rgb,e.color.tint||0)}break;case 1025:break;case 45:break;case 46:break;case 47:if(i[i.length-1]=="BrtBeginCellXFs"){a.CellXf.push(e)}break;case 48:;case 507:;case 572:;case 475:break;case 1171:;case 2102:;case 1130:;case 512:;case 2095:;case 3072:break;case 35:s=true;break;case 36:s=false;break;case 37:i.push(n);s=true;break;case 38:i.pop();s=false;break;default:if((n||"").indexOf("Begin")>0)i.push(n);else if((n||"").indexOf("End")>0)i.pop();else if(!s||t.WTF&&i[i.length-1]!="BrtACBegin")throw new Error("Unexpected record "+l+" "+n);}});return a}function Zl(e,r){if(!r)return;var t=0;[[5,8],[23,26],[41,44],[50,392]].forEach(function(e){for(var a=e[0];a<=e[1];++a)if(r[a]!=null)++t});if(t==0)return;Jr(e,"BrtBeginFmts",Ct(t));[[5,8],[23,26],[41,44],[50,392]].forEach(function(t){for(var a=t[0];a<=t[1];++a)if(r[a]!=null)Jr(e,"BrtFmt",Pl(a,r[a]))});Jr(e,"BrtEndFmts")}function Ql(e){var r=1;if(r==0)return;Jr(e,"BrtBeginFonts",Ct(r));Jr(e,"BrtFont",Ll({sz:12,color:{theme:1},name:"Calibri",family:2,scheme:"minor"}));Jr(e,"BrtEndFonts")}function Jl(e){var r=2;if(r==0)return;Jr(e,"BrtBeginFills",Ct(r));Jr(e,"BrtFill",Wl({patternType:"none"}));Jr(e,"BrtFill",Wl({patternType:"gray125"}));Jr(e,"BrtEndFills")}function ql(e){var r=1;if(r==0)return;Jr(e,"BrtBeginBorders",Ct(r));Jr(e,"BrtBorder",jl({}));Jr(e,"BrtEndBorders")}function eo(e){var r=1;Jr(e,"BrtBeginCellStyleXFs",Ct(r));Jr(e,"BrtXF",Vl({numFmtId:0,fontId:0,fillId:0,borderId:0},65535));Jr(e,"BrtEndCellStyleXFs")}function ro(e,r){Jr(e,"BrtBeginCellXFs",Ct(r.length));r.forEach(function(r){Jr(e,"BrtXF",Vl(r,0))});Jr(e,"BrtEndCellXFs")}function to(e){var r=1;Jr(e,"BrtBeginStyles",Ct(r));Jr(e,"BrtStyle",Kl({xfId:0,builtinId:0,name:"Normal"}));Jr(e,"BrtEndStyles")}function ao(e){var r=0;Jr(e,"BrtBeginDXFs",Ct(r));Jr(e,"BrtEndDXFs")}function no(e){var r=0;Jr(e,"BrtBeginTableStyles",Yl(r,"TableStyleMedium9","PivotStyleMedium4"));Jr(e,"BrtEndTableStyles")}function io(){return}function so(e,r){var t=Qr();Jr(t,"BrtBeginStyleSheet");Zl(t,e.SSF);Ql(t,e);Jl(t,e);ql(t,e);eo(t,e);ro(t,r.cellXfs);to(t,e);ao(t,e);no(t,e);io(t,e);Jr(t,"BrtEndStyleSheet");return t.end()}Na.THEME="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme";function fo(e,r,t){r.themeElements.clrScheme=[];var a={};(e[0].match(Ae)||[]).forEach(function(e){var n=De(e);switch(n[0]){case"<a:clrScheme":;case"</a:clrScheme>":break;case"<a:srgbClr":a.rgb=n.val;break;case"<a:sysClr":a.rgb=n.lastClr;break;case"<a:dk1>":;case"</a:dk1>":;case"<a:lt1>":;case"</a:lt1>":;case"<a:dk2>":;case"</a:dk2>":;case"<a:lt2>":;case"</a:lt2>":;case"<a:accent1>":;case"</a:accent1>":;case"<a:accent2>":;case"</a:accent2>":;case"<a:accent3>":;case"</a:accent3>":;case"<a:accent4>":;case"</a:accent4>":;case"<a:accent5>":;case"</a:accent5>":;case"<a:accent6>":;case"</a:accent6>":;case"<a:hlink>":;case"</a:hlink>":;case"<a:folHlink>":;case"</a:folHlink>":if(n[0].charAt(1)==="/"){r.themeElements.clrScheme.push(a);a={}}else{a.name=n[0].slice(3,n[0].length-1)}break;default:if(t&&t.WTF)throw new Error("Unrecognized "+n[0]+" in clrScheme");}})}function lo(){}function oo(){}var co=/<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/;var uo=/<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/;var ho=/<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;function vo(e,r,t){r.themeElements={};var a;[["clrScheme",co,fo],["fontScheme",uo,lo],["fmtScheme",ho,oo]].forEach(function(n){if(!(a=e.match(n[1])))throw new Error(n[0]+" not found in themeElements");n[2](a,r,t)})}var po=/<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;function mo(e,r){if(!e||e.length===0)return mo(bo());var t;var a={};if(!(t=e.match(po)))throw new Error("themeElements not found in theme");vo(t[0],a,r);a.raw=e;return a}function bo(e,r){if(r&&r.themeXLSX)return r.themeXLSX;if(e&&typeof e.raw=="string")return e.raw;var t=[ye];t[t.length]='<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';t[t.length]="<a:themeElements>";t[t.length]='<a:clrScheme name="Office">';t[t.length]='<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';t[t.length]='<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';t[t.length]='<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';t[t.length]='<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';t[t.length]='<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';t[t.length]='<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';t[t.length]='<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';t[t.length]='<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';t[t.length]='<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';t[t.length]='<a:accent6><a:srgbClr val="F79646"/></a:accent6>';t[t.length]='<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';t[t.length]='<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';t[t.length]="</a:clrScheme>";t[t.length]='<a:fontScheme name="Office">';t[t.length]="<a:majorFont>";t[t.length]='<a:latin typeface="Cambria"/>';t[t.length]='<a:ea typeface=""/>';t[t.length]='<a:cs typeface=""/>';t[t.length]='<a:font script="Jpan" typeface=" "/>';t[t.length]='<a:font script="Hang" typeface=" "/>';t[t.length]='<a:font script="Hans" typeface=""/>';t[t.length]='<a:font script="Hant" typeface=""/>';t[t.length]='<a:font script="Arab" typeface="Times New Roman"/>';t[t.length]='<a:font script="Hebr" typeface="Times New Roman"/>';t[t.length]='<a:font script="Thai" typeface="Tahoma"/>';t[t.length]='<a:font script="Ethi" typeface="Nyala"/>';t[t.length]='<a:font script="Beng" typeface="Vrinda"/>';t[t.length]='<a:font script="Gujr" typeface="Shruti"/>';t[t.length]='<a:font script="Khmr" typeface="MoolBoran"/>';t[t.length]='<a:font script="Knda" typeface="Tunga"/>';t[t.length]='<a:font script="Guru" typeface="Raavi"/>';t[t.length]='<a:font script="Cans" typeface="Euphemia"/>';t[t.length]='<a:font script="Cher" typeface="Plantagenet Cherokee"/>';t[t.length]='<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';t[t.length]='<a:font script="Tibt" typeface="Microsoft Himalaya"/>';t[t.length]='<a:font script="Thaa" typeface="MV Boli"/>';t[t.length]='<a:font script="Deva" typeface="Mangal"/>';t[t.length]='<a:font script="Telu" typeface="Gautami"/>';t[t.length]='<a:font script="Taml" typeface="Latha"/>';t[t.length]='<a:font script="Syrc" typeface="Estrangelo Edessa"/>';t[t.length]='<a:font script="Orya" typeface="Kalinga"/>';t[t.length]='<a:font script="Mlym" typeface="Kartika"/>';t[t.length]='<a:font script="Laoo" typeface="DokChampa"/>';t[t.length]='<a:font script="Sinh" typeface="Iskoola Pota"/>';t[t.length]='<a:font script="Mong" typeface="Mongolian Baiti"/>';t[t.length]='<a:font script="Viet" typeface="Times New Roman"/>';t[t.length]='<a:font script="Uigh" typeface="Microsoft Uighur"/>';t[t.length]='<a:font script="Geor" typeface="Sylfaen"/>';t[t.length]="</a:majorFont>";t[t.length]="<a:minorFont>";t[t.length]='<a:latin typeface="Calibri"/>';t[t.length]='<a:ea typeface=""/>';t[t.length]='<a:cs typeface=""/>';t[t.length]='<a:font script="Jpan" typeface=" "/>';t[t.length]='<a:font script="Hang" typeface=" "/>';t[t.length]='<a:font script="Hans" typeface=""/>';t[t.length]='<a:font script="Hant" typeface=""/>';t[t.length]='<a:font script="Arab" typeface="Arial"/>';t[t.length]='<a:font script="Hebr" typeface="Arial"/>';t[t.length]='<a:font script="Thai" typeface="Tahoma"/>';t[t.length]='<a:font script="Ethi" typeface="Nyala"/>';t[t.length]='<a:font script="Beng" typeface="Vrinda"/>';t[t.length]='<a:font script="Gujr" typeface="Shruti"/>';t[t.length]='<a:font script="Khmr" typeface="DaunPenh"/>';t[t.length]='<a:font script="Knda" typeface="Tunga"/>';t[t.length]='<a:font script="Guru" typeface="Raavi"/>';t[t.length]='<a:font script="Cans" typeface="Euphemia"/>';t[t.length]='<a:font script="Cher" typeface="Plantagenet Cherokee"/>';t[t.length]='<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';t[t.length]='<a:font script="Tibt" typeface="Microsoft Himalaya"/>';t[t.length]='<a:font script="Thaa" typeface="MV Boli"/>';t[t.length]='<a:font script="Deva" typeface="Mangal"/>';t[t.length]='<a:font script="Telu" typeface="Gautami"/>';t[t.length]='<a:font script="Taml" typeface="Latha"/>';t[t.length]='<a:font script="Syrc" typeface="Estrangelo Edessa"/>';t[t.length]='<a:font script="Orya" typeface="Kalinga"/>';t[t.length]='<a:font script="Mlym" typeface="Kartika"/>';t[t.length]='<a:font script="Laoo" typeface="DokChampa"/>';t[t.length]='<a:font script="Sinh" typeface="Iskoola Pota"/>';t[t.length]='<a:font script="Mong" typeface="Mongolian Baiti"/>';t[t.length]='<a:font script="Viet" typeface="Arial"/>';t[t.length]='<a:font script="Uigh" typeface="Microsoft Uighur"/>';t[t.length]='<a:font script="Geor" typeface="Sylfaen"/>';t[t.length]="</a:minorFont>";t[t.length]="</a:fontScheme>";t[t.length]='<a:fmtScheme name="Office">';t[t.length]="<a:fillStyleLst>";t[t.length]='<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';t[t.length]='<a:gradFill rotWithShape="1">';t[t.length]="<a:gsLst>";t[t.length]='<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';t[t.length]="</a:gsLst>";t[t.length]='<a:lin ang="16200000" scaled="1"/>';t[t.length]="</a:gradFill>";t[t.length]='<a:gradFill rotWithShape="1">';t[t.length]="<a:gsLst>";t[t.length]='<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';t[t.length]="</a:gsLst>";t[t.length]='<a:lin ang="16200000" scaled="0"/>';t[t.length]="</a:gradFill>";t[t.length]="</a:fillStyleLst>";t[t.length]="<a:lnStyleLst>";t[t.length]='<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';t[t.length]='<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';t[t.length]='<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';t[t.length]="</a:lnStyleLst>";t[t.length]="<a:effectStyleLst>";t[t.length]="<a:effectStyle>";t[t.length]="<a:effectLst>";t[t.length]='<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';t[t.length]="</a:effectLst>";t[t.length]="</a:effectStyle>";t[t.length]="<a:effectStyle>";t[t.length]="<a:effectLst>";t[t.length]='<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';t[t.length]="</a:effectLst>";t[t.length]="</a:effectStyle>";t[t.length]="<a:effectStyle>";t[t.length]="<a:effectLst>";t[t.length]='<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';t[t.length]="</a:effectLst>";t[t.length]='<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';t[t.length]='<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';t[t.length]="</a:effectStyle>";t[t.length]="</a:effectStyleLst>";t[t.length]="<a:bgFillStyleLst>";t[t.length]='<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';t[t.length]='<a:gradFill rotWithShape="1">';t[t.length]="<a:gsLst>";t[t.length]='<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';t[t.length]="</a:gsLst>";t[t.length]='<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';t[t.length]="</a:gradFill>";t[t.length]='<a:gradFill rotWithShape="1">';t[t.length]="<a:gsLst>";t[t.length]='<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';t[t.length]='<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';t[t.length]="</a:gsLst>";t[t.length]='<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';t[t.length]="</a:gradFill>";t[t.length]="</a:bgFillStyleLst>";t[t.length]="</a:fmtScheme>";t[t.length]="</a:themeElements>";t[t.length]="<a:objectDefaults>";t[t.length]="<a:spDef>";t[t.length]='<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';t[t.length]="</a:spDef>";t[t.length]="<a:lnDef>";t[t.length]='<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';t[t.length]="</a:lnDef>";t[t.length]="</a:objectDefaults>";t[t.length]="<a:extraClrSchemeLst/>";t[t.length]="</a:theme>";return t.join("")}function go(e,r,t){var a=e.l+r;var n=e._R(4);if(n===124226)return;if(!t.cellStyles||!_e){e.l=a;return}var i=e.slice(e.l);e.l=a;var s;try{s=new _e(i)}catch(f){return}var l=ke(s,"theme/theme/theme1.xml",true);if(!l)return;return mo(l,t)}function wo(e){return e._R(4)}function ko(e){var r={};r.xclrType=e._R(2);r.nTintShade=e._R(2);switch(r.xclrType){case 0:e.l+=4;break;case 1:r.xclrValue=Eo(e,4);break;case 2:r.xclrValue=ci(e,4);break;case 3:r.xclrValue=wo(e,4);break;case 4:e.l+=4;break;}e.l+=8;return r}function Eo(e,r){return Yr(e,r)}function So(e,r){return Yr(e,r)}function _o(e){var r=e._R(2);var t=e._R(2)-4;var a=[r];switch(r){case 4:;case 5:;case 7:;case 8:;case 9:;case 10:;case 11:;case 13:a[1]=ko(e,t);break;case 6:a[1]=So(e,t);break;case 14:;case 15:a[1]=e._R(t===1?1:2);break;default:throw new Error("Unrecognized ExtProp type: "+r+" "+t);}return a}function Co(e,r){var t=e.l+r;e.l+=2;var a=e._R(2);e.l+=2;var n=e._R(2);var i=[];while(n-- >0)i.push(_o(e,t-e.l));return{ixfe:a,ext:i}}function Bo(e,r){r.forEach(function(e){switch(e[0]){case 4:break;case 5:break;case 6:break;case 7:break;case 8:break;case 9:break;case 10:break;case 11:break;case 13:break;case 14:break;case 15:break;}})}function To(e){var r=[];if(!e)return r;var t=1;(e.match(Ae)||[]).forEach(function(e){var a=De(e);switch(a[0]){case"<?xml":break;case"<calcChain":;case"<calcChain>":;case"</calcChain>":break;case"<c":delete a[0];if(a.i)t=a.i;else a.i=t;r.push(a);break;}});return r}function yo(e){var r={};r.i=e._R(4);var t={};t.r=e._R(4);t.c=e._R(4);r.r=pt(t);var a=e._R(1);if(a&2)r.l="1";if(a&8)r.a="1";return r}function xo(e,r,t){var a=[];var n=false;Zr(e,function i(e,r,s){switch(s){case 63:a.push(e);break;default:if((r||"").indexOf("Begin")>0){}else if((r||"").indexOf("End")>0){}else if(!n||t.WTF)throw new Error("Unexpected record "+s+" "+r);}});return a}function Ao(){}function Io(e,r,t,a){if(!e)return e;var n=a||{};var i=false,s=false;Zr(e,function f(e,r,t){if(s)return;switch(t){case 359:;case 363:;case 364:;case 366:;case 367:;case 368:;case 369:;case 370:;case 371:;case 472:;case 577:;case 578:;case 579:;case 580:;case 581:;case 582:;case 583:;case 584:;case 585:;case 586:;case 587:break;case 35:i=true;break;case 36:i=false;break;default:if((r||"").indexOf("Begin")>0){}else if((r||"").indexOf("End")>0){}else if(!i||n.WTF)throw new Error("Unexpected record "+t.toString(16)+" "+r);}},n)}Na.IMG="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";Na.DRAW="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing";function Ro(e,r){if(!e)return"??";var t=(e.match(/<c:chart [^>]*r:id="([^"]*)"/)||["",""])[1];return r["!id"][t].Target}var Do=1024;function Fo(e,r){var t=[21600,21600];var a=["m0,0l0",t[1],t[0],t[1],t[0],"0xe"].join(",");var n=[fr("xml",null,{"xmlns:v":ur.v,"xmlns:o":ur.o,"xmlns:x":ur.x,"xmlns:mv":ur.mv}).replace(/\/>/,">"),fr("o:shapelayout",fr("o:idmap",null,{"v:ext":"edit",data:e}),{"v:ext":"edit"}),fr("v:shapetype",[fr("v:stroke",null,{joinstyle:"miter"}),fr("v:path",null,{gradientshapeok:"t","o:connecttype":"rect"})].join(""),{id:"_x0000_t202","o:spt":202,coordsize:t.join(","),path:a})];while(Do<e*1e3)Do+=1e3;r.forEach(function(e){var r=vt(e[0]);var t={color2:"#BEFF82",type:"gradient"};if(t.type=="gradient")t.angle="-180";var a=t.type=="gradient"?fr("o:fill",null,{type:"gradientUnscaled","v:ext":"view"}):null;var i=fr("v:fill",a,t);var s={on:"t",obscured:"t"};++Do;n=n.concat(["<v:shape"+sr({id:"_x0000_s"+Do,type:"#_x0000_t202",style:"position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10"+(e[1].hidden?";visibility:hidden":""),fillcolor:"#ECFAD4",strokecolor:"#edeaa1"})+">",i,fr("v:shadow",null,s),fr("v:path",null,{"o:connecttype":"none"}),'<v:textbox><div style="text-align:left"></div></v:textbox>','<x:ClientData ObjectType="Note">',"<x:MoveWithCells/>","<x:SizeWithCells/>",ir("x:Anchor",[r.c+1,0,r.r+1,0,r.c+3,20,r.r+5,20].join(",")),ir("x:AutoFill","False"),ir("x:Row",String(r.r)),ir("x:Column",String(r.c)),e[1].hidden?"":"<x:Visible/>","</x:ClientData>","</v:shape>"])});n.push("</xml>");return n.join("")}Na.CMNT="http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments";function Oo(e,r){var t=Array.isArray(e);var a;r.forEach(function(r){var n=vt(r.ref);if(t){if(!e[n.r])e[n.r]=[];a=e[n.r][n.c]}else a=e[r.ref];if(!a){a={t:"z"};if(t)e[n.r][n.c]=a;else e[r.ref]=a;var i=gt(e["!ref"]||"BDWGO1000001:A1");if(i.s.r>n.r)i.s.r=n.r;if(i.e.r<n.r)i.e.r=n.r;if(i.s.c>n.c)i.s.c=n.c;if(i.e.c<n.c)i.e.c=n.c;var s=bt(i);if(s!==e["!ref"])e["!ref"]=s}if(!a.c)a.c=[];var f={a:r.author,t:r.t,r:r.r};if(r.h)f.h=r.h;a.c.push(f)})}function Po(e,r){if(e.match(/<(?:\w+:)?comments *\/>/))return[];var t=[];var a=[];var n=e.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);if(n&&n[1])n[1].split(/<\/\w*:?author>/).forEach(function(e){if(e===""||e.trim()==="")return;var r=e.match(/<(?:\w+:)?author[^>]*>(.*)/);if(r)t.push(r[1])});var i=e.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);if(i&&i[1])i[1].split(/<\/\w*:?comment>/).forEach(function(e){if(e===""||e.trim()==="")return;var n=e.match(/<(?:\w+:)?comment[^>]*>/);if(!n)return;var i=De(n[0]);var s={author:i.authorId&&t[i.authorId]||"sheetjsghost",ref:i.ref,guid:i.guid};var f=vt(i.ref);if(r.sheetRows&&r.sheetRows<=f.r)return;var l=e.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/);var o=!!l&&!!l[1]&&kf(l[1])||{r:"",t:"",h:""};s.r=o.r;if(o.r=="<t></t>")o.t=o.h="";s.t=o.t.replace(/\r\n/g,"\n").replace(/\r/g,"\n");if(r.cellHTML)s.h=o.h;a.push(s)});return a}var No=fr("comments",null,{xmlns:cr.main[0]});function Lo(e){var r=[ye,No];var t=[];r.push("<authors>");e.forEach(function(e){e[1].forEach(function(e){var a=Ue(e.a);if(t.indexOf(a)>-1)return;t.push(a);r.push("<author>"+a+"</author>")})});r.push("</authors>");r.push("<commentList>");e.forEach(function(e){e[1].forEach(function(a){r.push('<comment ref="'+e[0]+'" authorId="'+t.indexOf(Ue(a.a))+'"><text>');r.push(ir("t",a.t==null?"":Ue(a.t)));r.push("</text></comment>")})});r.push("</commentList>");if(r.length>2){r[r.length]="</comments>";r[1]=r[1].replace("/>",">")}return r.join("")}function Mo(e){var r={};r.iauthor=e._R(4);var t=jt(e,16);r.rfx=t.s;r.ref=pt(t.s);e.l+=16;return r}function Uo(e,r){if(r==null)r=$r(36);r._W(4,e[1].iauthor);Kt(e[0],r);r._W(4,0);r._W(4,0);r._W(4,0);r._W(4,0);return r}var Ho=Bt;function Wo(e){return Tt(e.slice(0,54))}function zo(e,r){var t=[];var a=[];var n={};var i=false;Zr(e,function s(e,f,l){switch(l){case 632:a.push(e);break;case 635:n=e;break;case 637:n.t=e.t;n.h=e.h;n.r=e.r;break;case 636:n.author=a[n.iauthor];delete n.iauthor;if(r.sheetRows&&n.rfx&&r.sheetRows<=n.rfx.r)break;if(!n.t)n.t="";delete n.rfx;t.push(n);break;case 3072:break;case 35:i=true;break;case 36:i=false;break;case 37:break;case 38:break;default:if((f||"").indexOf("Begin")>0){}else if((f||"").indexOf("End")>0){}else if(!i||r.WTF)throw new Error("Unexpected record "+l+" "+f);}});return t}function Vo(e){var r=Qr();var t=[];Jr(r,"BrtBeginComments");Jr(r,"BrtBeginCommentAuthors");e.forEach(function(e){e[1].forEach(function(e){if(t.indexOf(e.a)>-1)return;t.push(e.a.slice(0,54));Jr(r,"BrtCommentAuthor",Wo(e.a))})});Jr(r,"BrtEndCommentAuthors");Jr(r,"BrtBeginCommentList");e.forEach(function(e){e[1].forEach(function(a){a.iauthor=t.indexOf(a.a);var n={s:vt(e[0]),e:vt(e[0])};Jr(r,"BrtBeginComment",Uo([n,a]));if(a.t&&a.t.length>0)Jr(r,"BrtCommentText",Dt(a));Jr(r,"BrtEndComment");delete a.iauthor})});Jr(r,"BrtEndCommentList");Jr(r,"BrtEndComments");return r.end()}var Xo="application/vnd.ms-office.vbaProject";function Go(e){var r=z.utils.cfb_new({root:"R"});e.FullPaths.forEach(function(t,a){if(t.slice(-1)==="/"||!t.match(/_VBA_PROJECT_CUR/))return;var n=t.replace(/^[^\/]*/,"R").replace(/\/_VBA_PROJECT_CUR\u0000*/,"");z.utils.cfb_add(r,n,e.FileIndex[a].content)});return z.write(r)}function jo(e,r){r.FullPaths.forEach(function(t,a){if(a==0)return;var n=t.replace(/[^\/]*[\/]/,"/_VBA_PROJECT_CUR/");if(n.slice(-1)!=="/")z.utils.cfb_add(e,n,r.FileIndex[a].content)})}var Ko=["xlsb","xlsm","xlam","biff8","xla"];Na.DS="http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet";Na.MS="http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet";function Yo(){return{"!type":"dialog"}}function $o(){return{"!type":"dialog"}}function Zo(){return{"!type":"macro"}}function Qo(){return{"!type":"macro"}}var Jo=function(){var e=/(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;var r={r:0,c:0};function t(e,t,a,n){var i=false,s=false;if(a.length==0)s=true;else if(a.charAt(0)=="["){s=true;a=a.slice(1,-1)}if(n.length==0)i=true;else if(n.charAt(0)=="["){i=true;n=n.slice(1,-1)}var f=a.length>0?parseInt(a,10)|0:0,l=n.length>0?parseInt(n,10)|0:0;if(i)l+=r.c;else--l;if(s)f+=r.r;else--f;return t+(i?"":"$")+ct(l)+(s?"":"$")+st(f)}return function a(n,i){r=i;return n.replace(e,t)}}();var qo=/(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)([1-9]\d{0,5}|10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6])(?![_.\(A-Za-z0-9])/g;var ec=function(){return function e(r,t){return r.replace(qo,function(e,r,a,n,i,s){var f=ot(n)-(a?0:t.c);var l=it(s)-(i?0:t.r);var o=l==0?"":!i?"["+l+"]":l+1;var c=f==0?"":!a?"["+f+"]":f+1;return r+"R"+o+"C"+c})}}();function rc(e,r){return e.replace(qo,function(e,t,a,n,i,s){return t+(a=="$"?a+n:ct(ot(n)+r.c))+(i=="$"?i+s:st(it(s)+r.r))})}function tc(e,r,t){var a=mt(r),n=a.s,i=vt(t);var s={r:i.r-n.r,c:i.c-n.c};return rc(e,s)}function ac(e){if(e.length==1)return false;return true}function nc(e){return e.replace(/_xlfn\./g,"")}function ic(e){e.l+=1;return}function sc(e,r){var t=e._R(r==1?1:2);return[t&16383,t>>14&1,t>>15&1]}function fc(e,r,t){var a=2;if(t){if(t.biff>=2&&t.biff<=5)return lc(e,r,t);else if(t.biff==12)a=4}var n=e._R(a),i=e._R(a);var s=sc(e,2);var f=sc(e,2);return{s:{r:n,c:s[0],cRel:s[1],rRel:s[2]},e:{r:i,c:f[0],cRel:f[1],rRel:f[2]}}}function lc(e){var r=sc(e,2),t=sc(e,2);var a=e._R(1);var n=e._R(1);return{s:{r:r[0],c:a,cRel:r[1],rRel:r[2]},e:{r:t[0],c:n,cRel:t[1],rRel:t[2]}}}function oc(e,r,t){if(t.biff<8)return lc(e,r,t);var a=e._R(t.biff==12?4:2),n=e._R(t.biff==12?4:2);var i=sc(e,2);var s=sc(e,2);return{s:{r:a,c:i[0],cRel:i[1],rRel:i[2]},e:{r:n,c:s[0],cRel:s[1],rRel:s[2]}}}function cc(e,r,t){if(t&&t.biff>=2&&t.biff<=5)return uc(e,r,t);var a=e._R(t&&t.biff==12?4:2);var n=sc(e,2);return{r:a,c:n[0],cRel:n[1],rRel:n[2]}}function uc(e){var r=sc(e,2);var t=e._R(1);return{r:r[0],c:t,cRel:r[1],rRel:r[2]}}function hc(e){var r=e._R(2);var t=e._R(2);
return{r:r,c:t&255,fQuoted:!!(t&16384),cRel:t>>15,rRel:t>>15}}function dc(e,r,t){var a=t&&t.biff?t.biff:8;if(a>=2&&a<=5)return vc(e,r,t);var n=e._R(a>=12?4:2);var i=e._R(2);var s=(i&16384)>>14,f=(i&32768)>>15;i&=16383;if(f==1)while(n>524287)n-=1048576;if(s==1)while(i>8191)i=i-16384;return{r:n,c:i,cRel:s,rRel:f}}function vc(e){var r=e._R(2);var t=e._R(1);var a=(r&32768)>>15,n=(r&16384)>>14;r&=16383;if(a==1&&r>=8192)r=r-16384;if(n==1&&t>=128)t=t-256;return{r:r,c:t,cRel:n,rRel:a}}function pc(e,r,t){var a=(e[e.l++]&96)>>5;var n=fc(e,t.biff>=2&&t.biff<=5?6:8,t);return[a,n]}function mc(e,r,t){var a=(e[e.l++]&96)>>5;var n=e._R(2,"i");var i=8;if(t)switch(t.biff){case 5:e.l+=12;i=6;break;case 12:i=12;break;}var s=fc(e,i,t);return[a,n,s]}function bc(e,r,t){var a=(e[e.l++]&96)>>5;e.l+=t&&t.biff>8?12:t.biff<8?6:8;return[a]}function gc(e,r,t){var a=(e[e.l++]&96)>>5;var n=e._R(2);var i=8;if(t)switch(t.biff){case 5:e.l+=12;i=6;break;case 12:i=12;break;}e.l+=i;return[a,n]}function wc(e,r,t){var a=(e[e.l++]&96)>>5;var n=oc(e,r-1,t);return[a,n]}function kc(e,r,t){var a=(e[e.l++]&96)>>5;e.l+=t.biff==2?6:t.biff==12?14:7;return[a]}function Ec(e){var r=e[e.l+1]&1;var t=1;e.l+=4;return[r,t]}function Sc(e,r,t){e.l+=2;var a=e._R(t&&t.biff==2?1:2);var n=[];for(var i=0;i<=a;++i)n.push(e._R(t&&t.biff==2?1:2));return n}function _c(e,r,t){var a=e[e.l+1]&255?1:0;e.l+=2;return[a,e._R(t&&t.biff==2?1:2)]}function Cc(e,r,t){var a=e[e.l+1]&255?1:0;e.l+=2;return[a,e._R(t&&t.biff==2?1:2)]}function Bc(e){var r=e[e.l+1]&255?1:0;e.l+=2;return[r,e._R(2)]}function Tc(e,r,t){var a=e[e.l+1]&255?1:0;e.l+=t&&t.biff==2?3:4;return[a]}function yc(e){var r=e._R(1),t=e._R(1);return[r,t]}function xc(e){e._R(2);return yc(e,2)}function Ac(e){e._R(2);return yc(e,2)}function Ic(e,r,t){var a=(e[e.l]&96)>>5;e.l+=1;var n=cc(e,0,t);return[a,n]}function Rc(e,r,t){var a=(e[e.l]&96)>>5;e.l+=1;var n=dc(e,0,t);return[a,n]}function Dc(e,r,t){var a=(e[e.l]&96)>>5;e.l+=1;var n=e._R(2);if(t&&t.biff==5)e.l+=12;var i=cc(e,0,t);return[a,n,i]}function Fc(e,r,t){var a=(e[e.l]&96)>>5;e.l+=1;var n=e._R(t&&t.biff<=3?1:2);return[$u[n],Yu[n],a]}function Oc(e,r,t){var a=e[e.l++];var n=e._R(1),i=t&&t.biff<=3?[a==88?-1:0,e._R(1)]:Pc(e);return[n,(i[0]===0?Yu:Ku)[i[1]]]}function Pc(e){return[e[e.l+1]>>7,e._R(2)&32767]}function Nc(e,r,t){e.l+=t&&t.biff==2?3:4;return}function Lc(e,r,t){e.l++;if(t&&t.biff==12)return[e._R(4,"i"),0];var a=e._R(2);var n=e._R(t&&t.biff==2?1:2);return[a,n]}function Mc(e){e.l++;return Zt[e._R(1)]}function Uc(e){e.l++;return e._R(2)}function Hc(e){e.l++;return e._R(1)!==0}function Wc(e){e.l++;return Yt(e,8)}function zc(e,r,t){e.l++;return Qn(e,r-1,t)}function Vc(e,r){var t=[e._R(1)];if(r==12)switch(t[0]){case 2:t[0]=4;break;case 4:t[0]=16;break;case 0:t[0]=1;break;case 1:t[0]=2;break;}switch(t[0]){case 4:t[1]=Xn(e,1)?"TRUE":"FALSE";if(r!=12)e.l+=7;break;case 37:;case 16:t[1]=Zt[e[e.l]];e.l+=r==12?4:8;break;case 0:e.l+=8;break;case 1:t[1]=Yt(e,8);break;case 2:t[1]=ri(e,0,{biff:r>0&&r<8?2:r});break;default:throw new Error("Bad SerAr: "+t[0]);}return t}function Xc(e,r,t){var a=e._R(t.biff==12?4:2);var n=[];for(var i=0;i!=a;++i)n.push((t.biff==12?jt:wi)(e,8));return n}function Gc(e,r,t){var a=0,n=0;if(t.biff==12){a=e._R(4);n=e._R(4)}else{n=1+e._R(1);a=1+e._R(2)}if(t.biff>=2&&t.biff<8){--a;if(--n==0)n=256}for(var i=0,s=[];i!=a&&(s[i]=[]);++i)for(var f=0;f!=n;++f)s[i][f]=Vc(e,t.biff);return s}function jc(e,r,t){var a=e._R(1)>>>5&3;var n=!t||t.biff>=8?4:2;var i=e._R(n);switch(t.biff){case 2:e.l+=5;break;case 3:;case 4:e.l+=8;break;case 5:e.l+=12;break;}return[a,0,i]}function Kc(e,r,t){if(t.biff==5)return Yc(e,r,t);var a=e._R(1)>>>5&3;var n=e._R(2);var i=e._R(4);return[a,n,i]}function Yc(e){var r=e._R(1)>>>5&3;var t=e._R(2,"i");e.l+=8;var a=e._R(2);e.l+=12;return[r,t,a]}function $c(e,r,t){var a=e._R(1)>>>5&3;e.l+=t&&t.biff==2?3:4;var n=e._R(t&&t.biff==2?1:2);return[a,n]}function Zc(e,r,t){var a=e._R(1)>>>5&3;var n=e._R(t&&t.biff==2?1:2);return[a,n]}function Qc(e,r,t){var a=e._R(1)>>>5&3;e.l+=4;if(t.biff<8)e.l--;if(t.biff==12)e.l+=2;return[a]}function Jc(e,r,t){var a=(e[e.l++]&96)>>5;var n=e._R(2);var i=4;if(t)switch(t.biff){case 5:i=15;break;case 12:i=6;break;}e.l+=i;return[a,n]}var qc=Yr;var eu=Yr;var ru=Yr;function tu(e,r,t){e.l+=2;return[hc(e,4,t)]}function au(e){e.l+=6;return[]}var nu=tu;var iu=au;var su=au;var fu=tu;function lu(e){e.l+=2;return[jn(e),e._R(2)&1]}var ou=tu;var cu=lu;var uu=au;var hu=tu;var du=tu;var vu=["Data","All","Headers","??","?Data2","??","?DataHeaders","??","Totals","??","??","??","?DataTotals","??","??","??","?Current"];function pu(e){e.l+=2;var r=e._R(2);var t=e._R(2);var a=e._R(4);var n=e._R(2);var i=e._R(2);var s=vu[t>>2&31];return{ixti:r,coltype:t&3,rt:s,idx:a,c:n,C:i}}function mu(e){e.l+=2;return[e._R(4)]}function bu(e,r,t){e.l+=5;e.l+=2;e.l+=t.biff==2?1:4;return["PTGSHEET"]}function gu(e,r,t){e.l+=t.biff==2?4:5;return["PTGENDSHEET"]}function wu(e){var r=e._R(1)>>>5&3;var t=e._R(2);return[r,t]}function ku(e){var r=e._R(1)>>>5&3;var t=e._R(2);return[r,t]}function Eu(e){e.l+=4;return[0,0]}var Su={1:{n:"PtgExp",f:Lc},2:{n:"PtgTbl",f:ru},3:{n:"PtgAdd",f:ic},4:{n:"PtgSub",f:ic},5:{n:"PtgMul",f:ic},6:{n:"PtgDiv",f:ic},7:{n:"PtgPower",f:ic},8:{n:"PtgConcat",f:ic},9:{n:"PtgLt",f:ic},10:{n:"PtgLe",f:ic},11:{n:"PtgEq",f:ic},12:{n:"PtgGe",f:ic},13:{n:"PtgGt",f:ic},14:{n:"PtgNe",f:ic},15:{n:"PtgIsect",f:ic},16:{n:"PtgUnion",f:ic},17:{n:"PtgRange",f:ic},18:{n:"PtgUplus",f:ic},19:{n:"PtgUminus",f:ic},20:{n:"PtgPercent",f:ic},21:{n:"PtgParen",f:ic},22:{n:"PtgMissArg",f:ic},23:{n:"PtgStr",f:zc},26:{n:"PtgSheet",f:bu},27:{n:"PtgEndSheet",f:gu},28:{n:"PtgErr",f:Mc},29:{n:"PtgBool",f:Hc},30:{n:"PtgInt",f:Uc},31:{n:"PtgNum",f:Wc},32:{n:"PtgArray",f:kc},33:{n:"PtgFunc",f:Fc},34:{n:"PtgFuncVar",f:Oc},35:{n:"PtgName",f:jc},36:{n:"PtgRef",f:Ic},37:{n:"PtgArea",f:pc},38:{n:"PtgMemArea",f:$c},39:{n:"PtgMemErr",f:qc},40:{n:"PtgMemNoMem",f:eu},41:{n:"PtgMemFunc",f:Zc},42:{n:"PtgRefErr",f:Qc},43:{n:"PtgAreaErr",f:bc},44:{n:"PtgRefN",f:Rc},45:{n:"PtgAreaN",f:wc},46:{n:"PtgMemAreaN",f:wu},47:{n:"PtgMemNoMemN",f:ku},57:{n:"PtgNameX",f:Kc},58:{n:"PtgRef3d",f:Dc},59:{n:"PtgArea3d",f:mc},60:{n:"PtgRefErr3d",f:Jc},61:{n:"PtgAreaErr3d",f:gc},255:{}};var _u={64:32,96:32,65:33,97:33,66:34,98:34,67:35,99:35,68:36,100:36,69:37,101:37,70:38,102:38,71:39,103:39,72:40,104:40,73:41,105:41,74:42,106:42,75:43,107:43,76:44,108:44,77:45,109:45,78:46,110:46,79:47,111:47,88:34,120:34,89:57,121:57,90:58,122:58,91:59,123:59,92:60,124:60,93:61,125:61};(function(){for(var e in _u)Su[e]=Su[_u[e]]})();var Cu={1:{n:"PtgElfLel",f:lu},2:{n:"PtgElfRw",f:hu},3:{n:"PtgElfCol",f:nu},6:{n:"PtgElfRwV",f:du},7:{n:"PtgElfColV",f:fu},10:{n:"PtgElfRadical",f:ou},11:{n:"PtgElfRadicalS",f:uu},13:{n:"PtgElfColS",f:iu},15:{n:"PtgElfColSV",f:su},16:{n:"PtgElfRadicalLel",f:cu},25:{n:"PtgList",f:pu},29:{n:"PtgSxName",f:mu},255:{}};var Bu={0:{n:"PtgAttrNoop",f:Eu},1:{n:"PtgAttrSemi",f:Tc},2:{n:"PtgAttrIf",f:Cc},4:{n:"PtgAttrChoose",f:Sc},8:{n:"PtgAttrGoto",f:_c},16:{n:"PtgAttrSum",f:Nc},32:{n:"PtgAttrBaxcel",f:Ec},64:{n:"PtgAttrSpace",f:xc},65:{n:"PtgAttrSpaceSemi",f:Ac},128:{n:"PtgAttrIfError",f:Bc},255:{}};Bu[33]=Bu[32];function Tu(e,r,t,a){if(a.biff<8)return Yr(e,r);var n=e.l+r;var i=[];for(var s=0;s!==t.length;++s){switch(t[s][0]){case"PtgArray":t[s][1]=Gc(e,0,a);i.push(t[s][1]);break;case"PtgMemArea":t[s][2]=Xc(e,t[s][1],a);i.push(t[s][2]);break;case"PtgExp":if(a&&a.biff==12){t[s][1][1]=e._R(4);i.push(t[s][1])}break;case"PtgList":;case"PtgElfRadicalS":;case"PtgElfColS":;case"PtgElfColSV":throw"Unsupported "+t[s][0];default:break;}}r=n-e.l;if(r!==0)i.push(Yr(e,r));return i}function yu(e,r,t){var a=e.l+r;var n,i,s=[];while(a!=e.l){r=a-e.l;i=e[e.l];n=Su[i];if(i===24||i===25)n=(i===24?Cu:Bu)[e[e.l+1]];if(!n||!n.f){Yr(e,r)}else{s.push([n.n,n.f(e,r,t)])}}return s}function xu(e){var r=[];for(var t=0;t<e.length;++t){var a=e[t],n=[];for(var i=0;i<a.length;++i){var s=a[i];if(s)switch(s[0]){case 2:n.push('"'+s[1].replace(/"/g,'""')+'"');break;default:n.push(s[1]);}else n.push("")}r.push(n.join(","))}return r.join(";")}var Au={PtgAdd:"+",PtgConcat:"&",PtgDiv:"/",PtgEq:"=",PtgGe:">=",PtgGt:">",PtgLe:"<=",PtgLt:"<",PtgMul:"*",PtgNe:"<>",PtgPower:"^",PtgSub:"-"};function Iu(e,r){if(!e&&!(r&&r.biff<=5&&r.biff>=2))throw new Error("empty sheet name");if(e.indexOf(" ")>-1)return"'"+e+"'";return e}function Ru(e,r,t){if(!e)return"SH33TJSERR0";if(t.biff>8&&(!e.XTI||!e.XTI[r]))return e.SheetNames[r];if(!e.XTI)return"SH33TJSERR6";var a=e.XTI[r];if(t.biff<8){if(r>1e4)r-=65536;if(r<0)r=-r;return r==0?"":e.XTI[r-1]}if(!a)return"SH33TJSERR1";var n="";if(t.biff>8)switch(e[a[0]][0]){case 357:n=a[1]==-1?"#REF":e.SheetNames[a[1]];return a[1]==a[2]?n:n+":"+e.SheetNames[a[2]];case 358:if(t.SID!=null)return e.SheetNames[t.SID];return"SH33TJSSAME"+e[a[0]][0];case 355:;default:return"SH33TJSSRC"+e[a[0]][0];}switch(e[a[0]][0][0]){case 1025:n=a[1]==-1?"#REF":e.SheetNames[a[1]]||"SH33TJSERR3";return a[1]==a[2]?n:n+":"+e.SheetNames[a[2]];case 14849:return e[a[0]].slice(1).map(function(e){return e.Name}).join(";;");default:if(!e[a[0]][0][3])return"SH33TJSERR2";n=a[1]==-1?"#REF":e[a[0]][0][3][a[1]]||"SH33TJSERR4";return a[1]==a[2]?n:n+":"+e[a[0]][0][3][a[2]];}}function Du(e,r,t){return Iu(Ru(e,r,t),t)}function Fu(e,r,t,a,n){var i=n&&n.biff||8;var s={s:{c:0,r:0},e:{c:0,r:0}};var f=[],l,o,c,u=0,h=0,d,v="";if(!e[0]||!e[0][0])return"";var p=-1,m="";for(var b=0,g=e[0].length;b<g;++b){var w=e[0][b];switch(w[0]){case"PtgUminus":f.push("-"+f.pop());break;case"PtgUplus":f.push("+"+f.pop());break;case"PtgPercent":f.push(f.pop()+"%");break;case"PtgAdd":;case"PtgConcat":;case"PtgDiv":;case"PtgEq":;case"PtgGe":;case"PtgGt":;case"PtgLe":;case"PtgLt":;case"PtgMul":;case"PtgNe":;case"PtgPower":;case"PtgSub":l=f.pop();o=f.pop();if(p>=0){switch(e[0][p][1][0]){case 0:m=oe(" ",e[0][p][1][1]);break;case 1:m=oe("\r",e[0][p][1][1]);break;default:m="";if(n.WTF)throw new Error("Unexpected PtgAttrSpaceType "+e[0][p][1][0]);}o=o+m;p=-1}f.push(o+Au[w[0]]+l);break;case"PtgIsect":l=f.pop();o=f.pop();f.push(o+" "+l);break;case"PtgUnion":l=f.pop();o=f.pop();f.push(o+","+l);break;case"PtgRange":l=f.pop();o=f.pop();f.push(o+":"+l);break;case"PtgAttrChoose":break;case"PtgAttrGoto":break;case"PtgAttrIf":break;case"PtgAttrIfError":break;case"PtgRef":c=qr(w[1][1],s,n);f.push(rt(c,i));break;case"PtgRefN":c=t?qr(w[1][1],t,n):w[1][1];f.push(rt(c,i));break;case"PtgRef3d":u=w[1][1];c=qr(w[1][2],s,n);v=Du(a,u,n);var k=v;f.push(v+"!"+rt(c,i));break;case"PtgFunc":;case"PtgFuncVar":var E=w[1][0],S=w[1][1];if(!E)E=0;E&=127;var _=E==0?[]:f.slice(-E);f.length-=E;if(S==="User")S=_.shift();f.push(S+"("+_.join(",")+")");break;case"PtgBool":f.push(w[1]?"TRUE":"FALSE");break;case"PtgInt":f.push(w[1]);break;case"PtgNum":f.push(String(w[1]));break;case"PtgStr":f.push('"'+w[1].replace(/"/g,'""')+'"');break;case"PtgErr":f.push(w[1]);break;case"PtgAreaN":d=et(w[1][1],t?{s:t}:s,n);f.push(tt(d,n));break;case"PtgArea":d=et(w[1][1],s,n);f.push(tt(d,n));break;case"PtgArea3d":u=w[1][1];d=w[1][2];v=Du(a,u,n);f.push(v+"!"+tt(d,n));break;case"PtgAttrSum":f.push("SUM("+f.pop()+")");break;case"PtgAttrBaxcel":;case"PtgAttrSemi":break;case"PtgName":h=w[1][2];var C=(a.names||[])[h-1]||(a[0]||[])[h];var B=C?C.Name:"SH33TJSNAME"+String(h);if(B in Zu)B=Zu[B];f.push(B);break;case"PtgNameX":var T=w[1][1];h=w[1][2];var y;if(n.biff<=5){if(T<0)T=-T;if(a[T])y=a[T][h]}else{var x="";if(((a[T]||[])[0]||[])[0]==14849){}else if(((a[T]||[])[0]||[])[0]==1025){if(a[T][h]&&a[T][h].itab>0){x=a.SheetNames[a[T][h].itab-1]+"!"}}else x=a.SheetNames[h-1]+"!";if(a[T]&&a[T][h])x+=a[T][h].Name;else if(a[0]&&a[0][h])x+=a[0][h].Name;else{var A=Ru(a,T,n).split(";;");if(A[h-1])x=A[h-1];else x+="SH33TJSERRX"}f.push(x);break}if(!y)y={Name:"SH33TJSERRY"};f.push(y.Name);break;case"PtgParen":var I="(",R=")";if(p>=0){m="";switch(e[0][p][1][0]){case 2:I=oe(" ",e[0][p][1][1])+I;break;case 3:I=oe("\r",e[0][p][1][1])+I;break;case 4:R=oe(" ",e[0][p][1][1])+R;break;case 5:R=oe("\r",e[0][p][1][1])+R;break;default:if(n.WTF)throw new Error("Unexpected PtgAttrSpaceType "+e[0][p][1][0]);}p=-1}f.push(I+f.pop()+R);break;case"PtgRefErr":f.push("#REF!");break;case"PtgRefErr3d":f.push("#REF!");break;case"PtgExp":c={c:w[1][1],r:w[1][0]};var D={c:t.c,r:t.r};if(a.sharedf[pt(c)]){var F=a.sharedf[pt(c)];f.push(Fu(F,s,D,a,n))}else{var O=false;for(l=0;l!=a.arrayf.length;++l){o=a.arrayf[l];if(c.c<o[0].s.c||c.c>o[0].e.c)continue;if(c.r<o[0].s.r||c.r>o[0].e.r)continue;f.push(Fu(o[1],s,D,a,n));O=true;break}if(!O)f.push(w[1])}break;case"PtgArray":f.push("{"+xu(w[1])+"}");break;case"PtgMemArea":break;case"PtgAttrSpace":;case"PtgAttrSpaceSemi":p=b;break;case"PtgTbl":break;case"PtgMemErr":break;case"PtgMissArg":f.push("");break;case"PtgAreaErr":f.push("#REF!");break;case"PtgAreaErr3d":f.push("#REF!");break;case"PtgList":f.push("Table"+w[1].idx+"[#"+w[1].rt+"]");break;case"PtgMemAreaN":;case"PtgMemNoMemN":;case"PtgAttrNoop":;case"PtgSheet":;case"PtgEndSheet":break;case"PtgMemFunc":break;case"PtgMemNoMem":break;case"PtgElfCol":;case"PtgElfColS":;case"PtgElfColSV":;case"PtgElfColV":;case"PtgElfLel":;case"PtgElfRadical":;case"PtgElfRadicalLel":;case"PtgElfRadicalS":;case"PtgElfRw":;case"PtgElfRwV":throw new Error("Unsupported ELFs");case"PtgSxName":throw new Error("Unrecognized Formula Token: "+String(w));default:throw new Error("Unrecognized Formula Token: "+String(w));}var P=["PtgAttrSpace","PtgAttrSpaceSemi","PtgAttrGoto"];if(n.biff!=3)if(p>=0&&P.indexOf(e[0][b][0])==-1){w=e[0][p];var N=true;switch(w[1][0]){case 4:N=false;case 0:m=oe(" ",w[1][1]);break;case 5:N=false;case 1:m=oe("\r",w[1][1]);break;default:m="";if(n.WTF)throw new Error("Unexpected PtgAttrSpaceType "+w[1][0]);}f.push((N?m:"")+f.pop()+(N?"":m));p=-1}}if(f.length>1&&n.WTF)throw new Error("bad formula stack");return f[0]}function Ou(e,r,t){var a=e.l+r,n=t.biff==2?1:2;var i,s=e._R(n);if(s==65535)return[[],Yr(e,r-2)];var f=yu(e,s,t);if(r!==s+n)i=Tu(e,r-s-n,f,t);e.l=a;return[f,i]}function Pu(e,r,t){var a=e.l+r,n=t.biff==2?1:2;var i,s=e._R(n);if(s==65535)return[[],Yr(e,r-2)];var f=yu(e,s,t);if(r!==s+n)i=Tu(e,r-s-n,f,t);e.l=a;return[f,i]}function Nu(e,r,t,a){var n=e.l+r;var i=yu(e,a,t);var s;if(n!==e.l)s=Tu(e,n-e.l,i,t);return[i,s]}function Lu(e,r,t){var a=e.l+r;var n,i=e._R(2);var s=yu(e,i,t);if(i==65535)return[[],Yr(e,r-2)];if(r!==i+2)n=Tu(e,a-i-2,s,t);return[s,n]}function Mu(e){var r;if(Nr(e,e.l+6)!==65535)return[Yt(e),"n"];switch(e[e.l]){case 0:e.l+=8;return["String","s"];case 1:r=e[e.l+2]===1;e.l+=8;return[r,"b"];case 2:r=e[e.l+2];e.l+=8;return[r,"e"];case 3:e.l+=8;return["","s"];}return[]}function Uu(e){if(e==null){var r=$r(8);r._W(1,3);r._W(1,0);r._W(2,0);r._W(2,0);r._W(2,65535);return r}else if(typeof e=="number")return $t(e);return $t(0)}function Hu(e,r,t){var a=e.l+r;var n=hi(e,6);if(t.biff==2)++e.l;var i=Mu(e,8);var s=e._R(1);if(t.biff!=2){e._R(1);if(t.biff>=5){e._R(4)}}var f=Pu(e,a-e.l,t);return{cell:n,val:i[0],formula:f,shared:s>>3&1,tt:i[1]}}function Wu(e,r,t,a,n){var i=di(r,t,n);var s=Uu(e.v);var f=$r(6);var l=1|32;f._W(2,l);f._W(4,0);var o=$r(e.bf.length);for(var c=0;c<e.bf.length;++c)o[c]=e.bf[c];var u=I([i,s,f,o]);return u}function zu(e,r,t){var a=e._R(4);var n=yu(e,a,t);var i=e._R(4);var s=i>0?Tu(e,i,n,t):null;return[n,s]}var Vu=zu;var Xu=zu;var Gu=zu;var ju=zu;var Ku={0:"BEEP",1:"OPEN",2:"OPEN.LINKS",3:"CLOSE.ALL",4:"SAVE",5:"SAVE.AS",6:"FILE.DELETE",7:"PAGE.SETUP",8:"PRINT",9:"PRINTER.SETUP",10:"QUIT",11:"NEW.WINDOW",12:"ARRANGE.ALL",13:"WINDOW.SIZE",14:"WINDOW.MOVE",15:"FULL",16:"CLOSE",17:"RUN",22:"SET.PRINT.AREA",23:"SET.PRINT.TITLES",24:"SET.PAGE.BREAK",25:"REMOVE.PAGE.BREAK",26:"FONT",27:"DISPLAY",28:"PROTECT.DOCUMENT",29:"PRECISION",30:"A1.R1C1",31:"CALCULATE.NOW",32:"CALCULATION",34:"DATA.FIND",35:"EXTRACT",36:"DATA.DELETE",37:"SET.DATABASE",38:"SET.CRITERIA",39:"SORT",40:"DATA.SERIES",41:"TABLE",42:"FORMAT.NUMBER",43:"ALIGNMENT",44:"STYLE",45:"BORDER",46:"CELL.PROTECTION",47:"COLUMN.WIDTH",48:"UNDO",49:"CUT",50:"COPY",51:"PASTE",52:"CLEAR",53:"PASTE.SPECIAL",54:"EDIT.DELETE",55:"INSERT",56:"FILL.RIGHT",57:"FILL.DOWN",61:"DEFINE.NAME",62:"CREATE.NAMES",63:"FORMULA.GOTO",64:"FORMULA.FIND",65:"SELECT.LAST.CELL",66:"SHOW.ACTIVE.CELL",67:"GALLERY.AREA",68:"GALLERY.BAR",69:"GALLERY.COLUMN",70:"GALLERY.LINE",71:"GALLERY.PIE",72:"GALLERY.SCATTER",73:"COMBINATION",74:"PREFERRED",75:"ADD.OVERLAY",76:"GRIDLINES",77:"SET.PREFERRED",78:"AXES",79:"LEGEND",80:"ATTACH.TEXT",81:"ADD.ARROW",82:"SELECT.CHART",83:"SELECT.PLOT.AREA",84:"PATTERNS",85:"MAIN.CHART",86:"OVERLAY",87:"SCALE",88:"FORMAT.LEGEND",89:"FORMAT.TEXT",90:"EDIT.REPEAT",91:"PARSE",92:"JUSTIFY",93:"HIDE",94:"UNHIDE",95:"WORKSPACE",96:"FORMULA",97:"FORMULA.FILL",98:"FORMULA.ARRAY",99:"DATA.FIND.NEXT",100:"DATA.FIND.PREV",101:"FORMULA.FIND.NEXT",102:"FORMULA.FIND.PREV",103:"ACTIVATE",104:"ACTIVATE.NEXT",105:"ACTIVATE.PREV",106:"UNLOCKED.NEXT",107:"UNLOCKED.PREV",108:"COPY.PICTURE",109:"SELECT",110:"DELETE.NAME",111:"DELETE.FORMAT",112:"VLINE",113:"HLINE",114:"VPAGE",115:"HPAGE",116:"VSCROLL",117:"HSCROLL",118:"ALERT",119:"NEW",120:"CANCEL.COPY",121:"SHOW.CLIPBOARD",122:"MESSAGE",124:"PASTE.LINK",125:"APP.ACTIVATE",126:"DELETE.ARROW",127:"ROW.HEIGHT",128:"FORMAT.MOVE",129:"FORMAT.SIZE",130:"FORMULA.REPLACE",131:"SEND.KEYS",132:"SELECT.SPECIAL",133:"APPLY.NAMES",134:"REPLACE.FONT",135:"FREEZE.PANES",136:"SHOW.INFO",137:"SPLIT",138:"ON.WINDOW",139:"ON.DATA",140:"DISABLE.INPUT",142:"OUTLINE",143:"LIST.NAMES",144:"FILE.CLOSE",145:"SAVE.WORKBOOK",146:"DATA.FORM",147:"COPY.CHART",148:"ON.TIME",149:"WAIT",150:"FORMAT.FONT",151:"FILL.UP",152:"FILL.LEFT",153:"DELETE.OVERLAY",155:"SHORT.MENUS",159:"SET.UPDATE.STATUS",161:"COLOR.PALETTE",162:"DELETE.STYLE",163:"WINDOW.RESTORE",164:"WINDOW.MAXIMIZE",166:"CHANGE.LINK",167:"CALCULATE.DOCUMENT",168:"ON.KEY",169:"APP.RESTORE",170:"APP.MOVE",171:"APP.SIZE",172:"APP.MINIMIZE",173:"APP.MAXIMIZE",174:"BRING.TO.FRONT",175:"SEND.TO.BACK",185:"MAIN.CHART.TYPE",186:"OVERLAY.CHART.TYPE",187:"SELECT.END",188:"OPEN.MAIL",189:"SEND.MAIL",190:"STANDARD.FONT",191:"CONSOLIDATE",192:"SORT.SPECIAL",193:"GALLERY.3D.AREA",194:"GALLERY.3D.COLUMN",195:"GALLERY.3D.LINE",196:"GALLERY.3D.PIE",197:"VIEW.3D",198:"GOAL.SEEK",199:"WORKGROUP",200:"FILL.GROUP",201:"UPDATE.LINK",202:"PROMOTE",203:"DEMOTE",204:"SHOW.DETAIL",206:"UNGROUP",207:"OBJECT.PROPERTIES",208:"SAVE.NEW.OBJECT",209:"SHARE",210:"SHARE.NAME",211:"DUPLICATE",212:"APPLY.STYLE",213:"ASSIGN.TO.OBJECT",214:"OBJECT.PROTECTION",215:"HIDE.OBJECT",216:"SET.EXTRACT",217:"CREATE.PUBLISHER",218:"SUBSCRIBE.TO",219:"ATTRIBUTES",220:"SHOW.TOOLBAR",222:"PRINT.PREVIEW",223:"EDIT.COLOR",224:"SHOW.LEVELS",225:"FORMAT.MAIN",226:"FORMAT.OVERLAY",227:"ON.RECALC",228:"EDIT.SERIES",229:"DEFINE.STYLE",240:"LINE.PRINT",243:"ENTER.DATA",249:"GALLERY.RADAR",250:"MERGE.STYLES",251:"EDITION.OPTIONS",252:"PASTE.PICTURE",253:"PASTE.PICTURE.LINK",254:"SPELLING",256:"ZOOM",259:"INSERT.OBJECT",260:"WINDOW.MINIMIZE",265:"SOUND.NOTE",266:"SOUND.PLAY",267:"FORMAT.SHAPE",268:"EXTEND.POLYGON",269:"FORMAT.AUTO",272:"GALLERY.3D.BAR",273:"GALLERY.3D.SURFACE",274:"FILL.AUTO",276:"CUSTOMIZE.TOOLBAR",277:"ADD.TOOL",278:"EDIT.OBJECT",279:"ON.DOUBLECLICK",280:"ON.ENTRY",281:"WORKBOOK.ADD",282:"WORKBOOK.MOVE",283:"WORKBOOK.COPY",284:"WORKBOOK.OPTIONS",285:"SAVE.WORKSPACE",288:"CHART.WIZARD",289:"DELETE.TOOL",290:"MOVE.TOOL",291:"WORKBOOK.SELECT",292:"WORKBOOK.ACTIVATE",293:"ASSIGN.TO.TOOL",295:"COPY.TOOL",296:"RESET.TOOL",297:"CONSTRAIN.NUMERIC",298:"PASTE.TOOL",302:"WORKBOOK.NEW",305:"SCENARIO.CELLS",306:"SCENARIO.DELETE",307:"SCENARIO.ADD",308:"SCENARIO.EDIT",309:"SCENARIO.SHOW",310:"SCENARIO.SHOW.NEXT",311:"SCENARIO.SUMMARY",312:"PIVOT.TABLE.WIZARD",313:"PIVOT.FIELD.PROPERTIES",314:"PIVOT.FIELD",315:"PIVOT.ITEM",316:"PIVOT.ADD.FIELDS",318:"OPTIONS.CALCULATION",319:"OPTIONS.EDIT",320:"OPTIONS.VIEW",321:"ADDIN.MANAGER",322:"MENU.EDITOR",323:"ATTACH.TOOLBARS",324:"VBAActivate",325:"OPTIONS.CHART",328:"VBA.INSERT.FILE",330:"VBA.PROCEDURE.DEFINITION",336:"ROUTING.SLIP",338:"ROUTE.DOCUMENT",339:"MAIL.LOGON",342:"INSERT.PICTURE",343:"EDIT.TOOL",344:"GALLERY.DOUGHNUT",350:"CHART.TREND",352:"PIVOT.ITEM.PROPERTIES",354:"WORKBOOK.INSERT",355:"OPTIONS.TRANSITION",356:"OPTIONS.GENERAL",370:"FILTER.ADVANCED",373:"MAIL.ADD.MAILER",374:"MAIL.DELETE.MAILER",375:"MAIL.REPLY",376:"MAIL.REPLY.ALL",377:"MAIL.FORWARD",378:"MAIL.NEXT.LETTER",379:"DATA.LABEL",380:"INSERT.TITLE",381:"FONT.PROPERTIES",382:"MACRO.OPTIONS",383:"WORKBOOK.HIDE",384:"WORKBOOK.UNHIDE",385:"WORKBOOK.DELETE",386:"WORKBOOK.NAME",388:"GALLERY.CUSTOM",390:"ADD.CHART.AUTOFORMAT",391:"DELETE.CHART.AUTOFORMAT",392:"CHART.ADD.DATA",393:"AUTO.OUTLINE",394:"TAB.ORDER",395:"SHOW.DIALOG",396:"SELECT.ALL",397:"UNGROUP.SHEETS",398:"SUBTOTAL.CREATE",399:"SUBTOTAL.REMOVE",400:"RENAME.OBJECT",412:"WORKBOOK.SCROLL",413:"WORKBOOK.NEXT",414:"WORKBOOK.PREV",415:"WORKBOOK.TAB.SPLIT",416:"FULL.SCREEN",417:"WORKBOOK.PROTECT",420:"SCROLLBAR.PROPERTIES",421:"PIVOT.SHOW.PAGES",422:"TEXT.TO.COLUMNS",423:"FORMAT.CHARTTYPE",424:"LINK.FORMAT",425:"TRACER.DISPLAY",430:"TRACER.NAVIGATE",431:"TRACER.CLEAR",432:"TRACER.ERROR",433:"PIVOT.FIELD.GROUP",434:"PIVOT.FIELD.UNGROUP",435:"CHECKBOX.PROPERTIES",436:"LABEL.PROPERTIES",437:"LISTBOX.PROPERTIES",438:"EDITBOX.PROPERTIES",439:"PIVOT.REFRESH",440:"LINK.COMBO",441:"OPEN.TEXT",442:"HIDE.DIALOG",443:"SET.DIALOG.FOCUS",444:"ENABLE.OBJECT",445:"PUSHBUTTON.PROPERTIES",446:"SET.DIALOG.DEFAULT",447:"FILTER",448:"FILTER.SHOW.ALL",449:"CLEAR.OUTLINE",450:"FUNCTION.WIZARD",451:"ADD.LIST.ITEM",452:"SET.LIST.ITEM",453:"REMOVE.LIST.ITEM",454:"SELECT.LIST.ITEM",455:"SET.CONTROL.VALUE",456:"SAVE.COPY.AS",458:"OPTIONS.LISTS.ADD",459:"OPTIONS.LISTS.DELETE",460:"SERIES.AXES",461:"SERIES.X",462:"SERIES.Y",463:"ERRORBAR.X",464:"ERRORBAR.Y",465:"FORMAT.CHART",466:"SERIES.ORDER",467:"MAIL.LOGOFF",468:"CLEAR.ROUTING.SLIP",469:"APP.ACTIVATE.MICROSOFT",470:"MAIL.EDIT.MAILER",471:"ON.SHEET",472:"STANDARD.WIDTH",473:"SCENARIO.MERGE",474:"SUMMARY.INFO",475:"FIND.FILE",476:"ACTIVE.CELL.FONT",477:"ENABLE.TIPWIZARD",478:"VBA.MAKE.ADDIN",480:"INSERTDATATABLE",481:"WORKGROUP.OPTIONS",482:"MAIL.SEND.MAILER",485:"AUTOCORRECT",489:"POST.DOCUMENT",491:"PICKLIST",493:"VIEW.SHOW",494:"VIEW.DEFINE",495:"VIEW.DELETE",509:"SHEET.BACKGROUND",510:"INSERT.MAP.OBJECT",511:"OPTIONS.MENONO",517:"MSOCHECKS",518:"NORMAL",519:"LAYOUT",520:"RM.PRINT.AREA",521:"CLEAR.PRINT.AREA",522:"ADD.PRINT.AREA",523:"MOVE.BRK",545:"HIDECURR.NOTE",546:"HIDEALL.NOTES",547:"DELETE.NOTE",548:"TRAVERSE.NOTES",549:"ACTIVATE.NOTES",620:"PROTECT.REVISIONS",621:"UNPROTECT.REVISIONS",647:"OPTIONS.ME",653:"WEB.PUBLISH",667:"NEWWEBQUERY",673:"PIVOT.TABLE.CHART",753:"OPTIONS.SAVE",755:"OPTIONS.SPELL",808:"HIDEALL.INKANNOTS"};var Yu={0:"COUNT",1:"IF",2:"ISNA",3:"ISERROR",4:"SUM",5:"AVERAGE",6:"MIN",7:"MAX",8:"ROW",9:"COLUMN",10:"NA",11:"NPV",12:"STDEV",13:"DOLLAR",14:"FIXED",15:"SIN",16:"COS",17:"TAN",18:"ATAN",19:"PI",20:"SQRT",21:"EXP",22:"LN",23:"LOG10",24:"ABS",25:"INT",26:"SIGN",27:"ROUND",28:"LOOKUP",29:"INDEX",30:"REPT",31:"MID",32:"LEN",33:"VALUE",34:"TRUE",35:"FALSE",36:"AND",37:"OR",38:"NOT",39:"MOD",40:"DCOUNT",41:"DSUM",42:"DAVERAGE",43:"DMIN",44:"DMAX",45:"DSTDEV",46:"VAR",47:"DVAR",48:"TEXT",49:"LINEST",50:"TREND",51:"LOGEST",52:"GROWTH",53:"GOTO",54:"HALT",55:"RETURN",56:"PV",57:"FV",58:"NPER",59:"PMT",60:"RATE",61:"MIRR",62:"IRR",63:"RAND",64:"MATCH",65:"DATE",66:"TIME",67:"DAY",68:"MONTH",69:"YEAR",70:"WEEKDAY",71:"HOUR",72:"MINUTE",73:"SECOND",74:"NOW",75:"AREAS",76:"ROWS",77:"COLUMNS",78:"OFFSET",79:"ABSREF",80:"RELREF",81:"ARGUMENT",82:"SEARCH",83:"TRANSPOSE",84:"ERROR",85:"STEP",86:"TYPE",87:"ECHO",88:"SET.NAME",89:"CALLER",90:"DEREF",91:"WINDOWS",92:"SERIES",93:"DOCUMENTS",94:"ACTIVE.CELL",95:"SELECTION",96:"RESULT",97:"ATAN2",98:"ASIN",99:"ACOS",100:"CHOOSE",101:"HLOOKUP",102:"VLOOKUP",103:"LINKS",104:"INPUT",105:"ISREF",106:"GET.FORMULA",107:"GET.NAME",108:"SET.VALUE",109:"LOG",110:"EXEC",111:"CHAR",112:"LOWER",113:"UPPER",114:"PROPER",115:"LEFT",116:"RIGHT",117:"EXACT",118:"TRIM",119:"REPLACE",120:"SUBSTITUTE",121:"CODE",122:"NAMES",123:"DIRECTORY",124:"FIND",125:"CELL",126:"ISERR",127:"ISTEXT",128:"ISNUMBER",129:"ISBLANK",130:"T",131:"N",132:"FOPEN",133:"FCLOSE",134:"FSIZE",135:"FREADLN",136:"FREAD",137:"FWRITELN",138:"FWRITE",139:"FPOS",140:"DATEVALUE",141:"TIMEVALUE",142:"SLN",143:"SYD",144:"DDB",145:"GET.DEF",146:"REFTEXT",147:"TEXTREF",148:"INDIRECT",149:"REGISTER",150:"CALL",151:"ADD.BAR",152:"ADD.MENU",153:"ADD.COMMAND",154:"ENABLE.COMMAND",155:"CHECK.COMMAND",156:"RENAME.COMMAND",157:"SHOW.BAR",158:"DELETE.MENU",159:"DELETE.COMMAND",160:"GET.CHART.ITEM",161:"DIALOG.BOX",162:"CLEAN",163:"MDETERM",164:"MINVERSE",165:"MMULT",166:"FILES",167:"IPMT",168:"PPMT",169:"COUNTA",170:"CANCEL.KEY",171:"FOR",172:"WHILE",173:"BREAK",174:"NEXT",175:"INITIATE",176:"REQUEST",177:"POKE",178:"EXECUTE",179:"TERMINATE",180:"RESTART",181:"HELP",182:"GET.BAR",183:"PRODUCT",184:"FACT",185:"GET.CELL",186:"GET.WORKSPACE",187:"GET.WINDOW",188:"GET.DOCUMENT",189:"DPRODUCT",190:"ISNONTEXT",191:"GET.NOTE",192:"NOTE",193:"STDEVP",194:"VARP",195:"DSTDEVP",196:"DVARP",197:"TRUNC",198:"ISLOGICAL",199:"DCOUNTA",200:"DELETE.BAR",201:"UNREGISTER",204:"USDOLLAR",205:"FINDB",206:"SEARCHB",207:"REPLACEB",208:"LEFTB",209:"RIGHTB",210:"MIDB",211:"LENB",212:"ROUNDUP",213:"ROUNDDOWN",214:"ASC",215:"DBCS",216:"RANK",219:"ADDRESS",220:"DAYS360",221:"TODAY",222:"VDB",223:"ELSE",224:"ELSE.IF",225:"END.IF",226:"FOR.CELL",227:"MEDIAN",228:"SUMPRODUCT",229:"SINH",230:"COSH",231:"TANH",232:"ASINH",233:"ACOSH",234:"ATANH",235:"DGET",236:"CREATE.OBJECT",237:"VOLATILE",238:"LAST.ERROR",239:"CUSTOM.UNDO",240:"CUSTOM.REPEAT",241:"FORMULA.CONVERT",242:"GET.LINK.INFO",243:"TEXT.BOX",244:"INFO",245:"GROUP",246:"GET.OBJECT",247:"DB",248:"PAUSE",251:"RESUME",252:"FREQUENCY",253:"ADD.TOOLBAR",254:"DELETE.TOOLBAR",255:"User",256:"RESET.TOOLBAR",257:"EVALUATE",258:"GET.TOOLBAR",259:"GET.TOOL",260:"SPELLING.CHECK",261:"ERROR.TYPE",262:"APP.TITLE",263:"WINDOW.TITLE",264:"SAVE.TOOLBAR",265:"ENABLE.TOOL",266:"PRESS.TOOL",267:"REGISTER.ID",268:"GET.WORKBOOK",269:"AVEDEV",270:"BETADIST",271:"GAMMALN",272:"BETAINV",273:"BINOMDIST",274:"CHIDIST",275:"CHIINV",276:"COMBIN",277:"CONFIDENCE",278:"CRITBINOM",279:"EVEN",280:"EXPONDIST",281:"FDIST",282:"FINV",283:"FISHER",284:"FISHERINV",285:"FLOOR",286:"GAMMADIST",287:"GAMMAINV",288:"CEILING",289:"HYPGEOMDIST",290:"LOGNORMDIST",291:"LOGINV",292:"NEGBINOMDIST",293:"NORMDIST",294:"NORMSDIST",295:"NORMINV",296:"NORMSINV",297:"STANDARDIZE",298:"ODD",299:"PERMUT",300:"POISSON",301:"TDIST",302:"WEIBULL",303:"SUMXMY2",304:"SUMX2MY2",305:"SUMX2PY2",306:"CHITEST",307:"CORREL",308:"COVAR",309:"FORECAST",310:"FTEST",311:"INTERCEPT",312:"PEARSON",313:"RSQ",314:"STEYX",315:"SLOPE",316:"TTEST",317:"PROB",318:"DEVSQ",319:"GEOMEAN",320:"HARMEAN",321:"SUMSQ",322:"KURT",323:"SKEW",324:"ZTEST",325:"LARGE",326:"SMALL",327:"QUARTILE",328:"PERCENTILE",329:"PERCENTRANK",330:"MODE",331:"TRIMMEAN",332:"TINV",334:"MOVIE.COMMAND",335:"GET.MOVIE",336:"CONCATENATE",337:"POWER",338:"PIVOT.ADD.DATA",339:"GET.PIVOT.TABLE",340:"GET.PIVOT.FIELD",341:"GET.PIVOT.ITEM",342:"RADIANS",343:"DEGREES",344:"SUBTOTAL",345:"SUMIF",346:"COUNTIF",347:"COUNTBLANK",348:"SCENARIO.GET",349:"OPTIONS.LISTS.GET",350:"ISPMT",351:"DATEDIF",352:"DATESTRING",353:"NUMBERSTRING",354:"ROMAN",355:"OPEN.DIALOG",356:"SAVE.DIALOG",357:"VIEW.GET",358:"GETPIVOTDATA",359:"HYPERLINK",360:"PHONETIC",361:"AVERAGEA",362:"MAXA",363:"MINA",364:"STDEVPA",365:"VARPA",366:"STDEVA",367:"VARA",368:"BAHTTEXT",369:"THAIDAYOFWEEK",370:"THAIDIGIT",371:"THAIMONTHOFYEAR",372:"THAINUMSOUND",373:"THAINUMSTRING",374:"THAISTRINGLENGTH",375:"ISTHAIDIGIT",376:"ROUNDBAHTDOWN",377:"ROUNDBAHTUP",378:"THAIYEAR",379:"RTD",380:"CUBEVALUE",381:"CUBEMEMBER",382:"CUBEMEMBERPROPERTY",383:"CUBERANKEDMEMBER",384:"HEX2BIN",385:"HEX2DEC",386:"HEX2OCT",387:"DEC2BIN",388:"DEC2HEX",389:"DEC2OCT",390:"OCT2BIN",391:"OCT2HEX",392:"OCT2DEC",393:"BIN2DEC",394:"BIN2OCT",395:"BIN2HEX",396:"IMSUB",397:"IMDIV",398:"IMPOWER",399:"IMABS",400:"IMSQRT",401:"IMLN",402:"IMLOG2",403:"IMLOG10",404:"IMSIN",405:"IMCOS",406:"IMEXP",407:"IMARGUMENT",408:"IMCONJUGATE",409:"IMAGINARY",410:"IMREAL",411:"COMPLEX",412:"IMSUM",413:"IMPRODUCT",414:"SERIESSUM",415:"FACTDOUBLE",416:"SQRTPI",417:"QUOTIENT",418:"DELTA",419:"GESTEP",420:"ISEVEN",421:"ISODD",422:"MROUND",423:"ERF",424:"ERFC",425:"BESSELJ",426:"BESSELK",427:"BESSELY",428:"BESSELI",429:"XIRR",430:"XNPV",431:"PRICEMAT",432:"YIELDMAT",433:"INTRATE",434:"RECEIVED",435:"DISC",436:"PRICEDISC",437:"YIELDDISC",438:"TBILLEQ",439:"TBILLPRICE",440:"TBILLYIELD",441:"PRICE",442:"YIELD",443:"DOLLARDE",444:"DOLLARFR",445:"NOMINAL",446:"EFFECT",447:"CUMPRINC",448:"CUMIPMT",449:"EDATE",450:"EOMONTH",451:"YEARFRAC",452:"COUPDAYBS",453:"COUPDAYS",454:"COUPDAYSNC",455:"COUPNCD",456:"COUPNUM",457:"COUPPCD",458:"DURATION",459:"MDURATION",460:"ODDLPRICE",461:"ODDLYIELD",462:"ODDFPRICE",463:"ODDFYIELD",464:"RANDBETWEEN",465:"WEEKNUM",466:"AMORDEGRC",467:"AMORLINC",468:"CONVERT",724:"SHEETJS",469:"ACCRINT",470:"ACCRINTM",471:"WORKDAY",472:"NETWORKDAYS",473:"GCD",474:"MULTINOMIAL",475:"LCM",476:"FVSCHEDULE",477:"CUBEKPIMEMBER",478:"CUBESET",479:"CUBESETCOUNT",480:"IFERROR",481:"COUNTIFS",482:"SUMIFS",483:"AVERAGEIF",484:"AVERAGEIFS"};var $u={2:1,3:1,10:0,15:1,16:1,17:1,18:1,19:0,20:1,21:1,22:1,23:1,24:1,25:1,26:1,27:2,30:2,31:3,32:1,33:1,34:0,35:0,38:1,39:2,40:3,41:3,42:3,43:3,44:3,45:3,47:3,48:2,53:1,61:3,63:0,65:3,66:3,67:1,68:1,69:1,70:1,71:1,72:1,73:1,74:0,75:1,76:1,77:1,79:2,80:2,83:1,85:0,86:1,89:0,90:1,94:0,95:0,97:2,98:1,99:1,101:3,102:3,105:1,106:1,108:2,111:1,112:1,113:1,114:1,117:2,118:1,119:4,121:1,126:1,127:1,128:1,129:1,130:1,131:1,133:1,134:1,135:1,136:2,137:2,138:2,140:1,141:1,142:3,143:4,144:4,161:1,162:1,163:1,164:1,165:2,172:1,175:2,176:2,177:3,178:2,179:1,184:1,186:1,189:3,190:1,195:3,196:3,197:1,198:1,199:3,201:1,207:4,210:3,211:1,212:2,213:2,214:1,215:1,225:0,229:1,230:1,231:1,232:1,233:1,234:1,235:3,244:1,247:4,252:2,257:1,261:1,271:1,273:4,274:2,275:2,276:2,277:3,278:3,279:1,280:3,281:3,282:3,283:1,284:1,285:2,286:4,287:3,288:2,289:4,290:3,291:3,292:3,293:4,294:1,295:3,296:1,297:3,298:1,299:2,300:3,301:3,302:4,303:2,304:2,305:2,306:2,307:2,308:2,309:3,310:2,311:2,312:2,313:2,314:2,315:2,316:4,325:2,326:2,327:2,328:2,331:2,332:2,337:2,342:1,343:1,346:2,347:1,350:4,351:3,352:1,353:2,360:1,368:1,369:1,370:1,371:1,372:1,373:1,374:1,375:1,376:1,377:1,378:1,382:3,385:1,392:1,393:1,396:2,397:2,398:2,399:1,400:1,401:1,402:1,403:1,404:1,405:1,406:1,407:1,408:1,409:1,410:1,414:4,415:1,416:1,417:2,420:1,421:1,422:2,424:1,425:2,426:2,427:2,428:2,430:3,438:3,439:3,440:3,443:2,444:2,445:2,446:2,447:6,448:6,449:2,450:2,464:2,468:3,476:2,479:1,480:2,65535:0};var Zu={"_xlfn.ACOT":"ACOT","_xlfn.ACOTH":"ACOTH","_xlfn.AGGREGATE":"AGGREGATE","_xlfn.ARABIC":"ARABIC","_xlfn.AVERAGEIF":"AVERAGEIF","_xlfn.AVERAGEIFS":"AVERAGEIFS","_xlfn.BASE":"BASE","_xlfn.BETA.DIST":"BETA.DIST","_xlfn.BETA.INV":"BETA.INV","_xlfn.BINOM.DIST":"BINOM.DIST","_xlfn.BINOM.DIST.RANGE":"BINOM.DIST.RANGE","_xlfn.BINOM.INV":"BINOM.INV","_xlfn.BITAND":"BITAND","_xlfn.BITLSHIFT":"BITLSHIFT","_xlfn.BITOR":"BITOR","_xlfn.BITRSHIFT":"BITRSHIFT","_xlfn.BITXOR":"BITXOR","_xlfn.CEILING.MATH":"CEILING.MATH","_xlfn.CEILING.PRECISE":"CEILING.PRECISE","_xlfn.CHISQ.DIST":"CHISQ.DIST","_xlfn.CHISQ.DIST.RT":"CHISQ.DIST.RT","_xlfn.CHISQ.INV":"CHISQ.INV","_xlfn.CHISQ.INV.RT":"CHISQ.INV.RT","_xlfn.CHISQ.TEST":"CHISQ.TEST","_xlfn.COMBINA":"COMBINA","_xlfn.CONCAT":"CONCAT","_xlfn.CONFIDENCE.NORM":"CONFIDENCE.NORM",
"_xlfn.CONFIDENCE.T":"CONFIDENCE.T","_xlfn.COT":"COT","_xlfn.COTH":"COTH","_xlfn.COUNTIFS":"COUNTIFS","_xlfn.COVARIANCE.P":"COVARIANCE.P","_xlfn.COVARIANCE.S":"COVARIANCE.S","_xlfn.CSC":"CSC","_xlfn.CSCH":"CSCH","_xlfn.DAYS":"DAYS","_xlfn.DECIMAL":"DECIMAL","_xlfn.ECMA.CEILING":"ECMA.CEILING","_xlfn.ERF.PRECISE":"ERF.PRECISE","_xlfn.ERFC.PRECISE":"ERFC.PRECISE","_xlfn.EXPON.DIST":"EXPON.DIST","_xlfn.F.DIST":"F.DIST","_xlfn.F.DIST.RT":"F.DIST.RT","_xlfn.F.INV":"F.INV","_xlfn.F.INV.RT":"F.INV.RT","_xlfn.F.TEST":"F.TEST","_xlfn.FILTERXML":"FILTERXML","_xlfn.FLOOR.MATH":"FLOOR.MATH","_xlfn.FLOOR.PRECISE":"FLOOR.PRECISE","_xlfn.FORECAST.ETS":"FORECAST.ETS","_xlfn.FORECAST.ETS.CONFINT":"FORECAST.ETS.CONFINT","_xlfn.FORECAST.ETS.SEASONALITY":"FORECAST.ETS.SEASONALITY","_xlfn.FORECAST.ETS.STAT":"FORECAST.ETS.STAT","_xlfn.FORECAST.LINEAR":"FORECAST.LINEAR","_xlfn.FORMULATEXT":"FORMULATEXT","_xlfn.GAMMA":"GAMMA","_xlfn.GAMMA.DIST":"GAMMA.DIST","_xlfn.GAMMA.INV":"GAMMA.INV","_xlfn.GAMMALN.PRECISE":"GAMMALN.PRECISE","_xlfn.GAUSS":"GAUSS","_xlfn.HYPGEOM.DIST":"HYPGEOM.DIST","_xlfn.IFERROR":"IFERROR","_xlfn.IFNA":"IFNA","_xlfn.IFS":"IFS","_xlfn.IMCOSH":"IMCOSH","_xlfn.IMCOT":"IMCOT","_xlfn.IMCSC":"IMCSC","_xlfn.IMCSCH":"IMCSCH","_xlfn.IMSEC":"IMSEC","_xlfn.IMSECH":"IMSECH","_xlfn.IMSINH":"IMSINH","_xlfn.IMTAN":"IMTAN","_xlfn.ISFORMULA":"ISFORMULA","_xlfn.ISO.CEILING":"ISO.CEILING","_xlfn.ISOWEEKNUM":"ISOWEEKNUM","_xlfn.LOGNORM.DIST":"LOGNORM.DIST","_xlfn.LOGNORM.INV":"LOGNORM.INV","_xlfn.MAXIFS":"MAXIFS","_xlfn.MINIFS":"MINIFS","_xlfn.MODE.MULT":"MODE.MULT","_xlfn.MODE.SNGL":"MODE.SNGL","_xlfn.MUNIT":"MUNIT","_xlfn.NEGBINOM.DIST":"NEGBINOM.DIST","_xlfn.NETWORKDAYS.INTL":"NETWORKDAYS.INTL","_xlfn.NIGBINOM":"NIGBINOM","_xlfn.NORM.DIST":"NORM.DIST","_xlfn.NORM.INV":"NORM.INV","_xlfn.NORM.S.DIST":"NORM.S.DIST","_xlfn.NORM.S.INV":"NORM.S.INV","_xlfn.NUMBERVALUE":"NUMBERVALUE","_xlfn.PDURATION":"PDURATION","_xlfn.PERCENTILE.EXC":"PERCENTILE.EXC","_xlfn.PERCENTILE.INC":"PERCENTILE.INC","_xlfn.PERCENTRANK.EXC":"PERCENTRANK.EXC","_xlfn.PERCENTRANK.INC":"PERCENTRANK.INC","_xlfn.PERMUTATIONA":"PERMUTATIONA","_xlfn.PHI":"PHI","_xlfn.POISSON.DIST":"POISSON.DIST","_xlfn.QUARTILE.EXC":"QUARTILE.EXC","_xlfn.QUARTILE.INC":"QUARTILE.INC","_xlfn.QUERYSTRING":"QUERYSTRING","_xlfn.RANK.AVG":"RANK.AVG","_xlfn.RANK.EQ":"RANK.EQ","_xlfn.RRI":"RRI","_xlfn.SEC":"SEC","_xlfn.SECH":"SECH","_xlfn.SHEET":"SHEET","_xlfn.SHEETS":"SHEETS","_xlfn.SKEW.P":"SKEW.P","_xlfn.STDEV.P":"STDEV.P","_xlfn.STDEV.S":"STDEV.S","_xlfn.SUMIFS":"SUMIFS","_xlfn.SWITCH":"SWITCH","_xlfn.T.DIST":"T.DIST","_xlfn.T.DIST.2T":"T.DIST.2T","_xlfn.T.DIST.RT":"T.DIST.RT","_xlfn.T.INV":"T.INV","_xlfn.T.INV.2T":"T.INV.2T","_xlfn.T.TEST":"T.TEST","_xlfn.TEXTJOIN":"TEXTJOIN","_xlfn.UNICHAR":"UNICHAR","_xlfn.UNICODE":"UNICODE","_xlfn.VAR.P":"VAR.P","_xlfn.VAR.S":"VAR.S","_xlfn.WEBSERVICE":"WEBSERVICE","_xlfn.WEIBULL.DIST":"WEIBULL.DIST","_xlfn.WORKDAY.INTL":"WORKDAY.INTL","_xlfn.XOR":"XOR","_xlfn.Z.TEST":"Z.TEST"};function Qu(e){if(e.slice(0,3)=="of:")e=e.slice(3);if(e.charCodeAt(0)==61){e=e.slice(1);if(e.charCodeAt(0)==61)e=e.slice(1)}e=e.replace(/COM\.MICROSOFT\./g,"");e=e.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g,function(e,r){return r.replace(/\./g,"")});e=e.replace(/\[.(#[A-Z]*[?!])\]/g,"$1");return e.replace(/[;~]/g,",").replace(/\|/g,";")}function Ju(e){var r="of:="+e.replace(qo,"$1[.$2$3$4$5]").replace(/\]:\[/g,":");return r.replace(/;/g,"|").replace(/,/g,";")}function qu(e){var r=e.split(":");var t=r[0].split(".")[0];return[t,r[0].split(".")[1]+(r.length>1?":"+(r[1].split(".")[1]||r[1].split(".")[0]):"")]}function eh(e){return e.replace(/\./,"!")}var rh={};var th={};Na.WS=["http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet","http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"];var ah=typeof Map!=="undefined";function nh(e,r,t){var a=0,n=e.length;if(t){if(ah?t.has(r):t.hasOwnProperty(r)){var i=ah?t.get(r):t[r];for(;a<i.length;++a){if(e[i[a]].t===r){e.Count++;return i[a]}}}}else for(;a<n;++a){if(e[a].t===r){e.Count++;return a}}e[n]={t:r};e.Count++;e.Unique++;if(t){if(ah){if(!t.has(r))t.set(r,[]);t.get(r).push(n)}else{if(!t.hasOwnProperty(r))t[r]=[];t[r].push(n)}}return n}function ih(e,r){var t={min:e+1,max:e+1};var a=-1;if(r.MDW)cl=r.MDW;if(r.width!=null)t.customWidth=1;else if(r.wpx!=null)a=hl(r.wpx);else if(r.wch!=null)a=r.wch;if(a>-1){t.width=dl(a);t.customWidth=1}else if(r.width!=null)t.width=r.width;if(r.hidden)t.hidden=true;return t}function sh(e,r){if(!e)return;var t=[.7,.7,.75,.75,.3,.3];if(r=="xlml")t=[1,1,1,1,.5,.5];if(e.left==null)e.left=t[0];if(e.right==null)e.right=t[1];if(e.top==null)e.top=t[2];if(e.bottom==null)e.bottom=t[3];if(e.header==null)e.header=t[4];if(e.footer==null)e.footer=t[5]}function fh(e,r,t){var a=t.revssf[r.z!=null?r.z:"General"];var n=60,i=e.length;if(a==null&&t.ssf){for(;n<392;++n)if(t.ssf[n]==null){F.load(r.z,n);t.ssf[n]=r.z;t.revssf[r.z]=a=n;break}}for(n=0;n!=i;++n)if(e[n].numFmtId===a)return n;e[i]={numFmtId:a,fontId:0,fillId:0,borderId:0,xfId:0,applyNumberFormat:1};return i}function lh(e,r,t,a,n,i){try{if(a.cellNF)e.z=F._table[r]}catch(s){if(a.WTF)throw s}if(e.t==="z")return;if(e.t==="d"&&typeof e.v==="string")e.v=se(e.v);if(!a||a.cellText!==false)try{if(F._table[r]==null)F.load(N[r]||"General",r);if(e.t==="e")e.w=e.w||Zt[e.v];else if(r===0){if(e.t==="n"){if((e.v|0)===e.v)e.w=F._general_int(e.v);else e.w=F._general_num(e.v)}else if(e.t==="d"){var f=re(e.v);if((f|0)===f)e.w=F._general_int(f);else e.w=F._general_num(f)}else if(e.v===undefined)return"";else e.w=F._general(e.v,th)}else if(e.t==="d")e.w=F.format(r,re(e.v),th);else e.w=F.format(r,e.v,th)}catch(s){if(a.WTF)throw s}if(!a.cellStyles)return;if(t!=null)try{e.s=i.Fills[t];if(e.s.fgColor&&e.s.fgColor.theme&&!e.s.fgColor.rgb){e.s.fgColor.rgb=sl(n.themeElements.clrScheme[e.s.fgColor.theme].rgb,e.s.fgColor.tint||0);if(a.WTF)e.s.fgColor.raw_rgb=n.themeElements.clrScheme[e.s.fgColor.theme].rgb}if(e.s.bgColor&&e.s.bgColor.theme){e.s.bgColor.rgb=sl(n.themeElements.clrScheme[e.s.bgColor.theme].rgb,e.s.bgColor.tint||0);if(a.WTF)e.s.bgColor.raw_rgb=n.themeElements.clrScheme[e.s.bgColor.theme].rgb}}catch(s){if(a.WTF&&i.Fills)throw s}}function oh(e,r,t){if(e&&e["!ref"]){var a=gt(e["!ref"]);if(a.e.c<a.s.c||a.e.r<a.s.r)throw new Error("Bad range ("+t+"): "+e["!ref"])}}function ch(e,r){var t=gt(r);if(t.s.r<=t.e.r&&t.s.c<=t.e.c&&t.s.r>=0&&t.s.c>=0)e["!ref"]=bt(t)}var uh=/<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g;var hh=/<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/;var dh=/<(?:\w:)?hyperlink [^>]*>/gm;var vh=/"(\w*:\w*)"/;var ph=/<(?:\w:)?col\b[^>]*[\/]?>/g;var mh=/<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g;var bh=/<(?:\w:)?pageMargins[^>]*\/>/g;var gh=/<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/;var wh=/<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;function kh(e,r,t,a,n,i,s){if(!e)return e;if(!a)a={"!id":{}};if(m!=null&&r.dense==null)r.dense=m;var f=r.dense?[]:{};var l={s:{r:2e6,c:2e6},e:{r:0,c:0}};var o="",c="";var u=e.match(hh);if(u){o=e.slice(0,u.index);c=e.slice(u.index+u[0].length)}else o=c=e;var h=o.match(gh);if(h)Sh(h[0],f,n,t);var d=(o.match(/<(?:\w*:)?dimension/)||{index:-1}).index;if(d>0){var v=o.slice(d,d+50).match(vh);if(v)ch(f,v[1])}var p=o.match(wh);if(p&&p[1])Ph(p[1],n);var b=[];if(r.cellStyles){var g=o.match(ph);if(g)Ih(b,g)}if(u)Mh(u[1],f,r,l,i,s);var w=c.match(mh);if(w)f["!autofilter"]=Dh(w[0]);var k=[];var E=c.match(uh);if(E)for(d=0;d!=E.length;++d)k[d]=gt(E[d].slice(E[d].indexOf('"')+1));var S=c.match(dh);if(S)yh(f,S,a);var _=c.match(bh);if(_)f["!margins"]=xh(De(_[0]));if(!f["!ref"]&&l.e.c>=l.s.c&&l.e.r>=l.s.r)f["!ref"]=bt(l);if(r.sheetRows>0&&f["!ref"]){var C=gt(f["!ref"]);if(r.sheetRows<=+C.e.r){C.e.r=r.sheetRows-1;if(C.e.r>l.e.r)C.e.r=l.e.r;if(C.e.r<C.s.r)C.s.r=C.e.r;if(C.e.c>l.e.c)C.e.c=l.e.c;if(C.e.c<C.s.c)C.s.c=C.e.c;f["!fullref"]=f["!ref"];f["!ref"]=bt(C)}}if(b.length>0)f["!cols"]=b;if(k.length>0)f["!merges"]=k;return f}function Eh(e){if(e.length===0)return"";var r='<mergeCells count="'+e.length+'">';for(var t=0;t!=e.length;++t)r+='<mergeCell ref="'+bt(e[t])+'"/>';return r+"</mergeCells>"}function Sh(e,r,t,a){var n=De(e);if(!t.Sheets[a])t.Sheets[a]={};if(n.codeName)t.Sheets[a].CodeName=n.codeName}function _h(e,r,t,a,n){var i=false;var s={},f=null;if(a.bookType!=="xlsx"&&r.vbaraw){var l=r.SheetNames[t];try{if(r.Workbook)l=r.Workbook.Sheets[t].CodeName||l}catch(o){}i=true;s.codeName=Ue(l)}if(!i&&!f)return;n[n.length]=fr("sheetPr",f,s)}var Ch=["objects","scenarios","selectLockedCells","selectUnlockedCells"];var Bh=["formatColumns","formatRows","formatCells","insertColumns","insertRows","insertHyperlinks","deleteColumns","deleteRows","sort","autoFilter","pivotTables"];function Th(e){var r={sheet:1};Ch.forEach(function(t){if(e[t]!=null&&e[t])r[t]="1"});Bh.forEach(function(t){if(e[t]!=null&&!e[t])r[t]="0"});if(e.password)r.password=Yf(e.password).toString(16).toUpperCase();return fr("sheetProtection",null,r)}function yh(e,r,t){var a=Array.isArray(e);for(var n=0;n!=r.length;++n){var i=De(Ke(r[n]),true);if(!i.ref)return;var s=((t||{})["!id"]||[])[i.id];if(s){i.Target=s.Target;if(i.location)i.Target+="#"+i.location}else{i.Target="#"+i.location;s={Target:i.Target,TargetMode:"Internal"}}i.Rel=s;if(i.tooltip){i.Tooltip=i.tooltip;delete i.tooltip}var f=gt(i.ref);for(var l=f.s.r;l<=f.e.r;++l)for(var o=f.s.c;o<=f.e.c;++o){var c=pt({c:o,r:l});if(a){if(!e[l])e[l]=[];if(!e[l][o])e[l][o]={t:"z",v:undefined};e[l][o].l=i}else{if(!e[c])e[c]={t:"z",v:undefined};e[c].l=i}}}}function xh(e){var r={};["left","right","top","bottom","header","footer"].forEach(function(t){if(e[t])r[t]=parseFloat(e[t])});return r}function Ah(e){sh(e);return fr("pageMargins",null,e)}function Ih(e,r){var t=false;for(var a=0;a!=r.length;++a){var n=De(r[a],true);if(n.hidden)n.hidden=je(n.hidden);var i=parseInt(n.min,10)-1,s=parseInt(n.max,10)-1;delete n.min;delete n.max;n.width=+n.width;if(!t&&n.width){t=true;pl(n.width)}ml(n);while(i<=s)e[i++]=le(n)}}function Rh(e,r){var t=["<cols>"],a;for(var n=0;n!=r.length;++n){if(!(a=r[n]))continue;t[t.length]=fr("col",null,ih(n,a))}t[t.length]="</cols>";return t.join("")}function Dh(e){var r={ref:(e.match(/ref="([^"]*)"/)||[])[1]};return r}function Fh(e,r,t,a){var n=typeof e.ref=="string"?e.ref:bt(e.ref);if(!t.Workbook)t.Workbook={Sheets:[]};if(!t.Workbook.Names)t.Workbook.Names=[];var i=t.Workbook.Names;var s=mt(n);if(s.s.r==s.e.r){s.e.r=mt(r["!ref"]).e.r;n=bt(s)}for(var f=0;f<i.length;++f){var l=i[f];if(l.Name!="_xlnm._FilterDatabase")continue;if(l.Sheet!=a)continue;l.Ref="'"+t.SheetNames[a]+"'!"+n;break}if(f==i.length)i.push({Name:"_xlnm._FilterDatabase",Sheet:a,Ref:"'"+t.SheetNames[a]+"'!"+n});return fr("autoFilter",null,{ref:n})}var Oh=/<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;function Ph(e,r){if(!r.Views)r.Views=[{}];(e.match(Oh)||[]).forEach(function(e,t){var a=De(e);if(!r.Views[t])r.Views[t]={};if(je(a.rightToLeft))r.Views[t].RTL=true})}function Nh(e,r,t,a){var n={workbookViewId:"0"};if((((a||{}).Workbook||{}).Views||[])[0])n.rightToLeft=a.Workbook.Views[0].RTL?"1":"0";return fr("sheetViews",fr("sheetView",null,n),{})}function Lh(e,r,t,a){if(e.v===undefined&&e.f===undefined||e.t==="z")return"";var n="";var i=e.t,s=e.v;if(e.t!=="z")switch(e.t){case"b":n=e.v?"1":"0";break;case"n":n=""+e.v;break;case"e":n=Zt[e.v];break;case"d":if(a&&a.cellDates)n=se(e.v,-1).toISOString();else{e=le(e);e.t="n";n=""+(e.v=re(se(e.v)))}if(typeof e.z==="undefined")e.z=F._table[14];break;default:n=e.v;break;}var f=ir("v",Ue(n)),l={r:r};var o=fh(a.cellXfs,e,a);if(o!==0)l.s=o;switch(e.t){case"n":break;case"d":l.t="d";break;case"b":l.t="b";break;case"e":l.t="e";break;case"z":break;default:if(e.v==null){delete e.t;break}if(a&&a.bookSST){f=ir("v",""+nh(a.Strings,e.v,a.revStrings));l.t="s";break}l.t="str";break;}if(e.t!=i){e.t=i;e.v=s}if(e.f){var c=e.F&&e.F.slice(0,r.length)==r?{t:"array",ref:e.F}:null;f=fr("f",Ue(e.f),c)+(e.v!=null?f:"")}if(e.l)t["!links"].push([r,e.l]);if(e.c)t["!comments"].push([r,e.c]);return fr("c",f,l)}var Mh=function(){var e=/<(?:\w+:)?c[ >]/,r=/<\/(?:\w+:)?row>/;var t=/r=["']([^"']*)["']/,a=/<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/;var n=/ref=["']([^"']*)["']/;var i=Je("v"),s=Je("f");return function f(l,o,c,u,h,d){var v=0,p="",m=[],b=[],g=0,w=0,k=0,E="",S;var _,C=0,B=0;var T,y;var x=0,A=0;var I=Array.isArray(d.CellXf),R;var D=[];var O=[];var P=Array.isArray(o);var N=[],L={},M=false;for(var U=l.split(r),H=0,W=U.length;H!=W;++H){p=U[H].trim();var z=p.length;if(z===0)continue;for(v=0;v<z;++v)if(p.charCodeAt(v)===62)break;++v;_=De(p.slice(0,v),true);C=_.r!=null?parseInt(_.r,10):C+1;B=-1;if(c.sheetRows&&c.sheetRows<C)continue;if(u.s.r>C-1)u.s.r=C-1;if(u.e.r<C-1)u.e.r=C-1;if(c&&c.cellStyles){L={};M=false;if(_.ht){M=true;L.hpt=parseFloat(_.ht);L.hpx=kl(L.hpt)}if(_.hidden=="1"){M=true;L.hidden=true}if(_.outlineLevel!=null){M=true;L.level=+_.outlineLevel}if(M)N[C-1]=L}m=p.slice(v).split(e);for(var V=0;V!=m.length;++V)if(m[V].trim().charAt(0)!="<")break;m=m.slice(V);for(v=0;v!=m.length;++v){p=m[v].trim();if(p.length===0)continue;b=p.match(t);g=v;w=0;k=0;p="<c "+(p.slice(0,1)=="<"?">":"")+p;if(b!=null&&b.length===2){g=0;E=b[1];for(w=0;w!=E.length;++w){if((k=E.charCodeAt(w)-64)<1||k>26)break;g=26*g+k}--g;B=g}else++B;for(w=0;w!=p.length;++w)if(p.charCodeAt(w)===62)break;++w;_=De(p.slice(0,w),true);if(!_.r)_.r=pt({r:C-1,c:B});E=p.slice(w);S={t:""};if((b=E.match(i))!=null&&b[1]!=="")S.v=Ne(b[1]);if(c.cellFormula){if((b=E.match(s))!=null&&b[1]!==""){S.f=nc(Ne(Ke(b[1])));if(b[0].indexOf('t="array"')>-1){S.F=(E.match(n)||[])[1];if(S.F.indexOf(":")>-1)D.push([gt(S.F),S.F])}else if(b[0].indexOf('t="shared"')>-1){y=De(b[0]);O[parseInt(y.si,10)]=[y,nc(Ne(Ke(b[1]))),_.r]}}else if(b=E.match(/<f[^>]*\/>/)){y=De(b[0]);if(O[y.si])S.f=tc(O[y.si][1],O[y.si][2],_.r)}var X=vt(_.r);for(w=0;w<D.length;++w)if(X.r>=D[w][0].s.r&&X.r<=D[w][0].e.r)if(X.c>=D[w][0].s.c&&X.c<=D[w][0].e.c)S.F=D[w][1]}if(_.t==null&&S.v===undefined){if(S.f||S.F){S.v=0;S.t="n"}else if(!c.sheetStubs)continue;else S.t="z"}else S.t=_.t||"n";if(u.s.c>B)u.s.c=B;if(u.e.c<B)u.e.c=B;switch(S.t){case"n":if(S.v==""||S.v==null){if(!c.sheetStubs)continue;S.t="z"}else S.v=parseFloat(S.v);break;case"s":if(typeof S.v=="undefined"){if(!c.sheetStubs)continue;S.t="z"}else{T=rh[parseInt(S.v,10)];S.v=T.t;S.r=T.r;if(c.cellHTML)S.h=T.h}break;case"str":S.t="s";S.v=S.v!=null?Ke(S.v):"";if(c.cellHTML)S.h=ze(S.v);break;case"inlineStr":b=E.match(a);S.t="s";if(b!=null&&(T=kf(b[1]))){S.v=T.t;if(c.cellHTML)S.h=T.h}else S.v="";break;case"b":S.v=je(S.v);break;case"d":if(c.cellDates)S.v=se(S.v,1);else{S.v=re(se(S.v,1));S.t="n"}break;case"e":if(!c||c.cellText!==false)S.w=S.v;S.v=Qt[S.v];break;}x=A=0;R=null;if(I&&_.s!==undefined){R=d.CellXf[_.s];if(R!=null){if(R.numFmtId!=null)x=R.numFmtId;if(c.cellStyles){if(R.fillId!=null)A=R.fillId}}}lh(S,x,A,c,h,d);if(c.cellDates&&I&&S.t=="n"&&F.is_date(F._table[x])){S.t="d";S.v=te(S.v)}if(P){var G=vt(_.r);if(!o[G.r])o[G.r]=[];o[G.r][G.c]=S}else o[_.r]=S}}if(N.length>0)o["!rows"]=N}}();function Uh(e,r,t,a){var n=[],i=[],s=gt(e["!ref"]),f="",l,o="",c=[],u=0,h=0,d=e["!rows"];var v=Array.isArray(e);var p={r:o},m,b=-1;for(h=s.s.c;h<=s.e.c;++h)c[h]=ct(h);for(u=s.s.r;u<=s.e.r;++u){i=[];o=st(u);for(h=s.s.c;h<=s.e.c;++h){l=c[h]+o;var g=v?(e[u]||[])[h]:e[l];if(g===undefined)continue;if((f=Lh(g,l,e,r,t,a))!=null)i.push(f)}if(i.length>0||d&&d[u]){p={r:o};if(d&&d[u]){m=d[u];if(m.hidden)p.hidden=1;b=-1;if(m.hpx)b=wl(m.hpx);else if(m.hpt)b=m.hpt;if(b>-1){p.ht=b;p.customHeight=1}if(m.level){p.outlineLevel=m.level}}n[n.length]=fr("row",i.join(""),p)}}if(d)for(;u<d.length;++u){if(d&&d[u]){p={r:u+1};m=d[u];if(m.hidden)p.hidden=1;b=-1;if(m.hpx)b=wl(m.hpx);else if(m.hpt)b=m.hpt;if(b>-1){p.ht=b;p.customHeight=1}if(m.level){p.outlineLevel=m.level}n[n.length]=fr("row","",p)}}return n.join("")}var Hh=fr("worksheet",null,{xmlns:cr.main[0],"xmlns:r":cr.r});function Wh(e,r,t,a){var n=[ye,Hh];var i=t.SheetNames[e],s=0,f="";var l=t.Sheets[i];if(l==null)l={};var o=l["!ref"]||"A1";var c=gt(o);if(c.e.c>16383||c.e.r>1048575){if(r.WTF)throw new Error("Range "+o+" exceeds format limit A1:XFD1048576");c.e.c=Math.min(c.e.c,16383);c.e.r=Math.min(c.e.c,1048575);o=bt(c)}if(!a)a={};l["!comments"]=[];var u=[];_h(l,t,e,r,n);n[n.length]=fr("dimension",null,{ref:o});n[n.length]=Nh(l,r,e,t);if(r.sheetFormat)n[n.length]=fr("sheetFormatPr",null,{defaultRowHeight:r.sheetFormat.defaultRowHeight||"16",baseColWidth:r.sheetFormat.baseColWidth||"10",outlineLevelRow:r.sheetFormat.outlineLevelRow||"7"});if(l["!cols"]!=null&&l["!cols"].length>0)n[n.length]=Rh(l,l["!cols"]);n[s=n.length]="<sheetData/>";l["!links"]=[];if(l["!ref"]!=null){f=Uh(l,r,e,t,a);if(f.length>0)n[n.length]=f}if(n.length>s+1){n[n.length]="</sheetData>";n[s]=n[s].replace("/>",">")}if(l["!protect"]!=null)n[n.length]=Th(l["!protect"]);if(l["!autofilter"]!=null)n[n.length]=Fh(l["!autofilter"],l,t,e);if(l["!merges"]!=null&&l["!merges"].length>0)n[n.length]=Eh(l["!merges"]);var h=-1,d,v=-1;if(l["!links"].length>0){n[n.length]="<hyperlinks>";l["!links"].forEach(function(e){if(!e[1].Target)return;d={ref:e[0]};if(e[1].Target.charAt(0)!="#"){v=za(a,-1,Ue(e[1].Target).replace(/#.*$/,""),Na.HLINK);d["r:id"]="rId"+v}if((h=e[1].Target.indexOf("#"))>-1)d.location=Ue(e[1].Target.slice(h+1));if(e[1].Tooltip)d.tooltip=Ue(e[1].Tooltip);n[n.length]=fr("hyperlink",null,d)});n[n.length]="</hyperlinks>"}delete l["!links"];if(l["!margins"]!=null)n[n.length]=Ah(l["!margins"]);if(!r||r.ignoreEC||r.ignoreEC==void 0)n[n.length]=ir("ignoredErrors",fr("ignoredError",null,{numberStoredAsText:1,sqref:o}));if(u.length>0){v=za(a,-1,"../drawings/drawing"+(e+1)+".xml",Na.DRAW);n[n.length]=fr("drawing",null,{"r:id":"rId"+v});l["!drawing"]=u}if(l["!comments"].length>0){v=za(a,-1,"../drawings/vmlDrawing"+(e+1)+".vml",Na.VML);n[n.length]=fr("legacyDrawing",null,{"r:id":"rId"+v});l["!legacy"]=v}if(n.length>1){n[n.length]="</worksheet>";n[1]=n[1].replace("/>",">")}return n.join("")}function zh(e,r){var t={};var a=e.l+r;t.r=e._R(4);e.l+=4;var n=e._R(2);e.l+=1;var i=e._R(1);e.l=a;if(i&7)t.level=i&7;if(i&16)t.hidden=true;if(i&32)t.hpt=n/20;return t}function Vh(e,r,t){var a=$r(17+8*16);var n=(t["!rows"]||[])[e]||{};a._W(4,e);a._W(4,0);var i=320;if(n.hpx)i=wl(n.hpx)*20;else if(n.hpt)i=n.hpt*20;a._W(2,i);a._W(1,0);var s=0;if(n.level)s|=n.level;if(n.hidden)s|=16;if(n.hpx||n.hpt)s|=32;a._W(1,s);a._W(1,0);var f=0,l=a.l;a.l+=4;var o={r:e,c:0};for(var c=0;c<16;++c){if(r.s.c>c+1<<10||r.e.c<c<<10)continue;var u=-1,h=-1;for(var d=c<<10;d<c+1<<10;++d){o.c=d;var v=Array.isArray(t)?(t[o.r]||[])[o.c]:t[pt(o)];if(v){if(u<0)u=d;h=d}}if(u<0)continue;++f;a._W(4,u);a._W(4,h)}var p=a.l;a.l=l;a._W(4,f);a.l=p;return a.length>a.l?a.slice(0,a.l):a}function Xh(e,r,t,a){var n=Vh(a,t,r);if(n.length>17||(r["!rows"]||[])[a])Jr(e,"BrtRowHdr",n)}var Gh=jt;var jh=Kt;function Kh(){}function Yh(e,r){var t={};e.l+=19;t.name=Pt(e,r-19);return t}function $h(e,r){if(r==null)r=$r(84+4*e.length);for(var t=0;t<3;++t)r._W(1,0);qt({auto:1},r);r._W(-4,-1);r._W(-4,-1);Nt(e,r);return r.slice(0,r.l)}function Zh(e){var r=Ft(e);return[r]}function Qh(e,r,t){if(t==null)t=$r(8);return Ot(r,t)}function Jh(e){var r=Ft(e);var t=e._R(1);return[r,t,"b"]}function qh(e,r,t){if(t==null)t=$r(9);Ot(r,t);t._W(1,e.v?1:0);return t}function ed(e){var r=Ft(e);var t=e._R(1);return[r,t,"e"]}function rd(e){var r=Ft(e);var t=e._R(4);return[r,t,"s"]}function td(e,r,t){if(t==null)t=$r(12);Ot(r,t);t._W(4,r.v);return t}function ad(e){var r=Ft(e);var t=Yt(e);return[r,t,"n"]}function nd(e,r,t){if(t==null)t=$r(16);Ot(r,t);$t(e.v,t);return t}function id(e){var r=Ft(e);var t=zt(e);return[r,t,"n"]}function sd(e,r,t){if(t==null)t=$r(12);Ot(r,t);Vt(e.v,t);return t}function fd(e){var r=Ft(e);var t=Bt(e);return[r,t,"str"]}function ld(e,r,t){if(t==null)t=$r(12+4*e.v.length);Ot(r,t);Tt(e.v,t);return t.length>t.l?t.slice(0,t.l):t}function od(e,r,t){var a=e.l+r;var n=Ft(e);n.r=t["!row"];var i=e._R(1);var s=[n,i,"b"];if(t.cellFormula){e.l+=2;var f=Xu(e,a-e.l,t);s[3]=Fu(f,null,n,t.supbooks,t)}else e.l=a;return s}function cd(e,r,t){var a=e.l+r;var n=Ft(e);n.r=t["!row"];var i=e._R(1);var s=[n,i,"e"];if(t.cellFormula){e.l+=2;var f=Xu(e,a-e.l,t);s[3]=Fu(f,null,n,t.supbooks,t)}else e.l=a;return s}function ud(e,r,t){var a=e.l+r;var n=Ft(e);n.r=t["!row"];var i=Yt(e);var s=[n,i,"n"];if(t.cellFormula){e.l+=2;var f=Xu(e,a-e.l,t);s[3]=Fu(f,null,n,t.supbooks,t)}else e.l=a;return s}function hd(e,r,t){var a=e.l+r;var n=Ft(e);n.r=t["!row"];var i=Bt(e);var s=[n,i,"str"];if(t.cellFormula){e.l+=2;var f=Xu(e,a-e.l,t);s[3]=Fu(f,null,n,t.supbooks,t)}else e.l=a;return s}var dd=jt;var vd=Kt;function pd(e,r){if(r==null)r=$r(4);r._W(4,e);return r}function md(e,r){var t=e.l+r;var a=jt(e,16);var n=Lt(e);var i=Bt(e);var s=Bt(e);var f=Bt(e);e.l=t;var l={rfx:a,relId:n,loc:i,display:f};if(s)l.Tooltip=s;return l}function bd(e,r){var t=$r(50+4*(e[1].Target.length+(e[1].Tooltip||"").length));Kt({s:vt(e[0]),e:vt(e[0])},t);Wt("rId"+r,t);var a=e[1].Target.indexOf("#");var n=a==-1?"":e[1].Target.slice(a+1);Tt(n||"",t);Tt(e[1].Tooltip||"",t);Tt("",t);return t.slice(0,t.l)}function gd(){}function wd(e,r,t){var a=e.l+r;var n=Xt(e,16);var i=e._R(1);var s=[n];s[2]=i;if(t.cellFormula){var f=Vu(e,a-e.l,t);s[1]=f}else e.l=a;return s}function kd(e,r,t){var a=e.l+r;var n=jt(e,16);var i=[n];if(t.cellFormula){var s=ju(e,a-e.l,t);i[1]=s;e.l=a}else e.l=a;return i}function Ed(e,r,t){if(t==null)t=$r(18);var a=ih(e,r);t._W(-4,e);t._W(-4,e);t._W(4,(a.width||10)*256);t._W(4,0);var n=0;if(r.hidden)n|=1;if(typeof a.width=="number")n|=2;if(r.level)n|=r.level<<8;t._W(2,n);return t}var Sd=["left","right","top","bottom","header","footer"];function _d(e){var r={};Sd.forEach(function(t){r[t]=Yt(e,8)});return r}function Cd(e,r){if(r==null)r=$r(6*8);sh(e);Sd.forEach(function(t){$t(e[t],r)});return r}function Bd(e){var r=e._R(2);e.l+=28;return{RTL:r&32}}function Td(e,r,t){if(t==null)t=$r(30);var a=924;if((((r||{}).Views||[])[0]||{}).RTL)a|=32;t._W(2,a);t._W(4,0);t._W(4,0);t._W(4,0);t._W(1,0);t._W(1,0);t._W(2,0);t._W(2,100);t._W(2,0);t._W(2,0);t._W(2,0);t._W(4,0);return t}function yd(e){var r=$r(24);r._W(4,4);r._W(4,1);Kt(e,r);return r}function xd(e,r){if(r==null)r=$r(16*4+2);r._W(2,e.password?Yf(e.password):0);r._W(4,1);[["objects",false],["scenarios",false],["formatCells",true],["formatColumns",true],["formatRows",true],["insertColumns",true],["insertRows",true],["insertHyperlinks",true],["deleteColumns",true],["deleteRows",true],["selectLockedCells",false],["sort",true],["autoFilter",true],["pivotTables",true],["selectUnlockedCells",false]].forEach(function(t){if(t[1])r._W(4,e[t[0]]!=null&&!e[t[0]]?1:0);else r._W(4,e[t[0]]!=null&&e[t[0]]?0:1)});return r}function Ad(){}function Id(){}function Rd(e,r,t,a,n,i,s){if(!e)return e;var f=r||{};if(!a)a={"!id":{}};if(m!=null&&f.dense==null)f.dense=m;var l=f.dense?[]:{};var o;var c={s:{r:2e6,c:2e6},e:{r:0,c:0}};var u=[];var h=false,d=false;var v,p,b,g,w,k,E,S,_;var C=[];f.biff=12;f["!row"]=0;var B=0,T=false;var y=[];var x={};var A=f.supbooks||n.supbooks||[[]];A.sharedf=x;A.arrayf=y;A.SheetNames=n.SheetNames||n.Sheets.map(function(e){return e.name});if(!f.supbooks){f.supbooks=A;if(n.Names)for(var I=0;I<n.Names.length;++I)A[0][I+1]=n.Names[I]}var R=[],D=[];var O=false;Zr(e,function N(e,r,m){if(d)return;switch(m){case 148:o=e;break;case 0:v=e;if(f.sheetRows&&f.sheetRows<=v.r)d=true;S=st(g=v.r);f["!row"]=v.r;if(e.hidden||e.hpt||e.level!=null){if(e.hpt)e.hpx=kl(e.hpt);D[e.r]=e}break;case 2:;case 3:;case 4:;case 5:;case 6:;case 7:;case 8:;case 9:;case 10:;case 11:p={t:e[2]};switch(e[2]){case"n":p.v=e[1];break;case"s":E=rh[e[1]];p.v=E.t;p.r=E.r;break;case"b":p.v=e[1]?true:false;break;case"e":p.v=e[1];if(f.cellText!==false)p.w=Zt[p.v];break;case"str":p.t="s";p.v=e[1];break;}if(b=s.CellXf[e[0].iStyleRef])lh(p,b.numFmtId,null,f,i,s);w=e[0].c;if(f.dense){if(!l[g])l[g]=[];l[g][w]=p}else l[ct(w)+S]=p;if(f.cellFormula){T=false;for(B=0;B<y.length;++B){var I=y[B];if(v.r>=I[0].s.r&&v.r<=I[0].e.r)if(w>=I[0].s.c&&w<=I[0].e.c){p.F=bt(I[0]);T=true}}if(!T&&e.length>3)p.f=e[3]}if(c.s.r>v.r)c.s.r=v.r;if(c.s.c>w)c.s.c=w;if(c.e.r<v.r)c.e.r=v.r;if(c.e.c<w)c.e.c=w;if(f.cellDates&&b&&p.t=="n"&&F.is_date(F._table[b.numFmtId])){var P=F.parse_date_code(p.v);if(P){p.t="d";p.v=new Date(P.y,P.m-1,P.d,P.H,P.M,P.S,P.u)}}break;case 1:if(!f.sheetStubs||h)break;p={t:"z",v:undefined};w=e[0].c;if(f.dense){if(!l[g])l[g]=[];l[g][w]=p}else l[ct(w)+S]=p;if(c.s.r>v.r)c.s.r=v.r;if(c.s.c>w)c.s.c=w;if(c.e.r<v.r)c.e.r=v.r;if(c.e.c<w)c.e.c=w;break;case 176:C.push(e);break;case 494:var N=a["!id"][e.relId];if(N){e.Target=N.Target;if(e.loc)e.Target+="#"+e.loc;e.Rel=N}else if(e.relId==""){e.Target="#"+e.loc}for(g=e.rfx.s.r;g<=e.rfx.e.r;++g)for(w=e.rfx.s.c;w<=e.rfx.e.c;++w){if(f.dense){if(!l[g])l[g]=[];if(!l[g][w])l[g][w]={t:"z",v:undefined};l[g][w].l=e}else{k=pt({c:w,r:g});if(!l[k])l[k]={t:"z",v:undefined};l[k].l=e}}break;case 426:if(!f.cellFormula)break;y.push(e);_=f.dense?l[g][w]:l[ct(w)+S];_.f=Fu(e[1],c,{r:v.r,c:w},A,f);_.F=bt(e[0]);break;case 427:if(!f.cellFormula)break;x[pt(e[0].s)]=e[1];_=f.dense?l[g][w]:l[ct(w)+S];_.f=Fu(e[1],c,{r:v.r,c:w},A,f);break;case 60:if(!f.cellStyles)break;while(e.e>=e.s){R[e.e--]={width:e.w/256,hidden:!!(e.flags&1),level:e.level};if(!O){O=true;pl(e.w/256)}ml(R[e.e+1])}break;case 161:l["!autofilter"]={ref:bt(e)};break;case 476:l["!margins"]=e;break;case 147:if(!n.Sheets[t])n.Sheets[t]={};if(e.name)n.Sheets[t].CodeName=e.name;break;case 137:if(!n.Views)n.Views=[{}];if(!n.Views[0])n.Views[0]={};if(e.RTL)n.Views[0].RTL=true;break;case 485:break;case 64:;case 1053:break;case 151:break;case 175:;case 644:;case 625:;case 562:;case 396:;case 1112:;case 1146:;case 471:;case 1050:;case 649:;case 1105:;case 49:;case 589:;case 607:;case 564:;case 1055:;case 168:;case 174:;case 1180:;case 499:;case 550:;case 171:;case 167:;case 1177:;case 169:;case 1181:;case 551:;case 552:;case 661:;case 639:;case 478:;case 537:;case 477:;case 536:;case 1103:;case 680:;case 1104:;case 1024:;case 152:;case 663:;case 535:;case 678:;case 504:;case 1043:;case 428:;case 170:;case 3072:;case 50:;case 2070:;case 1045:break;case 35:h=true;break;case 36:h=false;break;case 37:u.push(r);h=true;break;case 38:u.pop();h=false;break;default:if((r||"").indexOf("Begin")>0){}else if((r||"").indexOf("End")>0){}else if(!h||f.WTF)throw new Error("Unexpected record "+m+" "+r);}},f);delete f.supbooks;delete f["!row"];if(!l["!ref"]&&(c.s.r<2e6||o&&(o.e.r>0||o.e.c>0||o.s.r>0||o.s.c>0)))l["!ref"]=bt(o||c);if(f.sheetRows&&l["!ref"]){var P=gt(l["!ref"]);if(f.sheetRows<=+P.e.r){P.e.r=f.sheetRows-1;if(P.e.r>c.e.r)P.e.r=c.e.r;if(P.e.r<P.s.r)P.s.r=P.e.r;if(P.e.c>c.e.c)P.e.c=c.e.c;if(P.e.c<P.s.c)P.s.c=P.e.c;l["!fullref"]=l["!ref"];l["!ref"]=bt(P)}}if(C.length>0)l["!merges"]=C;if(R.length>0)l["!cols"]=R;if(D.length>0)l["!rows"]=D;return l}function Dd(e,r,t,a,n,i){if(r.v===undefined)return;var s="";switch(r.t){case"b":s=r.v?"1":"0";break;case"d":r=le(r);r.z=r.z||F._table[14];r.v=re(se(r.v));r.t="n";break;case"n":;case"e":s=""+r.v;break;default:s=r.v;break;}var f={r:t,c:a};f.s=fh(n.cellXfs,r,n);if(r.l)i["!links"].push([pt(f),r.l]);if(r.c)i["!comments"].push([pt(f),r.c]);switch(r.t){case"s":;case"str":if(n.bookSST){s=nh(n.Strings,r.v,n.revStrings);f.t="s";f.v=s;Jr(e,"BrtCellIsst",td(r,f))}else{f.t="str";Jr(e,"BrtCellSt",ld(r,f))}return;case"n":if(r.v==(r.v|0)&&r.v>-1e3&&r.v<1e3)Jr(e,"BrtCellRk",sd(r,f));else Jr(e,"BrtCellReal",nd(r,f));return;case"b":f.t="b";Jr(e,"BrtCellBool",qh(r,f));return;case"e":f.t="e";break;}Jr(e,"BrtCellBlank",Qh(r,f))}function Fd(e,r,t,a){var n=gt(r["!ref"]||"A1"),i,s="",f=[];Jr(e,"BrtBeginSheetData");var l=Array.isArray(r);var o=n.e.r;if(r["!rows"])o=Math.max(n.e.r,r["!rows"].length-1);for(var c=n.s.r;c<=o;++c){s=st(c);Xh(e,r,n,c);if(c<=n.e.r)for(var u=n.s.c;u<=n.e.c;++u){if(c===n.s.r)f[u]=ct(u);i=f[u]+s;var h=l?(r[c]||[])[u]:r[i];if(!h)continue;Dd(e,h,c,u,a,r)}}Jr(e,"BrtEndSheetData")}function Od(e,r){if(!r||!r["!merges"])return;Jr(e,"BrtBeginMergeCells",pd(r["!merges"].length));r["!merges"].forEach(function(r){Jr(e,"BrtMergeCell",vd(r))});Jr(e,"BrtEndMergeCells")}function Pd(e,r){if(!r||!r["!cols"])return;Jr(e,"BrtBeginColInfos");r["!cols"].forEach(function(r,t){if(r)Jr(e,"BrtColInfo",Ed(t,r))});Jr(e,"BrtEndColInfos")}function Nd(e,r){if(!r||!r["!ref"])return;Jr(e,"BrtBeginCellIgnoreECs");Jr(e,"BrtCellIgnoreEC",yd(gt(r["!ref"])));Jr(e,"BrtEndCellIgnoreECs")}function Ld(e,r,t){r["!links"].forEach(function(r){if(!r[1].Target)return;var a=za(t,-1,r[1].Target.replace(/#.*$/,""),Na.HLINK);Jr(e,"BrtHLink",bd(r,a))});delete r["!links"]}function Md(e,r,t,a){if(r["!comments"].length>0){var n=za(a,-1,"../drawings/vmlDrawing"+(t+1)+".vml",Na.VML);Jr(e,"BrtLegacyDrawing",Wt("rId"+n));r["!legacy"]=n}}function Ud(e,r,t,a){if(!r["!autofilter"])return;var n=r["!autofilter"];var i=typeof n.ref==="string"?n.ref:bt(n.ref);if(!t.Workbook)t.Workbook={Sheets:[]};if(!t.Workbook.Names)t.Workbook.Names=[];var s=t.Workbook.Names;var f=mt(i);if(f.s.r==f.e.r){f.e.r=mt(r["!ref"]).e.r;i=bt(f)}for(var l=0;l<s.length;++l){var o=s[l];if(o.Name!="_xlnm._FilterDatabase")continue;if(o.Sheet!=a)continue;o.Ref="'"+t.SheetNames[a]+"'!"+i;break}if(l==s.length)s.push({Name:"_xlnm._FilterDatabase",Sheet:a,Ref:"'"+t.SheetNames[a]+"'!"+i});Jr(e,"BrtBeginAFilter",Kt(gt(i)));Jr(e,"BrtEndAFilter")}function Hd(e,r,t){Jr(e,"BrtBeginWsViews");{Jr(e,"BrtBeginWsView",Td(r,t));Jr(e,"BrtEndWsView")}Jr(e,"BrtEndWsViews")}function Wd(){}function zd(e,r){if(!r["!protect"])return;Jr(e,"BrtSheetProtection",xd(r["!protect"]))}function Vd(e,r,t,a){var n=Qr();var i=t.SheetNames[e],s=t.Sheets[i]||{};var f=i;try{if(t&&t.Workbook)f=t.Workbook.Sheets[e].CodeName||f}catch(l){}var o=gt(s["!ref"]||"A1");if(o.e.c>16383||o.e.r>1048575){if(r.WTF)throw new Error("Range "+(s["!ref"]||"A1")+" exceeds format limit A1:XFD1048576");o.e.c=Math.min(o.e.c,16383);o.e.r=Math.min(o.e.c,1048575)}s["!links"]=[];s["!comments"]=[];Jr(n,"BrtBeginSheet");if(t.vbaraw)Jr(n,"BrtWsProp",$h(f));Jr(n,"BrtWsDim",jh(o));Hd(n,s,t.Workbook);Wd(n,s);Pd(n,s,e,r,t);Fd(n,s,e,r,t);zd(n,s);Ud(n,s,t,e);Od(n,s);Ld(n,s,a);if(s["!margins"])Jr(n,"BrtMargins",Cd(s["!margins"]));if(!r||r.ignoreEC||r.ignoreEC==void 0)Nd(n,s);Md(n,s,e,a);Jr(n,"BrtEndSheet");return n.end()}Na.CHART="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart";Na.CHARTEX="http://schemas.microsoft.com/office/2014/relationships/chartEx";function Xd(e){var r=[];var t=e.match(/^<c:numCache>/);var a;(e.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/gm)||[]).forEach(function(e){var a=e.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);if(!a)return;r[+a[1]]=t?+a[2]:a[2]});var n=Ne((e.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/)||["","General"])[1]);(e.match(/<c:f>(.*?)<\/c:f>/gm)||[]).forEach(function(e){a=e.replace(/<.*?>/g,"")});return[r,n,a]}function Gd(e,r,t,a,n,i){var s=i||{"!type":"chart"};if(!e)return i;var f=0,l=0,o="A";var c={s:{r:2e6,c:2e6},e:{r:0,c:0}};(e.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm)||[]).forEach(function(e){var r=Xd(e);c.s.r=c.s.c=0;c.e.c=f;o=ct(f);r[0].forEach(function(e,t){s[o+st(t)]={t:"n",v:e,z:r[1]};l=t});if(c.e.r<l)c.e.r=l;++f});if(f>0)s["!ref"]=bt(c);return s}Na.CS="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet";var jd=fr("chartsheet",null,{xmlns:cr.main[0],"xmlns:r":cr.r});function Kd(e,r,t,a,n){if(!e)return e;if(!a)a={"!id":{}};var i={"!type":"chart","!drawel":null,"!rel":""};var s;var f=e.match(gh);if(f)Sh(f[0],i,n,t);if(s=e.match(/drawing r:id="(.*?)"/))i["!rel"]=s[1];if(a["!id"][i["!rel"]])i["!drawel"]=a["!id"][i["!rel"]];return i}function Yd(e,r,t,a){
var n=[ye,jd];n[n.length]=fr("drawing",null,{"r:id":"rId1"});za(a,-1,"../drawings/drawing"+(e+1)+".xml",Na.DRAW);if(n.length>2){n[n.length]="</chartsheet>";n[1]=n[1].replace("/>",">")}return n.join("")}function $d(e,r){e.l+=10;var t=Bt(e,r-10);return{name:t}}function Zd(e,r,t,a,n){if(!e)return e;if(!a)a={"!id":{}};var i={"!type":"chart","!drawel":null,"!rel":""};var s=[];var f=false;Zr(e,function l(e,a,o){switch(o){case 550:i["!rel"]=e;break;case 651:if(!n.Sheets[t])n.Sheets[t]={};if(e.name)n.Sheets[t].CodeName=e.name;break;case 562:;case 652:;case 669:;case 679:;case 551:;case 552:;case 476:;case 3072:break;case 35:f=true;break;case 36:f=false;break;case 37:s.push(a);break;case 38:s.pop();break;default:if((a||"").indexOf("Begin")>0)s.push(a);else if((a||"").indexOf("End")>0)s.pop();else if(!f||r.WTF)throw new Error("Unexpected record "+o+" "+a);}},r);if(a["!id"][i["!rel"]])i["!drawel"]=a["!id"][i["!rel"]];return i}function Qd(){var e=Qr();Jr(e,"BrtBeginSheet");Jr(e,"BrtEndSheet");return e.end()}var Jd=[["allowRefreshQuery",false,"bool"],["autoCompressPictures",true,"bool"],["backupFile",false,"bool"],["checkCompatibility",false,"bool"],["CodeName",""],["date1904",false,"bool"],["defaultThemeVersion",0,"int"],["filterPrivacy",false,"bool"],["hidePivotFieldList",false,"bool"],["promptedSolutions",false,"bool"],["publishItems",false,"bool"],["refreshAllConnections",false,"bool"],["saveExternalLinkValues",true,"bool"],["showBorderUnselectedTables",true,"bool"],["showInkAnnotation",true,"bool"],["showObjects","all"],["showPivotChartFilter",false,"bool"],["updateLinks","userSet"]];var qd=[["activeTab",0,"int"],["autoFilterDateGrouping",true,"bool"],["firstSheet",0,"int"],["minimized",false,"bool"],["showHorizontalScroll",true,"bool"],["showSheetTabs",true,"bool"],["showVerticalScroll",true,"bool"],["tabRatio",600,"int"],["visibility","visible"]];var ev=[];var rv=[["calcCompleted","true"],["calcMode","auto"],["calcOnSave","true"],["concurrentCalc","true"],["fullCalcOnLoad","false"],["fullPrecision","true"],["iterate","false"],["iterateCount","100"],["iterateDelta","0.001"],["refMode","A1"]];function tv(e,r){for(var t=0;t!=e.length;++t){var a=e[t];for(var n=0;n!=r.length;++n){var i=r[n];if(a[i[0]]==null)a[i[0]]=i[1];else switch(i[2]){case"bool":if(typeof a[i[0]]=="string")a[i[0]]=je(a[i[0]]);break;case"int":if(typeof a[i[0]]=="string")a[i[0]]=parseInt(a[i[0]],10);break;}}}}function av(e,r){for(var t=0;t!=r.length;++t){var a=r[t];if(e[a[0]]==null)e[a[0]]=a[1];else switch(a[2]){case"bool":if(typeof e[a[0]]=="string")e[a[0]]=je(e[a[0]]);break;case"int":if(typeof e[a[0]]=="string")e[a[0]]=parseInt(e[a[0]],10);break;}}}function nv(e){av(e.WBProps,Jd);av(e.CalcPr,rv);tv(e.WBView,qd);tv(e.Sheets,ev);th.date1904=je(e.WBProps.date1904)}function iv(e){if(!e.Workbook)return"false";if(!e.Workbook.WBProps)return"false";return je(e.Workbook.WBProps.date1904)?"true":"false"}var sv="][*?/\\".split("");function fv(e,r){if(e.length>31){if(r)return false;throw new Error("Sheet names cannot exceed 31 chars")}var t=true;sv.forEach(function(a){if(e.indexOf(a)==-1)return;if(!r)throw new Error("Sheet name cannot contain : \\ / ? * [ ]");t=false});return t}function lv(e,r,t){e.forEach(function(a,n){fv(a);for(var i=0;i<n;++i)if(a==e[i])throw new Error("Duplicate Sheet Name: "+a);if(t){var s=r&&r[n]&&r[n].CodeName||a;if(s.charCodeAt(0)==95&&s.length>22)throw new Error("Bad Code Name: Worksheet"+s)}})}function ov(e){if(!e||!e.SheetNames||!e.Sheets)throw new Error("Invalid Workbook");if(!e.SheetNames.length)throw new Error("Workbook is empty");var r=e.Workbook&&e.Workbook.Sheets||[];lv(e.SheetNames,r,!!e.vbaraw);for(var t=0;t<e.SheetNames.length;++t)oh(e.Sheets[e.SheetNames[t]],e.SheetNames[t],t)}var cv=/<\w+:workbook/;function uv(e,r){if(!e)throw new Error("Could not find file");var t={AppVersion:{},WBProps:{},WBView:[],Sheets:[],CalcPr:{},Names:[],xmlns:""};var a=false,n="xmlns";var i={},s=0;e.replace(Ae,function f(l,o){var c=De(l);switch(Fe(c[0])){case"<?xml":break;case"<workbook":if(l.match(cv))n="xmlns"+l.match(/<(\w+):/)[1];t.xmlns=c[n];break;case"</workbook>":break;case"<fileVersion":delete c[0];t.AppVersion=c;break;case"<fileVersion/>":;case"</fileVersion>":break;case"<fileSharing":break;case"<fileSharing/>":break;case"<workbookPr":;case"<workbookPr/>":Jd.forEach(function(e){if(c[e[0]]==null)return;switch(e[2]){case"bool":t.WBProps[e[0]]=je(c[e[0]]);break;case"int":t.WBProps[e[0]]=parseInt(c[e[0]],10);break;default:t.WBProps[e[0]]=c[e[0]];}});if(c.codeName)t.WBProps.CodeName=c.codeName;break;case"</workbookPr>":break;case"<workbookProtection":break;case"<workbookProtection/>":break;case"<bookViews":;case"<bookViews>":;case"</bookViews>":break;case"<workbookView":;case"<workbookView/>":delete c[0];t.WBView.push(c);break;case"</workbookView>":break;case"<sheets":;case"<sheets>":;case"</sheets>":break;case"<sheet":switch(c.state){case"hidden":c.Hidden=1;break;case"veryHidden":c.Hidden=2;break;default:c.Hidden=0;}delete c.state;c.name=Ne(Ke(c.name));delete c[0];t.Sheets.push(c);break;case"</sheet>":break;case"<functionGroups":;case"<functionGroups/>":break;case"<functionGroup":break;case"<externalReferences":;case"</externalReferences>":;case"<externalReferences>":break;case"<externalReference":break;case"<definedNames/>":break;case"<definedNames>":;case"<definedNames":a=true;break;case"</definedNames>":a=false;break;case"<definedName":{i={};i.Name=Ke(c.name);if(c.comment)i.Comment=c.comment;if(c.localSheetId)i.Sheet=+c.localSheetId;if(je(c.hidden||"0"))i.Hidden=true;s=o+l.length}break;case"</definedName>":{i.Ref=Ne(Ke(e.slice(s,o)));t.Names.push(i)}break;case"<definedName/>":break;case"<calcPr":delete c[0];t.CalcPr=c;break;case"<calcPr/>":delete c[0];t.CalcPr=c;break;case"</calcPr>":break;case"<oleSize":break;case"<customWorkbookViews>":;case"</customWorkbookViews>":;case"<customWorkbookViews":break;case"<customWorkbookView":;case"</customWorkbookView>":break;case"<pivotCaches>":;case"</pivotCaches>":;case"<pivotCaches":break;case"<pivotCache":break;case"<smartTagPr":;case"<smartTagPr/>":break;case"<smartTagTypes":;case"<smartTagTypes>":;case"</smartTagTypes>":break;case"<smartTagType":break;case"<webPublishing":;case"<webPublishing/>":break;case"<fileRecoveryPr":;case"<fileRecoveryPr/>":break;case"<webPublishObjects>":;case"<webPublishObjects":;case"</webPublishObjects>":break;case"<webPublishObject":break;case"<extLst":;case"<extLst>":;case"</extLst>":;case"<extLst/>":break;case"<ext":a=true;break;case"</ext>":a=false;break;case"<ArchID":break;case"<AlternateContent":;case"<AlternateContent>":a=true;break;case"</AlternateContent>":a=false;break;case"<revisionPtr":break;default:if(!a&&r.WTF)throw new Error("unrecognized "+c[0]+" in workbook");}return l});if(cr.main.indexOf(t.xmlns)===-1)throw new Error("Unknown Namespace: "+t.xmlns);nv(t);return t}var hv=fr("workbook",null,{xmlns:cr.main[0],"xmlns:r":cr.r});function dv(e){var r=[ye];r[r.length]=hv;var t=e.Workbook&&(e.Workbook.Names||[]).length>0;var a={codeName:"ThisWorkbook"};if(e.Workbook&&e.Workbook.WBProps){Jd.forEach(function(r){if(e.Workbook.WBProps[r[0]]==null)return;if(e.Workbook.WBProps[r[0]]==r[1])return;a[r[0]]=e.Workbook.WBProps[r[0]]});if(e.Workbook.WBProps.CodeName){a.codeName=e.Workbook.WBProps.CodeName;delete a.CodeName}}r[r.length]=fr("workbookPr",null,a);var n=e.Workbook&&e.Workbook.Sheets||[];var i=0;r[r.length]="<sheets>";for(i=0;i!=e.SheetNames.length;++i){var s={name:Ue(e.SheetNames[i].slice(0,31))};s.sheetId=""+(i+1);s["r:id"]="rId"+(i+1);if(n[i])switch(n[i].Hidden){case 1:s.state="hidden";break;case 2:s.state="veryHidden";break;}r[r.length]=fr("sheet",null,s)}r[r.length]="</sheets>";if(t){r[r.length]="<definedNames>";if(e.Workbook&&e.Workbook.Names)e.Workbook.Names.forEach(function(e){var t={name:e.Name};if(e.Comment)t.comment=e.Comment;if(e.Sheet!=null)t.localSheetId=""+e.Sheet;if(e.Hidden)t.hidden="1";if(!e.Ref)return;r[r.length]=fr("definedName",String(e.Ref).replace(/</g,"&lt;").replace(/>/g,"&gt;"),t)});r[r.length]="</definedNames>"}if(r.length>2){r[r.length]="</workbook>";r[1]=r[1].replace("/>",">")}return r.join("")}function vv(e,r){var t={};t.Hidden=e._R(4);t.iTabID=e._R(4);t.strRelID=Ht(e,r-8);t.name=Bt(e);return t}function pv(e,r){if(!r)r=$r(127);r._W(4,e.Hidden);r._W(4,e.iTabID);Wt(e.strRelID,r);Tt(e.name.slice(0,31),r);return r.length>r.l?r.slice(0,r.l):r}function mv(e,r){var t={};var a=e._R(4);t.defaultThemeVersion=e._R(4);var n=r>8?Bt(e):"";if(n.length>0)t.CodeName=n;t.autoCompressPictures=!!(a&65536);t.backupFile=!!(a&64);t.checkCompatibility=!!(a&4096);t.date1904=!!(a&1);t.filterPrivacy=!!(a&8);t.hidePivotFieldList=!!(a&1024);t.promptedSolutions=!!(a&16);t.publishItems=!!(a&2048);t.refreshAllConnections=!!(a&262144);t.saveExternalLinkValues=!!(a&128);t.showBorderUnselectedTables=!!(a&4);t.showInkAnnotation=!!(a&32);t.showObjects=["all","placeholders","none"][a>>13&3];t.showPivotChartFilter=!!(a&32768);t.updateLinks=["userSet","never","always"][a>>8&3];return t}function bv(e,r){if(!r)r=$r(72);var t=0;if(e){if(e.filterPrivacy)t|=8}r._W(4,t);r._W(4,0);Nt(e&&e.CodeName||"ThisWorkbook",r);return r.slice(0,r.l)}function gv(e,r){var t={};e._R(4);t.ArchID=e._R(4);e.l+=r-8;return t}function wv(e,r,t){var a=e.l+r;e.l+=4;e.l+=1;var n=e._R(4);var i=Ut(e);var s=Gu(e,0,t);var f=Lt(e);e.l=a;var l={Name:i,Ptg:s};if(n<268435455)l.Sheet=n;if(f)l.Comment=f;return l}function kv(e,r){var t={AppVersion:{},WBProps:{},WBView:[],Sheets:[],CalcPr:{},xmlns:""};var a=[];var n=false;if(!r)r={};r.biff=12;var i=[];var s=[[]];s.SheetNames=[];s.XTI=[];Zr(e,function f(e,l,o){switch(o){case 156:s.SheetNames.push(e.name);t.Sheets.push(e);break;case 153:t.WBProps=e;break;case 39:if(e.Sheet!=null)r.SID=e.Sheet;e.Ref=Fu(e.Ptg,null,null,s,r);delete r.SID;delete e.Ptg;i.push(e);break;case 1036:break;case 357:;case 358:;case 355:;case 667:if(!s[0].length)s[0]=[o,e];else s.push([o,e]);s[s.length-1].XTI=[];break;case 362:if(s.length===0){s[0]=[];s[0].XTI=[]}s[s.length-1].XTI=s[s.length-1].XTI.concat(e);s.XTI=s.XTI.concat(e);break;case 361:break;case 3072:;case 3073:;case 2071:;case 534:;case 677:;case 158:;case 157:;case 610:;case 2050:;case 155:;case 548:;case 676:;case 128:;case 665:;case 2128:;case 2125:;case 549:;case 2053:;case 596:;case 2076:;case 2075:;case 2082:;case 397:;case 154:;case 1117:;case 553:;case 2091:break;case 35:a.push(l);n=true;break;case 36:a.pop();n=false;break;case 37:a.push(l);n=true;break;case 38:a.pop();n=false;break;case 16:break;default:if((l||"").indexOf("Begin")>0){}else if((l||"").indexOf("End")>0){}else if(!n||r.WTF&&a[a.length-1]!="BrtACBegin"&&a[a.length-1]!="BrtFRTBegin")throw new Error("Unexpected record "+o+" "+l);}},r);nv(t);t.Names=i;t.supbooks=s;return t}function Ev(e,r){Jr(e,"BrtBeginBundleShs");for(var t=0;t!=r.SheetNames.length;++t){var a=r.Workbook&&r.Workbook.Sheets&&r.Workbook.Sheets[t]&&r.Workbook.Sheets[t].Hidden||0;var n={Hidden:a,iTabID:t+1,strRelID:"rId"+(t+1),name:r.SheetNames[t]};Jr(e,"BrtBundleSh",pv(n))}Jr(e,"BrtEndBundleShs")}function Sv(r,t){if(!t)t=$r(127);for(var a=0;a!=4;++a)t._W(4,0);Tt("SheetJS",t);Tt(e.version,t);Tt(e.version,t);Tt("7262",t);t.length=t.l;return t.length>t.l?t.slice(0,t.l):t}function _v(e,r){if(!r)r=$r(29);r._W(-4,0);r._W(-4,460);r._W(4,28800);r._W(4,17600);r._W(4,500);r._W(4,e);r._W(4,e);var t=120;r._W(1,t);return r.length>r.l?r.slice(0,r.l):r}function Cv(e,r){if(!r.Workbook||!r.Workbook.Sheets)return;var t=r.Workbook.Sheets;var a=0,n=-1,i=-1;for(;a<t.length;++a){if(!t[a]||!t[a].Hidden&&n==-1)n=a;else if(t[a].Hidden==1&&i==-1)i=a}if(i>n)return;Jr(e,"BrtBeginBookViews");Jr(e,"BrtBookView",_v(n));Jr(e,"BrtEndBookViews")}function Bv(e,r){var t=Qr();Jr(t,"BrtBeginBook");Jr(t,"BrtFileVersion",Sv());Jr(t,"BrtWbProp",bv(e.Workbook&&e.Workbook.WBProps||null));Cv(t,e,r);Ev(t,e,r);Jr(t,"BrtEndBook");return t.end()}function Tv(e,r,t){if(r.slice(-4)===".bin")return kv(e,t);return uv(e,t)}function yv(e,r,t,a,n,i,s,f){if(r.slice(-4)===".bin")return Rd(e,a,t,n,i,s,f);return kh(e,a,t,n,i,s,f)}function xv(e,r,t,a,n,i,s,f){if(r.slice(-4)===".bin")return Zd(e,a,t,n,i,s,f);return Kd(e,a,t,n,i,s,f)}function Av(e,r,t,a,n,i,s,f){if(r.slice(-4)===".bin")return Zo(e,a,t,n,i,s,f);return Qo(e,a,t,n,i,s,f)}function Iv(e,r,t,a,n,i,s,f){if(r.slice(-4)===".bin")return Yo(e,a,t,n,i,s,f);return $o(e,a,t,n,i,s,f)}function Rv(e,r,t,a){if(r.slice(-4)===".bin")return $l(e,t,a);return Rl(e,t,a)}function Dv(e,r,t){return mo(e,t)}function Fv(e,r,t){if(r.slice(-4)===".bin")return xf(e,t);return Cf(e,t)}function Ov(e,r,t){if(r.slice(-4)===".bin")return zo(e,t);return Po(e,t)}function Pv(e,r,t){if(r.slice(-4)===".bin")return xo(e,r,t);return To(e,r,t)}function Nv(e,r,t,a){if(t.slice(-4)===".bin")return Io(e,r,t,a);return Ao(e,r,t,a)}function Lv(e,r,t){return(r.slice(-4)===".bin"?Bv:dv)(e,t)}function Mv(e,r,t,a,n){return(r.slice(-4)===".bin"?Vd:Wh)(e,t,a,n)}function Uv(e,r,t,a,n){return(r.slice(-4)===".bin"?Qd:Yd)(e,t,a,n)}function Hv(e,r,t){return(r.slice(-4)===".bin"?so:Fl)(e,t)}function Wv(e,r,t){return(r.slice(-4)===".bin"?Rf:Tf)(e,t)}function zv(e,r,t){return(r.slice(-4)===".bin"?Vo:Lo)(e,t)}var Vv=/([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;var Xv=/([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;function Gv(e,r){var t=e.split(/\s+/);var a=[];if(!r)a[0]=t[0];if(t.length===1)return a;var n=e.match(Vv),i,s,f,l;if(n)for(l=0;l!=n.length;++l){i=n[l].match(Xv);if((s=i[1].indexOf(":"))===-1)a[i[1]]=i[2].slice(1,i[2].length-1);else{if(i[1].slice(0,6)==="xmlns:")f="xmlns"+i[1].slice(6);else f=i[1].slice(s+1);a[f]=i[2].slice(1,i[2].length-1)}}return a}function jv(e){var r=e.split(/\s+/);var t={};if(r.length===1)return t;var a=e.match(Vv),n,i,s,f;if(a)for(f=0;f!=a.length;++f){n=a[f].match(Xv);if((i=n[1].indexOf(":"))===-1)t[n[1]]=n[2].slice(1,n[2].length-1);else{if(n[1].slice(0,6)==="xmlns:")s="xmlns"+n[1].slice(6);else s=n[1].slice(i+1);t[s]=n[2].slice(1,n[2].length-1)}}return t}function Kv(e,r){var t=P[e]||Ne(e);if(t==="General")return F._general(r);return F.format(t,r)}function Yv(e,r,t,a){var n=a;switch((t[0].match(/dt:dt="([\w.]+)"/)||["",""])[1]){case"boolean":n=je(a);break;case"i2":;case"int":n=parseInt(a,10);break;case"r4":;case"float":n=parseFloat(a);break;case"date":;case"dateTime.tz":n=se(a);break;case"i8":;case"string":;case"fixed":;case"uuid":;case"bin.base64":break;default:throw new Error("bad custprop:"+t[0]);}e[Ne(r)]=n}function $v(e,r,t){if(e.t==="z")return;if(!t||t.cellText!==false)try{if(e.t==="e"){e.w=e.w||Zt[e.v]}else if(r==="General"){if(e.t==="n"){if((e.v|0)===e.v)e.w=F._general_int(e.v);else e.w=F._general_num(e.v)}else e.w=F._general(e.v)}else e.w=Kv(r||"General",e.v)}catch(a){if(t.WTF)throw a}try{var n=P[r]||r||"General";if(t.cellNF)e.z=n;if(t.cellDates&&e.t=="n"&&F.is_date(n)){var i=F.parse_date_code(e.v);if(i){e.t="d";e.v=new Date(i.y,i.m-1,i.d,i.H,i.M,i.S,i.u)}}}catch(a){if(t.WTF)throw a}}function Zv(e,r,t){if(t.cellStyles){if(r.Interior){var a=r.Interior;if(a.Pattern)a.patternType=El[a.Pattern]||a.Pattern}}e[r.ID]=r}function Qv(e,r,t,a,n,i,s,f,l,o){var c="General",u=a.StyleID,h={};o=o||{};var d=[];var v=0;if(u===undefined&&f)u=f.StyleID;if(u===undefined&&s)u=s.StyleID;while(i[u]!==undefined){if(i[u].nf)c=i[u].nf;if(i[u].Interior)d.push(i[u].Interior);if(!i[u].Parent)break;u=i[u].Parent}switch(t.Type){case"Boolean":a.t="b";a.v=je(e);break;case"String":a.t="s";a.r=Xe(Ne(e));a.v=e.indexOf("<")>-1?Ne(r||e):a.r;break;case"DateTime":if(e.slice(-1)!="Z")e+="Z";a.v=(se(e)-new Date(Date.UTC(1899,11,30)))/(24*60*60*1e3);if(a.v!==a.v)a.v=Ne(e);else if(a.v<60)a.v=a.v-1;if(!c||c=="General")c="yyyy-mm-dd";case"Number":if(a.v===undefined)a.v=+e;if(!a.t)a.t="n";break;case"Error":a.t="e";a.v=Qt[e];if(o.cellText!==false)a.w=e;break;default:a.t="s";a.v=Xe(r||e);break;}$v(a,c,o);if(o.cellFormula!==false){if(a.Formula){var p=Ne(a.Formula);if(p.charCodeAt(0)==61)p=p.slice(1);a.f=Jo(p,n);delete a.Formula;if(a.ArrayRange=="RC")a.F=Jo("RC:RC",n);else if(a.ArrayRange){a.F=Jo(a.ArrayRange,n);l.push([gt(a.F),a.F])}}else{for(v=0;v<l.length;++v)if(n.r>=l[v][0].s.r&&n.r<=l[v][0].e.r)if(n.c>=l[v][0].s.c&&n.c<=l[v][0].e.c)a.F=l[v][1]}}if(o.cellStyles){d.forEach(function(e){if(!h.patternType&&e.patternType)h.patternType=e.patternType});a.s=h}if(a.StyleID!==undefined)a.ixfe=a.StyleID}function Jv(e){e.t=e.v||"";e.t=e.t.replace(/\r\n/g,"\n").replace(/\r/g,"\n");e.v=e.w=e.ixfe=undefined}function qv(e){if(w&&Buffer.isBuffer(e))return e.toString("utf8");if(typeof e==="string")return e;if(typeof Uint8Array!=="undefined"&&e instanceof Uint8Array)return Ke(y(A(e)));throw new Error("Bad input format: expected Buffer or string")}var ep=/<(\/?)([^\s?>!\/:]*:|)([^\s?>:\/]+)[^>]*>/gm;function rp(e,r){var t=r||{};O(F);var a=d(qv(e));if(t.type=="binary"||t.type=="array"||t.type=="base64"){if(typeof cptable!=="undefined")a=cptable.utils.decode(65001,c(a));else a=Ke(a)}var n=a.slice(0,1024).toLowerCase(),i=false;if(n.indexOf("<?xml")==-1)["html","table","head","meta","script","style","div"].forEach(function(e){if(n.indexOf("<"+e)>=0)i=true});if(i)return Kp.to_workbook(a,t);var s;var f=[],l;if(m!=null&&t.dense==null)t.dense=m;var o={},u=[],h=t.dense?[]:{},v="";var p={},b={},g={};var w=Gv('<Data ss:Type="String">'),k=0;var E=0,S=0;var _={s:{r:2e6,c:2e6},e:{r:0,c:0}};var C={},B={};var T="",y=0;var x=[];var A={},I={},R=0,D=[];var N=[],L={};var M=[],U,H=false;var W=[];var z=[],V={},X=0,G=0;var j={Sheets:[],WBProps:{date1904:false}},K={};ep.lastIndex=0;a=a.replace(/<!--([\s\S]*?)-->/gm,"");while(s=ep.exec(a))switch(s[3]){case"Data":if(f[f.length-1][1])break;if(s[1]==="/")Qv(a.slice(k,s.index),T,w,f[f.length-1][0]=="Comment"?L:b,{c:E,r:S},C,M[E],g,W,t);else{T="";w=Gv(s[0]);k=s.index+s[0].length}break;case"Cell":if(s[1]==="/"){if(N.length>0)b.c=N;if((!t.sheetRows||t.sheetRows>S)&&b.v!==undefined){if(t.dense){if(!h[S])h[S]=[];h[S][E]=b}else h[ct(E)+st(S)]=b}if(b.HRef){b.l={Target:b.HRef};if(b.HRefScreenTip)b.l.Tooltip=b.HRefScreenTip;delete b.HRef;delete b.HRefScreenTip}if(b.MergeAcross||b.MergeDown){X=E+(parseInt(b.MergeAcross,10)|0);G=S+(parseInt(b.MergeDown,10)|0);x.push({s:{c:E,r:S},e:{c:X,r:G}})}if(!t.sheetStubs){if(b.MergeAcross)E=X+1;else++E}else if(b.MergeAcross||b.MergeDown){for(var Y=E;Y<=X;++Y){for(var $=S;$<=G;++$){if(Y>E||$>S){if(t.dense){if(!h[$])h[$]=[];h[$][Y]={t:"z"}}else h[ct(Y)+st($)]={t:"z"}}}}E=X+1}else++E}else{b=jv(s[0]);if(b.Index)E=+b.Index-1;if(E<_.s.c)_.s.c=E;if(E>_.e.c)_.e.c=E;if(s[0].slice(-2)==="/>")++E;N=[]}break;case"Row":if(s[1]==="/"||s[0].slice(-2)==="/>"){if(S<_.s.r)_.s.r=S;if(S>_.e.r)_.e.r=S;if(s[0].slice(-2)==="/>"){g=Gv(s[0]);if(g.Index)S=+g.Index-1}E=0;++S}else{g=Gv(s[0]);if(g.Index)S=+g.Index-1;V={};if(g.AutoFitHeight=="0"||g.Height){V.hpx=parseInt(g.Height,10);V.hpt=wl(V.hpx);z[S]=V}if(g.Hidden=="1"){V.hidden=true;z[S]=V}}break;case"Worksheet":if(s[1]==="/"){if((l=f.pop())[0]!==s[3])throw new Error("Bad state: "+l.join("|"));u.push(v);if(_.s.r<=_.e.r&&_.s.c<=_.e.c){h["!ref"]=bt(_);if(t.sheetRows&&t.sheetRows<=_.e.r){h["!fullref"]=h["!ref"];_.e.r=t.sheetRows-1;h["!ref"]=bt(_)}}if(x.length)h["!merges"]=x;if(M.length>0)h["!cols"]=M;if(z.length>0)h["!rows"]=z;o[v]=h}else{_={s:{r:2e6,c:2e6},e:{r:0,c:0}};S=E=0;f.push([s[3],false]);l=Gv(s[0]);v=Ne(l.Name);h=t.dense?[]:{};x=[];W=[];z=[];K={name:v,Hidden:0};j.Sheets.push(K)}break;case"Table":if(s[1]==="/"){if((l=f.pop())[0]!==s[3])throw new Error("Bad state: "+l.join("|"))}else if(s[0].slice(-2)=="/>")break;else{p=Gv(s[0]);f.push([s[3],false]);M=[];H=false}break;case"Style":if(s[1]==="/")Zv(C,B,t);else B=Gv(s[0]);break;case"NumberFormat":B.nf=Ne(Gv(s[0]).Format||"General");if(P[B.nf])B.nf=P[B.nf];for(var Z=0;Z!=392;++Z)if(F._table[Z]==B.nf)break;if(Z==392)for(Z=57;Z!=392;++Z)if(F._table[Z]==null){F.load(B.nf,Z);break}break;case"Column":if(f[f.length-1][0]!=="Table")break;U=Gv(s[0]);if(U.Hidden){U.hidden=true;delete U.Hidden}if(U.Width)U.wpx=parseInt(U.Width,10);if(!H&&U.wpx>10){H=true;cl=fl;for(var Q=0;Q<M.length;++Q)if(M[Q])ml(M[Q])}if(H)ml(U);M[U.Index-1||M.length]=U;for(var J=0;J<+U.Span;++J)M[M.length]=le(U);break;case"NamedRange":if(!j.Names)j.Names=[];var q=De(s[0]);var ee={Name:q.Name,Ref:Jo(q.RefersTo.slice(1),{r:0,c:0})};if(j.Sheets.length>0)ee.Sheet=j.Sheets.length-1;j.Names.push(ee);break;case"NamedCell":break;case"B":break;case"I":break;case"U":break;case"S":break;case"Sub":break;case"Sup":break;case"Span":break;case"Alignment":break;case"Borders":break;case"Border":break;case"Font":if(s[0].slice(-2)==="/>")break;else if(s[1]==="/")T+=a.slice(y,s.index);else y=s.index+s[0].length;break;case"Interior":if(!t.cellStyles)break;B.Interior=Gv(s[0]);break;case"Protection":break;case"Author":;case"Title":;case"Description":;case"Created":;case"Keywords":;case"Subject":;case"Category":;case"Company":;case"LastAuthor":;case"LastSaved":;case"LastPrinted":;case"Version":;case"Revision":;case"TotalTime":;case"HyperlinkBase":;case"Manager":;case"ContentStatus":;case"Identifier":;case"Language":;case"AppName":if(s[0].slice(-2)==="/>")break;else if(s[1]==="/")pn(A,s[3],a.slice(R,s.index));else R=s.index+s[0].length;break;case"Paragraphs":break;case"Styles":;case"Workbook":if(s[1]==="/"){if((l=f.pop())[0]!==s[3])throw new Error("Bad state: "+l.join("|"))}else f.push([s[3],false]);break;case"Comment":if(s[1]==="/"){if((l=f.pop())[0]!==s[3])throw new Error("Bad state: "+l.join("|"));Jv(L);N.push(L)}else{f.push([s[3],false]);l=Gv(s[0]);L={a:l.Author}}break;case"AutoFilter":if(s[1]==="/"){if((l=f.pop())[0]!==s[3])throw new Error("Bad state: "+l.join("|"))}else if(s[0].charAt(s[0].length-2)!=="/"){var re=Gv(s[0]);h["!autofilter"]={ref:Jo(re.Range).replace(/\$/g,"")};f.push([s[3],true])}break;case"Name":break;case"DataValidation":if(s[1]==="/"){if((l=f.pop())[0]!==s[3])throw new Error("Bad state: "+l.join("|"))}else{if(s[0].charAt(s[0].length-2)!=="/")f.push([s[3],true])}break;case"ComponentOptions":;case"DocumentProperties":;case"CustomDocumentProperties":;case"OfficeDocumentSettings":;case"PivotTable":;case"PivotCache":;case"Names":;case"MapInfo":;case"PageBreaks":;case"QueryTable":;case"Sorting":;case"Schema":;case"data":;case"ConditionalFormatting":;case"SmartTagType":;case"SmartTags":;case"ExcelWorkbook":;case"WorkbookOptions":;case"WorksheetOptions":if(s[1]==="/"){if((l=f.pop())[0]!==s[3])throw new Error("Bad state: "+l.join("|"))}else if(s[0].charAt(s[0].length-2)!=="/")f.push([s[3],true]);break;default:if(f.length==0&&s[3]=="document")return em(a,t);if(f.length==0&&s[3]=="UOF")return em(a,t);var te=true;switch(f[f.length-1][0]){case"OfficeDocumentSettings":switch(s[3]){case"AllowPNG":break;case"RemovePersonalInformation":break;case"DownloadComponents":break;case"LocationOfComponents":break;case"Colors":break;case"Color":break;case"Index":break;case"RGB":break;case"PixelsPerInch":break;case"TargetScreenSize":break;case"ReadOnlyRecommended":break;default:te=false;}break;case"ComponentOptions":switch(s[3]){case"Toolbar":break;case"HideOfficeLogo":break;case"SpreadsheetAutoFit":break;case"Label":break;case"Caption":break;case"MaxHeight":break;case"MaxWidth":break;case"NextSheetNumber":break;default:te=false;}break;case"ExcelWorkbook":switch(s[3]){case"Date1904":j.WBProps.date1904=true;break;case"WindowHeight":break;case"WindowWidth":break;case"WindowTopX":break;case"WindowTopY":break;case"TabRatio":break;case"ProtectStructure":break;case"ProtectWindow":break;case"ProtectWindows":break;case"ActiveSheet":break;case"DisplayInkNotes":break;case"FirstVisibleSheet":break;case"SupBook":break;case"SheetName":break;case"SheetIndex":break;case"SheetIndexFirst":break;case"SheetIndexLast":break;case"Dll":break;case"AcceptLabelsInFormulas":break;case"DoNotSaveLinkValues":break;case"Iteration":break;case"MaxIterations":break;case"MaxChange":break;case"Path":break;case"Xct":break;case"Count":break;case"SelectedSheets":break;case"Calculation":break;case"Uncalced":break;case"StartupPrompt":break;case"Crn":break;case"ExternName":break;case"Formula":break;case"ColFirst":break;case"ColLast":break;case"WantAdvise":break;case"Boolean":break;case"Error":break;case"Text":break;case"OLE":break;case"NoAutoRecover":break;case"PublishObjects":break;case"DoNotCalculateBeforeSave":break;case"Number":break;case"RefModeR1C1":break;case"EmbedSaveSmartTags":break;default:te=false;}break;case"WorkbookOptions":switch(s[3]){case"OWCVersion":break;case"Height":break;case"Width":break;default:te=false;}break;case"WorksheetOptions":switch(s[3]){case"Visible":if(s[0].slice(-2)==="/>"){}else if(s[1]==="/")switch(a.slice(R,s.index)){case"SheetHidden":K.Hidden=1;break;case"SheetVeryHidden":K.Hidden=2;break;}else R=s.index+s[0].length;break;case"Header":if(!h["!margins"])sh(h["!margins"]={},"xlml");h["!margins"].header=De(s[0]).Margin;break;case"Footer":if(!h["!margins"])sh(h["!margins"]={},"xlml");h["!margins"].footer=De(s[0]).Margin;break;case"PageMargins":var ae=De(s[0]);if(!h["!margins"])sh(h["!margins"]={},"xlml");if(ae.Top)h["!margins"].top=ae.Top;if(ae.Left)h["!margins"].left=ae.Left;if(ae.Right)h["!margins"].right=ae.Right;if(ae.Bottom)h["!margins"].bottom=ae.Bottom;break;case"DisplayRightToLeft":if(!j.Views)j.Views=[];if(!j.Views[0])j.Views[0]={};j.Views[0].RTL=true;break;case"FreezePanes":break;case"FrozenNoSplit":break;case"SplitHorizontal":;case"SplitVertical":break;case"DoNotDisplayGridlines":break;case"TopRowBottomPane":break;case"LeftColumnRightPane":break;case"Unsynced":break;case"Print":break;case"Panes":break;case"Scale":break;case"Pane":break;case"Number":break;case"Layout":break;case"PageSetup":break;case"Selected":break;case"ProtectObjects":break;case"EnableSelection":break;case"ProtectScenarios":break;case"ValidPrinterInfo":break;case"HorizontalResolution":break;case"VerticalResolution":break;case"NumberofCopies":break;case"ActiveRow":break;case"ActiveCol":break;case"ActivePane":break;case"TopRowVisible":break;case"LeftColumnVisible":break;case"FitToPage":break;case"RangeSelection":break;case"PaperSizeIndex":break;case"PageLayoutZoom":break;case"PageBreakZoom":break;case"FilterOn":break;case"FitWidth":break;case"FitHeight":break;case"CommentsLayout":break;case"Zoom":break;case"LeftToRight":break;case"Gridlines":break;case"AllowSort":break;case"AllowFilter":break;case"AllowInsertRows":break;case"AllowDeleteRows":break;case"AllowInsertCols":break;case"AllowDeleteCols":break;case"AllowInsertHyperlinks":break;case"AllowFormatCells":break;case"AllowSizeCols":break;case"AllowSizeRows":break;case"NoSummaryRowsBelowDetail":break;case"TabColorIndex":break;case"DoNotDisplayHeadings":break;case"ShowPageLayoutZoom":break;case"NoSummaryColumnsRightDetail":break;case"BlackAndWhite":break;case"DoNotDisplayZeros":break;case"DisplayPageBreak":break;case"RowColHeadings":break;case"DoNotDisplayOutline":break;case"NoOrientation":break;case"AllowUsePivotTables":break;case"ZeroHeight":break;case"ViewableRange":break;case"Selection":break;case"ProtectContents":break;default:te=false;}break;case"PivotTable":;case"PivotCache":switch(s[3]){case"ImmediateItemsOnDrop":break;case"ShowPageMultipleItemLabel":break;case"CompactRowIndent":break;case"Location":break;case"PivotField":break;case"Orientation":break;case"LayoutForm":break;case"LayoutSubtotalLocation":break;case"LayoutCompactRow":break;case"Position":break;case"PivotItem":break;case"DataType":break;case"DataField":break;case"SourceName":break;case"ParentField":break;case"PTLineItems":break;case"PTLineItem":break;case"CountOfSameItems":break;case"Item":break;case"ItemType":break;case"PTSource":break;case"CacheIndex":break;case"ConsolidationReference":break;case"FileName":break;case"Reference":break;case"NoColumnGrand":break;case"NoRowGrand":break;case"BlankLineAfterItems":break;case"Hidden":break;case"Subtotal":break;case"BaseField":break;case"MapChildItems":break;case"Function":break;case"RefreshOnFileOpen":break;case"PrintSetTitles":break;case"MergeLabels":break;case"DefaultVersion":break;case"RefreshName":break;case"RefreshDate":break;case"RefreshDateCopy":break;case"VersionLastRefresh":break;case"VersionLastUpdate":break;case"VersionUpdateableMin":break;case"VersionRefreshableMin":break;case"Calculation":break;default:te=false;}break;case"PageBreaks":switch(s[3]){case"ColBreaks":break;case"ColBreak":break;case"RowBreaks":break;case"RowBreak":break;case"ColStart":break;case"ColEnd":break;case"RowEnd":break;default:te=false;}break;case"AutoFilter":switch(s[3]){case"AutoFilterColumn":break;case"AutoFilterCondition":break;case"AutoFilterAnd":break;case"AutoFilterOr":break;default:te=false;}break;case"QueryTable":switch(s[3]){case"Id":break;case"AutoFormatFont":break;case"AutoFormatPattern":break;case"QuerySource":break;case"QueryType":break;case"EnableRedirections":break;case"RefreshedInXl9":break;case"URLString":break;case"HTMLTables":break;case"Connection":break;case"CommandText":break;case"RefreshInfo":break;case"NoTitles":break;case"NextId":break;case"ColumnInfo":break;case"OverwriteCells":break;case"DoNotPromptForFile":break;case"TextWizardSettings":break;case"Source":break;case"Number":break;case"Decimal":break;case"ThousandSeparator":break;case"TrailingMinusNumbers":break;case"FormatSettings":break;case"FieldType":break;case"Delimiters":break;case"Tab":break;case"Comma":break;case"AutoFormatName":break;case"VersionLastEdit":break;case"VersionLastRefresh":break;default:te=false;}break;case"DataValidation":switch(s[3]){case"Range":break;case"Type":break;case"Min":break;case"Max":break;case"Sort":break;case"Descending":break;case"Order":break;case"CaseSensitive":break;case"Value":break;case"ErrorStyle":break;case"ErrorMessage":break;case"ErrorTitle":break;case"InputMessage":break;case"InputTitle":break;case"ComboHide":break;case"InputHide":break;case"Condition":break;case"Qualifier":break;case"UseBlank":break;case"Value1":break;case"Value2":break;case"Format":break;case"CellRangeList":break;default:te=false;}break;case"Sorting":;case"ConditionalFormatting":switch(s[3]){case"Range":break;case"Type":break;case"Min":break;case"Max":break;case"Sort":break;case"Descending":break;case"Order":break;case"CaseSensitive":break;case"Value":break;case"ErrorStyle":break;case"ErrorMessage":break;case"ErrorTitle":break;case"CellRangeList":break;case"InputMessage":break;case"InputTitle":break;case"ComboHide":break;case"InputHide":break;case"Condition":break;case"Qualifier":break;case"UseBlank":break;case"Value1":break;case"Value2":break;case"Format":break;default:te=false;}break;case"MapInfo":;case"Schema":;case"data":switch(s[3]){case"Map":break;case"Entry":break;case"Range":break;case"XPath":break;case"Field":break;case"XSDType":break;case"FilterOn":break;case"Aggregate":break;case"ElementType":break;case"AttributeType":break;case"schema":;case"element":;case"complexType":;case"datatype":;case"all":;case"attribute":;case"extends":break;case"row":break;default:te=false;}break;case"SmartTags":break;default:te=false;break;}if(te)break;if(s[3].match(/!\[CDATA/))break;if(!f[f.length-1][1])throw"Unrecognized tag: "+s[3]+"|"+f.join("|");if(f[f.length-1][0]==="CustomDocumentProperties"){if(s[0].slice(-2)==="/>")break;else if(s[1]==="/")Yv(I,s[3],D,a.slice(R,s.index));else{D=s;R=s.index+s[0].length}break}if(t.WTF)throw"Unrecognized tag: "+s[3]+"|"+f.join("|");}var ne={};if(!t.bookSheets&&!t.bookProps)ne.Sheets=o;ne.SheetNames=u;ne.Workbook=j;ne.SSF=F.get_table();ne.Props=A;ne.Custprops=I;return ne}function tp(e,r){mm(r=r||{});switch(r.type||"base64"){case"base64":return rp(g.decode(e),r);case"binary":;case"buffer":;case"file":return rp(e,r);case"array":return rp(y(e),r);}}function ap(e,r){var t=[];if(e.Props)t.push(mn(e.Props,r));if(e.Custprops)t.push(bn(e.Props,e.Custprops,r));return t.join("")}function np(){return""}function ip(e,r){var t=['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];r.cellXfs.forEach(function(e,r){var a=[];a.push(fr("NumberFormat",null,{"ss:Format":Ue(F._table[e.numFmtId])}));t.push(fr("Style",a.join(""),{
"ss:ID":"s"+(21+r)}))});return fr("Styles",t.join(""))}function sp(e){return fr("NamedRange",null,{"ss:Name":e.Name,"ss:RefersTo":"="+ec(e.Ref,{r:0,c:0})})}function fp(e){if(!((e||{}).Workbook||{}).Names)return"";var r=e.Workbook.Names;var t=[];for(var a=0;a<r.length;++a){var n=r[a];if(n.Sheet!=null)continue;if(n.Name.match(/^_xlfn\./))continue;t.push(sp(n))}return fr("Names",t.join(""))}function lp(e,r,t,a){if(!e)return"";if(!((a||{}).Workbook||{}).Names)return"";var n=a.Workbook.Names;var i=[];for(var s=0;s<n.length;++s){var f=n[s];if(f.Sheet!=t)continue;if(f.Name.match(/^_xlfn\./))continue;i.push(sp(f))}return i.join("")}function op(e,r,t,a){if(!e)return"";var n=[];if(e["!margins"]){n.push("<PageSetup>");if(e["!margins"].header)n.push(fr("Header",null,{"x:Margin":e["!margins"].header}));if(e["!margins"].footer)n.push(fr("Footer",null,{"x:Margin":e["!margins"].footer}));n.push(fr("PageMargins",null,{"x:Bottom":e["!margins"].bottom||"0.75","x:Left":e["!margins"].left||"0.7","x:Right":e["!margins"].right||"0.7","x:Top":e["!margins"].top||"0.75"}));n.push("</PageSetup>")}if(a&&a.Workbook&&a.Workbook.Sheets&&a.Workbook.Sheets[t]){if(a.Workbook.Sheets[t].Hidden)n.push(fr("Visible",a.Workbook.Sheets[t].Hidden==1?"SheetHidden":"SheetVeryHidden",{}));else{for(var i=0;i<t;++i)if(a.Workbook.Sheets[i]&&!a.Workbook.Sheets[i].Hidden)break;if(i==t)n.push("<Selected/>")}}if(((((a||{}).Workbook||{}).Views||[])[0]||{}).RTL)n.push("<DisplayRightToLeft/>");if(e["!protect"]){n.push(ir("ProtectContents","True"));if(e["!protect"].objects)n.push(ir("ProtectObjects","True"));if(e["!protect"].scenarios)n.push(ir("ProtectScenarios","True"));if(e["!protect"].selectLockedCells!=null&&!e["!protect"].selectLockedCells)n.push(ir("EnableSelection","NoSelection"));else if(e["!protect"].selectUnlockedCells!=null&&!e["!protect"].selectUnlockedCells)n.push(ir("EnableSelection","UnlockedCells"));[["formatCells","AllowFormatCells"],["formatColumns","AllowSizeCols"],["formatRows","AllowSizeRows"],["insertColumns","AllowInsertCols"],["insertRows","AllowInsertRows"],["insertHyperlinks","AllowInsertHyperlinks"],["deleteColumns","AllowDeleteCols"],["deleteRows","AllowDeleteRows"],["sort","AllowSort"],["autoFilter","AllowFilter"],["pivotTables","AllowUsePivotTables"]].forEach(function(r){if(e["!protect"][r[0]])n.push("<"+r[1]+"/>")})}if(n.length==0)return"";return fr("WorksheetOptions",n.join(""),{xmlns:ur.x})}function cp(e){return e.map(function(e){var r=Ge(e.t||"");var t=fr("ss:Data",r,{xmlns:"http://www.w3.org/TR/REC-html40"});return fr("Comment",t,{"ss:Author":e.a})}).join("")}function up(e,r,t,a,n,i,s){if(!e||e.v==undefined&&e.f==undefined)return"";var f={};if(e.f)f["ss:Formula"]="="+Ue(ec(e.f,s));if(e.F&&e.F.slice(0,r.length)==r){var l=vt(e.F.slice(r.length+1));f["ss:ArrayRange"]="RC:R"+(l.r==s.r?"":"["+(l.r-s.r)+"]")+"C"+(l.c==s.c?"":"["+(l.c-s.c)+"]")}if(e.l&&e.l.Target){f["ss:HRef"]=Ue(e.l.Target);if(e.l.Tooltip)f["x:HRefScreenTip"]=Ue(e.l.Tooltip)}if(t["!merges"]){var o=t["!merges"];for(var c=0;c!=o.length;++c){if(o[c].s.c!=s.c||o[c].s.r!=s.r)continue;if(o[c].e.c>o[c].s.c)f["ss:MergeAcross"]=o[c].e.c-o[c].s.c;if(o[c].e.r>o[c].s.r)f["ss:MergeDown"]=o[c].e.r-o[c].s.r}}var u="",h="";switch(e.t){case"z":if(!a.sheetStubs)return"";break;case"n":u="Number";h=String(e.v);break;case"b":u="Boolean";h=e.v?"1":"0";break;case"e":u="Error";h=Zt[e.v];break;case"d":u="DateTime";h=new Date(e.v).toISOString();if(e.z==null)e.z=e.z||F._table[14];break;case"s":u="String";h=Ve(e.v||"");break;}var d=fh(a.cellXfs,e,a);f["ss:StyleID"]="s"+(21+d);f["ss:Index"]=s.c+1;var v=e.v!=null?h:"";var p=e.t=="z"?"":'<Data ss:Type="'+u+'">'+v+"</Data>";if((e.c||[]).length>0)p+=cp(e.c);return fr("Cell",p,f)}function hp(e,r){var t='<Row ss:Index="'+(e+1)+'"';if(r){if(r.hpt&&!r.hpx)r.hpx=kl(r.hpt);if(r.hpx)t+=' ss:AutoFitHeight="0" ss:Height="'+r.hpx+'"';if(r.hidden)t+=' ss:Hidden="1"'}return t+">"}function dp(e,r,t,a){if(!e["!ref"])return"";var n=gt(e["!ref"]);var i=e["!merges"]||[],s=0;var f=[];if(e["!cols"])e["!cols"].forEach(function(e,r){ml(e);var t=!!e.width;var a=ih(r,e);var n={"ss:Index":r+1};if(t)n["ss:Width"]=ul(a.width);if(e.hidden)n["ss:Hidden"]="1";f.push(fr("Column",null,n))});var l=Array.isArray(e);for(var o=n.s.r;o<=n.e.r;++o){var c=[hp(o,(e["!rows"]||[])[o])];for(var u=n.s.c;u<=n.e.c;++u){var h=false;for(s=0;s!=i.length;++s){if(i[s].s.c>u)continue;if(i[s].s.r>o)continue;if(i[s].e.c<u)continue;if(i[s].e.r<o)continue;if(i[s].s.c!=u||i[s].s.r!=o)h=true;break}if(h)continue;var d={r:o,c:u};var v=pt(d),p=l?(e[o]||[])[u]:e[v];c.push(up(p,v,e,r,t,a,d))}c.push("</Row>");if(c.length>2)f.push(c.join(""))}return f.join("")}function vp(e,r,t){var a=[];var n=t.SheetNames[e];var i=t.Sheets[n];var s=i?lp(i,r,e,t):"";if(s.length>0)a.push("<Names>"+s+"</Names>");s=i?dp(i,r,e,t):"";if(s.length>0)a.push("<Table>"+s+"</Table>");a.push(op(i,r,e,t));return a.join("")}function pp(e,r){if(!r)r={};if(!e.SSF)e.SSF=F.get_table();if(e.SSF){O(F);F.load_table(e.SSF);r.revssf=Q(e.SSF);r.revssf[e.SSF[65535]]=0;r.ssf=e.SSF;r.cellXfs=[];fh(r.cellXfs,{},{revssf:{General:0}})}var t=[];t.push(ap(e,r));t.push(np(e,r));t.push("");t.push("");for(var a=0;a<e.SheetNames.length;++a)t.push(fr("Worksheet",vp(a,r,e),{"ss:Name":Ue(e.SheetNames[a])}));t[2]=ip(e,r);t[3]=fp(e,r);return ye+fr("Workbook",t.join(""),{xmlns:ur.ss,"xmlns:o":ur.o,"xmlns:x":ur.x,"xmlns:ss":ur.ss,"xmlns:dt":ur.dt,"xmlns:html":ur.html})}function mp(e){var r={};var t=e.content;t.l=28;r.AnsiUserType=t._R(0,"lpstr-ansi");r.AnsiClipboardFormat=aa(t);if(t.length-t.l<=4)return r;var a=t._R(4);if(a==0||a>40)return r;t.l-=4;r.Reserved1=t._R(0,"lpstr-ansi");if(t.length-t.l<=4)return r;a=t._R(4);if(a!==1907505652)return r;r.UnicodeClipboardFormat=na(t);a=t._R(4);if(a==0||a>40)return r;t.l-=4;r.Reserved2=t._R(0,"lpwstr")}function bp(e,r,t,a){var n=t;var i=[];var s=r.slice(r.l,r.l+n);if(a&&a.enc&&a.enc.insitu)switch(e.n){case"BOF":;case"FilePass":;case"FileLock":;case"InterfaceHdr":;case"RRDInfo":;case"RRDHead":;case"UsrExcl":break;default:if(s.length===0)break;a.enc.insitu(s);}i.push(s);r.l+=n;var f=xp[Nr(r,r.l)];var l=0;while(f!=null&&f.n.slice(0,8)==="Continue"){n=Nr(r,r.l+2);l=r.l+4;if(f.n=="ContinueFrt")l+=4;else if(f.n.slice(0,11)=="ContinueFrt")l+=12;i.push(r.slice(l,r.l+4+n));r.l+=4+n;f=xp[Nr(r,r.l)]}var o=I(i);Kr(o,0);var c=0;o.lens=[];for(var u=0;u<i.length;++u){o.lens.push(c);c+=i[u].length}return e.f(o,o.length,a)}function gp(e,r,t){if(e.t==="z")return;if(!e.XF)return;var a=0;try{a=e.z||e.XF.numFmtId||0;if(r.cellNF)e.z=F._table[a]}catch(n){if(r.WTF)throw n}if(!r||r.cellText!==false)try{if(e.t==="e"){e.w=e.w||Zt[e.v]}else if(a===0||a=="General"){if(e.t==="n"){if((e.v|0)===e.v)e.w=F._general_int(e.v);else e.w=F._general_num(e.v)}else e.w=F._general(e.v)}else e.w=F.format(a,e.v,{date1904:!!t})}catch(n){if(r.WTF)throw n}if(r.cellDates&&a&&e.t=="n"&&F.is_date(F._table[a]||String(a))){var i=F.parse_date_code(e.v);if(i){e.t="d";e.v=new Date(i.y,i.m-1,i.d,i.H,i.M,i.S,i.u)}}}function wp(e,r,t){return{v:e,ixfe:r,t:t}}function kp(e,r){var t={opts:{}};var a={};if(m!=null&&r.dense==null)r.dense=m;var n=r.dense?[]:{};var i={};var s={};var f=null;var o=[];var c="";var u={};var h,d="",v,p,b,g;var w={};var k=[];var E;var S;var _=true;var C=[];var B=[];var T={Sheets:[],WBProps:{date1904:false},Views:[{}]},y={};var x=function we(e){if(e<8)return ya[e];if(e<64)return B[e-8]||ya[e];return ya[e]};var A=function ke(e,r,t){var a=r.XF.data;if(!a||!a.patternType||!t||!t.cellStyles)return;r.s={};r.s.patternType=a.patternType;var n;if(n=al(x(a.icvFore))){r.s.fgColor={rgb:n}}if(n=al(x(a.icvBack))){r.s.bgColor={rgb:n}}};var I=function Ee(e,r,t){if(V>1)return;if(t.sheetRows&&e.r>=t.sheetRows)_=false;if(!_)return;if(t.cellStyles&&r.XF&&r.XF.data)A(e,r,t);delete r.ixfe;delete r.XF;h=e;d=pt(e);if(!s||!s.s||!s.e)s={s:{r:0,c:0},e:{r:0,c:0}};if(e.r<s.s.r)s.s.r=e.r;if(e.c<s.s.c)s.s.c=e.c;if(e.r+1>s.e.r)s.e.r=e.r+1;if(e.c+1>s.e.c)s.e.c=e.c+1;if(t.cellFormula&&r.f){for(var a=0;a<k.length;++a){if(k[a][0].s.c>e.c||k[a][0].s.r>e.r)continue;if(k[a][0].e.c<e.c||k[a][0].e.r<e.r)continue;r.F=bt(k[a][0]);if(k[a][0].s.c!=e.c||k[a][0].s.r!=e.r)delete r.f;if(r.f)r.f=""+Fu(k[a][1],s,e,W,R);break}}{if(t.dense){if(!n[e.r])n[e.r]=[];n[e.r][e.c]=r}else n[d]=r}};var R={enc:false,sbcch:0,snames:[],sharedf:w,arrayf:k,rrtabid:[],lastuser:"",biff:8,codepage:0,winlocked:0,cellStyles:!!r&&!!r.cellStyles,WTF:!!r&&!!r.wtf};if(r.password)R.password=r.password;var D;var O=[];var P=[];var N=[],L=[];var M=0,U=0;var H=false;var W=[];W.SheetNames=R.snames;W.sharedf=R.sharedf;W.arrayf=R.arrayf;W.names=[];W.XTI=[];var z="";var V=0;var X=0,G=[];var j=[];var Y;R.codepage=1200;l(1200);var $=false;while(e.l<e.length-1){var Z=e.l;var Q=e._R(2);if(Q===0&&z==="EOF")break;var J=e.l===e.length?0:e._R(2);var q=xp[Q];if(q&&q.f){if(r.bookSheets){if(z==="BoundSheet8"&&q.n!=="BoundSheet8")break}z=q.n;if(q.r===2||q.r==12){var ee=e._R(2);J-=2;if(!R.enc&&ee!==Q&&((ee&255)<<8|ee>>8)!==Q)throw new Error("rt mismatch: "+ee+"!="+Q);if(q.r==12){e.l+=10;J-=10}}var re={};if(q.n==="EOF")re=q.f(e,J,R);else re=bp(q,e,J,R);var te=q.n;if(V==0&&te!="BOF")continue;switch(te){case"Date1904":t.opts.Date1904=T.WBProps.date1904=re;break;case"WriteProtect":t.opts.WriteProtect=true;break;case"FilePass":if(!R.enc)e.l=0;R.enc=re;if(!r.password)throw new Error("File is password-protected");if(re.valid==null)throw new Error("Encryption scheme unsupported");if(!re.valid)throw new Error("Password is incorrect");break;case"WriteAccess":R.lastuser=re;break;case"FileSharing":break;case"CodePage":var ae=Number(re);switch(ae){case 21010:ae=1200;break;case 32768:ae=1e4;break;case 32769:ae=1252;break;}l(R.codepage=ae);$=true;break;case"RRTabId":R.rrtabid=re;break;case"WinProtect":R.winlocked=re;break;case"Template":break;case"BookBool":break;case"UsesELFs":break;case"MTRSettings":break;case"RefreshAll":;case"CalcCount":;case"CalcDelta":;case"CalcIter":;case"CalcMode":;case"CalcPrecision":;case"CalcSaveRecalc":t.opts[te]=re;break;case"CalcRefMode":R.CalcRefMode=re;break;case"Uncalced":break;case"ForceFullCalculation":t.opts.FullCalc=re;break;case"WsBool":if(re.fDialog)n["!type"]="dialog";break;case"XF":C.push(re);break;case"ExtSST":break;case"BookExt":break;case"RichTextStream":break;case"BkHim":break;case"SupBook":W.push([re]);W[W.length-1].XTI=[];break;case"ExternName":W[W.length-1].push(re);break;case"Index":break;case"Lbl":Y={Name:re.Name,Ref:Fu(re.rgce,s,null,W,R)};if(re.itab>0)Y.Sheet=re.itab-1;W.names.push(Y);if(!W[0]){W[0]=[];W[0].XTI=[]}W[W.length-1].push(re);if(re.Name=="_xlnm._FilterDatabase"&&re.itab>0)if(re.rgce&&re.rgce[0]&&re.rgce[0][0]&&re.rgce[0][0][0]=="PtgArea3d")j[re.itab-1]={ref:bt(re.rgce[0][0][1][2])};break;case"ExternCount":R.ExternCount=re;break;case"ExternSheet":if(W.length==0){W[0]=[];W[0].XTI=[]}W[W.length-1].XTI=W[W.length-1].XTI.concat(re);W.XTI=W.XTI.concat(re);break;case"NameCmt":if(R.biff<8)break;if(Y!=null)Y.Comment=re[1];break;case"Protect":n["!protect"]=re;break;case"Password":if(re!==0&&R.WTF)console.error("Password verifier: "+re);break;case"Prot4Rev":;case"Prot4RevPass":break;case"BoundSheet8":{i[re.pos]=re;R.snames.push(re.name)}break;case"EOF":{if(--V)break;if(s.e){if(s.e.r>0&&s.e.c>0){s.e.r--;s.e.c--;n["!ref"]=bt(s);if(r.sheetRows&&r.sheetRows<=s.e.r){var ne=s.e.r;s.e.r=r.sheetRows-1;n["!fullref"]=n["!ref"];n["!ref"]=bt(s);s.e.r=ne}s.e.r++;s.e.c++}if(O.length>0)n["!merges"]=O;if(P.length>0)n["!objects"]=P;if(N.length>0)n["!cols"]=N;if(L.length>0)n["!rows"]=L;T.Sheets.push(y)}if(c==="")u=n;else a[c]=n;n=r.dense?[]:{}}break;case"BOF":{if(R.biff===8)R.biff={9:2,521:3,1033:4}[Q]||{512:2,768:3,1024:4,1280:5,1536:8,2:2,7:2}[re.BIFFVer]||8;if(R.biff==8&&re.BIFFVer==0&&re.dt==16)R.biff=2;if(V++)break;_=true;n=r.dense?[]:{};if(R.biff<8&&!$){$=true;l(R.codepage=r.codepage||1252)}if(R.biff<5){if(c==="")c="Sheet1";s={s:{r:0,c:0},e:{r:0,c:0}};var ie={pos:e.l-J,name:c};i[ie.pos]=ie;R.snames.push(c)}else c=(i[Z]||{name:""}).name;if(re.dt==32)n["!type"]="chart";if(re.dt==64)n["!type"]="macro";O=[];P=[];R.arrayf=k=[];N=[];L=[];M=U=0;H=false;y={Hidden:(i[Z]||{hs:0}).hs,name:c}}break;case"Number":;case"BIFF2NUM":;case"BIFF2INT":{if(n["!type"]=="chart")if(r.dense?(n[re.r]||[])[re.c]:n[pt({c:re.c,r:re.r})])++re.c;E={ixfe:re.ixfe,XF:C[re.ixfe]||{},v:re.val,t:"n"};if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I({c:re.c,r:re.r},E,r)}break;case"BoolErr":{E={ixfe:re.ixfe,XF:C[re.ixfe],v:re.val,t:re.t};if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I({c:re.c,r:re.r},E,r)}break;case"RK":{E={ixfe:re.ixfe,XF:C[re.ixfe],v:re.rknum,t:"n"};if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I({c:re.c,r:re.r},E,r)}break;case"MulRk":{for(var se=re.c;se<=re.C;++se){var fe=re.rkrec[se-re.c][0];E={ixfe:fe,XF:C[fe],v:re.rkrec[se-re.c][1],t:"n"};if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I({c:se,r:re.r},E,r)}}break;case"Formula":{if(re.val=="String"){f=re;break}E=wp(re.val,re.cell.ixfe,re.tt);E.XF=C[E.ixfe];if(r.cellFormula){var le=re.formula;if(le&&le[0]&&le[0][0]&&le[0][0][0]=="PtgExp"){var oe=le[0][0][1][0],ce=le[0][0][1][1];var ue=pt({r:oe,c:ce});if(w[ue])E.f=""+Fu(re.formula,s,re.cell,W,R);else E.F=((r.dense?(n[oe]||[])[ce]:n[ue])||{}).F}else E.f=""+Fu(re.formula,s,re.cell,W,R)}if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I(re.cell,E,r);f=re}break;case"String":{if(f){f.val=re;E=wp(re,f.cell.ixfe,"s");E.XF=C[E.ixfe];if(r.cellFormula){E.f=""+Fu(f.formula,s,f.cell,W,R)}if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I(f.cell,E,r);f=null}else throw new Error("String record expects Formula")}break;case"Array":{k.push(re);var he=pt(re[0].s);v=r.dense?(n[re[0].s.r]||[])[re[0].s.c]:n[he];if(r.cellFormula&&v){if(!f)break;if(!he||!v)break;v.f=""+Fu(re[1],s,re[0],W,R);v.F=bt(re[0])}}break;case"ShrFmla":{if(!_)break;if(!r.cellFormula)break;if(d){if(!f)break;w[pt(f.cell)]=re[0];v=r.dense?(n[f.cell.r]||[])[f.cell.c]:n[pt(f.cell)];(v||{}).f=""+Fu(re[0],s,h,W,R)}}break;case"LabelSst":E=wp(o[re.isst].t,re.ixfe,"s");if(o[re.isst].h)E.h=o[re.isst].h;E.XF=C[E.ixfe];if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I({c:re.c,r:re.r},E,r);break;case"Blank":if(r.sheetStubs){E={ixfe:re.ixfe,XF:C[re.ixfe],t:"z"};if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I({c:re.c,r:re.r},E,r)}break;case"MulBlank":if(r.sheetStubs){for(var de=re.c;de<=re.C;++de){var ve=re.ixfe[de-re.c];E={ixfe:ve,XF:C[ve],t:"z"};if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I({c:de,r:re.r},E,r)}}break;case"RString":;case"Label":;case"BIFF2STR":E=wp(re.val,re.ixfe,"s");E.XF=C[E.ixfe];if(X>0)E.z=G[E.ixfe>>8&31];gp(E,r,t.opts.Date1904);I({c:re.c,r:re.r},E,r);break;case"Dimensions":{if(V===1)s=re}break;case"SST":{o=re}break;case"Format":{if(R.biff==4){G[X++]=re[1];for(var pe=0;pe<X+163;++pe)if(F._table[pe]==re[1])break;if(pe>=163)F.load(re[1],X+163)}else F.load(re[1],re[0])}break;case"BIFF2FORMAT":{G[X++]=re;for(var me=0;me<X+163;++me)if(F._table[me]==re)break;if(me>=163)F.load(re,X+163)}break;case"MergeCells":O=O.concat(re);break;case"Obj":P[re.cmo[0]]=R.lastobj=re;break;case"TxO":R.lastobj.TxO=re;break;case"ImData":R.lastobj.ImData=re;break;case"HLink":{for(g=re[0].s.r;g<=re[0].e.r;++g)for(b=re[0].s.c;b<=re[0].e.c;++b){v=r.dense?(n[g]||[])[b]:n[pt({c:b,r:g})];if(v)v.l=re[1]}}break;case"HLinkTooltip":{for(g=re[0].s.r;g<=re[0].e.r;++g)for(b=re[0].s.c;b<=re[0].e.c;++b){v=r.dense?(n[g]||[])[b]:n[pt({c:b,r:g})];if(v&&v.l)v.l.Tooltip=re[1]}}break;case"Note":{if(R.biff<=5&&R.biff>=2)break;v=r.dense?(n[re[0].r]||[])[re[0].c]:n[pt(re[0])];var be=P[re[2]];if(!v){if(r.dense){if(!n[re[0].r])n[re[0].r]=[];v=n[re[0].r][re[0].c]={t:"z"}}else{v=n[pt(re[0])]={t:"z"}}s.e.r=Math.max(s.e.r,re[0].r);s.s.r=Math.min(s.s.r,re[0].r);s.e.c=Math.max(s.e.c,re[0].c);s.s.c=Math.min(s.s.c,re[0].c)}if(!v.c)v.c=[];p={a:re[1],t:be.TxO.t};v.c.push(p)}break;default:switch(q.n){case"ClrtClient":break;case"XFExt":Bo(C[re.ixfe],re.ext);break;case"DefColWidth":M=re;break;case"DefaultRowHeight":U=re[1];break;case"ColInfo":{if(!R.cellStyles)break;while(re.e>=re.s){N[re.e--]={width:re.w/256};if(!H){H=true;pl(re.w/256)}ml(N[re.e+1])}}break;case"Row":{var ge={};if(re.level!=null){L[re.r]=ge;ge.level=re.level}if(re.hidden){L[re.r]=ge;ge.hidden=true}if(re.hpt){L[re.r]=ge;ge.hpt=re.hpt;ge.hpx=kl(re.hpt)}}break;case"LeftMargin":;case"RightMargin":;case"TopMargin":;case"BottomMargin":if(!n["!margins"])sh(n["!margins"]={});n["!margins"][te.slice(0,-6).toLowerCase()]=re;break;case"Setup":if(!n["!margins"])sh(n["!margins"]={});n["!margins"].header=re.header;n["!margins"].footer=re.footer;break;case"Window2":if(re.RTL)T.Views[0].RTL=true;break;case"Header":break;case"Footer":break;case"HCenter":break;case"VCenter":break;case"Pls":break;case"GCW":break;case"LHRecord":break;case"DBCell":break;case"EntExU2":break;case"SxView":break;case"Sxvd":break;case"SXVI":break;case"SXVDEx":break;case"SxIvd":break;case"SXString":break;case"Sync":break;case"Addin":break;case"SXDI":break;case"SXLI":break;case"SXEx":break;case"QsiSXTag":break;case"Selection":break;case"Feat":break;case"FeatHdr":;case"FeatHdr11":break;case"Feature11":;case"Feature12":;case"List12":break;case"Country":S=re;break;case"RecalcId":break;case"DxGCol":break;case"Fbi":;case"Fbi2":;case"GelFrame":break;case"Font":break;case"XFCRC":break;case"Style":break;case"StyleExt":break;case"Palette":B=re;break;case"Theme":D=re;break;case"ScenarioProtect":break;case"ObjProtect":break;case"CondFmt12":break;case"Table":break;case"TableStyles":break;case"TableStyle":break;case"TableStyleElement":break;case"SXStreamID":break;case"SXVS":break;case"DConRef":break;case"SXAddl":break;case"DConBin":break;case"DConName":break;case"SXPI":break;case"SxFormat":break;case"SxSelect":break;case"SxRule":break;case"SxFilt":break;case"SxItm":break;case"SxDXF":break;case"ScenMan":break;case"DCon":break;case"CellWatch":break;case"PrintRowCol":break;case"PrintGrid":break;case"PrintSize":break;case"XCT":break;case"CRN":break;case"Scl":{}break;case"SheetExt":{}break;case"SheetExtOptional":{}break;case"ObNoMacros":{}break;case"ObProj":{}break;case"CodeName":{if(!c)T.WBProps.CodeName=re||"ThisWorkbook";else y.CodeName=re||y.name}break;case"GUIDTypeLib":{}break;case"WOpt":break;case"PhoneticInfo":break;case"OleObjectSize":break;case"DXF":;case"DXFN":;case"DXFN12":;case"DXFN12List":;case"DXFN12NoCB":break;case"Dv":;case"DVal":break;case"BRAI":;case"Series":;case"SeriesText":break;case"DConn":break;case"DbOrParamQry":break;case"DBQueryExt":break;case"OleDbConn":break;case"ExtString":break;case"IFmtRecord":break;case"CondFmt":;case"CF":;case"CF12":;case"CFEx":break;case"Excel9File":break;case"Units":break;case"InterfaceHdr":;case"Mms":;case"InterfaceEnd":;case"DSF":break;case"BuiltInFnGroupCount":break;case"Window1":;case"HideObj":;case"GridSet":;case"Guts":;case"UserBView":;case"UserSViewBegin":;case"UserSViewEnd":break;case"Pane":break;default:switch(q.n){case"Dat":;case"Begin":;case"End":;case"StartBlock":;case"EndBlock":;case"Frame":;case"Area":;case"Axis":;case"AxisLine":;case"Tick":break;case"AxesUsed":;case"CrtLayout12":;case"CrtLayout12A":;case"CrtLink":;case"CrtLine":;case"CrtMlFrt":;case"CrtMlFrtContinue":break;case"LineFormat":;case"AreaFormat":;case"Chart":;case"Chart3d":;case"Chart3DBarShape":;case"ChartFormat":;case"ChartFrtInfo":break;case"PlotArea":;case"PlotGrowth":break;case"SeriesList":;case"SerParent":;case"SerAuxTrend":break;case"DataFormat":;case"SerToCrt":;case"FontX":break;case"CatSerRange":;case"AxcExt":;case"SerFmt":break;case"ShtProps":break;case"DefaultText":;case"Text":;case"CatLab":break;case"DataLabExtContents":break;case"Legend":;case"LegendException":break;case"Pie":;case"Scatter":break;case"PieFormat":;case"MarkerFormat":break;case"StartObject":;case"EndObject":break;case"AlRuns":;case"ObjectLink":break;case"SIIndex":break;case"AttachedLabel":;case"YMult":break;case"Line":;case"Bar":break;case"Surf":break;case"AxisParent":break;case"Pos":break;case"ValueRange":break;case"SXViewEx9":break;case"SXViewLink":break;case"PivotChartBits":break;case"SBaseRef":break;case"TextPropsStream":break;case"LnExt":break;case"MkrExt":break;case"CrtCoopt":break;case"Qsi":;case"Qsif":;case"Qsir":;case"QsiSXTag":break;case"TxtQry":break;case"FilterMode":break;case"AutoFilter":;case"AutoFilterInfo":break;case"AutoFilter12":break;case"DropDownObjIds":break;case"Sort":break;case"SortData":break;case"ShapePropsStream":break;case"MsoDrawing":;case"MsoDrawingGroup":;case"MsoDrawingSelection":break;case"WebPub":;case"AutoWebPub":break;case"HeaderFooter":;case"HFPicture":;case"PLV":;case"HorizontalPageBreaks":;case"VerticalPageBreaks":break;case"Backup":;case"CompressPictures":;case"Compat12":break;case"Continue":;case"ContinueFrt12":break;case"FrtFontList":;case"FrtWrapper":break;default:switch(q.n){case"TabIdConf":;case"Radar":;case"RadarArea":;case"DropBar":;case"Intl":;case"CoordList":;case"SerAuxErrBar":break;case"BIFF2FONTCLR":;case"BIFF2FMTCNT":;case"BIFF2FONTXTRA":break;case"BIFF2XF":;case"BIFF3XF":;case"BIFF4XF":break;case"BIFF4FMTCNT":;case"BIFF2ROW":;case"BIFF2WINDOW2":break;case"SCENARIO":;case"DConBin":;case"PicF":;case"DataLabExt":;case"Lel":;case"BopPop":;case"BopPopCustom":;case"RealTimeData":;case"Name":break;case"LHNGraph":;case"FnGroupName":;case"AddMenu":;case"LPr":break;case"ListObj":;case"ListField":break;case"RRSort":break;case"BigName":break;case"ToolbarHdr":;case"ToolbarEnd":break;case"DDEObjName":break;case"FRTArchId$":break;default:if(r.WTF)throw"Unrecognized Record "+q.n;};};};}}else e.l+=J}t.SheetNames=K(i).sort(function(e,r){return Number(e)-Number(r)}).map(function(e){return i[e].name});if(!r.bookSheets)t.Sheets=a;if(t.Sheets)j.forEach(function(e,r){t.Sheets[t.SheetNames[r]]["!autofilter"]=e});t.Preamble=u;t.Strings=o;t.SSF=F.get_table();if(R.enc)t.Encryption=R.enc;if(D)t.Themes=D;t.Metadata={};if(S!==undefined)t.Metadata.Country=S;if(W.names.length>0)T.Names=W.names;t.Workbook=T;return t}var Ep={SI:"e0859ff2f94f6810ab9108002b27b3d9",DSI:"02d5cdd59c2e1b10939708002b2cf9ae",UDI:"05d5cdd59c2e1b10939708002b2cf9ae"};function Sp(e,r,t){var a=z.find(e,"!DocumentSummaryInformation");if(a&&a.size>0)try{var n=Un(a,ga,Ep.DSI);for(var i in n)r[i]=n[i]}catch(s){if(t.WTF)throw s}var f=z.find(e,"!SummaryInformation");if(f&&f.size>0)try{var l=Un(f,wa,Ep.SI);for(var o in l)if(r[o]==null)r[o]=l[o]}catch(s){if(t.WTF)throw s}if(r.HeadingPairs&&r.TitlesOfParts){nn(r.HeadingPairs,r.TitlesOfParts,r,t);delete r.HeadingPairs;delete r.TitlesOfParts}}function _p(e,r){var t=[],a=[],n=[];var i=0,s;if(e.Props){s=K(e.Props);for(i=0;i<s.length;++i)(Ea.hasOwnProperty(s[i])?t:Sa.hasOwnProperty(s[i])?a:n).push([s[i],e.Props[s[i]]])}if(e.Custprops){s=K(e.Custprops);for(i=0;i<s.length;++i)if(!(e.Props||{}).hasOwnProperty(s[i]))(Ea.hasOwnProperty(s[i])?t:Sa.hasOwnProperty(s[i])?a:n).push([s[i],e.Custprops[s[i]]])}var f=[];for(i=0;i<n.length;++i){if(Nn.indexOf(n[i][0])>-1)continue;if(n[i][1]==null)continue;f.push(n[i])}if(a.length)z.utils.cfb_add(r,"/SummaryInformation",Hn(a,Ep.SI,Sa,wa));if(t.length||f.length)z.utils.cfb_add(r,"/DocumentSummaryInformation",Hn(t,Ep.DSI,Ea,ga,f.length?f:null,Ep.UDI))}function Cp(e,r){if(!r)r={};mm(r);o();if(r.codepage)s(r.codepage);var t,a;if(e.FullPaths){if(z.find(e,"/encryption"))throw new Error("File is password-protected");t=z.find(e,"!CompObj");a=z.find(e,"/Workbook")||z.find(e,"/Book")}else{switch(r.type){case"base64":e=B(g.decode(e));break;case"binary":e=B(e);break;case"buffer":break;case"array":if(!Array.isArray(e))e=Array.prototype.slice.call(e);break;}Kr(e,0);a={content:e}}var n;var i;if(t)mp(t);if(r.bookProps&&!r.bookSheets)n={};else{var f=w?"buffer":"array";if(a&&a.content)n=kp(a.content,r);else if((i=z.find(e,"PerfectOffice_MAIN"))&&i.content)n=df.to_workbook(i.content,(r.type=f,r));else if((i=z.find(e,"NativeContent_MAIN"))&&i.content)n=df.to_workbook(i.content,(r.type=f,r));else throw new Error("Cannot find Workbook stream");if(r.bookVBA&&e.FullPaths&&z.find(e,"/_VBA_PROJECT_CUR/VBA/dir"))n.vbaraw=Go(e)}var l={};if(e.FullPaths)Sp(e,l,r);n.Props=n.Custprops=l;if(r.bookFiles)n.cfb=e;return n}function Bp(e,r){var t=r||{};var a=z.utils.cfb_new({root:"R"});var n="/Workbook";switch(t.bookType||"xls"){case"xls":t.bookType="biff8";case"xla":if(!t.bookType)t.bookType="xla";case"biff8":n="/Workbook";t.biff=8;break;case"biff5":n="/Book";t.biff=5;break;default:throw new Error("invalid type "+t.bookType+" for XLS CFB");}z.utils.cfb_add(a,n,jp(e,t));if(t.biff==8&&(e.Props||e.Custprops))_p(e,a);if(t.biff==8&&e.vbaraw)jo(a,z.read(e.vbaraw,{type:typeof e.vbaraw=="string"?"binary":"buffer"}));return a}var Tp={0:{n:"BrtRowHdr",f:zh},1:{n:"BrtCellBlank",f:Zh},2:{n:"BrtCellRk",f:id},3:{n:"BrtCellError",f:ed},4:{n:"BrtCellBool",f:Jh},5:{n:"BrtCellReal",f:ad},6:{n:"BrtCellSt",f:fd},7:{n:"BrtCellIsst",f:rd},8:{n:"BrtFmlaString",f:hd},9:{n:"BrtFmlaNum",f:ud},10:{n:"BrtFmlaBool",f:od},11:{n:"BrtFmlaError",f:cd},16:{n:"BrtFRTArchID$",f:gv},19:{n:"BrtSSTItem",f:At},20:{n:"BrtPCDIMissing"},21:{n:"BrtPCDINumber"},22:{n:"BrtPCDIBoolean"},23:{n:"BrtPCDIError"},24:{n:"BrtPCDIString"},25:{n:"BrtPCDIDatetime"},26:{n:"BrtPCDIIndex"},27:{n:"BrtPCDIAMissing"},28:{n:"BrtPCDIANumber"},29:{n:"BrtPCDIABoolean"},30:{n:"BrtPCDIAError"},31:{n:"BrtPCDIAString"},32:{n:"BrtPCDIADatetime"},33:{n:"BrtPCRRecord"},34:{n:"BrtPCRRecordDt"},35:{n:"BrtFRTBegin"},36:{n:"BrtFRTEnd"},37:{n:"BrtACBegin"},38:{n:"BrtACEnd"},39:{n:"BrtName",f:wv},40:{n:"BrtIndexRowBlock"},42:{n:"BrtIndexBlock"},43:{n:"BrtFont",f:Nl},44:{n:"BrtFmt",f:Ol},45:{n:"BrtFill",f:Hl},46:{n:"BrtBorder",f:Gl},47:{n:"BrtXF",f:zl},48:{n:"BrtStyle"},49:{n:"BrtCellMeta"},50:{n:"BrtValueMeta"},51:{n:"BrtMdb"},52:{n:"BrtBeginFmd"},53:{n:"BrtEndFmd"},54:{n:"BrtBeginMdx"},55:{n:"BrtEndMdx"},56:{n:"BrtBeginMdxTuple"},57:{n:"BrtEndMdxTuple"},58:{n:"BrtMdxMbrIstr"},59:{n:"BrtStr"},60:{n:"BrtColInfo",f:Xs},62:{n:"BrtCellRString"},63:{n:"BrtCalcChainItem$",f:yo},64:{n:"BrtDVal",f:Ad},65:{n:"BrtSxvcellNum"},66:{n:"BrtSxvcellStr"},67:{n:"BrtSxvcellBool"},68:{n:"BrtSxvcellErr"},69:{n:"BrtSxvcellDate"},70:{n:"BrtSxvcellNil"},128:{n:"BrtFileVersion"},129:{n:"BrtBeginSheet"},130:{n:"BrtEndSheet"},131:{n:"BrtBeginBook",f:Yr,p:0},132:{n:"BrtEndBook"},133:{n:"BrtBeginWsViews"},134:{n:"BrtEndWsViews"},135:{n:"BrtBeginBookViews"},136:{n:"BrtEndBookViews"},137:{n:"BrtBeginWsView",f:Bd},138:{n:"BrtEndWsView"},139:{n:"BrtBeginCsViews"},140:{n:"BrtEndCsViews"},141:{n:"BrtBeginCsView"},142:{n:"BrtEndCsView"},143:{n:"BrtBeginBundleShs"},144:{n:"BrtEndBundleShs"},145:{n:"BrtBeginSheetData"},146:{n:"BrtEndSheetData"},147:{n:"BrtWsProp",f:Yh},148:{n:"BrtWsDim",f:Gh,p:16},151:{n:"BrtPane",f:gd},152:{n:"BrtSel"},153:{n:"BrtWbProp",f:mv},154:{n:"BrtWbFactoid"},155:{n:"BrtFileRecover"},156:{n:"BrtBundleSh",f:vv},157:{n:"BrtCalcProp"},158:{n:"BrtBookView"},159:{n:"BrtBeginSst",f:yf},160:{n:"BrtEndSst"},161:{n:"BrtBeginAFilter",f:jt},162:{n:"BrtEndAFilter"},163:{n:"BrtBeginFilterColumn"},164:{n:"BrtEndFilterColumn"},165:{n:"BrtBeginFilters"},166:{n:"BrtEndFilters"},167:{n:"BrtFilter"},168:{n:"BrtColorFilter"},169:{n:"BrtIconFilter"},170:{n:"BrtTop10Filter"},171:{n:"BrtDynamicFilter"},172:{n:"BrtBeginCustomFilters"},173:{n:"BrtEndCustomFilters"},174:{n:"BrtCustomFilter"},175:{n:"BrtAFilterDateGroupItem"},176:{n:"BrtMergeCell",f:dd},177:{n:"BrtBeginMergeCells"},178:{n:"BrtEndMergeCells"},179:{n:"BrtBeginPivotCacheDef"},180:{n:"BrtEndPivotCacheDef"},181:{n:"BrtBeginPCDFields"},182:{n:"BrtEndPCDFields"},183:{n:"BrtBeginPCDField"},184:{n:"BrtEndPCDField"},185:{n:"BrtBeginPCDSource"},186:{n:"BrtEndPCDSource"},187:{n:"BrtBeginPCDSRange"},188:{n:"BrtEndPCDSRange"},189:{n:"BrtBeginPCDFAtbl"},190:{n:"BrtEndPCDFAtbl"},191:{n:"BrtBeginPCDIRun"},192:{n:"BrtEndPCDIRun"},193:{n:"BrtBeginPivotCacheRecords"},194:{n:"BrtEndPivotCacheRecords"},195:{n:"BrtBeginPCDHierarchies"},196:{n:"BrtEndPCDHierarchies"},197:{n:"BrtBeginPCDHierarchy"},198:{n:"BrtEndPCDHierarchy"},199:{n:"BrtBeginPCDHFieldsUsage"},200:{n:"BrtEndPCDHFieldsUsage"},201:{n:"BrtBeginExtConnection"},202:{n:"BrtEndExtConnection"},203:{n:"BrtBeginECDbProps"},204:{n:"BrtEndECDbProps"},205:{n:"BrtBeginECOlapProps"},206:{n:"BrtEndECOlapProps"},207:{n:"BrtBeginPCDSConsol"},208:{n:"BrtEndPCDSConsol"},209:{n:"BrtBeginPCDSCPages"},210:{n:"BrtEndPCDSCPages"},211:{n:"BrtBeginPCDSCPage"},212:{n:"BrtEndPCDSCPage"},213:{n:"BrtBeginPCDSCPItem"},214:{n:"BrtEndPCDSCPItem"},215:{n:"BrtBeginPCDSCSets"},216:{n:"BrtEndPCDSCSets"},217:{n:"BrtBeginPCDSCSet"},218:{n:"BrtEndPCDSCSet"},219:{n:"BrtBeginPCDFGroup"},220:{n:"BrtEndPCDFGroup"},221:{n:"BrtBeginPCDFGItems"},222:{n:"BrtEndPCDFGItems"},223:{n:"BrtBeginPCDFGRange"},224:{n:"BrtEndPCDFGRange"},225:{n:"BrtBeginPCDFGDiscrete"},226:{n:"BrtEndPCDFGDiscrete"},227:{n:"BrtBeginPCDSDTupleCache"},228:{n:"BrtEndPCDSDTupleCache"},229:{n:"BrtBeginPCDSDTCEntries"},230:{n:"BrtEndPCDSDTCEntries"},231:{n:"BrtBeginPCDSDTCEMembers"},232:{n:"BrtEndPCDSDTCEMembers"},233:{n:"BrtBeginPCDSDTCEMember"},234:{n:"BrtEndPCDSDTCEMember"},235:{n:"BrtBeginPCDSDTCQueries"},236:{n:"BrtEndPCDSDTCQueries"},237:{n:"BrtBeginPCDSDTCQuery"},238:{n:"BrtEndPCDSDTCQuery"},239:{n:"BrtBeginPCDSDTCSets"},240:{n:"BrtEndPCDSDTCSets"},241:{n:"BrtBeginPCDSDTCSet"},242:{n:"BrtEndPCDSDTCSet"},243:{n:"BrtBeginPCDCalcItems"},244:{n:"BrtEndPCDCalcItems"},245:{n:"BrtBeginPCDCalcItem"},246:{n:"BrtEndPCDCalcItem"},247:{n:"BrtBeginPRule"},248:{n:"BrtEndPRule"},249:{n:"BrtBeginPRFilters"},250:{n:"BrtEndPRFilters"},251:{n:"BrtBeginPRFilter"},252:{n:"BrtEndPRFilter"},253:{n:"BrtBeginPNames"},254:{n:"BrtEndPNames"},255:{n:"BrtBeginPName"},256:{n:"BrtEndPName"},257:{n:"BrtBeginPNPairs"},258:{n:"BrtEndPNPairs"},259:{n:"BrtBeginPNPair"},260:{n:"BrtEndPNPair"},261:{n:"BrtBeginECWebProps"},262:{n:"BrtEndECWebProps"},263:{n:"BrtBeginEcWpTables"},264:{n:"BrtEndECWPTables"},265:{n:"BrtBeginECParams"},266:{n:"BrtEndECParams"},267:{n:"BrtBeginECParam"},268:{n:"BrtEndECParam"},269:{n:"BrtBeginPCDKPIs"},270:{n:"BrtEndPCDKPIs"},271:{n:"BrtBeginPCDKPI"},272:{n:"BrtEndPCDKPI"},273:{n:"BrtBeginDims"},274:{n:"BrtEndDims"},275:{n:"BrtBeginDim"},276:{n:"BrtEndDim"},277:{n:"BrtIndexPartEnd"},278:{n:"BrtBeginStyleSheet"},279:{n:"BrtEndStyleSheet"},280:{n:"BrtBeginSXView"},281:{n:"BrtEndSXVI"},282:{n:"BrtBeginSXVI"},283:{n:"BrtBeginSXVIs"},284:{n:"BrtEndSXVIs"},285:{n:"BrtBeginSXVD"},286:{n:"BrtEndSXVD"},287:{n:"BrtBeginSXVDs"},288:{n:"BrtEndSXVDs"},289:{n:"BrtBeginSXPI"},290:{n:"BrtEndSXPI"},291:{n:"BrtBeginSXPIs"},292:{n:"BrtEndSXPIs"},293:{n:"BrtBeginSXDI"},294:{n:"BrtEndSXDI"},295:{n:"BrtBeginSXDIs"},296:{n:"BrtEndSXDIs"},297:{n:"BrtBeginSXLI"},298:{n:"BrtEndSXLI"},299:{n:"BrtBeginSXLIRws"},300:{n:"BrtEndSXLIRws"},301:{n:"BrtBeginSXLICols"},302:{n:"BrtEndSXLICols"},303:{n:"BrtBeginSXFormat"},304:{n:"BrtEndSXFormat"},305:{n:"BrtBeginSXFormats"},306:{n:"BrtEndSxFormats"},307:{n:"BrtBeginSxSelect"},308:{n:"BrtEndSxSelect"},309:{n:"BrtBeginISXVDRws"},310:{n:"BrtEndISXVDRws"},311:{n:"BrtBeginISXVDCols"},312:{n:"BrtEndISXVDCols"},313:{n:"BrtEndSXLocation"},314:{n:"BrtBeginSXLocation"},315:{n:"BrtEndSXView"},316:{n:"BrtBeginSXTHs"},317:{n:"BrtEndSXTHs"},318:{n:"BrtBeginSXTH"},319:{n:"BrtEndSXTH"},320:{n:"BrtBeginISXTHRws"},321:{n:"BrtEndISXTHRws"},322:{n:"BrtBeginISXTHCols"},323:{n:"BrtEndISXTHCols"},324:{n:"BrtBeginSXTDMPS"},325:{n:"BrtEndSXTDMPs"},326:{n:"BrtBeginSXTDMP"},327:{n:"BrtEndSXTDMP"},328:{n:"BrtBeginSXTHItems"},329:{n:"BrtEndSXTHItems"},330:{n:"BrtBeginSXTHItem"},331:{n:"BrtEndSXTHItem"},332:{n:"BrtBeginMetadata"},333:{n:"BrtEndMetadata"},334:{n:"BrtBeginEsmdtinfo"},335:{n:"BrtMdtinfo"},336:{n:"BrtEndEsmdtinfo"},337:{n:"BrtBeginEsmdb"},338:{n:"BrtEndEsmdb"},339:{n:"BrtBeginEsfmd"},340:{n:"BrtEndEsfmd"},341:{n:"BrtBeginSingleCells"},342:{n:"BrtEndSingleCells"},343:{n:"BrtBeginList"},344:{n:"BrtEndList"},345:{n:"BrtBeginListCols"},346:{n:"BrtEndListCols"},347:{n:"BrtBeginListCol"},348:{n:"BrtEndListCol"},349:{n:"BrtBeginListXmlCPr"},350:{n:"BrtEndListXmlCPr"},351:{n:"BrtListCCFmla"},352:{n:"BrtListTrFmla"},353:{n:"BrtBeginExternals"},354:{n:"BrtEndExternals"},355:{n:"BrtSupBookSrc",f:Ht},357:{n:"BrtSupSelf"
},358:{n:"BrtSupSame"},359:{n:"BrtSupTabs"},360:{n:"BrtBeginSupBook"},361:{n:"BrtPlaceholderName"},362:{n:"BrtExternSheet",f:Es},363:{n:"BrtExternTableStart"},364:{n:"BrtExternTableEnd"},366:{n:"BrtExternRowHdr"},367:{n:"BrtExternCellBlank"},368:{n:"BrtExternCellReal"},369:{n:"BrtExternCellBool"},370:{n:"BrtExternCellError"},371:{n:"BrtExternCellString"},372:{n:"BrtBeginEsmdx"},373:{n:"BrtEndEsmdx"},374:{n:"BrtBeginMdxSet"},375:{n:"BrtEndMdxSet"},376:{n:"BrtBeginMdxMbrProp"},377:{n:"BrtEndMdxMbrProp"},378:{n:"BrtBeginMdxKPI"},379:{n:"BrtEndMdxKPI"},380:{n:"BrtBeginEsstr"},381:{n:"BrtEndEsstr"},382:{n:"BrtBeginPRFItem"},383:{n:"BrtEndPRFItem"},384:{n:"BrtBeginPivotCacheIDs"},385:{n:"BrtEndPivotCacheIDs"},386:{n:"BrtBeginPivotCacheID"},387:{n:"BrtEndPivotCacheID"},388:{n:"BrtBeginISXVIs"},389:{n:"BrtEndISXVIs"},390:{n:"BrtBeginColInfos"},391:{n:"BrtEndColInfos"},392:{n:"BrtBeginRwBrk"},393:{n:"BrtEndRwBrk"},394:{n:"BrtBeginColBrk"},395:{n:"BrtEndColBrk"},396:{n:"BrtBrk"},397:{n:"BrtUserBookView"},398:{n:"BrtInfo"},399:{n:"BrtCUsr"},400:{n:"BrtUsr"},401:{n:"BrtBeginUsers"},403:{n:"BrtEOF"},404:{n:"BrtUCR"},405:{n:"BrtRRInsDel"},406:{n:"BrtRREndInsDel"},407:{n:"BrtRRMove"},408:{n:"BrtRREndMove"},409:{n:"BrtRRChgCell"},410:{n:"BrtRREndChgCell"},411:{n:"BrtRRHeader"},412:{n:"BrtRRUserView"},413:{n:"BrtRRRenSheet"},414:{n:"BrtRRInsertSh"},415:{n:"BrtRRDefName"},416:{n:"BrtRRNote"},417:{n:"BrtRRConflict"},418:{n:"BrtRRTQSIF"},419:{n:"BrtRRFormat"},420:{n:"BrtRREndFormat"},421:{n:"BrtRRAutoFmt"},422:{n:"BrtBeginUserShViews"},423:{n:"BrtBeginUserShView"},424:{n:"BrtEndUserShView"},425:{n:"BrtEndUserShViews"},426:{n:"BrtArrFmla",f:wd},427:{n:"BrtShrFmla",f:kd},428:{n:"BrtTable"},429:{n:"BrtBeginExtConnections"},430:{n:"BrtEndExtConnections"},431:{n:"BrtBeginPCDCalcMems"},432:{n:"BrtEndPCDCalcMems"},433:{n:"BrtBeginPCDCalcMem"},434:{n:"BrtEndPCDCalcMem"},435:{n:"BrtBeginPCDHGLevels"},436:{n:"BrtEndPCDHGLevels"},437:{n:"BrtBeginPCDHGLevel"},438:{n:"BrtEndPCDHGLevel"},439:{n:"BrtBeginPCDHGLGroups"},440:{n:"BrtEndPCDHGLGroups"},441:{n:"BrtBeginPCDHGLGroup"},442:{n:"BrtEndPCDHGLGroup"},443:{n:"BrtBeginPCDHGLGMembers"},444:{n:"BrtEndPCDHGLGMembers"},445:{n:"BrtBeginPCDHGLGMember"},446:{n:"BrtEndPCDHGLGMember"},447:{n:"BrtBeginQSI"},448:{n:"BrtEndQSI"},449:{n:"BrtBeginQSIR"},450:{n:"BrtEndQSIR"},451:{n:"BrtBeginDeletedNames"},452:{n:"BrtEndDeletedNames"},453:{n:"BrtBeginDeletedName"},454:{n:"BrtEndDeletedName"},455:{n:"BrtBeginQSIFs"},456:{n:"BrtEndQSIFs"},457:{n:"BrtBeginQSIF"},458:{n:"BrtEndQSIF"},459:{n:"BrtBeginAutoSortScope"},460:{n:"BrtEndAutoSortScope"},461:{n:"BrtBeginConditionalFormatting"},462:{n:"BrtEndConditionalFormatting"},463:{n:"BrtBeginCFRule"},464:{n:"BrtEndCFRule"},465:{n:"BrtBeginIconSet"},466:{n:"BrtEndIconSet"},467:{n:"BrtBeginDatabar"},468:{n:"BrtEndDatabar"},469:{n:"BrtBeginColorScale"},470:{n:"BrtEndColorScale"},471:{n:"BrtCFVO"},472:{n:"BrtExternValueMeta"},473:{n:"BrtBeginColorPalette"},474:{n:"BrtEndColorPalette"},475:{n:"BrtIndexedColor"},476:{n:"BrtMargins",f:_d},477:{n:"BrtPrintOptions"},478:{n:"BrtPageSetup"},479:{n:"BrtBeginHeaderFooter"},480:{n:"BrtEndHeaderFooter"},481:{n:"BrtBeginSXCrtFormat"},482:{n:"BrtEndSXCrtFormat"},483:{n:"BrtBeginSXCrtFormats"},484:{n:"BrtEndSXCrtFormats"},485:{n:"BrtWsFmtInfo",f:Kh},486:{n:"BrtBeginMgs"},487:{n:"BrtEndMGs"},488:{n:"BrtBeginMGMaps"},489:{n:"BrtEndMGMaps"},490:{n:"BrtBeginMG"},491:{n:"BrtEndMG"},492:{n:"BrtBeginMap"},493:{n:"BrtEndMap"},494:{n:"BrtHLink",f:md},495:{n:"BrtBeginDCon"},496:{n:"BrtEndDCon"},497:{n:"BrtBeginDRefs"},498:{n:"BrtEndDRefs"},499:{n:"BrtDRef"},500:{n:"BrtBeginScenMan"},501:{n:"BrtEndScenMan"},502:{n:"BrtBeginSct"},503:{n:"BrtEndSct"},504:{n:"BrtSlc"},505:{n:"BrtBeginDXFs"},506:{n:"BrtEndDXFs"},507:{n:"BrtDXF"},508:{n:"BrtBeginTableStyles"},509:{n:"BrtEndTableStyles"},510:{n:"BrtBeginTableStyle"},511:{n:"BrtEndTableStyle"},512:{n:"BrtTableStyleElement"},513:{n:"BrtTableStyleClient"},514:{n:"BrtBeginVolDeps"},515:{n:"BrtEndVolDeps"},516:{n:"BrtBeginVolType"},517:{n:"BrtEndVolType"},518:{n:"BrtBeginVolMain"},519:{n:"BrtEndVolMain"},520:{n:"BrtBeginVolTopic"},521:{n:"BrtEndVolTopic"},522:{n:"BrtVolSubtopic"},523:{n:"BrtVolRef"},524:{n:"BrtVolNum"},525:{n:"BrtVolErr"},526:{n:"BrtVolStr"},527:{n:"BrtVolBool"},528:{n:"BrtBeginCalcChain$"},529:{n:"BrtEndCalcChain$"},530:{n:"BrtBeginSortState"},531:{n:"BrtEndSortState"},532:{n:"BrtBeginSortCond"},533:{n:"BrtEndSortCond"},534:{n:"BrtBookProtection"},535:{n:"BrtSheetProtection"},536:{n:"BrtRangeProtection"},537:{n:"BrtPhoneticInfo"},538:{n:"BrtBeginECTxtWiz"},539:{n:"BrtEndECTxtWiz"},540:{n:"BrtBeginECTWFldInfoLst"},541:{n:"BrtEndECTWFldInfoLst"},542:{n:"BrtBeginECTwFldInfo"},548:{n:"BrtFileSharing"},549:{n:"BrtOleSize"},550:{n:"BrtDrawing",f:Ht},551:{n:"BrtLegacyDrawing"},552:{n:"BrtLegacyDrawingHF"},553:{n:"BrtWebOpt"},554:{n:"BrtBeginWebPubItems"},555:{n:"BrtEndWebPubItems"},556:{n:"BrtBeginWebPubItem"},557:{n:"BrtEndWebPubItem"},558:{n:"BrtBeginSXCondFmt"},559:{n:"BrtEndSXCondFmt"},560:{n:"BrtBeginSXCondFmts"},561:{n:"BrtEndSXCondFmts"},562:{n:"BrtBkHim"},564:{n:"BrtColor"},565:{n:"BrtBeginIndexedColors"},566:{n:"BrtEndIndexedColors"},569:{n:"BrtBeginMRUColors"},570:{n:"BrtEndMRUColors"},572:{n:"BrtMRUColor"},573:{n:"BrtBeginDVals"},574:{n:"BrtEndDVals"},577:{n:"BrtSupNameStart"},578:{n:"BrtSupNameValueStart"},579:{n:"BrtSupNameValueEnd"},580:{n:"BrtSupNameNum"},581:{n:"BrtSupNameErr"},582:{n:"BrtSupNameSt"},583:{n:"BrtSupNameNil"},584:{n:"BrtSupNameBool"},585:{n:"BrtSupNameFmla"},586:{n:"BrtSupNameBits"},587:{n:"BrtSupNameEnd"},588:{n:"BrtEndSupBook"},589:{n:"BrtCellSmartTagProperty"},590:{n:"BrtBeginCellSmartTag"},591:{n:"BrtEndCellSmartTag"},592:{n:"BrtBeginCellSmartTags"},593:{n:"BrtEndCellSmartTags"},594:{n:"BrtBeginSmartTags"},595:{n:"BrtEndSmartTags"},596:{n:"BrtSmartTagType"},597:{n:"BrtBeginSmartTagTypes"},598:{n:"BrtEndSmartTagTypes"},599:{n:"BrtBeginSXFilters"},600:{n:"BrtEndSXFilters"},601:{n:"BrtBeginSXFILTER"},602:{n:"BrtEndSXFilter"},603:{n:"BrtBeginFills"},604:{n:"BrtEndFills"},605:{n:"BrtBeginCellWatches"},606:{n:"BrtEndCellWatches"},607:{n:"BrtCellWatch"},608:{n:"BrtBeginCRErrs"},609:{n:"BrtEndCRErrs"},610:{n:"BrtCrashRecErr"},611:{n:"BrtBeginFonts"},612:{n:"BrtEndFonts"},613:{n:"BrtBeginBorders"},614:{n:"BrtEndBorders"},615:{n:"BrtBeginFmts"},616:{n:"BrtEndFmts"},617:{n:"BrtBeginCellXFs"},618:{n:"BrtEndCellXFs"},619:{n:"BrtBeginStyles"},620:{n:"BrtEndStyles"},625:{n:"BrtBigName"},626:{n:"BrtBeginCellStyleXFs"},627:{n:"BrtEndCellStyleXFs"},628:{n:"BrtBeginComments"},629:{n:"BrtEndComments"},630:{n:"BrtBeginCommentAuthors"},631:{n:"BrtEndCommentAuthors"},632:{n:"BrtCommentAuthor",f:Ho},633:{n:"BrtBeginCommentList"},634:{n:"BrtEndCommentList"},635:{n:"BrtBeginComment",f:Mo},636:{n:"BrtEndComment"},637:{n:"BrtCommentText",f:Rt},638:{n:"BrtBeginOleObjects"},639:{n:"BrtOleObject"},640:{n:"BrtEndOleObjects"},641:{n:"BrtBeginSxrules"},642:{n:"BrtEndSxRules"},643:{n:"BrtBeginActiveXControls"},644:{n:"BrtActiveX"},645:{n:"BrtEndActiveXControls"},646:{n:"BrtBeginPCDSDTCEMembersSortBy"},648:{n:"BrtBeginCellIgnoreECs"},649:{n:"BrtCellIgnoreEC"},650:{n:"BrtEndCellIgnoreECs"},651:{n:"BrtCsProp",f:$d},652:{n:"BrtCsPageSetup"},653:{n:"BrtBeginUserCsViews"},654:{n:"BrtEndUserCsViews"},655:{n:"BrtBeginUserCsView"},656:{n:"BrtEndUserCsView"},657:{n:"BrtBeginPcdSFCIEntries"},658:{n:"BrtEndPCDSFCIEntries"},659:{n:"BrtPCDSFCIEntry"},660:{n:"BrtBeginListParts"},661:{n:"BrtListPart"},662:{n:"BrtEndListParts"},663:{n:"BrtSheetCalcProp"},664:{n:"BrtBeginFnGroup"},665:{n:"BrtFnGroup"},666:{n:"BrtEndFnGroup"},667:{n:"BrtSupAddin"},668:{n:"BrtSXTDMPOrder"},669:{n:"BrtCsProtection"},671:{n:"BrtBeginWsSortMap"},672:{n:"BrtEndWsSortMap"},673:{n:"BrtBeginRRSort"},674:{n:"BrtEndRRSort"},675:{n:"BrtRRSortItem"},676:{n:"BrtFileSharingIso"},677:{n:"BrtBookProtectionIso"},678:{n:"BrtSheetProtectionIso"},679:{n:"BrtCsProtectionIso"},680:{n:"BrtRangeProtectionIso"},681:{n:"BrtDValList"},1024:{n:"BrtRwDescent"},1025:{n:"BrtKnownFonts"},1026:{n:"BrtBeginSXTupleSet"},1027:{n:"BrtEndSXTupleSet"},1028:{n:"BrtBeginSXTupleSetHeader"},1029:{n:"BrtEndSXTupleSetHeader"},1030:{n:"BrtSXTupleSetHeaderItem"},1031:{n:"BrtBeginSXTupleSetData"},1032:{n:"BrtEndSXTupleSetData"},1033:{n:"BrtBeginSXTupleSetRow"},1034:{n:"BrtEndSXTupleSetRow"},1035:{n:"BrtSXTupleSetRowItem"},1036:{n:"BrtNameExt"},1037:{n:"BrtPCDH14"},1038:{n:"BrtBeginPCDCalcMem14"},1039:{n:"BrtEndPCDCalcMem14"},1040:{n:"BrtSXTH14"},1041:{n:"BrtBeginSparklineGroup"},1042:{n:"BrtEndSparklineGroup"},1043:{n:"BrtSparkline"},1044:{n:"BrtSXDI14"},1045:{n:"BrtWsFmtInfoEx14"},1046:{n:"BrtBeginConditionalFormatting14"},1047:{n:"BrtEndConditionalFormatting14"},1048:{n:"BrtBeginCFRule14"},1049:{n:"BrtEndCFRule14"},1050:{n:"BrtCFVO14"},1051:{n:"BrtBeginDatabar14"},1052:{n:"BrtBeginIconSet14"},1053:{n:"BrtDVal14",f:Id},1054:{n:"BrtBeginDVals14"},1055:{n:"BrtColor14"},1056:{n:"BrtBeginSparklines"},1057:{n:"BrtEndSparklines"},1058:{n:"BrtBeginSparklineGroups"},1059:{n:"BrtEndSparklineGroups"},1061:{n:"BrtSXVD14"},1062:{n:"BrtBeginSXView14"},1063:{n:"BrtEndSXView14"},1064:{n:"BrtBeginSXView16"},1065:{n:"BrtEndSXView16"},1066:{n:"BrtBeginPCD14"},1067:{n:"BrtEndPCD14"},1068:{n:"BrtBeginExtConn14"},1069:{n:"BrtEndExtConn14"},1070:{n:"BrtBeginSlicerCacheIDs"},1071:{n:"BrtEndSlicerCacheIDs"},1072:{n:"BrtBeginSlicerCacheID"},1073:{n:"BrtEndSlicerCacheID"},1075:{n:"BrtBeginSlicerCache"},1076:{n:"BrtEndSlicerCache"},1077:{n:"BrtBeginSlicerCacheDef"},1078:{n:"BrtEndSlicerCacheDef"},1079:{n:"BrtBeginSlicersEx"},1080:{n:"BrtEndSlicersEx"},1081:{n:"BrtBeginSlicerEx"},1082:{n:"BrtEndSlicerEx"},1083:{n:"BrtBeginSlicer"},1084:{n:"BrtEndSlicer"},1085:{n:"BrtSlicerCachePivotTables"},1086:{n:"BrtBeginSlicerCacheOlapImpl"},1087:{n:"BrtEndSlicerCacheOlapImpl"},1088:{n:"BrtBeginSlicerCacheLevelsData"},1089:{n:"BrtEndSlicerCacheLevelsData"},1090:{n:"BrtBeginSlicerCacheLevelData"},1091:{n:"BrtEndSlicerCacheLevelData"},1092:{n:"BrtBeginSlicerCacheSiRanges"},1093:{n:"BrtEndSlicerCacheSiRanges"},1094:{n:"BrtBeginSlicerCacheSiRange"},1095:{n:"BrtEndSlicerCacheSiRange"},1096:{n:"BrtSlicerCacheOlapItem"},1097:{n:"BrtBeginSlicerCacheSelections"},1098:{n:"BrtSlicerCacheSelection"},1099:{n:"BrtEndSlicerCacheSelections"},1100:{n:"BrtBeginSlicerCacheNative"},1101:{n:"BrtEndSlicerCacheNative"},1102:{n:"BrtSlicerCacheNativeItem"},1103:{n:"BrtRangeProtection14"},1104:{n:"BrtRangeProtectionIso14"},1105:{n:"BrtCellIgnoreEC14"},1111:{n:"BrtList14"},1112:{n:"BrtCFIcon"},1113:{n:"BrtBeginSlicerCachesPivotCacheIDs"},1114:{n:"BrtEndSlicerCachesPivotCacheIDs"},1115:{n:"BrtBeginSlicers"},1116:{n:"BrtEndSlicers"},1117:{n:"BrtWbProp14"},1118:{n:"BrtBeginSXEdit"},1119:{n:"BrtEndSXEdit"},1120:{n:"BrtBeginSXEdits"},1121:{n:"BrtEndSXEdits"},1122:{n:"BrtBeginSXChange"},1123:{n:"BrtEndSXChange"},1124:{n:"BrtBeginSXChanges"},1125:{n:"BrtEndSXChanges"},1126:{n:"BrtSXTupleItems"},1128:{n:"BrtBeginSlicerStyle"},1129:{n:"BrtEndSlicerStyle"},1130:{n:"BrtSlicerStyleElement"},1131:{n:"BrtBeginStyleSheetExt14"},1132:{n:"BrtEndStyleSheetExt14"},1133:{n:"BrtBeginSlicerCachesPivotCacheID"},1134:{n:"BrtEndSlicerCachesPivotCacheID"},1135:{n:"BrtBeginConditionalFormattings"},1136:{n:"BrtEndConditionalFormattings"},1137:{n:"BrtBeginPCDCalcMemExt"},1138:{n:"BrtEndPCDCalcMemExt"},1139:{n:"BrtBeginPCDCalcMemsExt"},1140:{n:"BrtEndPCDCalcMemsExt"},1141:{n:"BrtPCDField14"},1142:{n:"BrtBeginSlicerStyles"},1143:{n:"BrtEndSlicerStyles"},1144:{n:"BrtBeginSlicerStyleElements"},1145:{n:"BrtEndSlicerStyleElements"},1146:{n:"BrtCFRuleExt"},1147:{n:"BrtBeginSXCondFmt14"},1148:{n:"BrtEndSXCondFmt14"},1149:{n:"BrtBeginSXCondFmts14"},1150:{n:"BrtEndSXCondFmts14"},1152:{n:"BrtBeginSortCond14"},1153:{n:"BrtEndSortCond14"},1154:{n:"BrtEndDVals14"},1155:{n:"BrtEndIconSet14"},1156:{n:"BrtEndDatabar14"},1157:{n:"BrtBeginColorScale14"},1158:{n:"BrtEndColorScale14"},1159:{n:"BrtBeginSxrules14"},1160:{n:"BrtEndSxrules14"},1161:{n:"BrtBeginPRule14"},1162:{n:"BrtEndPRule14"},1163:{n:"BrtBeginPRFilters14"},1164:{n:"BrtEndPRFilters14"},1165:{n:"BrtBeginPRFilter14"},1166:{n:"BrtEndPRFilter14"},1167:{n:"BrtBeginPRFItem14"},1168:{n:"BrtEndPRFItem14"},1169:{n:"BrtBeginCellIgnoreECs14"},1170:{n:"BrtEndCellIgnoreECs14"},1171:{n:"BrtDxf14"},1172:{n:"BrtBeginDxF14s"},1173:{n:"BrtEndDxf14s"},1177:{n:"BrtFilter14"},1178:{n:"BrtBeginCustomFilters14"},1180:{n:"BrtCustomFilter14"},1181:{n:"BrtIconFilter14"},1182:{n:"BrtPivotCacheConnectionName"},2048:{n:"BrtBeginDecoupledPivotCacheIDs"},2049:{n:"BrtEndDecoupledPivotCacheIDs"},2050:{n:"BrtDecoupledPivotCacheID"},2051:{n:"BrtBeginPivotTableRefs"},2052:{n:"BrtEndPivotTableRefs"},2053:{n:"BrtPivotTableRef"},2054:{n:"BrtSlicerCacheBookPivotTables"},2055:{n:"BrtBeginSxvcells"},2056:{n:"BrtEndSxvcells"},2057:{n:"BrtBeginSxRow"},2058:{n:"BrtEndSxRow"},2060:{n:"BrtPcdCalcMem15"},2067:{n:"BrtQsi15"},2068:{n:"BrtBeginWebExtensions"},2069:{n:"BrtEndWebExtensions"},2070:{n:"BrtWebExtension"},2071:{n:"BrtAbsPath15"},2072:{n:"BrtBeginPivotTableUISettings"},2073:{n:"BrtEndPivotTableUISettings"},2075:{n:"BrtTableSlicerCacheIDs"},2076:{n:"BrtTableSlicerCacheID"},2077:{n:"BrtBeginTableSlicerCache"},2078:{n:"BrtEndTableSlicerCache"},2079:{n:"BrtSxFilter15"},2080:{n:"BrtBeginTimelineCachePivotCacheIDs"},2081:{n:"BrtEndTimelineCachePivotCacheIDs"},2082:{n:"BrtTimelineCachePivotCacheID"},2083:{n:"BrtBeginTimelineCacheIDs"},2084:{n:"BrtEndTimelineCacheIDs"},2085:{n:"BrtBeginTimelineCacheID"},2086:{n:"BrtEndTimelineCacheID"},2087:{n:"BrtBeginTimelinesEx"},2088:{n:"BrtEndTimelinesEx"},2089:{n:"BrtBeginTimelineEx"},2090:{n:"BrtEndTimelineEx"},2091:{n:"BrtWorkBookPr15"},2092:{n:"BrtPCDH15"},2093:{n:"BrtBeginTimelineStyle"},2094:{n:"BrtEndTimelineStyle"},2095:{n:"BrtTimelineStyleElement"},2096:{n:"BrtBeginTimelineStylesheetExt15"},2097:{n:"BrtEndTimelineStylesheetExt15"},2098:{n:"BrtBeginTimelineStyles"},2099:{n:"BrtEndTimelineStyles"},2100:{n:"BrtBeginTimelineStyleElements"},2101:{n:"BrtEndTimelineStyleElements"},2102:{n:"BrtDxf15"},2103:{n:"BrtBeginDxfs15"},2104:{n:"brtEndDxfs15"},2105:{n:"BrtSlicerCacheHideItemsWithNoData"},2106:{n:"BrtBeginItemUniqueNames"},2107:{n:"BrtEndItemUniqueNames"},2108:{n:"BrtItemUniqueName"},2109:{n:"BrtBeginExtConn15"},2110:{n:"BrtEndExtConn15"},2111:{n:"BrtBeginOledbPr15"},2112:{n:"BrtEndOledbPr15"},2113:{n:"BrtBeginDataFeedPr15"},2114:{n:"BrtEndDataFeedPr15"},2115:{n:"BrtTextPr15"},2116:{n:"BrtRangePr15"},2117:{n:"BrtDbCommand15"},2118:{n:"BrtBeginDbTables15"},2119:{n:"BrtEndDbTables15"},2120:{n:"BrtDbTable15"},2121:{n:"BrtBeginDataModel"},2122:{n:"BrtEndDataModel"},2123:{n:"BrtBeginModelTables"},2124:{n:"BrtEndModelTables"},2125:{n:"BrtModelTable"},2126:{n:"BrtBeginModelRelationships"},2127:{n:"BrtEndModelRelationships"},2128:{n:"BrtModelRelationship"},2129:{n:"BrtBeginECTxtWiz15"},2130:{n:"BrtEndECTxtWiz15"},2131:{n:"BrtBeginECTWFldInfoLst15"},2132:{n:"BrtEndECTWFldInfoLst15"},2133:{n:"BrtBeginECTWFldInfo15"},2134:{n:"BrtFieldListActiveItem"},2135:{n:"BrtPivotCacheIdVersion"},2136:{n:"BrtSXDI15"},2137:{n:"BrtBeginModelTimeGroupings"},2138:{n:"BrtEndModelTimeGroupings"},2139:{n:"BrtBeginModelTimeGrouping"},2140:{n:"BrtEndModelTimeGrouping"},2141:{n:"BrtModelTimeGroupingCalcCol"},3072:{n:"BrtUid"},3073:{n:"BrtRevisionPtr"},5095:{n:"BrtBeginCalcFeatures"},5096:{n:"BrtEndCalcFeatures"},5097:{n:"BrtCalcFeature"},65535:{n:""}};var yp=Y(Tp,"n");var xp={3:{n:"BIFF2NUM",f:qs},4:{n:"BIFF2STR",f:Js},6:{n:"Formula",f:Hu},9:{n:"BOF",f:Ai},10:{n:"EOF",f:Wn},12:{n:"CalcCount",f:jn},13:{n:"CalcMode",f:jn},14:{n:"CalcPrecision",f:Xn},15:{n:"CalcRefMode",f:Xn},16:{n:"CalcDelta",f:Yt},17:{n:"CalcIter",f:Xn},18:{n:"Protect",f:Xn},19:{n:"Password",f:jn},20:{n:"Header",f:ms},21:{n:"Footer",f:ms},23:{n:"ExternSheet",f:Es},24:{n:"Lbl",f:ks},25:{n:"WinProtect",f:Xn},26:{n:"VerticalPageBreaks"},27:{n:"HorizontalPageBreaks"},28:{n:"Note",f:xs},29:{n:"Selection"},34:{n:"Date1904",f:Xn},35:{n:"ExternName",f:gs},36:{n:"COLWIDTH"},38:{n:"LeftMargin",f:Yt},39:{n:"RightMargin",f:Yt},40:{n:"TopMargin",f:Yt},41:{n:"BottomMargin",f:Yt},42:{n:"PrintRowCol",f:Xn},43:{n:"PrintGrid",f:Xn},47:{n:"FilePass",f:el},49:{n:"Font",f:Yi},51:{n:"PrintSize",f:jn},60:{n:"Continue"},61:{n:"Window1",f:Vi},64:{n:"Backup",f:Xn},65:{n:"Pane",f:Ki},66:{n:"CodePage",f:jn},77:{n:"Pls"},80:{n:"DCon"},81:{n:"DConRef"},82:{n:"DConName"},85:{n:"DefColWidth",f:jn},89:{n:"XCT"},90:{n:"CRN"},91:{n:"FileSharing"},92:{n:"WriteAccess",f:Di},93:{n:"Obj",f:Rs},94:{n:"Uncalced"},95:{n:"CalcSaveRecalc",f:Xn},96:{n:"Template"},97:{n:"Intl"},99:{n:"ObjProtect",f:Xn},125:{n:"ColInfo",f:Xs},128:{n:"Guts",f:cs},129:{n:"WsBool",f:Oi},130:{n:"GridSet",f:jn},131:{n:"HCenter",f:Xn},132:{n:"VCenter",f:Xn},133:{n:"BoundSheet8",f:Pi},134:{n:"WriteProtect"},140:{n:"Country",f:Us},141:{n:"HideObj",f:jn},144:{n:"Sort"},146:{n:"Palette",f:zs},151:{n:"Sync"},152:{n:"LPr"},153:{n:"DxGCol"},154:{n:"FnGroupName"},155:{n:"FilterMode"},156:{n:"BuiltInFnGroupCount",f:jn},157:{n:"AutoFilterInfo"},158:{n:"AutoFilter"},160:{n:"Scl",f:$s},161:{n:"Setup",f:Gs},174:{n:"ScenMan"},175:{n:"SCENARIO"},176:{n:"SxView"},177:{n:"Sxvd"},178:{n:"SXVI"},180:{n:"SxIvd"},181:{n:"SXLI"},182:{n:"SXPI"},184:{n:"DocRoute"},185:{n:"RecipName"},189:{n:"MulRk",f:is},190:{n:"MulBlank",f:ss},193:{n:"Mms",f:Wn},197:{n:"SXDI"},198:{n:"SXDB"},199:{n:"SXFDB"},200:{n:"SXDBB"},201:{n:"SXNum"},202:{n:"SxBool",f:Xn},203:{n:"SxErr"},204:{n:"SXInt"},205:{n:"SXString"},206:{n:"SXDtr"},207:{n:"SxNil"},208:{n:"SXTbl"},209:{n:"SXTBRGIITM"},210:{n:"SxTbpg"},211:{n:"ObProj"},213:{n:"SXStreamID"},215:{n:"DBCell"},216:{n:"SXRng"},217:{n:"SxIsxoper"},218:{n:"BookBool",f:jn},220:{n:"DbOrParamQry"},221:{n:"ScenarioProtect",f:Xn},222:{n:"OleObjectSize"},224:{n:"XF",f:ls},225:{n:"InterfaceHdr",f:Ri},226:{n:"InterfaceEnd",f:Wn},227:{n:"SXVS"},229:{n:"MergeCells",f:As},233:{n:"BkHim"},235:{n:"MsoDrawingGroup"},236:{n:"MsoDrawing"},237:{n:"MsoDrawingSelection"},239:{n:"PhoneticInfo"},240:{n:"SxRule"},241:{n:"SXEx"},242:{n:"SxFilt"},244:{n:"SxDXF"},245:{n:"SxItm"},246:{n:"SxName"},247:{n:"SxSelect"},248:{n:"SXPair"},249:{n:"SxFmla"},251:{n:"SxFormat"},252:{n:"SST",f:Li},253:{n:"LabelSst",f:Zi},255:{n:"ExtSST",f:Mi},256:{n:"SXVDEx"},259:{n:"SXFormula"},290:{n:"SXDBEx"},311:{n:"RRDInsDel"},312:{n:"RRDHead"},315:{n:"RRDChgCell"},317:{n:"RRTabId",f:Yn},318:{n:"RRDRenSheet"},319:{n:"RRSort"},320:{n:"RRDMove"},330:{n:"RRFormat"},331:{n:"RRAutoFmt"},333:{n:"RRInsertSh"},334:{n:"RRDMoveBegin"},335:{n:"RRDMoveEnd"},336:{n:"RRDInsDelBegin"},337:{n:"RRDInsDelEnd"},338:{n:"RRDConflict"},339:{n:"RRDDefName"},340:{n:"RRDRstEtxp"},351:{n:"LRng"},352:{n:"UsesELFs",f:Xn},353:{n:"DSF",f:Wn},401:{n:"CUsr"},402:{n:"CbUsr"},403:{n:"UsrInfo"},404:{n:"UsrExcl"},405:{n:"FileLock"},406:{n:"RRDInfo"},407:{n:"BCUsrs"},408:{n:"UsrChk"},425:{n:"UserBView"},426:{n:"UserSViewBegin"},427:{n:"UserSViewEnd"},428:{n:"RRDUserView"},429:{n:"Qsi"},430:{n:"SupBook",f:bs},431:{n:"Prot4Rev",f:Xn},432:{n:"CondFmt"},433:{n:"CF"},434:{n:"DVal"},437:{n:"DConBin"},438:{n:"TxO",f:Os},439:{n:"RefreshAll",f:Xn},440:{n:"HLink",f:Ps},441:{n:"Lel"},442:{n:"CodeName",f:ei},443:{n:"SXFDBType"},444:{n:"Prot4RevPass",f:jn},445:{n:"ObNoMacros"},446:{n:"Dv"},448:{n:"Excel9File",f:Wn},449:{n:"RecalcId",f:Wi,r:2},450:{n:"EntExU2",f:Wn},512:{n:"Dimensions",f:ts},513:{n:"Blank",f:Ys},515:{n:"Number",f:vs},516:{n:"Label",f:Qi},517:{n:"BoolErr",f:hs},518:{n:"Formula",f:Hu},519:{n:"String",f:Zs},520:{n:"Row",f:Ui},523:{n:"Index"},545:{n:"Array",f:Bs},549:{n:"DefaultRowHeight",f:zi},566:{n:"Table"},574:{n:"Window2",f:Gi},638:{n:"RK",f:ns},659:{n:"Style"},1030:{n:"Formula",f:Hu},1048:{n:"BigName"},1054:{n:"Format",f:qi},1084:{n:"ContinueBigName"},1212:{n:"ShrFmla",f:Cs},2048:{n:"HLinkTooltip",f:Ls},2049:{n:"WebPub"},2050:{n:"QsiSXTag"},2051:{n:"DBQueryExt"},2052:{n:"ExtString"},2053:{n:"TxtQry"},2054:{n:"Qsir"},2055:{n:"Qsif"},2056:{n:"RRDTQSIF"},2057:{n:"BOF",f:Ai},2058:{n:"OleDbConn"},2059:{n:"WOpt"},2060:{n:"SXViewEx"},2061:{n:"SXTH"},2062:{n:"SXPIEx"},2063:{n:"SXVDTEx"},2064:{n:"SXViewEx9"},2066:{n:"ContinueFrt"},2067:{n:"RealTimeData"},2128:{n:"ChartFrtInfo"},2129:{n:"FrtWrapper"},2130:{n:"StartBlock"},2131:{n:"EndBlock"},2132:{n:"StartObject"},2133:{n:"EndObject"},2134:{n:"CatLab"},2135:{n:"YMult"},2136:{n:"SXViewLink"},2137:{n:"PivotChartBits"},2138:{n:"FrtFontList"},2146:{n:"SheetExt"},2147:{n:"BookExt",r:12},2148:{n:"SXAddl"},2149:{n:"CrErr"},2150:{n:"HFPicture"},2151:{n:"FeatHdr",f:Wn},2152:{n:"Feat"},2154:{n:"DataLabExt"},2155:{n:"DataLabExtContents"},2156:{n:"CellWatch"},2161:{n:"FeatHdr11"},2162:{n:"Feature11"},2164:{n:"DropDownObjIds"},2165:{n:"ContinueFrt11"},2166:{n:"DConn"},2167:{n:"List12"},2168:{n:"Feature12"},2169:{n:"CondFmt12"},2170:{n:"CF12"},2171:{n:"CFEx"},2172:{n:"XFCRC",f:Vs,r:12},2173:{n:"XFExt",f:Co,r:12},2174:{n:"AutoFilter12"},2175:{n:"ContinueFrt12"},2180:{n:"MDTInfo"},2181:{n:"MDXStr"},2182:{n:"MDXTuple"},2183:{n:"MDXSet"},2184:{n:"MDXProp"},2185:{n:"MDXKPI"},2186:{n:"MDB"},2187:{n:"PLV"},2188:{n:"Compat12",f:Xn,r:12},2189:{n:"DXF"},2190:{n:"TableStyles",r:12},2191:{n:"TableStyle"},2192:{n:"TableStyleElement"},2194:{n:"StyleExt"},2195:{n:"NamePublish"},2196:{n:"NameCmt",f:_s,r:12},2197:{n:"SortData"},2198:{n:"Theme",f:go,r:12},2199:{n:"GUIDTypeLib"},2200:{n:"FnGrp12"},2201:{n:"NameFnGrp12"},2202:{n:"MTRSettings",f:Ts,r:12},2203:{n:"CompressPictures",f:Wn},2204:{n:"HeaderFooter"},2205:{n:"CrtLayout12"},2206:{n:"CrtMlFrt"},2207:{n:"CrtMlFrtContinue"},2211:{n:"ForceFullCalculation",f:Hi},2212:{n:"ShapePropsStream"},2213:{n:"TextPropsStream"},2214:{n:"RichTextStream"},2215:{n:"CrtLayout12A"},4097:{n:"Units"},4098:{n:"Chart"},4099:{n:"Series"},4102:{n:"DataFormat"},4103:{n:"LineFormat"},4105:{n:"MarkerFormat"},4106:{n:"AreaFormat"},4107:{n:"PieFormat"},4108:{n:"AttachedLabel"},4109:{n:"SeriesText"},4116:{n:"ChartFormat"},4117:{n:"Legend"},4118:{n:"SeriesList"},4119:{n:"Bar"},4120:{n:"Line"},4121:{n:"Pie"},4122:{n:"Area"},4123:{n:"Scatter"},4124:{n:"CrtLine"},4125:{n:"Axis"},4126:{n:"Tick"},4127:{n:"ValueRange"},4128:{n:"CatSerRange"},4129:{n:"AxisLine"},4130:{n:"CrtLink"},4132:{n:"DefaultText"},4133:{n:"Text"},4134:{n:"FontX",f:jn},4135:{n:"ObjectLink"},4146:{n:"Frame"},4147:{n:"Begin"},4148:{n:"End"},4149:{n:"PlotArea"},4154:{n:"Chart3d"},4156:{n:"PicF"},4157:{n:"DropBar"},4158:{n:"Radar"},4159:{n:"Surf"},4160:{n:"RadarArea"},4161:{n:"AxisParent"},4163:{n:"LegendException"},4164:{n:"ShtProps",f:js},4165:{n:"SerToCrt"},4166:{n:"AxesUsed"},4168:{n:"SBaseRef"},4170:{n:"SerParent"},4171:{n:"SerAuxTrend"},4174:{n:"IFmtRecord"},4175:{n:"Pos"},4176:{n:"AlRuns"},4177:{n:"BRAI"},4187:{n:"SerAuxErrBar"},4188:{n:"ClrtClient",f:Ws},4189:{n:"SerFmt"},4191:{n:"Chart3DBarShape"},4192:{n:"Fbi"},4193:{n:"BopPop"},4194:{n:"AxcExt"},4195:{n:"Dat"},4196:{n:"PlotGrowth"},4197:{n:"SIIndex"},4198:{n:"GelFrame"},4199:{n:"BopPopCustom"},4200:{n:"Fbi2"},0:{n:"Dimensions",f:ts},2:{n:"BIFF2INT",f:rf},5:{n:"BoolErr",f:hs},7:{n:"String",f:af},8:{n:"BIFF2ROW"},11:{n:"Index"},22:{n:"ExternCount",f:jn},30:{n:"BIFF2FORMAT",f:rs},31:{n:"BIFF2FMTCNT"},32:{n:"BIFF2COLINFO"},33:{n:"Array",f:Bs},37:{n:"DefaultRowHeight",f:zi},50:{n:"BIFF2FONTXTRA",f:nf},52:{n:"DDEObjName"},62:{n:"BIFF2WINDOW2"},67:{n:"BIFF2XF"},69:{n:"BIFF2FONTCLR"},86:{n:"BIFF4FMTCNT"},126:{n:"RK"},127:{n:"ImData",f:Qs},135:{n:"Addin"},136:{n:"Edg"},137:{n:"Pub"},145:{n:"Sub"},148:{n:"LHRecord"},149:{n:"LHNGraph"},150:{n:"Sound"},169:{n:"CoordList"},171:{n:"GCW"},188:{n:"ShrFmla"},191:{n:"ToolbarHdr"},192:{n:"ToolbarEnd"},194:{n:"AddMenu"},195:{n:"DelMenu"},214:{n:"RString",f:sf},223:{n:"UDDesc"},234:{n:"TabIdConf"},354:{n:"XL5Modify"},421:{n:"FileSharing2"},521:{n:"BOF",f:Ai},536:{n:"Lbl",f:ks},547:{n:"ExternName",f:gs},561:{n:"Font"},579:{n:"BIFF3XF"},1033:{n:"BOF",f:Ai},1091:{n:"BIFF4XF"},2157:{n:"FeatInfo"},2163:{n:"FeatInfo11"},2177:{n:"SXAddl12"},2240:{n:"AutoWebPub"},2241:{n:"ListObj"},2242:{n:"ListField"},2243:{n:"ListDV"},2244:{n:"ListCondFmt"},2245:{n:"ListCF"},2246:{n:"FMQry"},2247:{n:"FMSQry"},2248:{n:"PLV"},2249:{n:"LnExt"},2250:{n:"MkrExt"},2251:{n:"CrtCoopt"},2262:{n:"FRTArchId$",r:12},29282:{}};var Ap=Y(xp,"n");function Ip(e,r,t,a){var n=+r||+Ap[r];if(isNaN(n))return;var i=a||(t||[]).length||0;var s=e.next(4);s._W(2,n);s._W(2,i);if(i>0&&Or(t))e.push(t)}function Rp(e,r,t){if(!e)e=$r(7);e._W(2,r);e._W(2,t);e._W(2,0);e._W(1,0);return e}function Dp(e,r,t,a){var n=$r(9);Rp(n,e,r);if(a=="e"){n._W(1,t);n._W(1,1)}else{n._W(1,t?1:0);n._W(1,0)}return n}function Fp(e,r,t){var a=$r(8+2*t.length);Rp(a,e,r);a._W(1,t.length);a._W(t.length,t,"sbcs");return a.l<a.length?a.slice(0,a.l):a}function Op(e,r,t,a){if(r.v!=null)switch(r.t){case"d":;case"n":var n=r.t=="d"?re(se(r.v)):r.v;if(n==(n|0)&&n>=0&&n<65536)Ip(e,2,tf(t,a,n));else Ip(e,3,ef(t,a,n));return;case"b":;case"e":Ip(e,5,Dp(t,a,r.v,r.t));return;case"s":;case"str":Ip(e,4,Fp(t,a,r.v));return;}Ip(e,1,Rp(null,t,a))}function Pp(e,r,t,a){var n=Array.isArray(r);var i=gt(r["!ref"]||"A1"),s,f="",l=[];if(i.e.c>255||i.e.r>16383){if(a.WTF)throw new Error("Range "+(r["!ref"]||"A1")+" exceeds format limit A1:IV16384");i.e.c=Math.min(i.e.c,255);i.e.r=Math.min(i.e.c,16383);s=bt(i)}for(var o=i.s.r;o<=i.e.r;++o){f=st(o);for(var c=i.s.c;c<=i.e.c;++c){if(o===i.s.r)l[c]=ct(c);s=l[c]+f;var u=n?(r[o]||[])[c]:r[s];if(!u)continue;Op(e,u,o,c,a)}}}function Np(e,r){var t=r||{};if(m!=null&&t.dense==null)t.dense=m;var a=Qr();var n=0;for(var i=0;i<e.SheetNames.length;++i)if(e.SheetNames[i]==t.sheet)n=i;if(n==0&&!!t.sheet&&e.SheetNames[0]!=t.sheet)throw new Error("Sheet not found: "+t.sheet);Ip(a,9,Ii(e,16,t));Pp(a,e.Sheets[e.SheetNames[n]],n,t,e);Ip(a,10);return a.end()}function Lp(e,r,t){Ip(e,"Font",$i({sz:12,color:{theme:1},name:"Arial",family:2,scheme:"minor"},t))}function Mp(e,r,t){if(!r)return;[[5,8],[23,26],[41,44],[50,392]].forEach(function(a){for(var n=a[0];n<=a[1];++n)if(r[n]!=null)Ip(e,"Format",es(n,r[n],t))})}function Up(e,r){var t=$r(19);t._W(4,2151);t._W(4,0);t._W(4,0);t._W(2,3);t._W(1,1);t._W(4,0);Ip(e,"FeatHdr",t);t=$r(39);t._W(4,2152);t._W(4,0);t._W(4,0);t._W(2,3);t._W(1,0);t._W(4,0);t._W(2,1);t._W(4,4);t._W(2,0);ki(gt(r["!ref"]||"A1"),t);t._W(4,4);Ip(e,"Feat",t)}function Hp(e,r){for(var t=0;t<16;++t)Ip(e,"XF",os({numFmtId:0,style:true},0,r));r.cellXfs.forEach(function(t){Ip(e,"XF",os(t,0,r))})}function Wp(e,r){for(var t=0;t<r["!links"].length;++t){var a=r["!links"][t];Ip(e,"HLink",Ns(a));if(a[1].Tooltip)Ip(e,"HLinkTooltip",Ms(a))}delete r["!links"]}function zp(e,r,t,a,n){var i=16+fh(n.cellXfs,r,n);if(r.v==null&&!r.bf){Ip(e,"Blank",di(t,a,i));return}if(r.bf)Ip(e,"Formula",Wu(r,t,a,n,i));else switch(r.t){case"d":;case"n":var s=r.t=="d"?re(se(r.v)):r.v;Ip(e,"Number",ps(t,a,s,i,n));break;case"b":;case"e":Ip(e,517,ds(t,a,r.v,i,n,r.t));break;case"s":;case"str":Ip(e,"Label",Ji(t,a,r.v,i,n));break;default:Ip(e,"Blank",di(t,a,i));}}function Vp(e,r,t){var a=Qr();var n=t.SheetNames[e],i=t.Sheets[n]||{};var s=(t||{}).Workbook||{};var f=(s.Sheets||[])[e]||{};var l=Array.isArray(i);var o=r.biff==8;var c,u="",h=[];var d=gt(i["!ref"]||"A1");var v=o?65536:16384;if(d.e.c>255||d.e.r>=v){if(r.WTF)throw new Error("Range "+(i["!ref"]||"A1")+" exceeds format limit A1:IV16384");d.e.c=Math.min(d.e.c,255);d.e.r=Math.min(d.e.c,v-1)}Ip(a,2057,Ii(t,16,r));Ip(a,"CalcMode",Kn(1));Ip(a,"CalcCount",Kn(100));Ip(a,"CalcRefMode",Gn(true));Ip(a,"CalcIter",Gn(false));Ip(a,"CalcDelta",$t(.001));Ip(a,"CalcSaveRecalc",Gn(true));Ip(a,"PrintRowCol",Gn(false));Ip(a,"PrintGrid",Gn(false));Ip(a,"GridSet",Kn(1));Ip(a,"Guts",us([0,0]));Ip(a,"HCenter",Gn(false));Ip(a,"VCenter",Gn(false));Ip(a,512,as(d,r));if(o)i["!links"]=[];for(var p=d.s.r;p<=d.e.r;++p){u=st(p);for(var m=d.s.c;m<=d.e.c;++m){if(p===d.s.r)h[m]=ct(m);c=h[m]+u;var b=l?(i[p]||[])[m]:i[c];if(!b)continue;zp(a,b,p,m,r);if(o&&b.l)i["!links"].push([c,b.l])}}var g=f.CodeName||f.name||n;if(o&&s.Views)Ip(a,"Window2",ji(s.Views[0]));if(o&&(i["!merges"]||[]).length)Ip(a,"MergeCells",Is(i["!merges"]));if(o)Wp(a,i);Ip(a,"CodeName",ti(g,r));if(o)Up(a,i);Ip(a,"EOF");return a.end()}function Xp(e,r,t){var a=Qr();var n=(e||{}).Workbook||{};var i=n.Sheets||[];var s=n.WBProps||{};var f=t.biff==8,l=t.biff==5;Ip(a,2057,Ii(e,5,t));if(t.bookType=="xla")Ip(a,"Addin");Ip(a,"InterfaceHdr",f?Kn(1200):null);Ip(a,"Mms",zn(2));if(l)Ip(a,"ToolbarHdr");if(l)Ip(a,"ToolbarEnd");Ip(a,"InterfaceEnd");Ip(a,"WriteAccess",Fi("SheetJS",t));Ip(a,"CodePage",Kn(f?1200:1252));if(f)Ip(a,"DSF",Kn(0));if(f)Ip(a,"Excel9File");Ip(a,"RRTabId",Ks(e.SheetNames.length));if(f&&e.vbaraw)Ip(a,"ObProj");if(f&&e.vbaraw){var o=s.CodeName||"ThisWorkbook";Ip(a,"CodeName",ti(o,t))}Ip(a,"BuiltInFnGroupCount",Kn(17));Ip(a,"WinProtect",Gn(false));Ip(a,"Protect",Gn(false));Ip(a,"Password",Kn(0));if(f)Ip(a,"Prot4Rev",Gn(false));if(f)Ip(a,"Prot4RevPass",Kn(0));Ip(a,"Window1",Xi(t));Ip(a,"Backup",Gn(false));Ip(a,"HideObj",Kn(0));Ip(a,"Date1904",Gn(iv(e)=="true"));Ip(a,"CalcPrecision",Gn(true));if(f)Ip(a,"RefreshAll",Gn(false));Ip(a,"BookBool",Kn(0));Lp(a,e,t);Mp(a,e.SSF,t);Hp(a,t);if(f)Ip(a,"UsesELFs",Gn(false));var c=a.end();var u=Qr();if(f)Ip(u,"Country",Hs());Ip(u,"EOF");var h=u.end();var d=Qr();var v=0,p=0;for(p=0;p<e.SheetNames.length;++p)v+=(f?12:11)+(f?2:1)*e.SheetNames[p].length;var m=c.length+v+h.length;for(p=0;p<e.SheetNames.length;++p){var b=i[p]||{};Ip(d,"BoundSheet8",Ni({pos:m,hs:b.Hidden||0,dt:0,name:e.SheetNames[p]},t));m+=r[p].length}var g=d.end();if(v!=g.length)throw new Error("BS8 "+v+" != "+g.length);var w=[];if(c.length)w.push(c);if(g.length)w.push(g);if(h.length)w.push(h);return vr([w])}function Gp(e,r){var t=r||{};var a=[];if(e&&!e.SSF){e.SSF=F.get_table()}if(e&&e.SSF){O(F);F.load_table(e.SSF);t.revssf=Q(e.SSF);t.revssf[e.SSF[65535]]=0;t.ssf=e.SSF}t.Strings=[];t.Strings.Count=0;t.Strings.Unique=0;bm(t);t.cellXfs=[];fh(t.cellXfs,{},{revssf:{General:0}});if(!e.Props)e.Props={};for(var n=0;n<e.SheetNames.length;++n)a[a.length]=Vp(n,t,e);a.unshift(Xp(e,a,t));return vr([a])}function jp(e,r){var t=r||{};switch(t.biff||2){case 8:;case 5:return Gp(e,r);case 4:;case 3:;case 2:return Np(e,r);}throw new Error("invalid type "+t.bookType+" for BIFF")}var Kp=function(){function e(e,r){var t=r||{};if(m!=null&&t.dense==null)t.dense=m;var a=t.dense?[]:{};e=e.replace(/<!--.*?-->/g,"");var n=e.match(/<table/i);if(!n)throw new Error("Invalid HTML: could not find <table>");var i=e.match(/<\/table/i);var s=n.index,f=i&&i.index||e.length;var l=de(e.slice(s,f),/(:?<tr[^>]*>)/i,"<tr>");var o=-1,c=0,u=0,h=0;var d={s:{r:1e7,c:1e7},e:{r:0,c:0}};var v=[];for(s=0;s<l.length;++s){var p=l[s].trim();var b=p.slice(0,3).toLowerCase();if(b=="<tr"){++o;if(t.sheetRows&&t.sheetRows<=o){--o;break}c=0;continue}if(b!="<td"&&b!="<th")continue;var g=p.split(/<\/t[dh]>/i);for(f=0;f<g.length;++f){var w=g[f].trim();if(!w.match(/<t[dh]/i))continue;var k=w,E=0;while(k.charAt(0)=="<"&&(E=k.indexOf(">"))>-1)k=k.slice(E+1);for(var S=0;S<v.length;++S){var _=v[S];if(_.s.c==c&&_.s.r<o&&o<=_.e.r){c=_.e.c+1;S=-1}}var C=De(w.slice(0,w.indexOf(">")));h=C.colspan?+C.colspan:1;if((u=+C.rowspan)>1||h>1)v.push({s:{r:o,c:c},e:{r:o+(u||1)-1,c:c+h-1}});var B=C.t||"";if(!k.length){c+=h;continue}k=qe(k);if(d.s.r>o)d.s.r=o;if(d.e.r<o)d.e.r=o;if(d.s.c>c)d.s.c=c;if(d.e.c<c)d.e.c=c;if(!k.length)continue;var T={t:"s",v:k};if(t.raw||!k.trim().length||B=="s"){}else if(k==="TRUE")T={t:"b",v:true};else if(k==="FALSE")T={t:"b",v:false};else if(!isNaN(ce(k)))T={t:"n",v:ce(k)};else if(!isNaN(ue(k).getDate())){T={t:"d",v:se(k)};if(!t.cellDates)T={t:"n",v:re(T.v)};T.z=t.dateNF||F._table[14]}if(t.dense){if(!a[o])a[o]=[];a[o][c]=T}else a[pt({r:o,c:c})]=T;c+=h}}a["!ref"]=bt(d);if(v.length)a["!merges"]=v;return a}function r(r,t){return Et(e(r,t),t)}function t(e,r,t,a){var n=e["!merges"]||[];var i=[];for(var s=r.s.c;s<=r.e.c;++s){var f=0,l=0;for(var o=0;o<n.length;++o){if(n[o].s.r>t||n[o].s.c>s)continue;if(n[o].e.r<t||n[o].e.c<s)continue;if(n[o].s.r<t||n[o].s.c<s){f=-1;break}f=n[o].e.r-n[o].s.r+1;
l=n[o].e.c-n[o].s.c+1;break}if(f<0)continue;var c=pt({r:t,c:s});var u=a.dense?(e[t]||[])[s]:e[c];var h=u&&u.v!=null&&(u.h||ze(u.w||(kt(u),u.w)||""))||"";var d={};if(f>1)d.rowspan=f;if(l>1)d.colspan=l;d.t=u&&u.t||"z";if(a.editable)h='<span contenteditable="true">'+h+"</span>";d.id=(a.id||"sjs")+"-"+c;i.push(fr("td",h,d))}var v="<tr>";return v+i.join("")+"</tr>"}function a(e,r,t){var a=[];return a.join("")+"<table"+(t&&t.id?' id="'+t.id+'"':"")+">"}var n='<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';var i="</body></html>";function s(e,r){var s=r||{};var f=s.header!=null?s.header:n;var l=s.footer!=null?s.footer:i;var o=[f];var c=mt(e["!ref"]);s.dense=Array.isArray(e);o.push(a(e,c,s));for(var u=c.s.r;u<=c.e.r;++u)o.push(t(e,c,u,s));o.push("</table>"+l);return o.join("")}return{to_workbook:r,to_sheet:e,_row:t,BEGIN:n,END:i,_preamble:a,from_sheet:s}}();function Yp(e,r){var t=r||{};if(m!=null)t.dense=m;var a=t.dense?[]:{};var n=e.getElementsByTagName("tr");var i=t.sheetRows||1e7;var s={s:{r:0,c:0},e:{r:0,c:0}};var f=[],l=0;var o=[];var c=0,u=0,h=0,d=0,v=0,p=0;for(;c<n.length&&u<i;++c){var b=n[c];if(Zp(b)){if(t.display)continue;o[u]={hidden:true}}var g=b.children;for(h=d=0;h<g.length;++h){var w=g[h];if(t.display&&Zp(w))continue;var k=qe(w.innerHTML);for(l=0;l<f.length;++l){var E=f[l];if(E.s.c==d&&E.s.r<=u&&u<=E.e.r){d=E.e.c+1;l=-1}}p=+w.getAttribute("colspan")||1;if((v=+w.getAttribute("rowspan"))>0||p>1)f.push({s:{r:u,c:d},e:{r:u+(v||1)-1,c:d+p-1}});var S={t:"s",v:k};var _=w.getAttribute("t")||"";if(k!=null){if(k.length==0)S.t=_||"z";else if(t.raw||k.trim().length==0||_=="s"){}else if(k==="TRUE")S={t:"b",v:true};else if(k==="FALSE")S={t:"b",v:false};else if(!isNaN(ce(k)))S={t:"n",v:ce(k)};else if(!isNaN(ue(k).getDate())){S={t:"d",v:se(k)};if(!t.cellDates)S={t:"n",v:re(S.v)};S.z=t.dateNF||F._table[14]}}if(t.dense){if(!a[u])a[u]=[];a[u][d]=S}else a[pt({c:d,r:u})]=S;if(s.e.c<d)s.e.c=d;d+=p}++u}if(f.length)a["!merges"]=f;if(o.length)a["!rows"]=o;s.e.r=u-1;a["!ref"]=bt(s);if(u>=i)a["!fullref"]=bt((s.e.r=n.length-c+u-1,s));return a}function $p(e,r){return Et(Yp(e,r),r)}function Zp(e){var r="";var t=Qp(e);if(t)r=t(e).getPropertyValue("display");if(!r)r=e.style.display;return r==="none"}function Qp(e){if(e.ownerDocument.defaultView&&typeof e.ownerDocument.defaultView.getComputedStyle==="function")return e.ownerDocument.defaultView.getComputedStyle;if(typeof getComputedStyle==="function")return getComputedStyle;return null}var Jp=function(){var e=function(e){var r=e.replace(/[\t\r\n]/g," ").trim().replace(/ +/g," ").replace(/<text:s\/>/g," ").replace(/<text:s text:c="(\d+)"\/>/g,function(e,r){return Array(parseInt(r,10)+1).join(" ")}).replace(/<text:tab[^>]*\/>/g,"\t").replace(/<text:line-break\/>/g,"\n");var t=Ne(r.replace(/<[^>]*>/g,""));return[t]};var r={day:["d","dd"],month:["m","mm"],year:["y","yy"],hours:["h","hh"],minutes:["m","mm"],seconds:["s","ss"],"am-pm":["A/P","AM/PM"],"day-of-week":["ddd","dddd"],era:["e","ee"],quarter:["\\Qm",'m\\"th quarter"']};return function t(a,n){var i=n||{};if(m!=null&&i.dense==null)i.dense=m;var s=qv(a);var f=[],l;var o;var c={name:""},u="",h=0;var d;var v;var p={},b=[];var g=i.dense?[]:{};var w,k;var E={value:""};var S="",_=0,C;var B=[];var T=-1,y=-1,x={s:{r:1e6,c:1e7},e:{r:0,c:0}};var A=0;var I={};var R=[],D={},F=0,O=0;var P=[],N=1,L=1;var M=[];var U={Names:[]};var H={};var W=["",""];var z=[],V={};var X="",G=0;var j=false,K=false;var Y=0;ep.lastIndex=0;s=s.replace(/<!--([\s\S]*?)-->/gm,"").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm,"");while(w=ep.exec(s))switch(w[3]=w[3].replace(/_.*$/,"")){case"table":;case"":if(w[1]==="/"){if(x.e.c>=x.s.c&&x.e.r>=x.s.r)g["!ref"]=bt(x);if(i.sheetRows>0&&i.sheetRows<=x.e.r){g["!fullref"]=g["!ref"];x.e.r=i.sheetRows-1;g["!ref"]=bt(x)}if(R.length)g["!merges"]=R;if(P.length)g["!rows"]=P;d.name=d[""]||d.name;if(typeof JSON!=="undefined")JSON.stringify(d);b.push(d.name);p[d.name]=g;K=false}else if(w[0].charAt(w[0].length-2)!=="/"){d=De(w[0],false);T=y=-1;x.s.r=x.s.c=1e7;x.e.r=x.e.c=0;g=i.dense?[]:{};R=[];P=[];K=true}break;case"table-row-group":if(w[1]==="/")--A;else++A;break;case"table-row":;case"":if(w[1]==="/"){T+=N;N=1;break}v=De(w[0],false);if(v[""])T=v[""]-1;else if(T==-1)T=0;N=+v["number-rows-repeated"]||1;if(N<10)for(Y=0;Y<N;++Y)if(A>0)P[T+Y]={level:A};y=-1;break;case"covered-table-cell":if(w[1]!=="/")++y;if(i.sheetStubs){if(i.dense){if(!g[T])g[T]=[];g[T][y]={t:"z"}}else g[pt({r:T,c:y})]={t:"z"}}S="";B=[];break;case"table-cell":;case"":if(w[0].charAt(w[0].length-2)==="/"){++y;E=De(w[0],false);L=parseInt(E["number-columns-repeated"]||"1",10);k={t:"z",v:null};if(E.formula&&i.cellFormula!=false)k.f=Qu(Ne(E.formula));if((E[""]||E["value-type"])=="string"){k.t="s";k.v=Ne(E["string-value"]||"");if(i.dense){if(!g[T])g[T]=[];g[T][y]=k}else{g[pt({r:T,c:y})]=k}}y+=L-1}else if(w[1]!=="/"){++y;L=1;var $=N?T+N-1:T;if(y>x.e.c)x.e.c=y;if(y<x.s.c)x.s.c=y;if(T<x.s.r)x.s.r=T;if($>x.e.r)x.e.r=$;E=De(w[0],false);z=[];V={};k={t:E[""]||E["value-type"],v:null};if(i.cellFormula){if(E.formula)E.formula=Ne(E.formula);if(E["number-matrix-columns-spanned"]&&E["number-matrix-rows-spanned"]){F=parseInt(E["number-matrix-rows-spanned"],10)||0;O=parseInt(E["number-matrix-columns-spanned"],10)||0;D={s:{r:T,c:y},e:{r:T+F-1,c:y+O-1}};k.F=bt(D);M.push([D,k.F])}if(E.formula)k.f=Qu(E.formula);else for(Y=0;Y<M.length;++Y)if(T>=M[Y][0].s.r&&T<=M[Y][0].e.r)if(y>=M[Y][0].s.c&&y<=M[Y][0].e.c)k.F=M[Y][1]}if(E["number-columns-spanned"]||E["number-rows-spanned"]){F=parseInt(E["number-rows-spanned"],10)||0;O=parseInt(E["number-columns-spanned"],10)||0;D={s:{r:T,c:y},e:{r:T+F-1,c:y+O-1}};R.push(D)}if(E["number-columns-repeated"])L=parseInt(E["number-columns-repeated"],10);switch(k.t){case"boolean":k.t="b";k.v=je(E["boolean-value"]);break;case"float":k.t="n";k.v=parseFloat(E.value);break;case"percentage":k.t="n";k.v=parseFloat(E.value);break;case"currency":k.t="n";k.v=parseFloat(E.value);break;case"date":k.t="d";k.v=se(E["date-value"]);if(!i.cellDates){k.t="n";k.v=re(k.v)}k.z="m/d/yy";break;case"time":k.t="n";k.v=ae(E["time-value"])/86400;break;case"number":k.t="n";k.v=parseFloat(E[""]);break;default:if(k.t==="string"||k.t==="text"||!k.t){k.t="s";if(E["string-value"]!=null){S=Ne(E["string-value"]);B=[]}}else throw new Error("Unsupported value type "+k.t);}}else{j=false;if(k.t==="s"){k.v=S||"";if(B.length)k.R=B;j=_==0}if(H.Target)k.l=H;if(z.length>0){k.c=z;z=[]}if(S&&i.cellText!==false)k.w=S;if(!j||i.sheetStubs){if(!(i.sheetRows&&i.sheetRows<=T)){for(var Z=0;Z<N;++Z){L=parseInt(E["number-columns-repeated"]||"1",10);if(i.dense){if(!g[T+Z])g[T+Z]=[];g[T+Z][y]=Z==0?k:le(k);while(--L>0)g[T+Z][y+L]=le(k)}else{g[pt({r:T+Z,c:y})]=k;while(--L>0)g[pt({r:T+Z,c:y+L})]=le(k)}if(x.e.c<=y)x.e.c=y}}}L=parseInt(E["number-columns-repeated"]||"1",10);y+=L-1;L=0;k={};S="";B=[]}H={};break;case"document":;case"document-content":;case"":;case"spreadsheet":;case"":;case"scripts":;case"styles":;case"font-face-decls":if(w[1]==="/"){if((l=f.pop())[0]!==w[3])throw"Bad state: "+l}else if(w[0].charAt(w[0].length-2)!=="/")f.push([w[3],true]);break;case"annotation":if(w[1]==="/"){if((l=f.pop())[0]!==w[3])throw"Bad state: "+l;V.t=S;if(B.length)V.R=B;V.a=X;z.push(V)}else if(w[0].charAt(w[0].length-2)!=="/"){f.push([w[3],false])}X="";G=0;S="";_=0;B=[];break;case"creator":if(w[1]==="/"){X=s.slice(G,w.index)}else G=w.index+w[0].length;break;case"meta":;case"":;case"settings":;case"config-item-set":;case"config-item-map-indexed":;case"config-item-map-entry":;case"config-item-map-named":;case"shapes":;case"frame":;case"text-box":;case"image":;case"data-pilot-tables":;case"list-style":;case"form":;case"dde-links":;case"event-listeners":;case"chart":if(w[1]==="/"){if((l=f.pop())[0]!==w[3])throw"Bad state: "+l}else if(w[0].charAt(w[0].length-2)!=="/")f.push([w[3],false]);S="";_=0;B=[];break;case"scientific-number":break;case"currency-symbol":break;case"currency-style":break;case"number-style":;case"percentage-style":;case"date-style":;case"time-style":if(w[1]==="/"){I[c.name]=u;if((l=f.pop())[0]!==w[3])throw"Bad state: "+l}else if(w[0].charAt(w[0].length-2)!=="/"){u="";c=De(w[0],false);f.push([w[3],true])}break;case"script":break;case"libraries":break;case"automatic-styles":break;case"master-styles":break;case"default-style":;case"page-layout":break;case"style":break;case"map":break;case"font-face":break;case"paragraph-properties":break;case"table-properties":break;case"table-column-properties":break;case"table-row-properties":break;case"table-cell-properties":break;case"number":switch(f[f.length-1][0]){case"time-style":;case"date-style":o=De(w[0],false);u+=r[w[3]][o.style==="long"?1:0];break;}break;case"fraction":break;case"day":;case"month":;case"year":;case"era":;case"day-of-week":;case"week-of-year":;case"quarter":;case"hours":;case"minutes":;case"seconds":;case"am-pm":switch(f[f.length-1][0]){case"time-style":;case"date-style":o=De(w[0],false);u+=r[w[3]][o.style==="long"?1:0];break;}break;case"boolean-style":break;case"boolean":break;case"text-style":break;case"text":if(w[0].slice(-2)==="/>")break;else if(w[1]==="/")switch(f[f.length-1][0]){case"number-style":;case"date-style":;case"time-style":u+=s.slice(h,w.index);break;}else h=w.index+w[0].length;break;case"named-range":o=De(w[0],false);W=qu(o["cell-range-address"]);var Q={Name:o.name,Ref:W[0]+"!"+W[1]};if(K)Q.Sheet=b.length;U.Names.push(Q);break;case"text-content":break;case"text-properties":break;case"embedded-text":break;case"body":;case"":break;case"forms":break;case"table-column":break;case"table-header-rows":break;case"table-rows":break;case"table-column-group":break;case"table-header-columns":break;case"table-columns":break;case"null-date":break;case"graphic-properties":break;case"calculation-settings":break;case"named-expressions":break;case"label-range":break;case"label-ranges":break;case"named-expression":break;case"sort":break;case"sort-by":break;case"sort-groups":break;case"tab":break;case"line-break":break;case"span":break;case"p":;case"":if(w[1]==="/"&&(!E||!E["string-value"])){var J=e(s.slice(_,w.index),C);S=(S.length>0?S+"\n":"")+J[0]}else{C=De(w[0],false);_=w.index+w[0].length}break;case"s":break;case"database-range":if(w[1]==="/")break;try{W=qu(De(w[0])["target-range-address"]);p[W[0]]["!autofilter"]={ref:W[1]}}catch(q){}break;case"date":break;case"object":break;case"title":;case"":break;case"desc":break;case"binary-data":break;case"table-source":break;case"scenario":break;case"iteration":break;case"content-validations":break;case"content-validation":break;case"help-message":break;case"error-message":break;case"database-ranges":break;case"filter":break;case"filter-and":break;case"filter-or":break;case"filter-condition":break;case"list-level-style-bullet":break;case"list-level-style-number":break;case"list-level-properties":break;case"sender-firstname":;case"sender-lastname":;case"sender-initials":;case"sender-title":;case"sender-position":;case"sender-email":;case"sender-phone-private":;case"sender-fax":;case"sender-company":;case"sender-phone-work":;case"sender-street":;case"sender-city":;case"sender-postal-code":;case"sender-country":;case"sender-state-or-province":;case"author-name":;case"author-initials":;case"chapter":;case"file-name":;case"template-name":;case"sheet-name":break;case"event-listener":break;case"initial-creator":;case"creation-date":;case"print-date":;case"generator":;case"document-statistic":;case"user-defined":;case"editing-duration":;case"editing-cycles":break;case"config-item":break;case"page-number":break;case"page-count":break;case"time":break;case"cell-range-source":break;case"detective":break;case"operation":break;case"highlighted-range":break;case"data-pilot-table":;case"source-cell-range":;case"source-service":;case"data-pilot-field":;case"data-pilot-level":;case"data-pilot-subtotals":;case"data-pilot-subtotal":;case"data-pilot-members":;case"data-pilot-member":;case"data-pilot-display-info":;case"data-pilot-sort-info":;case"data-pilot-layout-info":;case"data-pilot-field-reference":;case"data-pilot-groups":;case"data-pilot-group":;case"data-pilot-group-member":break;case"rect":break;case"dde-connection-decls":;case"dde-connection-decl":;case"dde-link":;case"dde-source":break;case"properties":break;case"property":break;case"a":if(w[1]!=="/"){H=De(w[0],false);if(!H.href)break;H.Target=H.href;delete H.href;if(H.Target.charAt(0)=="#"&&H.Target.indexOf(".")>-1){W=qu(H.Target.slice(1));H.Target="#"+W[0]+"!"+W[1]}}break;case"table-protection":break;case"data-pilot-grand-total":break;case"office-document-common-attrs":break;default:switch(w[2]){case"dc:":;case"calcext:":;case"loext:":;case"ooo:":;case"chartooo:":;case"draw:":;case"style:":;case"chart:":;case"form:":;case"uof:":;case":":;case":":break;default:if(i.WTF)throw new Error(w);};}var ee={Sheets:p,SheetNames:b,Workbook:U};if(i.bookSheets)delete ee.Sheets;return ee}}();function qp(e,r){r=r||{};var t=!!be(e,"objectdata");if(t)Xa(we(e,"META-INF/manifest.xml"),r);var a=ke(e,"content.xml");if(!a)throw new Error("Missing content.xml in "+(t?"ODS":"UOF")+" file");var n=Jp(t?a:Ke(a),r);if(be(e,"meta.xml"))n.Props=Ja(we(e,"meta.xml"));return n}function em(e,r){return Jp(e,r)}var rm=function(){var e="<office:document-styles "+sr({"xmlns:office":"urn:oasis:names:tc:opendocument:xmlns:office:1.0","xmlns:table":"urn:oasis:names:tc:opendocument:xmlns:table:1.0","xmlns:style":"urn:oasis:names:tc:opendocument:xmlns:style:1.0","xmlns:text":"urn:oasis:names:tc:opendocument:xmlns:text:1.0","xmlns:draw":"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0","xmlns:fo":"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0","xmlns:xlink":"http://www.w3.org/1999/xlink","xmlns:dc":"http://purl.org/dc/elements/1.1/","xmlns:number":"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0","xmlns:svg":"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0","xmlns:of":"urn:oasis:names:tc:opendocument:xmlns:of:1.2","office:version":"1.2"})+"></office:document-styles>";return function r(){return ye+e}}();var tm=function(){var e=function(e){return Ue(e).replace(/  +/g,function(e){return'<text:s text:c="'+e.length+'"/>'}).replace(/\t/g,"<text:tab/>").replace(/\n/g,"<text:line-break/>").replace(/^ /,"<text:s/>").replace(/ $/,"<text:s/>")};var r="          <table:table-cell />\n";var t="          <table:covered-table-cell/>\n";var a=function(a,n,i){var s=[];s.push('      <table:table table:name="'+Ue(n.SheetNames[i])+'">\n');var f=0,l=0,o=mt(a["!ref"]);var c=a["!merges"]||[],u=0;var h=Array.isArray(a);for(f=0;f<o.s.r;++f)s.push("        <table:table-row></table:table-row>\n");for(;f<=o.e.r;++f){s.push("        <table:table-row>\n");for(l=0;l<o.s.c;++l)s.push(r);for(;l<=o.e.c;++l){var d=false,v={},p="";for(u=0;u!=c.length;++u){if(c[u].s.c>l)continue;if(c[u].s.r>f)continue;if(c[u].e.c<l)continue;if(c[u].e.r<f)continue;if(c[u].s.c!=l||c[u].s.r!=f)d=true;v["table:number-columns-spanned"]=c[u].e.c-c[u].s.c+1;v["table:number-rows-spanned"]=c[u].e.r-c[u].s.r+1;break}if(d){s.push(t);continue}var m=pt({r:f,c:l}),b=h?(a[f]||[])[l]:a[m];if(b&&b.f){v["table:formula"]=Ue(Ju(b.f));if(b.F){if(b.F.slice(0,m.length)==m){var g=mt(b.F);v["table:number-matrix-columns-spanned"]=g.e.c-g.s.c+1;v["table:number-matrix-rows-spanned"]=g.e.r-g.s.r+1}}}if(!b){s.push(r);continue}switch(b.t){case"b":p=b.v?"TRUE":"FALSE";v["office:value-type"]="boolean";v["office:boolean-value"]=b.v?"true":"false";break;case"n":p=b.w||String(b.v||0);v["office:value-type"]="float";v["office:value"]=b.v||0;break;case"s":;case"str":p=b.v;v["office:value-type"]="string";break;case"d":p=b.w||se(b.v).toISOString();v["office:value-type"]="date";v["office:date-value"]=se(b.v).toISOString();v["table:style-name"]="ce1";break;default:s.push(r);continue;}var w=e(p);if(b.l&&b.l.Target){var k=b.l.Target;k=k.charAt(0)=="#"?"#"+eh(k.slice(1)):k;w=fr("text:a",w,{"xlink:href":k})}s.push("          "+fr("table:table-cell",fr("text:p",w,{}),v)+"\n")}s.push("        </table:table-row>\n")}s.push("      </table:table>\n");return s.join("")};var n=function(e){e.push(" <office:automatic-styles>\n");e.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');e.push('   <number:month number:style="long"/>\n');e.push("   <number:text>/</number:text>\n");e.push('   <number:day number:style="long"/>\n');e.push("   <number:text>/</number:text>\n");e.push("   <number:year/>\n");e.push("  </number:date-style>\n");e.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');e.push(" </office:automatic-styles>\n")};return function i(e,r){var t=[ye];var i=sr({"xmlns:office":"urn:oasis:names:tc:opendocument:xmlns:office:1.0","xmlns:table":"urn:oasis:names:tc:opendocument:xmlns:table:1.0","xmlns:style":"urn:oasis:names:tc:opendocument:xmlns:style:1.0","xmlns:text":"urn:oasis:names:tc:opendocument:xmlns:text:1.0","xmlns:draw":"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0","xmlns:fo":"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0","xmlns:xlink":"http://www.w3.org/1999/xlink","xmlns:dc":"http://purl.org/dc/elements/1.1/","xmlns:meta":"urn:oasis:names:tc:opendocument:xmlns:meta:1.0","xmlns:number":"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0","xmlns:presentation":"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0","xmlns:svg":"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0","xmlns:chart":"urn:oasis:names:tc:opendocument:xmlns:chart:1.0","xmlns:dr3d":"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0","xmlns:math":"http://www.w3.org/1998/Math/MathML","xmlns:form":"urn:oasis:names:tc:opendocument:xmlns:form:1.0","xmlns:script":"urn:oasis:names:tc:opendocument:xmlns:script:1.0","xmlns:ooo":"http://openoffice.org/2004/office","xmlns:ooow":"http://openoffice.org/2004/writer","xmlns:oooc":"http://openoffice.org/2004/calc","xmlns:dom":"http://www.w3.org/2001/xml-events","xmlns:xforms":"http://www.w3.org/2002/xforms","xmlns:xsd":"http://www.w3.org/2001/XMLSchema","xmlns:xsi":"http://www.w3.org/2001/XMLSchema-instance","xmlns:sheet":"urn:oasis:names:tc:opendocument:sh33tjs:1.0","xmlns:rpt":"http://openoffice.org/2005/report","xmlns:of":"urn:oasis:names:tc:opendocument:xmlns:of:1.2","xmlns:xhtml":"http://www.w3.org/1999/xhtml","xmlns:grddl":"http://www.w3.org/2003/g/data-view#","xmlns:tableooo":"http://openoffice.org/2009/table","xmlns:drawooo":"http://openoffice.org/2010/draw","xmlns:calcext":"urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0","xmlns:loext":"urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0","xmlns:field":"urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0","xmlns:formx":"urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0","xmlns:css3t":"http://www.w3.org/TR/css3-text/","office:version":"1.2"});var s=sr({"xmlns:config":"urn:oasis:names:tc:opendocument:xmlns:config:1.0","office:mimetype":"application/vnd.oasis.opendocument.spreadsheet"});if(r.bookType=="fods")t.push("<office:document"+i+s+">\n");else t.push("<office:document-content"+i+">\n");n(t);t.push("  <office:body>\n");t.push("    <office:spreadsheet>\n");for(var f=0;f!=e.SheetNames.length;++f)t.push(a(e.Sheets[e.SheetNames[f]],e,f,r));t.push("    </office:spreadsheet>\n");t.push("  </office:body>\n");if(r.bookType=="fods")t.push("</office:document>");else t.push("</office:document-content>");return t.join("")}}();function am(e,r){if(r.bookType=="fods")return tm(e,r);var t=Ce();var a="";var n=[];var i=[];a="mimetype";Se(t,a,"application/vnd.oasis.opendocument.spreadsheet");a="content.xml";Se(t,a,tm(e,r));n.push([a,"text/xml"]);i.push([a,"ContentFile"]);a="styles.xml";Se(t,a,rm(e,r));n.push([a,"text/xml"]);i.push([a,"StylesFile"]);a="meta.xml";Se(t,a,$a());n.push([a,"text/xml"]);i.push([a,"MetadataFile"]);a="manifest.rdf";Se(t,a,Ya(i));n.push([a,"application/rdf+xml"]);a="META-INF/manifest.xml";Se(t,a,Ga(n));return t}function nm(e,r){if(!r)return 0;var t=e.SheetNames.indexOf(r);if(t==-1)throw new Error("Sheet not found: "+r);return t}function im(e){return function r(t,a){var n=nm(t,a.sheet);return e.from_sheet(t.Sheets[t.SheetNames[n]],a,t)}}var sm=im(Kp);var fm=im({from_sheet:$m});var lm=im(typeof lf!=="undefined"?lf:{});var om=im(typeof of!=="undefined"?of:{});var cm=im(typeof uf!=="undefined"?uf:{});var um=im(typeof rl!=="undefined"?rl:{});var hm=im({from_sheet:Zm});var dm=im(typeof ff!=="undefined"?ff:{});var vm=im(typeof cf!=="undefined"?cf:{});function pm(e){return function r(t){for(var a=0;a!=e.length;++a){var n=e[a];if(t[n[0]]===undefined)t[n[0]]=n[1];if(n[2]==="n")t[n[0]]=Number(t[n[0]])}}}var mm=pm([["cellNF",false],["cellHTML",true],["cellFormula",true],["cellStyles",false],["cellText",true],["cellDates",false],["sheetStubs",false],["sheetRows",0,"n"],["bookDeps",false],["bookSheets",false],["bookProps",false],["bookFiles",false],["bookVBA",false],["password",""],["WTF",false]]);var bm=pm([["cellDates",false],["bookSST",false],["bookType","xlsx"],["compression",false],["WTF",false]]);function gm(e){if(Na.WS.indexOf(e)>-1)return"sheet";if(Na.CS&&e==Na.CS)return"chart";if(Na.DS&&e==Na.DS)return"dialog";if(Na.MS&&e==Na.MS)return"macro";return e&&e.length?e:"sheet"}function wm(e,r){if(!e)return 0;try{e=r.map(function a(r){if(!r.id)r.id=r.strRelID;return[r.name,e["!id"][r.id].Target,gm(e["!id"][r.id].Type)]})}catch(t){return null}return!e||e.length===0?null:e}function km(e,r,t,a,n,i,s,f,l,o,c,u){try{i[a]=Ma(ke(e,t,true),r);var h=we(e,r);var d;switch(f){case"sheet":d=yv(h,r,n,l,i[a],o,c,u);break;case"chart":d=xv(h,r,n,l,i[a],o,c,u);if(!d||!d["!drawel"])break;var v=Te(d["!drawel"].Target,r);var p=La(v);var m=Ro(ke(e,v,true),Ma(ke(e,p,true),v));var b=Te(m,v);var g=La(b);d=Gd(ke(e,b,true),b,l,Ma(ke(e,g,true),b),o,d);break;case"macro":d=Av(h,r,n,l,i[a],o,c,u);break;case"dialog":d=Iv(h,r,n,l,i[a],o,c,u);break;default:throw new Error("Unrecognized sheet type "+f);}s[a]=d;var w=[];if(i&&i[a])K(i[a]).forEach(function(t){if(i[a][t].Type==Na.CMNT){var n=Te(i[a][t].Target,r);w=Ov(we(e,n,true),n,l);if(!w||!w.length)return;Oo(d,w)}})}catch(k){if(l.WTF)throw k}}function Em(e){return e.charAt(0)=="/"?e.slice(1):e}function Sm(e,r){O(F);r=r||{};mm(r);if(be(e,"META-INF/manifest.xml"))return qp(e,r);if(be(e,"objectdata.xml"))return qp(e,r);if(be(e,"Index/Document.iwa"))throw new Error("Unsupported NUMBERS file");var t=Ee(e);var a=Da(ke(e,"[Content_Types].xml"));var n=false;var i,s;if(a.workbooks.length===0){s="xl/workbook.xml";if(we(e,s,true))a.workbooks.push(s)}if(a.workbooks.length===0){s="xl/workbook.bin";if(!we(e,s,true))throw new Error("Could not find workbook");a.workbooks.push(s);n=true}if(a.workbooks[0].slice(-3)=="bin")n=true;var f={};var l={};if(!r.bookSheets&&!r.bookProps){rh=[];if(a.sst)try{rh=Fv(we(e,Em(a.sst)),a.sst,r)}catch(o){if(r.WTF)throw o}if(r.cellStyles&&a.themes.length)f=Dv(ke(e,a.themes[0].replace(/^\//,""),true)||"",a.themes[0],r);if(a.style)l=Rv(we(e,Em(a.style)),a.style,f,r)}a.links.map(function(t){try{var a=Ma(ke(e,La(Em(t))),t);return Nv(we(e,Em(t)),a,t,r)}catch(n){}});var c=Tv(we(e,Em(a.workbooks[0])),a.workbooks[0],r);var u={},h="";if(a.coreprops.length){h=we(e,Em(a.coreprops[0]),true);if(h)u=Ja(h);if(a.extprops.length!==0){h=we(e,Em(a.extprops[0]),true);if(h)sn(h,u,r)}}var d={};if(!r.bookSheets||r.bookProps){if(a.custprops.length!==0){h=ke(e,Em(a.custprops[0]),true);if(h)d=cn(h,r)}}var v={};if(r.bookSheets||r.bookProps){if(c.Sheets)i=c.Sheets.map(function I(e){return e.name});else if(u.Worksheets&&u.SheetNames.length>0)i=u.SheetNames;if(r.bookProps){v.Props=u;v.Custprops=d}if(r.bookSheets&&typeof i!=="undefined")v.SheetNames=i;if(r.bookSheets?v.SheetNames:r.bookProps)return v}i={};var p={};if(r.bookDeps&&a.calcchain)p=Pv(we(e,Em(a.calcchain)),a.calcchain,r);var m=0;var b={};var g,w;{var k=c.Sheets;u.Worksheets=k.length;u.SheetNames=[];for(var E=0;E!=k.length;++E){u.SheetNames[E]=k[E].name}}var S=n?"bin":"xml";var _=a.workbooks[0].lastIndexOf("/");var C=(a.workbooks[0].slice(0,_+1)+"_rels/"+a.workbooks[0].slice(_+1)+".rels").replace(/^\//,"");if(!be(e,C))C="xl/_rels/workbook."+S+".rels";var B=Ma(ke(e,C,true),C);if(B)B=wm(B,c.Sheets);var T=we(e,"xl/worksheets/sheet.xml",true)?1:0;e:for(m=0;m!=u.Worksheets;++m){var y="sheet";if(B&&B[m]){g="xl/"+B[m][1].replace(/[\/]?xl\//,"");if(!be(e,g))g=B[m][1];if(!be(e,g))g=C.replace(/_rels\/.*$/,"")+B[m][1];y=B[m][2]}else{g="xl/worksheets/sheet"+(m+1-T)+"."+S;g=g.replace(/sheet0\./,"sheet.")}w=g.replace(/^(.*)(\/)([^\/]*)$/,"$1/_rels/$3.rels");if(r&&r.sheets!=null)switch(typeof r.sheets){case"number":if(m!=r.sheets)continue e;break;case"string":if(u.SheetNames[m].toLowerCase()!=r.sheets.toLowerCase())continue e;break;default:if(Array.isArray&&Array.isArray(r.sheets)){var x=false;for(var A=0;A!=r.sheets.length;++A){if(typeof r.sheets[A]=="number"&&r.sheets[A]==m)x=1;if(typeof r.sheets[A]=="string"&&r.sheets[A].toLowerCase()==u.SheetNames[m].toLowerCase())x=1}if(!x)continue e};}km(e,g,w,u.SheetNames[m],m,b,i,y,r,c,f,l)}v={Directory:a,Workbook:c,Props:u,Custprops:d,Deps:p,Sheets:i,SheetNames:u.SheetNames,Strings:rh,Styles:l,Themes:f,SSF:F.get_table()};if(r&&r.bookFiles){v.keys=t;v.files=e.files}if(r&&r.bookVBA){if(a.vba.length>0)v.vbaraw=we(e,Em(a.vba[0]),true);else if(a.defaults&&a.defaults.bin===Xo)v.vbaraw=we(e,"xl/vbaProject.bin",true)}return v}function _m(e,r){var t=r||{};var a="Workbook",n=z.find(e,a);try{a="/!DataSpaces/Version";n=z.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);Of(n.content);a="/!DataSpaces/DataSpaceMap";n=z.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);var i=Nf(n.content);if(i.length!==1||i[0].comps.length!==1||i[0].comps[0].t!==0||i[0].name!=="StrongEncryptionDataSpace"||i[0].comps[0].v!=="EncryptedPackage")throw new Error("ECMA-376 Encrypted file bad "+a);a="/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";n=z.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);var s=Lf(n.content);if(s.length!=1||s[0]!="StrongEncryptionTransform")throw new Error("ECMA-376 Encrypted file bad "+a);a="/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";n=z.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);Uf(n.content)}catch(f){}a="/EncryptionInfo";n=z.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);var l=zf(n.content);a="/EncryptedPackage";n=z.find(e,a);if(!n||!n.content)throw new Error("ECMA-376 Encrypted file missing "+a);if(l[0]==4&&typeof decrypt_agile!=="undefined")return decrypt_agile(l[1],n.content,t.password||"",t);if(l[0]==2&&typeof decrypt_std76!=="undefined")return decrypt_std76(l[1],n.content,t.password||"",t);throw new Error("File is password-protected")}function Cm(e,r){Do=1024;if(r.bookType=="ods")return am(e,r);if(e&&!e.SSF){e.SSF=F.get_table()}if(e&&e.SSF){O(F);F.load_table(e.SSF);r.revssf=Q(e.SSF);r.revssf[e.SSF[65535]]=0;r.ssf=e.SSF}r.rels={};r.wbrels={};r.Strings=[];r.Strings.Count=0;r.Strings.Unique=0;if(ah)r.revStrings=new Map;else{r.revStrings={};r.revStrings.foo=[];delete r.revStrings.foo}var t=r.bookType=="xlsb"?"bin":"xml";var a=Ko.indexOf(r.bookType)>-1;var n=Ra();bm(r=r||{});var i=Ce();var s="",f=0;r.cellXfs=[];fh(r.cellXfs,{},{revssf:{General:0}});if(!e.Props)e.Props={};s="docProps/core.xml";Se(i,s,rn(e.Props,r));n.coreprops.push(s);za(r.rels,2,s,Na.CORE_PROPS);s="docProps/app.xml";if(e.Props&&e.Props.SheetNames){}else if(!e.Workbook||!e.Workbook.Sheets)e.Props.SheetNames=e.SheetNames;else{var l=[];for(var o=0;o<e.SheetNames.length;++o)if((e.Workbook.Sheets[o]||{}).Hidden!=2)l.push(e.SheetNames[o]);e.Props.SheetNames=l}e.Props.Worksheets=e.Props.SheetNames.length;Se(i,s,ln(e.Props,r));n.extprops.push(s);za(r.rels,3,s,Na.EXT_PROPS);if(e.Custprops!==e.Props&&K(e.Custprops||{}).length>0){s="docProps/custom.xml";Se(i,s,hn(e.Custprops,r));n.custprops.push(s);za(r.rels,4,s,Na.CUST_PROPS)}for(f=1;f<=e.SheetNames.length;++f){var c={"!id":{}};var u=e.Sheets[e.SheetNames[f-1]];var h=(u||{})["!type"]||"sheet";switch(h){case"chart":;default:s="xl/worksheets/sheet"+f+"."+t;Se(i,s,Mv(f-1,s,r,e,c));n.sheets.push(s);za(r.wbrels,-1,"worksheets/sheet"+f+"."+t,Na.WS[0]);}if(u){var d=u["!comments"];var v=false;if(d&&d.length>0){var p="xl/comments"+f+"."+t;Se(i,p,zv(d,p,r));n.comments.push(p);za(c,-1,"../comments"+f+"."+t,Na.CMNT);v=true}if(u["!legacy"]){if(v)Se(i,"xl/drawings/vmlDrawing"+f+".vml",Fo(f,u["!comments"]))}delete u["!comments"];delete u["!legacy"]}if(c["!id"].rId1)Se(i,La(s),Ha(c))}if(r.Strings!=null&&r.Strings.length>0){s="xl/sharedStrings."+t;Se(i,s,Wv(r.Strings,s,r));n.strs.push(s);za(r.wbrels,-1,"sharedStrings."+t,Na.SST)}s="xl/workbook."+t;Se(i,s,Lv(e,s,r));n.workbooks.push(s);za(r.rels,1,s,Na.WB);s="xl/theme/theme1.xml";Se(i,s,bo(e.Themes,r));n.themes.push(s);za(r.wbrels,-1,"theme/theme1.xml",Na.THEME);s="xl/styles."+t;Se(i,s,Hv(e,s,r));n.styles.push(s);za(r.wbrels,-1,"styles."+t,Na.STY);if(e.vbaraw&&a){s="xl/vbaProject.bin";Se(i,s,e.vbaraw);n.vba.push(s);za(r.wbrels,-1,"vbaProject.bin",Na.VBA)}Se(i,"[Content_Types].xml",Pa(n,r));Se(i,"_rels/.rels",Ha(r.rels));Se(i,"xl/_rels/workbook."+t+".rels",Ha(r.wbrels));delete r.revssf;delete r.ssf;return i}function Bm(e,r){var t="";switch((r||{}).type||"base64"){case"buffer":return[e[0],e[1],e[2],e[3]];case"base64":t=g.decode(e.slice(0,24));break;case"binary":t=e;break;case"array":return[e[0],e[1],e[2],e[3]];default:throw new Error("Unrecognized type "+(r&&r.type||"undefined"));}return[t.charCodeAt(0),t.charCodeAt(1),t.charCodeAt(2),t.charCodeAt(3)]}function Tm(e,r){if(z.find(e,"EncryptedPackage"))return _m(e,r);return Cp(e,r)}function ym(e,r){var t,a=e;var n=r||{};if(!n.type)n.type=w&&Buffer.isBuffer(e)?"buffer":"base64";t=Be(a,n);return Sm(t,n)}function xm(e,r){var t=0;e:while(t<e.length)switch(e.charCodeAt(t)){case 10:;case 13:;case 32:++t;break;case 60:return tp(e.slice(t),r);default:break e;}return uf.to_workbook(e,r)}function Am(e,r){var t="",a=Bm(e,r);switch(r.type){case"base64":t=g.decode(e);break;case"binary":t=e;break;case"buffer":t=e.toString("binary");break;case"array":t=fe(e);break;default:throw new Error("Unrecognized type "+r.type);}if(a[0]==239&&a[1]==187&&a[2]==191)t=Ke(t);return xm(t,r)}function Im(e,r){var t=e;if(r.type=="base64")t=g.decode(t);t=cptable.utils.decode(1200,t.slice(2),"str");r.type="binary";return xm(t,r)}function Rm(e){return!e.match(/[^\x00-\x7F]/)?e:Ye(e)}function Dm(e,r,t,a){if(a){t.type="string";return uf.to_workbook(e,t)}return uf.to_workbook(r,t)}function Fm(e,r){o();if(typeof ArrayBuffer!=="undefined"&&e instanceof ArrayBuffer)return Fm(new Uint8Array(e),r);var t=e,a=[0,0,0,0],n=false;var i=r||{};if(i.cellStyles){i.cellNF=true}th={};if(i.dateNF)th.dateNF=i.dateNF;if(!i.type)i.type=w&&Buffer.isBuffer(e)?"buffer":"base64";if(i.type=="file"){i.type=w?"buffer":"binary";t=j(e)}if(i.type=="string"){n=true;i.type="binary";i.codepage=65001;t=Rm(e)}if(i.type=="array"&&typeof Uint8Array!=="undefined"&&e instanceof Uint8Array&&typeof ArrayBuffer!=="undefined"){var s=new ArrayBuffer(3),f=new Uint8Array(s);f.foo="bar";if(!f.foo){i=le(i);i.type="array";return Fm(A(t),i)}}switch((a=Bm(t,i))[0]){case 208:return Tm(z.read(t,i),i);case 9:if(a[1]<=4)return Cp(t,i);break;case 60:return tp(t,i);case 73:if(a[1]===68)return hf(t,i);break;case 84:if(a[1]===65&&a[2]===66&&a[3]===76)return of.to_workbook(t,i);break;case 80:return a[1]===75&&a[2]<9&&a[3]<9?ym(t,i):Dm(e,t,i,n);case 239:return a[3]===60?tp(t,i):Dm(e,t,i,n);case 255:if(a[1]===254){return Im(t,i)}break;case 0:if(a[1]===0&&a[2]>=2&&a[3]===0)return df.to_workbook(t,i);break;case 3:;case 131:;case 139:;case 140:return ff.to_workbook(t,i);case 123:if(a[1]===92&&a[2]===114&&a[3]===116)return rl.to_workbook(t,i);break;case 10:;case 13:;case 32:return Am(t,i);}if(a[2]<=12&&a[3]<=31)return ff.to_workbook(t,i);return Dm(e,t,i,n)}function Om(e,r){var t=r||{};t.type="file";return Fm(e,t)}function Pm(e,r){switch(r.type){case"base64":;case"binary":break;case"buffer":;case"array":
r.type="";break;case"file":return G(r.file,z.write(e,{type:w?"buffer":""}));case"string":throw new Error("'string' output type invalid for '"+r.bookType+"' files");default:throw new Error("Unrecognized type "+r.type);}return z.write(e,r)}function Nm(e,r){var t=r||{};var a=Cm(e,t);var n={};if(t.compression)n.compression="DEFLATE";if(t.password)n.type=w?"nodebuffer":"string";else switch(t.type){case"base64":n.type="base64";break;case"binary":n.type="string";break;case"string":throw new Error("'string' output type invalid for '"+t.bookType+"' files");case"buffer":;case"file":n.type=w?"nodebuffer":"string";break;default:throw new Error("Unrecognized type "+t.type);}var i=a.FullPaths?z.write(a,{fileType:"zip",type:{nodebuffer:"buffer",string:"binary"}[n.type]||n.type}):a.generate(n);if(t.password&&typeof encrypt_agile!=="undefined")return Pm(encrypt_agile(i,t.password),t);if(t.type==="file")return G(t.file,i);return t.type=="string"?Ke(i):i}function Lm(e,r){var t=r||{};var a=Bp(e,t);return Pm(a,t)}function Mm(e,r,t){if(!t)t="";var a=t+e;switch(r.type){case"base64":return g.encode(Ye(a));case"binary":return Ye(a);case"string":return e;case"file":return G(r.file,a,"utf8");case"buffer":{if(w)return k(a,"utf8");else return Mm(a,{type:"binary"}).split("").map(function(e){return e.charCodeAt(0)})};}throw new Error("Unrecognized type "+r.type)}function Um(e,r){switch(r.type){case"base64":return g.encode(e);case"binary":return e;case"string":return e;case"file":return G(r.file,e,"binary");case"buffer":{if(w)return k(e,"binary");else return e.split("").map(function(e){return e.charCodeAt(0)})};}throw new Error("Unrecognized type "+r.type)}function Hm(e,r){switch(r.type){case"string":;case"base64":;case"binary":var t="";for(var a=0;a<e.length;++a)t+=String.fromCharCode(e[a]);return r.type=="base64"?g.encode(t):r.type=="string"?Ke(t):t;case"file":return G(r.file,e);case"buffer":return e;default:throw new Error("Unrecognized type "+r.type);}}function Wm(e,r){o();ov(e);var t=r||{};if(t.cellStyles){t.cellNF=true}if(t.type=="array"){t.type="binary";var a=Wm(e,t);t.type="array";return T(a)}switch(t.bookType||"xlsb"){case"xml":;case"xlml":return Mm(pp(e,t),t);case"slk":;case"sylk":return Mm(lm(e,t),t);case"htm":;case"html":return Mm(sm(e,t),t);case"txt":return Um(hm(e,t),t);case"csv":return Mm(fm(e,t),t,"\ufeff");case"dif":return Mm(om(e,t),t);case"dbf":return Hm(dm(e,t),t);case"prn":return Mm(cm(e,t),t);case"rtf":return Mm(um(e,t),t);case"eth":return Mm(vm(e,t),t);case"fods":return Mm(am(e,t),t);case"biff2":if(!t.biff)t.biff=2;case"biff3":if(!t.biff)t.biff=3;case"biff4":if(!t.biff)t.biff=4;return Hm(jp(e,t),t);case"biff5":if(!t.biff)t.biff=5;case"biff8":;case"xla":;case"xls":if(!t.biff)t.biff=8;return Lm(e,t);case"xlsx":;case"xlsm":;case"xlam":;case"xlsb":;case"ods":return Nm(e,t);default:throw new Error("Unrecognized bookType |"+t.bookType+"|");}}function zm(e){if(e.bookType)return;var r={xls:"biff8",htm:"html",slk:"sylk",socialcalc:"eth",Sh33tJS:"WTF"};var t=e.file.slice(e.file.lastIndexOf(".")).toLowerCase();if(t.match(/^\.[a-z]+$/))e.bookType=t.slice(1);e.bookType=r[e.bookType]||e.bookType}function Vm(e,r,t){var a=t||{};a.type="file";a.file=r;zm(a);return Wm(e,a)}function Xm(e,r,t,a){var n=t||{};n.type="file";n.file=e;zm(n);n.type="buffer";var i=a;if(!(i instanceof Function))i=t;return V.writeFile(e,Wm(r,n),i)}function Gm(e,r,t,a,n,i,s,f){var l=st(t);var o=f.defval,c=f.raw||!f.hasOwnProperty("raw");var u=true;var h=n===1?[]:{};if(n!==1){if(Object.defineProperty)try{Object.defineProperty(h,"__rowNum__",{value:t,enumerable:false})}catch(d){h.__rowNum__=t}else h.__rowNum__=t}if(!s||e[t])for(var v=r.s.c;v<=r.e.c;++v){var p=s?e[t][v]:e[a[v]+l];if(p===undefined||p.t===undefined){if(o===undefined)continue;if(i[v]!=null){h[i[v]]=o}continue}var m=p.v;switch(p.t){case"z":if(m==null)break;continue;case"e":m=void 0;break;case"s":;case"d":;case"b":;case"n":break;default:throw new Error("unrecognized type "+p.t);}if(i[v]!=null){if(m==null){if(o!==undefined)h[i[v]]=o;else if(c&&m===null)h[i[v]]=null;else continue}else{h[i[v]]=c?m:kt(p,m,f)}if(m!=null)u=false}}return{row:h,isempty:u}}function jm(e,r){if(e==null||e["!ref"]==null)return[];var t={t:"n",v:0},a=0,n=1,i=[],s=0,f="";var l={s:{r:0,c:0},e:{r:0,c:0}};var o=r||{};var c=o.range!=null?o.range:e["!ref"];if(o.header===1)a=1;else if(o.header==="A")a=2;else if(Array.isArray(o.header))a=3;else if(o.header==null)a=0;switch(typeof c){case"string":l=gt(c);break;case"number":l=gt(e["!ref"]);l.s.r=c;break;default:l=c;}if(a>0)n=0;var u=st(l.s.r);var h=[];var d=[];var v=0,p=0;var m=Array.isArray(e);var b=l.s.r,g=0,w=0;if(m&&!e[b])e[b]=[];for(g=l.s.c;g<=l.e.c;++g){h[g]=ct(g);t=m?e[b][g]:e[h[g]+u];switch(a){case 1:i[g]=g-l.s.c;break;case 2:i[g]=h[g];break;case 3:i[g]=o.header[g-l.s.c];break;default:if(t==null)t={w:"__EMPTY",t:"s"};f=s=kt(t,null,o);p=0;for(w=0;w<i.length;++w)if(i[w]==f)f=s+"_"+ ++p;i[g]=f;}}for(b=l.s.r+n;b<=l.e.r;++b){var k=Gm(e,l,b,h,a,i,m,o);if(k.isempty===false||(a===1?o.blankrows!==false:!!o.blankrows))d[v++]=k.row}d.length=v;return d}var Km=/"/g;function Ym(e,r,t,a,n,i,s,f){var l=true;var o=[],c="",u=st(t);for(var h=r.s.c;h<=r.e.c;++h){if(!a[h])continue;var d=f.dense?(e[t]||[])[h]:e[a[h]+u];if(d==null)c="";else if(d.v!=null){l=false;c=""+kt(d,null,f);for(var v=0,p=0;v!==c.length;++v)if((p=c.charCodeAt(v))===n||p===i||p===34){c='"'+c.replace(Km,'""')+'"';break}if(c=="ID")c='"ID"'}else if(d.f!=null&&!d.F){l=false;c="="+d.f;if(c.indexOf(",")>=0)c='"'+c.replace(Km,'""')+'"'}else c="";o.push(c)}if(f.blankrows===false&&l)return null;return o.join(s)}function $m(e,r){var t=[];var a=r==null?{}:r;if(e==null||e["!ref"]==null)return"";var n=gt(e["!ref"]);var i=a.FS!==undefined?a.FS:",",s=i.charCodeAt(0);var f=a.RS!==undefined?a.RS:"\n",l=f.charCodeAt(0);var o=new RegExp((i=="|"?"\\|":i)+"+$");var c="",u=[];a.dense=Array.isArray(e);var h=a.skipHidden&&e["!cols"]||[];var d=a.skipHidden&&e["!rows"]||[];for(var v=n.s.c;v<=n.e.c;++v)if(!(h[v]||{}).hidden)u[v]=ct(v);for(var p=n.s.r;p<=n.e.r;++p){if((d[p]||{}).hidden)continue;c=Ym(e,n,p,u,s,l,i,a);if(c==null){continue}if(a.strip)c=c.replace(o,"");t.push(c+f)}delete a.dense;return t.join("")}function Zm(e,r){if(!r)r={};r.FS="\t";r.RS="\n";var t=$m(e,r);if(typeof cptable=="undefined"||r.type=="string")return t;var a=cptable.utils.encode(1200,t,"str");return String.fromCharCode(255)+String.fromCharCode(254)+a}function Qm(e){var r="",t,a="";if(e==null||e["!ref"]==null)return[];var n=gt(e["!ref"]),i="",s=[],f;var l=[];var o=Array.isArray(e);for(f=n.s.c;f<=n.e.c;++f)s[f]=ct(f);for(var c=n.s.r;c<=n.e.r;++c){i=st(c);for(f=n.s.c;f<=n.e.c;++f){r=s[f]+i;t=o?(e[c]||[])[f]:e[r];a="";if(t===undefined)continue;else if(t.F!=null){r=t.F;if(!t.f)continue;a=t.f;if(r.indexOf(":")==-1)r=r+":"+r}if(t.f!=null)a=t.f;else if(t.t=="z")continue;else if(t.t=="n"&&t.v!=null)a=""+t.v;else if(t.t=="b")a=t.v?"TRUE":"FALSE";else if(t.w!==undefined)a="'"+t.w;else if(t.v===undefined)continue;else if(t.t=="s")a="'"+t.v;else a=""+t.v;l[l.length]=r+"="+a}}return l}function Jm(e,r,t){var a=t||{};var n=+!a.skipHeader;var i=e||{};var s=0,f=0;if(i&&a.origin!=null){if(typeof a.origin=="number")s=a.origin;else{var l=typeof a.origin=="string"?vt(a.origin):a.origin;s=l.r;f=l.c}}var o;var c={s:{c:0,r:0},e:{c:f,r:s+r.length-1+n}};if(i["!ref"]){var u=gt(i["!ref"]);c.e.c=Math.max(c.e.c,u.e.c);c.e.r=Math.max(c.e.r,u.e.r);if(s==-1){s=c.e.r+1;c.e.r=s+r.length-1+n}}var h=a.header||[],d=0;r.forEach(function(e,r){K(e).forEach(function(t){if((d=h.indexOf(t))==-1)h[d=h.length]=t;var l=e[t];var c="z";var u="";var v=pt({c:f+d,r:s+r+n});o=eb.sheet_get_cell(i,v);if(l&&typeof l==="object"&&!(l instanceof Date)){i[v]=l}else{if(typeof l=="number")c="n";else if(typeof l=="boolean")c="b";else if(typeof l=="string")c="s";else if(l instanceof Date){c="d";if(!a.cellDates){c="n";l=re(l)}u=a.dateNF||F._table[14]}if(!o)i[v]=o={t:c,v:l};else{o.t=c;o.v=l;delete o.w;delete o.R;if(u)o.z=u}if(u)o.z=u}})});c.e.c=Math.max(c.e.c,f+h.length-1);var v=st(s);if(n)for(d=0;d<h.length;++d)i[ct(d+f)+v]={t:"s",v:h[d]};i["!ref"]=bt(c);return i}function qm(e,r){return Jm(null,e,r)}var eb={encode_col:ct,encode_row:st,encode_cell:pt,encode_range:bt,decode_col:ot,decode_row:it,split_cell:dt,decode_cell:vt,decode_range:mt,format_cell:kt,get_formulae:Qm,make_csv:$m,make_json:jm,make_formulae:Qm,sheet_add_aoa:St,sheet_add_json:Jm,aoa_to_sheet:_t,json_to_sheet:qm,table_to_sheet:Yp,table_to_book:$p,sheet_to_csv:$m,sheet_to_txt:Zm,sheet_to_json:jm,sheet_to_html:Kp.from_sheet,sheet_to_formulae:Qm,sheet_to_row_object_array:jm};(function(e){e.consts=e.consts||{};function r(r){r.forEach(function(r){e.consts[r[0]]=r[1]})}function t(e,r,t){return e[r]!=null?e[r]:e[r]=t}function a(e,r,t){if(typeof r=="string"){if(Array.isArray(e)){var n=vt(r);if(!e[n.r])e[n.r]=[];return e[n.r][n.c]||(e[n.r][n.c]={t:"z"})}return e[r]||(e[r]={t:"z"})}if(typeof r!="number")return a(e,pt(r));return a(e,pt({r:r,c:t||0}))}e.sheet_get_cell=a;function n(e,r){if(typeof r=="number"){if(r>=0&&e.SheetNames.length>r)return r;throw new Error("Cannot find sheet # "+r)}else if(typeof r=="string"){var t=e.SheetNames.indexOf(r);if(t>-1)return t;throw new Error("Cannot find sheet name |"+r+"|")}else throw new Error("Cannot find sheet |"+r+"|")}e.book_new=function(){return{SheetNames:[],Sheets:{}}};e.book_append_sheet=function(e,r,t){if(!t)for(var a=1;a<=65535;++a)if(e.SheetNames.indexOf(t="Sheet"+a)==-1)break;if(!t)throw new Error("Too many worksheets");fv(t);if(e.SheetNames.indexOf(t)>=0)throw new Error("Worksheet with name |"+t+"| already exists!");e.SheetNames.push(t);e.Sheets[t]=r};e.book_set_sheet_visibility=function(e,r,a){t(e,"Workbook",{});t(e.Workbook,"Sheets",[]);var i=n(e,r);t(e.Workbook.Sheets,i,{});switch(a){case 0:;case 1:;case 2:break;default:throw new Error("Bad sheet visibility setting "+a);}e.Workbook.Sheets[i].Hidden=a};r([["SHEET_VISIBLE",0],["SHEET_HIDDEN",1],["SHEET_VERY_HIDDEN",2]]);e.cell_set_number_format=function(e,r){e.z=r;return e};e.cell_set_hyperlink=function(e,r,t){if(!r){delete e.l}else{e.l={Target:r};if(t)e.l.Tooltip=t}return e};e.cell_set_internal_link=function(r,t,a){return e.cell_set_hyperlink(r,"#"+t,a)};e.cell_add_comment=function(e,r,t){if(!e.c)e.c=[];e.c.push({t:r,a:t||"SheetJS"})};e.sheet_set_array_formula=function(e,r,t){var n=typeof r!="string"?r:gt(r);var i=typeof r=="string"?r:bt(r);for(var s=n.s.r;s<=n.e.r;++s)for(var f=n.s.c;f<=n.e.c;++f){var l=a(e,s,f);l.t="n";l.F=i;delete l.v;if(s==n.s.r&&f==n.s.c)l.f=t}return e};return e})(eb);if(w&&typeof require!="undefined")(function(){var r={}.Readable;var t=function(e,t){var a=r();var n=t==null?{}:t;if(e==null||e["!ref"]==null){a.push(null);return a}var i=gt(e["!ref"]);var s=n.FS!==undefined?n.FS:",",f=s.charCodeAt(0);var l=n.RS!==undefined?n.RS:"\n",o=l.charCodeAt(0);var c=new RegExp((s=="|"?"\\|":s)+"+$");var u="",h=[];n.dense=Array.isArray(e);var d=n.skipHidden&&e["!cols"]||[];var v=n.skipHidden&&e["!rows"]||[];for(var p=i.s.c;p<=i.e.c;++p)if(!(d[p]||{}).hidden)h[p]=ct(p);var m=i.s.r;var b=false;a._read=function(){if(!b){b=true;return a.push("\ufeff")}while(m<=i.e.r){++m;if((v[m-1]||{}).hidden)continue;u=Ym(e,i,m-1,h,f,o,s,n);if(u!=null){if(n.strip)u=u.replace(c,"");a.push(u+l);break}}if(m>i.e.r)return a.push(null)};return a};var a=function(e,t){var a=r();var n=t||{};var i=n.header!=null?n.header:Kp.BEGIN;var s=n.footer!=null?n.footer:Kp.END;a.push(i);var f=mt(e["!ref"]);n.dense=Array.isArray(e);a.push(Kp._preamble(e,f,n));var l=f.s.r;var o=false;a._read=function(){if(l>f.e.r){if(!o){o=true;a.push("</table>"+s)}return a.push(null)}while(l<=f.e.r){a.push(Kp._row(e,f,l,n));++l;break}};return a};var n=function(e,t){var a=r({objectMode:true});if(e==null||e["!ref"]==null){a.push(null);return a}var n={t:"n",v:0},i=0,s=1,f=[],l=0,o="";var c={s:{r:0,c:0},e:{r:0,c:0}};var u=t||{};var h=u.range!=null?u.range:e["!ref"];if(u.header===1)i=1;else if(u.header==="A")i=2;else if(Array.isArray(u.header))i=3;switch(typeof h){case"string":c=gt(h);break;case"number":c=gt(e["!ref"]);c.s.r=h;break;default:c=h;}if(i>0)s=0;var d=st(c.s.r);var v=[];var p=0;var m=Array.isArray(e);var b=c.s.r,g=0,w=0;if(m&&!e[b])e[b]=[];for(g=c.s.c;g<=c.e.c;++g){v[g]=ct(g);n=m?e[b][g]:e[v[g]+d];switch(i){case 1:f[g]=g-c.s.c;break;case 2:f[g]=v[g];break;case 3:f[g]=u.header[g-c.s.c];break;default:if(n==null)n={w:"__EMPTY",t:"s"};o=l=kt(n,null,u);p=0;for(w=0;w<f.length;++w)if(f[w]==o)o=l+"_"+ ++p;f[g]=o;}}b=c.s.r+s;a._read=function(){if(b>c.e.r)return a.push(null);while(b<=c.e.r){var r=Gm(e,c,b,v,i,f,m,u);++b;if(r.isempty===false||(i===1?u.blankrows!==false:!!u.blankrows)){a.push(r.row);break}}};return a};e.stream={to_json:n,to_html:a,to_csv:t}})();if(typeof Cp!=="undefined")e.parse_xlscfb=Cp;e.parse_zip=Sm;e.read=Fm;e.readFile=Om;e.readFileSync=Om;e.write=Wm;e.writeFile=Vm;e.writeFileSync=Vm;e.writeFileAsync=Xm;e.utils=eb;e.SSF=F;if(typeof z!=="undefined")e.CFB=z}if(typeof exports!=="undefined")make_xlsx_lib(exports);else if(typeof module!=="undefined"&&module.exports)make_xlsx_lib(module.exports);else if(typeof define==="function"&&define.amd)define("xlsx",[],function(){if(!XLSX.version)make_xlsx_lib(XLSX);return XLSX});else make_xlsx_lib(XLSX);var XLS=XLSX,ODS=XLSX;



/**
 * Objects of this class handle change events from the input of type "file".
 *
 *
 */
class UpLoad {
  constructor() {
    var self = this;
    this.cb = null;

    /**
     * Reset the file input. (inputDiv[0].value = "";)
     * @param {object} inputDiv jQuery element selector
     */
    this.reset = function (inputDiv) {
      inputDiv[0].value = "";
    };

    this.handleFiles = function (files) {
      // Loop through the FileList.
      for (var i = 0, f; (f = files[i]); i++) {
        // Only process image files.
        var fileExtension = f.name.split(".")[1];

        if (
          fileExtension != "txt" &&
          fileExtension != "xls" &&
          fileExtension != "xlsx" &&
          fileExtension != "plt" &&
          fileExtension != "fnc"
        ) {
          continue;
        }

        var reader = new FileReader();

        // Closure to capture the file information.
        reader.onload = (function (theFile) {
          return function (e) {
            //console.log(e)
            if (self.cb)
              self.cb({
                fileName: theFile.name,
                content: e.target.result,
              });
            else
              console.log({
                fileName: theFile.name,
                content: e.target.result,
              });
          };
        })(f);

        //console.log(f)
        // Read in the file.
        if (fileExtension == "xls" || fileExtension == "xlsx") {
          reader.readAsBinaryString(f);
        } else {
          reader.readAsText(f);
        }
      } //
    };

    /**
     * Set the file input element.
     *
     * This method sets the input selector and installs the change event handler. The change event handler is equipped
     * with a {@link FileReader} that executes a callback with an object as argument. The object has two
     * properties: fileName and content.
     * @example
     * {
     *    fileName: "table1.txt",
     *    content: "-10, 100\r\n-8, 64\r\n-6, 36\r\n-4, 16\r\n-2, 4\r\n0, 0\r\n2, 4\r\n4, 16"
     * }
     *
     * Applications must set the callback.
     * @example
     * const upload = new UpLoad();
     * upload.cb = function(fileData){
     *    console.log(fileData.fileName);
     *    console.log(fileData.content);
     * }
     * @param {object} inputDiv jQuery element selector
     */
    this.setInputElement = function (inputDiv) {
      Static.bind("itemAttached", function (e, plotItem, on) {
        //if (plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        if (
          plotItem.rtti > PlotItem.RttiValues.Rtti_PlotMarker &&
          plotItem.rtti < PlotItem.RttiValues.Rtti_PlotShape
        ) {
          if ($("#fileInput").val().includes(plotItem.title()) && !on)
            self.reset($("#fileInput"));
        }
      });
      inputDiv.change(function (evt) {
        //var files = evt.target.files; // FileList object
        self.handleFiles(evt.target.files);
      });
    };
  }
}
;
define("upload", function(){});



/**
 * @classdesc A abstract base class for drawing scales. It can be used to draw linear or logarithmic scales.
 *
 */
class MFile {
  constructor(plot /* , constructors */) {
    //const curveConstructor = constructors.curveConstructor;
    //const markerConstructor = constructors.markerConstructor;
    const Enum = Enumerator.getDefaultEnumNampespace();
    let Upload = new UpLoad();
    let self = this;
    let _plot = null;

    function get_plotData() {
      ////m__plot.setAxisScaleEngine(Axis.AxisId.yLeft, new LinearScaleEngine())
      let data = [];
      let p = {};
      p.bottomScaleEngineType = _plot
        .axisScaleEngine(Axis.AxisId.xBottom)
        .toString();
      p.leftScaleEngineType = _plot
        .axisScaleEngine(Axis.AxisId.yLeft)
        .toString();
      p.topScaleEngineType = _plot.axisScaleEngine(Axis.AxisId.xTop).toString();
      p.rightScaleEngineType = _plot
        .axisScaleEngine(Axis.AxisId.yRight)
        .toString();
      p.title = _plot.title();
      p.titleFont = _plot.titleFont();
      p.footer = _plot.footer();
      p.footerFont = _plot.footerFont();

      p.axisTitleFont = _plot.axisTitleFont(Axis.AxisId.xBottom);
      p.xBottomAxisTitle = _plot.axisTitle(Axis.AxisId.xBottom);
      p.xTopAxisTitle = _plot.axisTitle(Axis.AxisId.xTop);
      p.yLeftAxisTitle = _plot.axisTitle(Axis.AxisId.yLeft);
      p.yRightAxisTitle = _plot.axisTitle(Axis.AxisId.yRight);

      p.autoScale = _plot.axisAutoScale(Axis.AxisId.xBottom);
      if (!p.autoScale) {
        p.xBottomMin = _plot.axisInterval(Axis.AxisId.xBottom).minValue();
        p.xBottomMax = _plot.axisInterval(Axis.AxisId.xBottom).maxValue();
        p.yLeftMin = _plot.axisInterval(Axis.AxisId.yLeft).minValue();
        p.yLeftMax = _plot.axisInterval(Axis.AxisId.yLeft).maxValue();
        p.xTopMin = _plot.axisInterval(Axis.AxisId.xTop).minValue();
        p.xTopMax = _plot.axisInterval(Axis.AxisId.xTop).maxValue();
        p.yRightMin = _plot.axisInterval(Axis.AxisId.yRight).minValue();
        p.yRightMax = _plot.axisInterval(Axis.AxisId.yRight).maxValue();
      }

      data.push(p);

      //Handle Rtti_PlotCurve
      let list = _plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
      for (let i = 0; i < list.length; ++i) {
        /* let d = {};
        d.rtti = PlotItem.RttiValues.Rtti_PlotCurve;
        d.title = list[i].title();

        const fn = list[i].fn;
        if (fn) {
          d.functionDlgData = list[i].functionDlgData;
        } else {
          d.samples = list[i].data().samples();
        }

        d.fn = list[i].fn;

        d.pen = list[i].pen();
        d.fitType = list[i].fitType;
        d.equation = list[i].equation;

        let sym = list[i].symbol();
        d.symbolType = Symbol2.Style.NoSymbol;
        if (sym) {
          d.symbolType = sym.style();
          d.symbolWidth = sym.size().width;
          d.symbolPenColor = sym.pen().color;
          d.symbolPenWidth = sym.pen().width;
          d.symbolBrushColor = sym.brush().color;
        }
        d.style = list[i].style();

        d.xAxis = list[i].xAxis();
        d.yAxis = list[i].yAxis(); */

        data.push(Utility.getPlotCurveData(list[i]));
      }

      //Handle Rtti_PlotMarker
      list = _plot.itemList(PlotItem.RttiValues.Rtti_PlotMarker);
      list = _.filter(list, function (item) {
        return (
          item.rulers === undefined &&
          item.title() !== "ClosestPointMarker123@###" &&
          item.title() !== "cgMarker@12345"
        );
      });
      for (let i = 0; i < list.length; ++i) {
        let d = {};
        d.title = list[i].title();
        d.rtti = PlotItem.RttiValues.Rtti_PlotMarker;
        d.label = list[i].label();
        d.x = list[i].xValue();
        d.y = list[i].yValue();
        d.labelAlignment = list[i].labelAlignment();
        d.labelOrientation = list[i].labelOrientation();
        d.labelFont = list[i].labelFont();
        d.lineStyle = list[i].lineStyle();
        d.linePen = list[i].linePen();

        let sym = list[i].symbol();

        if (sym) {
          d.type = sym.type;
          d.symbolType = sym.style();
          d.symbolWidth = sym.size().width;
          d.symbolHeight = sym.size().height;
          d.symbolPenColor = sym.pen().color;
          d.symbolPenWidth = sym.pen().width;
          d.symbolBrushColor = sym.brush().color;
          d.rotation = sym.rotation && sym.rotation();
        }
        d.xAxis = list[i].xAxis();
        d.yAxis = list[i].yAxis();

        data.push(d);
      }

      //Handle PlotSpectroCurve
      list = _plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve);
      for (let i = 0; i < list.length; ++i) {
        let d = {};
        d.title = list[i].title();
        d.rtti = PlotItem.RttiValues.Rtti_PlotSpectroCurve;

        const fn = list[i].fn;
        if (fn) {
          d.functionDlgData = list[i].functionDlgData;
        } else {
          d.samples = list[i].data().samples();
        }
        d.color1 = list[i].color1();
        d.color2 = list[i].color2();
        d.minZ = list[i].minZ;
        d.maxZ = list[i].maxZ;
        //d.samples = list[i].data().samples();
        d.fn = list[i].fn;
        d.penWidth = list[i].penWidth(); //here

        d.xAxis = list[i].xAxis();
        d.yAxis = list[i].yAxis();

        data.push(d);
      }

      //Handle PlotSpectrogram
      list = _plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram);
      for (let i = 0; i < list.length; ++i) {
        let d = {};
        d.title = list[i].title();
        d.rtti = PlotItem.RttiValues.Rtti_PlotSpectrogram;

        const fn = list[i].fn;
        if (fn) {
          d.functionDlgData = list[i].functionDlgData;
        } else {
          //d.samples = list[i].data().samples();
        }
        d.fn = list[i].fn;

        d.upload = list[i].upload;
        d.spectrogramData = list[i].spectrogramData; //file data
        const colorMap = list[i].colorMap();
        d.color1 = colorMap.color1();
        d.color2 = colorMap.color2();
        d.showContour = list[i].testDisplayMode(
          PlotSpectrogram.DisplayMode.ContourMode
        );
        d.showSpectrogram = list[i].testDisplayMode(
          PlotSpectrogram.DisplayMode.ImageMode
        );
        d.numberOfContourPlanes = list[i].numberOfContourPlanes();
        data.push(d);
      }
      return data;
    }

    this.getPlotData = function () {
      const _data = get_plotData();
      //console.log(2000, _data);
      return JSON.stringify(_data);
    };

    // function saveData(data, fileName) {
    //   let a = document.createElement("a");
    //   document.body.appendChild(a);
    //   a.style = "display: none";
    //   //return function (data, fileName) {
    //   let json = JSON.stringify(data),
    //     blob = new Blob([json], { type: "octet/stream" }),
    //     url = window.URL.createObjectURL(blob);
    //   a.href = url;
    //   a.download = fileName;
    //   a.click();
    //   window.URL.revokeObjectURL(url);
    //   //};
    // }

    function saveData(data, fileName) {
      return new Promise(function (resolve, reject) {
        if (!data || !fileName) {
          return reject("Invalid data and (or) filename");
        }
        let a = document.createElement("a");
        document.body.appendChild(a);
        a.style = "display: none";
        //return function (data, fileName) {
        let json = JSON.stringify(data),
          blob = new Blob([json], { type: "octet/stream" }),
          url = window.URL.createObjectURL(blob);
        a.href = url;
        a.download = fileName;
        a.click();
        window.URL.revokeObjectURL(url);
        resolve(0);
      });
    }

    function plt(data) {
      let obj = JSON.parse(data.content);

      let p = obj[0];
      if (p.rightScaleEngineType == "[LogScaleEngine]") {
        _plot.setAxisScaleEngine(Axis.AxisId.yRight, new LogScaleEngine());
      }
      if (p.leftScaleEngineType == "[LogScaleEngine]") {
        _plot.setAxisScaleEngine(Axis.AxisId.yLeft, new LogScaleEngine());
      }
      if (p.bottomScaleEngineType == "[LogScaleEngine]") {
        _plot.setAxisScaleEngine(Axis.AxisId.xBottom, new LogScaleEngine());
      }
      if (p.topScaleEngineType == "[LogScaleEngine]") {
        _plot.setAxisScaleEngine(Axis.AxisId.xTop, new LogScaleEngine());
      }

      if (p.rightScaleEngineType == "[LinearScaleEngine]") {
        _plot.setAxisScaleEngine(Axis.AxisId.yRight, new LinearScaleEngine());
      }
      if (p.leftScaleEngineType == "[LinearScaleEngine]") {
        _plot.setAxisScaleEngine(Axis.AxisId.yLeft, new LinearScaleEngine());
      }
      if (p.bottomScaleEngineType == "[LinearScaleEngine]") {
        _plot.setAxisScaleEngine(Axis.AxisId.xBottom, new LinearScaleEngine());
      }
      if (p.topScaleEngineType == "[LinearScaleEngine]") {
        _plot.setAxisScaleEngine(Axis.AxisId.xTop, new LinearScaleEngine());
      }

      if (!p.autoScale) {
        _plot.setAxisScale(Axis.AxisId.xBottom, p.xBottomMin, p.xBottomMax);
        _plot.setAxisScale(Axis.AxisId.yLeft, p.yLeftMin, p.yLeftMax);
        _plot.setAxisScale(Axis.AxisId.xTop, p.xTopMin, p.xTopMax);
        _plot.setAxisScale(Axis.AxisId.yRight, p.yRightMin, p.yRightMax);
      } else {
        Utility.setAutoScale(_plot, true);
      }
      //setAutoScale(true)

      _plot.setTitleFont(new Misc.Font(p.titleFont));
      _plot.setFooterFont(new Misc.Font(p.footerFont));
      _plot.setAxisTitleFont(
        Axis.AxisId.xBottom,
        new Misc.Font(p.axisTitleFont)
      );
      _plot.setAxisTitleFont(Axis.AxisId.xTop, new Misc.Font(p.axisTitleFont));
      _plot.setAxisTitleFont(Axis.AxisId.yLeft, new Misc.Font(p.axisTitleFont));
      _plot.setAxisTitleFont(
        Axis.AxisId.yRight,
        new Misc.Font(p.axisTitleFont)
      );

      _plot.setTitle(p.title);
      _plot.setFooter(p.footer);
      _plot.setAxisTitle(Axis.AxisId.xBottom, p.xBottomAxisTitle);
      _plot.setAxisTitle(Axis.AxisId.xTop, p.xTopAxisTitle);
      _plot.setAxisTitle(Axis.AxisId.yLeft, p.yLeftAxisTitle);
      _plot.setAxisTitle(Axis.AxisId.yRight, p.yRightAxisTitle);

      for (let i = 1; i < obj.length; ++i) {
        if (
          obj[i].rtti == PlotItem.RttiValues.Rtti_PlotCurve &&
          _plot.findPlotCurve(obj[i].title)
        ) {
          Utility.alert(obj[i].title + " already exist");
          Upload.reset($("#fileInput"));
          return; //false;
        }
      }

      for (let i = 1; i < obj.length; ++i) {
        //Deal with Rtti_PlotCurve
        if (obj[i].rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
          /*let curve = null;
           if (obj[i].fn) {
            curve = _plot.functionDlgCb(obj[i].functionDlgData);
            //return;
          } else {
            //curve = new curveConstructor(obj[i].title);
            curve = _plot.createCurve(obj[i].rtti, obj[i].title);
            curve.setSamples(Utility.pointsFromXYObjectArray(obj[i].samples));
          }

          if (obj[i].symbolType !== Symbol2.Style.NoSymbol) {
            let sym = new Symbol2();
            sym.setStyle(obj[i].symbolType);
            sym.setSize(new Misc.Size(obj[i].symbolWidth, obj[i].symbolWidth));
            sym.setPen(
              new Misc.Pen(obj[i].symbolPenColor, obj[i].symbolPenWidth)
            );
            sym.setBrush(new Misc.Brush(obj[i].symbolBrushColor));
            curve.setSymbol(sym);
          }

          curve.setStyle(obj[i].style);
          if (obj[i].fitType) {
            curve.fitType = obj[i].fitType;
            curve.equation = obj[i].equation;
          }

          //curve.setSamples(Utility.pointsFromXYObjectArray(obj[i].samples));
          if (obj[i].fitType == "natural" || obj[i].fitType == "periodic") {
            //curve.setData(CurveFitDlg.curve.data())
            let f = new SplineCurveFitter();
            let s = f.spline();
            if (obj[i].fitType == "periodic") {
              s.setSplineType(Static.SplineType.Periodic);
            } else {
              s.setSplineType(Static.SplineType.Natural);
            }
            curve.setCurveFitter(f);
          }

          curve.setPen(
            new Misc.Pen(obj[i].pen.color, obj[i].pen.width, obj[i].pen.style)
          );

          curve.setAxes(obj[i].xAxis, obj[i].yAxis); */

          let curve = Utility.pltPlotCurveData(_plot, obj[i]);
          curve.attach(_plot);
        }

        //Deal with Rtti_PlotSpectroCurve
        if (obj[i].rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve) {
          //console.log("obj[i].color1, obj[i].color2", obj[i].color1, obj[i].color2)
          let curve = null;
          if (obj[i].fn) {
            curve = _plot.functionDlgCb(obj[i].functionDlgData);
          } else {
            //curve = new curveConstructor(obj[i].title);
            curve = _plot.createCurve(obj[i].rtti, obj[i].title);
            curve.setSamples(obj[i].samples);
          }

          //let curve = new SpectroCurve(obj[i].title);
          curve.setPenWidth(obj[i].penWidth);
          //curve.setSamples(obj[i].samples);
          curve.setColorInterval(obj[i].color1, obj[i].color2);
          curve.setColorRange(new Interval(obj[i].minZ, obj[i].maxZ));
          curve.minZ = obj[i].minZ;
          curve.maxZ = obj[i].maxZ;

          //curve.attach(_plot);
        }

        //Deal with Rtti_PlotSpectrogram
        if (obj[i].rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram) {
          let curve = null;
          if (obj[i].fn) {
            curve = _plot.functionDlgCb(obj[i].functionDlgData);
            curve.setNumberOfContourPlanes(obj[i].numberOfContourPlanes);
            curve.showContour(obj[i].showContour);
            curve.showSpectrogram(obj[i].showSpectrogram);
          } else {
            const displayData = {
              title: obj[i].title,
              color1: obj[i].color1,
              color2: obj[i].color2,
              showContour: obj[i].showContour,
              showSpectrogram: obj[i].showSpectrogram,
              numberOfContourPlanes: obj[i].numberOfContourPlanes,
            };
            _plot.uploadSpectrogram(
              displayData,
              obj[i].spectrogramData,
              obj[i].upload
            );
          }
          curve.attach(_plot);
        }

        //Deal with PlotItem.RttiValues.Rtti_PlotMarker
        if (obj[i].rtti == PlotItem.RttiValues.Rtti_PlotMarker) {
          //let marker = new markerConstructor(obj[i].title);
          let marker = _plot.createCurve(obj[i].rtti, obj[i].title);
          if (obj[i].symbolType !== Symbol2.Style.NoSymbol) {
            let sym = null;
            if (obj[i].type && obj[i].type === "arrow") sym = new ArrowSymbol();
            else if (obj[i].type && obj[i].type === "dotOnLine")
              sym = new DotOnLineSymbol();

            if (sym) {
              sym.setSize(
                new Misc.Size(obj[i].symbolWidth, obj[i].symbolHeight)
              );
              if (sym.setRotation) {
                sym.setRotation(obj[i].rotation);
              }
              sym.setPen(
                new Misc.Pen(obj[i].symbolPenColor, obj[i].symbolPenWidth)
              );
              sym.setBrush(new Misc.Brush(obj[i].symbolBrushColor));
              marker.setSymbol(sym);
            }

            marker.setLineStyle(obj[i].lineStyle);
            marker.setLinePen(
              new Misc.Pen(
                obj[i].linePen.color,
                obj[i].linePen.width,
                obj[i].linePen.style
              )
            );
            marker.setAxes(obj[i].xAxis, obj[i].yAxis);
            marker.setValue(obj[i].x, obj[i].y);
            marker.setLabel(obj[i].label);
            marker.setLabelAlignment(obj[i].labelAlignment);
            marker.setLabelOrientation(obj[i].labelOrientation); //Misc.Font = function (th, name, style, weight,fontColor)
            marker.setLabelFont(
              new Misc.Font(
                obj[i].labelFont.th,
                obj[i].labelFont.name,
                obj[i].labelFont.style,
                obj[i].labelFont.weight,
                obj[i].labelFont.fontColor
              )
            );
            marker.attach(_plot);
            //
          }
        }
      }

      Upload.reset($("#fileInput"));
    }

    this.setPlotData = function (data) {
      //console.log(1000, data)
      //plt(data);
      this.upload(data);
    };

    this.init = function (plot) {
      // self = this
      _plot = plot;
      Upload.cb = this.upload;
    };

    this.setInputElement = function (el) {
      Upload.setInputElement(el);
    };

    ////////////////////////////////////////////////////////////////////////////////
    const centralDiv = plot.getLayout().getCentralDiv();

    Utility.dragAndDropFiles(centralDiv, Upload.handleFiles);

    ///////////////////////////////////////////////////////////

    this.upload = function (data) {
      let extension = data.fileName.split(".")[1];
      //console.log(extension)
      if (
        extension == "xls" ||
        extension == "xlsx" ||
        extension == "txt" ||
        extension == "tbl"
      ) {
        //csv
        let samples = null;
        let csvArray = null;
        if (extension == "xls" || extension == "xlsx") {
          let workbook = XLSX.read(data.content, {
            type: "binary",
          });
          //Fetch the name of First Sheet.
          let firstSheet = workbook.SheetNames[0];

          /* XLSX.utils.sheet_to_csv generates CSV
          XLSX.utils.sheet_to_json generates an array of objects
          XLSX.utils.sheet_to_formulae generates a list of formulae */
          csvArray = Utility.toArrays(
            XLSX.utils.sheet_to_csv(workbook.Sheets[firstSheet])
          );
        } else {
          csvArray = Utility.toArrays(data.content);
        }

        if (!csvArray.dataType) {
          //data type not specified. Try to determine type from data traits
          if (csvArray.array.length && csvArray.array[0].hasOwnProperty("z")) {
            //3d data
            // let tempArray = [];
            // for (let i = 0; i < csvArray.array.length; i++) {
            //   tempArray.push(csvArray.array[i].x);
            // }
            let tempArray = csvArray.array.map(function (pt) {
              return pt.x;
            });

            if (tempArray.length === _.uniq(tempArray).length) {
              csvArray.dataType = "spectrocurve";
            } else {
              csvArray.dataType = "spectrogram";
            }
          } else {
            //2 d
            csvArray.dataType = "curve";
          }
        }

        if (csvArray.dataType === "curve") {
          //2 d
          let samples = Utility.makePoints(csvArray.array);
          Static.trigger("addCurve", [data.fileName, samples, true]);
        } else if (csvArray.dataType === "spectrocurve") {
          //3 d
          //let samples = Utility.makeSpectrocurvePoints(csvArray.array);
          Static.trigger("addSpectrocurve", [data.fileName, csvArray, true]);
        } else if (csvArray.dataType === "spectrogram") {
          //3 d
          //let samples = Utility.toArrays(csvArray.array);"#008b8b", "#ff0000"
          Static.trigger("addSpectrogram", [data.fileName, csvArray, true]);
        }
      } else if (extension == "plt") {
        //console.log(100, _plot.rightSidebar)
        let sideBarHidden = false;
        if (_plot.rightSidebar.isSideBarVisible()) {
          _plot.rightSidebar.showSidebar(false);
          //_plot.sidebar.setSidebarReDisplay(true);
          sideBarHidden = true;
        }

        let list = _plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
        let list2 = _plot.itemList(PlotItem.RttiValues.Rtti_PlotMarker);
        let list3 = _plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve);
        let list4 = _plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram);
        list2 = _.filter(list2, function (item) {
          return (
            item.rulers === undefined &&
            item.title() !== "ClosestPointMarker123@###" &&
            item.title() !== "cgMarker@12345"
          );
        });
        list = list.concat(list2);
        list = list.concat(list3);
        list = list.concat(list4);
        if (list.length) {
          Utility.alertYesNo(
            "Do you want to save the changes to the Grapher?",
            function (answer) {
              if (answer == Cancel) {
                Upload.reset($("#fileInput"));
                if (sideBarHidden) {
                  _plot.rightSidebar.showSidebar(true);

                  //_plot.sidebar.setSidebarReDisplay(true);
                }
                return;
              }
              if (answer == Yes) {
                function saveCb() {
                  Upload.reset($("#fileInput"));
                  for (let i = 0; i < list.length; ++i) {
                    list[i].detach();
                    list[i].delete();
                  }
                  plt(data);
                }
                self.save(saveCb);
                // Upload.reset($("#fileInput"));
                // for (let i = 0; i < list.length; ++i) {
                //   list[i].detach();
                //   list[i].delete();
                // }
                // plt(data);

                return;
              }
              if (answer == No) {
                for (let i = 0; i < list.length; ++i) {
                  list[i].detach();
                  list[i].delete();
                }
                plt(data);
                if (sideBarHidden) {
                  _plot.rightSidebar.showSidebar(true);

                  //_plot.sidebar.setSidebarReDisplay(true);
                }

                return;
              }
            }
          );
        } else {
          plt(data);
        }
      } else if (extension == "fnc") {
        let _fndefs = data.content.replace(/\r\n/g, "%").replace(/\s/g, "");
        _fndefs = _fndefs.split("%");
        let fndefs = [];
        for (let i = 0; i < _fndefs.length; i++) {
          if (_fndefs[i].length) fndefs.push(_fndefs[i]);
        }

        let samples = [];
        let curve = null;
        //let title = "";
        let domainRight = undefined;
        const merge = fndefs[0].trim() == "merge";
        //let i = 0;
        if (merge) {
          fndefs.shift();
          fndefs.sort(function (a, b) {
            let domainA = a
              .split("[")[1]
              .replace("]", "")
              .split(",")
              .map(function (val) {
                return parseFloat(val);
              });
            let domainB = b
              .split("[")[1]
              .replace("]", "")
              .split(",")
              .map(function (val) {
                return parseFloat(val);
              });
            return domainA[0] - domainB[0];
          });
        }
        for (let i = 0; i < fndefs.length; i++) {
          const arr = fndefs[i].split("=")[1];
          const variables = fndefs[i]
            .split("=")[0]
            .split("(")[1]
            .replace(")", "")
            .split(",")
            .map(function (v) {
              return v.trim();
            });
          let eq = arr.split("[")[0].trim();
          let domain = arr
            .split("[")[1]
            .replace("]", "")
            .split(",")
            .map(function (val) {
              return parseFloat(val);
            });

          if (domainRight) {
            if (domain[0] < domainRight) {
              domain[0] = domainRight;
            }
          }
          domainRight = domain[1];

          /*
     functionDlgData=
      {
        rtti: PlotItem.RttiValues.Rtti_PlotCurve,
        lowerLimit: undefined, //Number
        upperLimit: undefined, //Number
        threeD: false
        title: null, //String
        variable: null, //String
        fn: null, //String
        expandedFn: null, //String
        numOfPoints: undefined, //Number
        unboundedRange: false, //Boolean
        coeffs: null, //Array
        threeDType: null, //String e.g. "spectrocurve"
        threeDInterpolationType: null, //String e.g. "bilinear"
        lowerLimitY: undefined, //Number
        upperLimitY: undefined, //Number
        lowerLimitFxy: undefined, //Number
        upperLimitFxy: undefined, //Number
        variableY: null, //String
        color1: "#008b8b", //String
        color2: "#ff0000" //String
      }
      */
          const functionDlgData = {
            rtti: PlotItem.RttiValues.Rtti_PlotCurve,
            lowerLimit: domain[0], //Number
            upperLimit: domain[1], //Number
            threeD: false,
            title: Utility.generateCurveName(_plot), //eq + domain[0], //String
            variable: variables[0], //String
            fn: eq, //String
            expandedFn: eq, //String
            numOfPoints: undefined, //Number
            unboundedRange: false, //Boolean
            coeffs: null, //Array
            threeDType: null, //String e.g. "spectrocurve"
            threeDInterpolationType: null, //String e.g. "bilinear"
            lowerLimitY: undefined, //Number
            upperLimitY: undefined, //Number
            lowerLimitFxy: undefined, //Number
            upperLimitFxy: undefined, //Number
            variableY: variables[1], //String
            color1: "#008b8b", //String
            color2: "#ff0000", //String
          };

          if (merge) {
            functionDlgData.numOfPoints = Math.round(100 / (fndefs.length - 1));
          }

          curve = _plot.functionDlgCb(functionDlgData);
          if (merge) {
            samples = samples.concat(curve.data().samples());
            continue;
          } else {
            curve.attach(_plot);
          }
        }
        if (merge) {
          curve.setSamples(samples);
          curve.fn = curve.expandedFn = undefined;
          curve.attach(_plot);
        }
        Upload.reset($("#fileInput"));
      }
    };

    this.save = function (cb) {
      Utility.prompt(
        "Enter a filename without extensions",
        "plot_1",
        async function (filename) {
          filename += ".plt";
          //console.log(filename)
          //let textFile = new Blob(['Hello Sir'],{type: 'text/plain'})

          let data = get_plotData();
          //console.log(data)
          try {
            await saveData(data, filename);
            if (cb) cb();
          } catch (err) {
            throw err;
          }

          return true;
        },
        "small"
      );
    };

    this.init(plot);
  } //,,,,
}
;
define("file", ["xlsx","upload"], function(){});



"include []";

//function Watch(rulerGroup, dependentRuler){
class Watch {
  constructor(rulerGroup, dependentRuler) {
    var self = this;
    this._dependentRuler = dependentRuler || MPicker.DisplayChange.NoRuler;
    this._rulerGroup = rulerGroup;
    var _enable = true;
    this._curveName = "";
    this._curve = null;
    this._rulerLeft = Number.MAX_VALUE;
    this._rulerRight = Number.MAX_VALUE;
    this._rulerBottom = Number.MAX_VALUE;
    this._rulerTop = Number.MAX_VALUE;
    this._value; //undefined
    this._magnifying = false;

    this._update = false;

    this._rulerLeftPrevious = Number.MAX_VALUE;
    this._rulerRightPrevious = Number.MAX_VALUE;

    //Forces re-computation of watches without a ruler position change.
    Static.bind("invalidateWatch", function () {
      self._rulerLeftPrevious = Number.MAX_VALUE;
      self._rulerRightPrevious = Number.MAX_VALUE;
    });

    // Static.bind("magnifyingStart", function () {
    //     //console.log("magnifyingStart");
    //     self._magnifying = true;
    // })

    Static.bind("magnifyingStart", function () {
      //console.log("magnifyingStart");
      self._magnifying = true;
    });

    // Static.bind("magnifyingEnd", function () {
    //     //console.log("magnifyingEnd");
    //     self._magnifying = false;
    //     Static.trigger("positionChanged");
    // })

    Static.bind("magnifyingEnd", function () {
      //console.log("magnifyingEnd");
      self._magnifying = false;
      Static.trigger("positionChanged");
    });

    //subclass reimplement
    this.name = function () {};
    //subclass reimplement
    this.computeWatch = function () {};
    this.value = function () {
      return this._value;
    };

    this.setCurveName = function (curveName) {
      this._curveName = curveName;
    };
    this.setCurve = function (curve) {
      this._curve = curve;
    };
    this.setRulerLeft = function (val) {
      this._rulerLeft = val;
    };
    this.setRulerRight = function (val) {
      this._rulerRight = val;
    };
    this.setRulerBottom = function (val) {
      if (this._curve && this._curve.plot())
        val = Utility.adjustForDecimalPlaces(
          val,
          this._curve.plot().axisDecimalPlaces(this._curve.yAxis())
        );
      this._rulerBottom = val;
    };
    this.setRulerTop = function (val) {
      if (this._curve && this._curve.plot())
        val = Utility.adjustForDecimalPlaces(
          val,
          this._curve.plot().axisDecimalPlaces(this._curve.yAxis())
        );
      this._rulerTop = val;
    };

    this.setEnable = function (set) {
      _enable = set;
      Static.trigger("watchEnabled", [this, set]);
    };
    this.isEnable = function () {
      return _enable;
    };
    Utility.enableIntegrate();
  }
}

/*class WatchCurveName : public Watch
{
public:
    WatchCurveName():Watch(NO_RULER)
    {

    }
    QString name()const
    {
        return "Curve Name";
    }

    void computeWatch()
    {
        _value = _curveName;
    }


protected:


};

class WatchLeftRulerPosition : public Watch
{
public:
    WatchLeftRulerPosition():Watch(LEFT)
    {

    }
    QString name()const
    {
        return "Left Ruler Position";
    }

    void computeWatch()
    {
        if(_rulerLeft == DBL_MAX)
            _value = "Invalid";
        else
            _value = QString::number(_rulerLeft);
    }
protected:


};

class WatchRightRulerPosition : public Watch
{
public:
    WatchRightRulerPosition():Watch(RIGHT)
    {

    }
    QString name()const
    {
        return "Right Ruler Position";
    }

    void computeWatch()
    {
        if(_rulerRight == DBL_MAX)
            _value = "Invalid";
        else
            _value = QString::number(_rulerRight);
    }
protected:


};

class WatchBottomRulerPosition : public Watch
{
public:
    WatchBottomRulerPosition():Watch(BOTTOM)
    {

    }
    QString name()const
    {
        return "Bottom Ruler Position";
    }

    void computeWatch()
    {
        if(_rulerBottom == DBL_MAX)
            _value = "Invalid";
        else
            _value = QString::number(_rulerBottom);
    }
protected:


};

class WatchTopRulerPosition : public Watch
{
public:
    WatchTopRulerPosition():Watch(TOP)
    {

    }
    QString name()const
    {
        return "Top Ruler Position";
    }

    void computeWatch()
    {
        if(_rulerTop == DBL_MAX)
            _value = "Invalid";
        else
            _value = QString::number(_rulerTop);
    }
protected:


};



#endif // WATCH_H
*/
;
define("watch", function(){});



/**
 * Base class for items on the plot canvas.
 *
 * A plot item is "something", that can be painted on the plot canvas, or only affects the scales of the plot widget. They can be categorized as:
 *
 * <dl><dt>Representator<br>A "Representator" is an item that represents some sort of data on the plot canvas. The different representator classes are organized according to the characteristics of the data:
 * <ul><li>QwtPlotMarker Represents a point or a horizontal/vertical coordinate</li>
 * <li>QwtPlotCurve Represents a series of points</li>
 * <li>QwtPlotSpectrogram ( QwtPlotRasterItem ) Represents raster data</li>
 * <li>...</li></ul></dt>
 * <dt><br>Decorators<br>A "Decorator" is an item, that displays additional information, that is not related to any data:
 * <ul><li>QwtPlotGrid</li>
 * <li>QwtPlotScaleItem</li>
 * <li>QwtPlotSvgItem</li>
 * <li>...</li></ul></dt></dl>
 *
 * Depending on the{@link PlotItem.ItemAttribute}flags, an item is included into autoscaling or has an entry on the legend.
 * Before misusing the existing item classes it might be better to implement a new type of plot item ( don't implement a
 * watermark as spectrogram ). Deriving a new type of QwtPlotItem primarily means to implement the YourPlotItem::draw() method.
 *
 */
class PlotItem {
  /**
   *
   * @param {String} tle Title of the plotitem
   */
  constructor(tle) {
    var self = this;
    this.plotId = "";
    var _context = null;
    var _plot = null;
    var cnvs = null;
    var d_interests;

    var m_domDiv = $("#centralDiv");

    var m_isVisible = true;
    var m_attributes = 0x0;
    //interests( 0 ),
    //renderHints( 0 ),
    //renderThreadCount( 1 ),
    var m_z = 0.0;
    var m_xAxis = Axis.AxisId.xBottom;
    var m_yAxis = Axis.AxisId.yLeft;
    var m_title = tle || "";

    this.rtti = PlotItem.RttiValues.Rtti_PlotItem;

    var m_legendIconSize = new Misc.Size(10, 10);

    /**
     *
     * @returns {Misc.Size} Legeng icon size
     * @see {@link PlotItem#setLegendIconSize setLegendIconSize()}
     * @see {@link PlotItem#legendIcon legendIcon()}
     */
    this.getLegendIconSize = function () {
      return m_legendIconSize;
    };

    /**
     * Set the size of the legend icon
     * @param {Misc.Size} size Size
     * @see {@link PlotItem#getLegendIconSize getLegendIconSize()}
     * @see {@link PlotItem#legendIcon legendIcon()}
     */
    this.setLegendIconSize = function (size) {
      m_legendIconSize = size;
      //legendChanged();
      if (_plot) _plot.updateLegend(this);
    };

    /**
     * Toggle an item interest
     * @param {PlotItem.ItemInterest} interest Interest type
     * @param {Boolean} on true/false
     * @see {@link PlotItem#testItemInterest testItemInterest()}
     * @see {@link PlotItem.ItemAttribute ItemAttribute}
     */
    this.setItemInterest = function (interest, on) {
      //if ( d_interests.testFlag( interest ) != on )
      {
        if (on) d_interests |= interest;
        else d_interests &= ~interest;

        this.itemChanged();
      }
    };

    /**
     * Test an item interest
     * @param {PlotItem.ItemInterest} interest Interest type
     * @returns {Boolean} true/false
     * @see {@link PlotItem#setItemInterest setItemInterest()}
     * @see {@link PlotItem.ItemAttribute ItemAttribute}
     */
    this.testItemInterest = function (interest) {
      //return d_interests.testFlag( interest );
      return d_interests & interest;
    };

    /**
     *
     * @returns {Plot} Return attached plot.
     */
    this.plot = function () {
      return _plot;
    };

    /**
     *
     * @returns {String} Title of the item
     * @see {@link PlotItem#setTitle setTitle()}
     */
    this.title = function () {
      return m_title;
    };

    /**
     * Set a new title
     * @param {String} tle Title
     * @see {@link PlotItem#title title()}
     */
    this.setTitle = function (tle) {
      if (m_title !== tle) {
        m_title = tle;
        this.legendChanged();
        this.itemChanged();
        Static.trigger("titleChange", [this, tle]);
      }
    };

    /**
     * Clears the canvas for the central div (i.e. the div in which plotitems are drawn)
     */
    this.clearCanvas = function () {
      this.getContext().clearRect(0, 0, cnvs[0].width, cnvs[0].height);
    };

    /**
     * Attach the item to a plot.
     *
     * This method will attach a PlotItem to the Plot argument. It will first detach the PlotItem
     * from any plot from a previous call to attach (if necessary). If a null argument is passed, it will
     * detach from any Plot it was attached to.
     * @param {Plot} plot Plot widget
     * @see {@link PlotItem#detach detach()}
     */
    this.attach = function (plot) {
      if (plot == _plot) {
        //Cannot attach the same plot more than once
        return;
      }

      if (_plot) {
        _plot.attachItem(this, false);
      }

      _plot = plot;

      if (_plot) {
        //if (cnvs === null) {
        cnvs = $("<canvas />").attr({
          style: "position: absolute; background-color: transparent",
        });
        //console.log("canvas created")
        _plot.getLayout().getCentralDiv().append(cnvs);
        cnvs.css({
          "border-radius": "inherit",
        });

        if (m_z != 0) {
          cnvs.css("zIndex", m_z);
        }
        //}
        _plot.attachItem(this, true);
      }
    };

    /**
     * This method detaches a PlotItem from any Plot it has been associated with.
     * detach() is equivalent to calling attach( null )
     * @see {@link PlotItem#attach attach()}
     */
    this.detach = function () {
      this.attach(null);
    };

    /**
     *
     * @param {Number} z Z order
     */
    this.setZ = function (z) {
      if (m_z !== z) {
        m_z = z;
        if (cnvs) {
          cnvs.css("zIndex", m_z);
        }
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Number} Z order
     */
    this.getZ = function (z) {
      return m_z;
    };

    /**
     *
     * @returns {object} Canvas for the central div (i.e. the div in which plotitems are drawn)
     */
    this.getCanvas = function () {
      return cnvs;
    };

    function syncSizes() {
      if (_plot) {
        var cd = _plot.getLayout().getCentralDiv();
        cnvs[0].width = parseFloat(cd.css("width"));
        cnvs[0].height = parseFloat(cd.css("height"));
      }
    }

    /**
     *
     * @returns {object} 2d context for the central div canvas
     */
    this.getContext = function () {
      syncSizes();
      if (!cnvs) return null;
      return cnvs[0].getContext("2d");
    };

    //Helper
    this._setAxes = function (xAxis, yAxis) {
      if (xAxis == m_xAxis && yAxis == m_yAxis) return;
      if (xAxis == Axis.AxisId.xBottom || xAxis == Axis.AxisId.xTop)
        m_xAxis = xAxis;

      if (yAxis == Axis.AxisId.yLeft || yAxis == Axis.AxisId.yRight)
        m_yAxis = yAxis;

      this.itemChanged();
    };

    /**
     * Toggle an item attribute
     * @param {PlotItem.ItemAttribute} attribute Attribute type
     * @param {*} on true/false
     * @see {@link PlotItem#testItemAttribute testItemAttribute()}
     */
    this.setItemAttribute = function (attribute, on) {
      if (on) m_attributes |= attribute;
      else m_attributes &= ~attribute;
      if (attribute == PlotItem.ItemAttribute.Legend) this.legendChanged();

      this.itemChanged();
    };

    /**
     * Test an item attribute
     * @param {PlotItem.ItemAttribute} attribute Attribute type
     * @returns {Boolean} true/false
     * @see {@link PlotItem#setItemAttribute setItemAttribute()}
     *
     */
    this.testItemAttribute = function (attribute) {
      return m_attributes & attribute;
    };

    /**
     * Show the item
     */
    this.show = function () {
      this.setVisible(true);
    };

    /**
     * Hide the item.
     */
    this.hide = function () {
      this.setVisible(false);
    };

    //Helper
    this.doSetVisible = function (on) {
      if (on !== m_isVisible) {
        m_isVisible = on;
        if (!on) cnvs.hide();
        else cnvs.show();
        this.itemChanged();
        Static.trigger("visibilityChange", [this, on]);
      }
    };

    /**
     *
     * @returns {Boolean} true if visible
     * @see {@link PlotItem#setVisible setVisible()}
     * @see {@link PlotItem#show show()}
     * @see {@link PlotItem#hide hide()}
     */
    this.isVisible = function () {
      return m_isVisible;
    };

    /**
     * Update the legend and call Plot.autoRefresh() for the parent plot.
     * @see {@link PlotItem#legendChanged legendChanged()}
     * @see {@link Plot#autoRefresh autoRefresh()}
     */
    this.itemChanged = function () {
      if (_plot) _plot.autoRefresh();
    };

    /**
     * Update the legend of the parent plot.
     * @see {@link Plot#updateLegend updateLegend()}
     */
    this.legendChanged = function () {
      if (this.testItemAttribute(PlotItem.ItemAttribute.Legend) && _plot)
        _plot.updateLegend(this);
    };

    //Helper
    this._setXAxis = function (axis) {
      if (m_xAxis == axis) return;
      if (axis == Axis.AxisId.xBottom || axis == Axis.AxisId.xTop) {
        m_xAxis = axis;
        this.itemChanged();
      }
      /*if(_plot)
            _plot.autoRefresh()*/
    };

    //Helper
    this._setYAxis = function (axis) {
      if (m_yAxis == axis) return;
      if (axis == Axis.AxisId.yLeft || axis == Axis.AxisId.yRight) {
        m_yAxis = axis;
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Axis.AxisId} Return xAxis
     */
    this.xAxis = function () {
      return m_xAxis;
    };

    /**
     *
     * @returns {Axis.AxisId} Return yAxis
     */
    this.yAxis = function () {
      return m_yAxis;
    };

    /**
     *
     * @returns {Misc.Rect} Rectangle of the central div element. (i.e. the div where plotitems are drawn)
     */
    this.getCanvasRect = function () {
      syncSizes();
      return new Misc.Rect(new Misc.Point(), cnvs[0].width, cnvs[0].height);
    };

    /**
     *
     * @returns {Misc.Size} Legend icon size
     * @see {@link PlotItem#setLegendIconSize setLegendIconSize()}
     * @see {@link PlotItem#legendIcon legendIcon()}
     */
    this.legendIconSize = function () {
      return this.getLegendIconSize();
    };

    /**
     * The default implementation returns an invalid icon
     * @param {Number} index Index of the legend entry
     * @param {Misc.Size} size Icon size
     * @returns {Graphic} Icon representing the item on the legend
     * @see {@link PlotItem#setLegendIconSize setLegendIconSize()}
     * @see {@link PlotItem#legendData legendData()}
     */
    this.legendIcon = function (index, size) {
      return null;
    };

    // /**
    //  * Return a default icon from a brush.
    //  * The default icon is a filled rectangle used in several derived classes as legendIcon().
    //  * @param {Misc.Brush} brush Fill brush
    //  * @param {Misc.Size} size Icon size
    //  * @returns {object} A filled rectangle
    //  */
    // this.defaultIcon = function (brush, size) {
    //   var icon = null;
    //   if (size.width > 0 && size.height > 0) {
    //     //icon.setDefaultSize( size );

    //     var r = new Misc.Rect(0, 0, size.width, size.height);
    //     icon = new GraphicUtil.Graphic(null, size.width + 1, size.height + 1);
    //     var painter = new GraphicPainter(icon);
    //     painter.fillRect(r, brush);
    //   }

    //   return icon;
    // };

    /**
     * Return all information, that is needed to represent the item on the legend.
     * Most items are represented by one entry on the legend showing an icon and a text. LegendData is basically an Array that can contain any type. It is possible to overload
     * and reimplement legendData() to return almost any type of information, that is understood by the receiver that acts as the legend.
     * The default implementation returns one entry with the title() of the item and the legendIcon().
     * @returns {LegendData} Data needed to represent the item on the legend
     * @see {@link PlotItem#title title()}
     * @see {@link PlotItem#legendIcon legendIcon()}
     * @see {@link Legend}
     */
    this.legendData = function () {
      var data = new LegendData();

      var titleValue = this.title();

      //QVariant titleValue;
      //qVariantSetValue( titleValue, label );
      data.setValue(LegendData.Role.TitleRole, titleValue);
      //alert(this.legendIconSize())
      var iconValue = this.legendIcon(0, this.legendIconSize());
      if (iconValue) {
        //QVariant iconValue;
        //qVariantSetValue( iconValue, graphic );
        data.setValue(LegendData.Role.IconRole, iconValue);
      }

      //var list =[];
      //list.push(data);
      return [data];
    };
  }

  /**
   *
   * @returns {String} A string representation of the object.
   */
  toString() {
    return '[PlotItem "' + this.plotId + '"]';
  }

  /**
   * A width or height < 0.0 is ignored by the autoscaler
   * @returns {Misc.Rect} An invalid bounding rect: Misc.Rect()
   */
  boundingRect() {
    return new Misc.Rect(); //1.0, 1.0, -2.0, -2.0); //{ left:1.0, top:1.0, right:-2.0, bottom:-2.0 , width:-3.0, height: -3.0}; // invalid
  }

  /**
   * Show/Hide the item
   * @param {Boolean} on Show if true, otherwise hide
   * @see {@link PlotItem#isVisible isVisible()}
   * @see {@link PlotItem#show show()}
   * @see {@link PlotItem#hide hide()}
   */
  setVisible(on) {
    this.doSetVisible(on);
  }

  /**
   * Set the X axis
   *
   * The item will painted according to the coordinates its Axes.
   * @param {Axis.AxisId} axis X Axis ( Axis.AxisId.xBottom or Axis.AxisId.xTop )
   * @see {@link PlotItem#setAxes setAxes()}
   * @see {@link PlotItem#setYAxis setYAxis()}
   * @see {@link PlotItem#xAxis xAxis()}
   */
  setXAxis(axis) {
    this._setXAxis(axis);
  }

  /**
   * Set the Y axis
   *
   * The item will painted according to the coordinates its Axes.
   * @param {Axis.AxisId} axis Y Axis ( Axis.AxisId.yLeft or Axis.AxisId.yRight )
   * @see {@link PlotItem#setAxes setAxes()}
   * @see {@link PlotItem#setXAxis setXAxis()}
   * @see {@link PlotItem#yAxis yAxis()}
   */
  setYAxis(axis) {
    this._setYAxis(axis);
  }

  /**
   * Set X and Y axis
   *
   * The item will painted according to the coordinates of its Axes.
   * @param {Axis.AxisId} xAxis X Axis ( Axis.AxisId.xBottom or Axis.AxisId.xTop )
   * @param {Axis.AxisId} yAxis Y Axis ( Axis.AxisId.yLeft or Axis.AxisId.yRight )
   * @see {@link PlotItem#setXAxis setXAxis()}
   * @see {@link PlotItem#setYAxis setYAxis()}
   * @see {@link PlotItem#xAxis xAxis()}
   * @see {@link PlotItem#yAxis yAxis()}
   */
  setAxes(xAxis, yAxis) {
    this._setAxes(xAxis, yAxis);
  }

  /**
   * Draw the item.
   * @param {ScaleMap} xMap Maps x-values into pixel coordinates.
   * @param {ScaleMap} yMap Maps y-values into pixel coordinates.
   */
  draw(xMap, yMap) {
    console.log("No drawing mehod define in subclass");
  }

  /**
   * Subclasses of PlotItem must implement this method and do all required clean-up work prior to item destruction. See example.
   *
   * This method is not called automatically. You must call this method explicitly.
   *
   * If no clean-up work is required, you can rely on the base method, `PlotItem#delete()`, which does nothing.
   * @example
   *
   * class MyPlotItem extends PlotItem{
   *    constructor(){
   *       super();
   *       ...
   *       const cb = function () {
   *          //Doing something on myCustomEvent
   *       };
   *
   *       Static.bind("myCustomEvent", cb);
   *
   *       //Do all your clean-up here
   *       this.cleanUp = function(){
   *           Static.bind("myCustomEvent", cb);
   *       }
   *    }
   *
   *    //Implement the destroy method to remove the handler.
   *    delete() {
   *        this.cleanUp();
   *        super.delete();
   *    }
   * }
   *
   * const plot new Plot();
   * ...
   * const myPlotItem = new MyPlotItem(); //creates an instance that binds `myCustomEvent` to a callback `cb`
   * myPlotItem.attach(plot);
   * ...
   * myPlotItem.detach();
   * myPlotItem.delete();
   *
   */
  delete() {}

  /**
   * Use this method to do all required clean-up work prior to destruction of an array of objects. See example
   * @param {Array<object>} arr Array of objects
   * @example
   *
   * class MyHObject extends HObject{
   *    constructor(){
   *        super();
   *        ...
   *        const cb = function () {
   *          //Doing something on myCustomEvent
   *       };
   *
   *       Static.bind("myCustomEvent", cb);
   *
   *       //Do all your clean-up here
   *       this.cleanUp = function(){
   *           Static.unbind("myCustomEvent", cb);
   *       }
   *    }
   *    //Implement the destroy method to remove the handler.
   *    delete() {
   *        this.cleanUp();
   *        super.delete(); //Call the base class
   *    }
   * }
   *
   * class MyPlotItem extends PlotItem{
   *    constructor(){
   *       super();
   *       ...
   *       let listOfHObjects = [];
   *       for(let i=0; i<4; i++){
   *           listOfHObjects.push(new MyHObject());
   *       }
   *       ...
   *       //Do all your clean-up here
   *       this.cleanUp = function(){
   *           this.deleteArray(listOfHObjects);
   *       }
   *    }
   *
   *    //Implement the destroy method to remove the handler.
   *    delete() {
   *        this.cleanUp();
   *        super.delete();
   *    }
   * }
   *
   * const myPlotItem = new MyPlotItem();
   *
   * myPlotItem.delete();
   *
   *
   */
  deleteArray(arr) {
    arr.forEach((element) => {
      element.delete();
    });
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link PlotItem.RttiValues}</div>
 *
 * Runtime type information.
 * RttiValues is used to cast plot items, without having to enable runtime type information of the compiler
 * @name PlotItem.RttiValues
 * @readonly
 * @property {Number} Rtti_PlotItem                 Unspecific value, that can be used, when it doesn't matter.
 * @property {Number} Rtti_PlotGrid                 For PlotGrid.
 * @property {Number} Rtti_PlotScale                For PlotScaleItem.
 * @property {Number} Rtti_PlotLegend               For LegendItem.
 * @property {Number} Rtti_PlotMarker               For PlotMarker.
 * @property {Number} Rtti_PlotCurve                For Curve.
 * @property {Number} Rtti_PlotSpectroCurve         For SpectroCurve.
 * @property {Number} Rtti_PlotIntervalCurve        For IntervalCurve.
 * @property {Number} Rtti_PlotHistogram            For Histogram.
 * @property {Number} Rtti_PlotSpectrogram          For PlotSpectrogram.
 * @property {Number} Rtti_PlotGraphic              For PlotGraphic.
 * @property {Number} Rtti_PlotTradingCurve         For PlotTradingCurve.
 * @property {Number} Rtti_PlotBarChart             For PlotBarChart.
 * @property {Number} Rtti_PlotMultiBarChart        For PlotMultiBarChart .
 * @property {Number} Rtti_PlotShape                For PlotShapeItem.
 * @property {Number} Rtti_PlotTextLabel            For PlotTextLabel.
 * @property {Number} Rtti_PlotZone                 For PlotZoneItem.
 * @property {Number} Rtti_PlotVectorField          For PlotVectorField.
 * @property {Number} Rtti_PlotUserItem             For PlotUserItem = 1000.
 */
Enumerator.enum(
  "RttiValues {\
    Rtti_PlotItem = 0 , Rtti_PlotGrid , Rtti_PlotScale , Rtti_PlotLegend ,\
    Rtti_PlotMarker , Rtti_PlotCurve , Rtti_PlotSpectroCurve , Rtti_PlotIntervalCurve ,\
    Rtti_PlotHistogram , Rtti_PlotSpectrogram , Rtti_PlotGraphic , Rtti_PlotTradingCurve ,\
    Rtti_PlotBarChart , Rtti_PlotMultiBarChart , Rtti_PlotShape , Rtti_PlotTextLabel ,\
    Rtti_PlotZone , Rtti_PlotVectorField , Rtti_PlotUserItem = 1000\
  }",
  PlotItem
);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link PlotItem.ItemAttribute}</div>
 *
 * Plot Item Attributes.
 * Various aspects of a plot widget depend on the attributes of the attached plot items. If and how a single plot item participates in these updates depends on its attributes.
 * @name PlotItem.ItemAttribute
 * @readonly
 * @property {Number} Legend             The item is represented on the legend.
 * @property {Number} AutoScale          The boundingRect() of the item is included in the autoscaling calculation as long as its width or height is >= 0.0
 * @property {Number} Margins            The item needs extra space to display something outside its bounding rectangle.
 */
Enumerator.enum(
  "ItemAttribute { Legend = 0x01 , AutoScale = 0x02 , Margins = 0x04 }",
  PlotItem
);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link PlotItem.ItemInterest}</div>
 *
 * Plot Item Interests.
 * Plot items might depend on the situation of the corresponding plot widget. By enabling an interest the plot item
 * will be notified, when the corresponding attribute of the plot widgets has changed.
 * @name PlotItem.ItemInterest
 * @readonly
 * @property {Number} ScaleInterest              The item is interested in updates of the scales
 * @property {Number} LegendInterest             The item is interested in updates of the legend ( of other items ) This flag is intended for items, that want to implement a legend for displaying entries of other plot item.
 */
Enumerator.enum(
  "ItemInterest { ScaleInterest = 0x01 , LegendInterest = 0x02 }",
  PlotItem
);

define("plotItem", ["static","enumerator"], function(){});



/**
 * A class for drawing markers.
 *
 * A marker can be a horizontal line, a vertical line, a symbol, a label or any combination of them, which can be drawn
 * around a center point inside a bounding rectangle.
 *
 * The setSymbol() member assigns a symbol to the marker. The symbol is drawn at the specified point.
 *
 * With setLabel(), a label can be assigned to the marker. The setLabelAlignment() member specifies where the label is drawn.
 * All the Align*-constants in static.js are valid. The interpretation of the alignment depends on the marker's line style.
 * The alignment refers to the center point of the marker, which means, for example, that the label would be printed left above
 * the center point if the alignment was set to AlignLeft | AlignTop.
 * @extends PlotItem
 */
class PlotMarker extends PlotItem {
  /**
   *
   * @param {String} tle Title of the marker
   */
  constructor(tle) {
    super(tle);
    var m_label = "";
    var m_labelFont = new Misc.Font();
    var m_labelAlignment = Static.AlignCenter;
    var m_labelOrientation = Static.Horizontal;
    var m_spacing = 2;
    var m_pen = new Misc.Pen(); //mMakePen();
    var m_symbol = null;
    var m_style = PlotMarker.LineStyle.NoLine;
    var m_xValue = 0.0;
    var m_yValue = 0.0;

    this.rtti = PlotItem.RttiValues.Rtti_PlotMarker;

    /**
     *
     * @returns {Misc.Font} label font
     */
    this.labelFont = function () {
      return m_labelFont;
    };

    /**
     * Sets the label font
     * @param {Misc.Font} f New font
     */
    this.setLabelFont = function (f) {
      m_labelFont = f;
    };

    /**
     *
     * @returns {Misc.Pont} Value
     */
    this.value = function () {
      return new Misc.Point(m_xValue, m_yValue);
    };

    /**
     *
     * @returns {Number} x Value
     */
    this.xValue = function () {
      return m_xValue;
    };

    /**
     *
     * @returns {Number} y Value
     */
    this.yValue = function () {
      return m_yValue;
    };

    /**
     * Set Value.
     * @param {Number} x X value
     * @param {number} y Y value
     */
    this.setValue = function (x, y) {
      //console.log(x)
      if (typeof x == "object") {
        var temp = x;
        x = temp.x;
        y = temp.y;
      }
      if (x != m_xValue || y != m_yValue) {
        m_xValue = x;
        m_yValue = y;
        //itemChanged();
        if (this.plot()) this.plot().autoRefresh();
      }
    };

    //! Set X Value

    /**
     * Set X Value
     * @param {Number} x
     */
    this.setXValue = function (x) {
      this.setValue(x, m_yValue);
    };

    /**
     * Set Y Value
     * @param {Number} y
     */
    this.setYValue = function (y) {
      this.setValue(m_xValue, y);
    };

    /**
     * Set the label
     * @param {String} label Label text
     * @see {@link PlotMarker#label label()}
     */
    this.setLabel = function (label) {
      if (label != m_label) {
        m_label = label;
        //itemChanged();
      }
    };

    /**
     *
     * @returns {String} the label
     * @see {@link PlotMarker#setLabel setLabel()}
     */
    this.label = function () {
      return m_label;
    };

    /**
     * Set the alignment of the label
     * In case of HLine the alignment is relative to the y position of the marker, but the horizontal flags correspond to the canvas rectangle. In case of QwtPlotMarker::VLine the alignment is relative to the x position of the marker, but the vertical flags correspond to the canvas rectangle. In all other styles the alignment is relative to the marker's position.
     * @param {Number} align Alignment.
     * @see {@link PlotMarker#labelAlignment labelAlignment()}
     * @see {@link PlotMarker#labelOrientation labelOrientation()}
     */
    this.setLabelAlignment = function (align) {
      if (align !== m_labelAlignment) {
        m_labelAlignment = align;
        //itemChanged();
      }
    };

    /**
     *
     * @returns {Number} the label alignment
     * @see {@link PlotMarker#setLabelAlignment setLabelAlignment()}
     * @see {@link PlotMarker#setLabelOrientation setLabelOrientation()}
     */
    this.labelAlignment = function () {
      return m_labelAlignment;
    };

    /**
     * Set the orientation of the label
     * When orientation is Qt::Vertical the label is rotated by 90.0 degrees ( from bottom to top ).
     * @param {Number} orientation Orientation of the label
     * @see {@link PlotMarker#labelOrientation labelOrientation()}
     */
    this.setLabelOrientation = function (orientation) {
      if (orientation != m_labelOrientation) {
        m_labelOrientation = orientation;
        //itemChanged();
      }
    };

    /**
     *
     * @returns {Number} the label orientation
     * @see {@link PlotMarker#setLabelOrientation setLabelOrientation()}
     * @see {@link PlotMarker#labelAlignment labelAlignment()}
     */
    this.labelOrientation = function () {
      return m_labelOrientation;
    };

    /**
     * Set the spacing
     * When the label is not centered on the marker position, the spacing is the distance between the position and the label.
     * @param {Number} spacing Spacing
     * @see {@link PlotMarker#spacing spacing()}
     * @see {@link PlotMarker#setLabelAlignment setLabelAlignment()}
     */
    this.setSpacing = function (spacing) {
      if (spacing < 0) spacing = 0;

      if (spacing == m_spacing) return;

      m_spacing = spacing;
      //itemChanged();
    };

    /**
     *
     * @returns {Number} the spacing
     * @see {@link PlotMarker#setSpacing setSpacing()}
     */
    this.spacing = function () {
      return m_spacing;
    };

    /**
     * Assign a symbol
     * @param {Symbol} symbol New symbol
     * @see {@link PlotMarker#symbol symbol()}
     */
    this.setSymbol = function (symbol) {
      m_symbol = symbol;
    };

    /**
     *
     * @returns {Symbol} the symbol
     */
    this.symbol = function () {
      return m_symbol;
    };

    /**
     * Draw the marker
     * @param {ScaleMap} xMap x Scale Map
     * @param {ScaleMap} yMap y Scale Map
     */
    this.draw = function (xMap, yMap) {
      var canvasRect = this.getCanvasRect();
      //$("#demo").text(mRectToString(canvasRect))
      var pos = new Misc.Point(
        xMap.transform(m_xValue),
        yMap.transform(m_yValue)
      );

      var ctx = this.getContext();

      // draw lines
      this.drawLines(ctx, canvasRect, pos);

      // draw symbol
      //console.log(m_symbol.style())
      if (m_symbol && m_symbol.style() !== Symbol2.Style.NoSymbol) {
        var sz = m_symbol.size();
        var clipRect = canvasRect.adjusted(
          -sz.width,
          -sz.height,
          sz.width,
          sz.height
        );
        if (clipRect.contains(pos)) {
          m_symbol.drawSymbol(ctx, pos);
        }
      }

      this.drawLabel(ctx, canvasRect, pos);
    };

    /**
     * Align and draw the text label of the marker
     * @param {object} ctx Paint context
     * @param {Misc.Rect} canvasRect Contents rectangle of the canvas in painter coordinates
     * @param {Misc.Point} pos Position of the marker, translated into widget coordinates
     *
     */
    this.drawLabel = function (ctx, canvasRect, pos) {
      if (m_label === "") return;

      var align = m_labelAlignment;
      var alignPos = pos;

      var symbolOff = new Misc.Size(0, 0);
      //var canvasRect = this.getCanvasRect();

      //var ctx = this.getContext();

      switch (m_style) {
        case PlotMarker.LineStyle.VLine: {
          // In VLine-style the y-position is pointless and
          // the alignment flags are relative to the canvas

          if (m_labelAlignment & Static.AlignTop) {
            alignPos.y = canvasRect.top();
            align &= ~Static.AlignTop;
            align |= Static.AlignBottom;
          } else if (m_labelAlignment & Static.AlignBottom) {
            // In HLine-style the x-position is pointless and
            // the alignment flags are relative to the canvas

            alignPos.y = canvasRect.bottom() - 1;
            align &= ~Static.AlignBottom;
            align |= Static.AlignTop;
          } else {
            alignPos.y = canvasRect.center().y;
          }
          break;
        }
        case PlotMarker.LineStyle.HLine: {
          if (m_labelAlignment & Static.AlignLeft) {
            alignPos.x = canvasRect.left();
            align &= ~Static.AlignLeft;
            align |= Static.AlignRight;
          } else if (m_labelAlignment & Static.AlignRight) {
            alignPos.x = canvasRect.right() - 1;
            align &= ~Static.AlignRight;
            align |= Static.AlignLeft;
          } else {
            alignPos.x = canvasRect.center().x;
          }
          break;
        }
        default: {
          if (m_symbol && m_symbol.style() !== Symbol2.Style.NoSymbol) {
            var sz = m_symbol.size();
            symbolOff = new Misc.Size((sz.width + 1) / 2, (sz.height + 1) / 2);
            //symbolOff /= 2;
          }
        }
      }

      var pw2 = m_pen.width / 2.0;
      if (pw2 == 0.0) pw2 = 0.5;

      var spacing = m_spacing;

      var xOff = Math.max(pw2, symbolOff.width);
      var yOff = Math.max(pw2, symbolOff.height);

      var textSize = m_labelFont.textSize(m_label);

      if (align & Static.AlignLeft) {
        alignPos.x -= xOff + spacing;
        if (m_labelOrientation == Static.Vertical)
          alignPos.x -= textSize.height;
        else alignPos.x -= textSize.width;
      } else if (align & Static.AlignRight) {
        alignPos.x += xOff + spacing;
        //>>>>>>>>>>>>Added>>>>>>>>>>>>>>>>>>>>>
        if (m_labelOrientation == Static.Vertical)
          alignPos.x += textSize.height;
        /*else
                    alignPos.x += textSize.width; */
        //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      } else {
        if (m_labelOrientation == Static.Vertical)
          alignPos.x -= textSize.height / 2;
        else alignPos.x -= textSize.width / 2;
      }

      if (align & Static.AlignTop) {
        alignPos.y -= yOff + spacing;
        if (m_labelOrientation != Static.Vertical)
          alignPos.y -= textSize.height;
      } else if (align & Static.AlignBottom) {
        alignPos.y += yOff + spacing;
        if (m_labelOrientation == Static.Vertical) alignPos.y += textSize.width;
      } else {
        if (m_labelOrientation == Static.Vertical)
          alignPos.y += textSize.width / 2;
        else alignPos.y -= textSize.height / 2;
      }

      var painter = new PaintUtil.Painter(ctx);
      //painter.save();
      painter.translate(alignPos.x, alignPos.y);
      //if ( m_labelOrientation == Static.Vertical )
      //painter.rotate( -90*Math.PI/180 );
      painter.setFont(m_labelFont);
      var textRect = new Misc.Rect(0, 0, textSize.width, textSize.height);
      if (m_labelOrientation == Static.Vertical)
        painter.drawVerticalText(
          m_label,
          textRect.left() + textSize.height * 0.3,
          textRect.bottom() - textSize.width * 0.75
        );
      else painter.drawText(m_label, textRect.left(), textRect.bottom() - 2);
      //painter.restore();

      //painter = null
    }; //this.drawVerticalText = function(txt, tx, ty, topDown)

    /**
     * Draw the lines marker
     * @param {object} ctx Paint context
     * @param {Misc.Rect} canvasRect Contents rectangle of the canvas in painter coordinates
     * @param {Misc.Point} pos Position of the marker, translated into widget coordinates
     * @see {@link PlotMarker#drawLabel drawLabel()}
     * @see {@link Symbol#drawSymbol drawSymbol()}
     */
    this.drawLines = function (ctx, canvasRect, pos) {
      if (m_style == PlotMarker.LineStyle.NoLine) return;

      //var doAlign = QwtPainter::roundingAlignment( painter );

      var painter = new PaintUtil.Painter(ctx);
      painter.setPen(m_pen);

      if (
        m_style == PlotMarker.LineStyle.HLine ||
        m_style == PlotMarker.LineStyle.Cross
      ) {
        var y = pos.y;
        //if ( doAlign )
        //y = qRound( y );

        painter.drawLine(canvasRect.left(), y, canvasRect.right() - 1.0, y);
      }
      if (
        m_style == PlotMarker.LineStyle.VLine ||
        m_style == PlotMarker.LineStyle.Cross
      ) {
        var x = pos.x;
        //if ( doAlign )
        //x = qRound( x );

        painter.drawLine(x, canvasRect.top(), x, canvasRect.bottom() - 1.0);
      }
      painter = null;
    };

    /**
     * Set the line style
     * @param {PlotMarker.LineStyle} style Line style.
     * @see {@link PlotMarker#lineStyle lineStyle()}
     */
    this.setLineStyle = function (style) {
      if (style != m_style) {
        m_style = style;

        // legendChanged();
        // itemChanged();
      }
    };

    /**
     *
     * @returns {PlotMarker.LineStyle} the line style
     * @see {@link PlotMarker#setLineStyle setLineStyle()}
     */
    this.lineStyle = function () {
      return m_style;
    };

    /**
     * Specify a pen for the line.
     * @param {Misc.Pen} pen New pen
     * @see {@link PlotMarker#linePen linePen()}
     */
    this.setLinePen = function (pen) {
      // if ( pen != m_pen )
      //{
      m_pen = pen;
      if (this.plot()) this.plot().autoRefresh();

      // legendChanged();
      //itemChanged();
      //}
    };

    /**
     *
     * @returns {Misc.Pen} the line pen
     * @see {@link PlotMarker#setLinePen setLinePen()}
     */
    this.linePen = function () {
      return m_pen;
    };

    this.setZ(1000.0);

    /**
     *
     * @returns {String} Returns a string representing the object.
     */
    this.toString = function () {
      return "[PlotMarker]";
    };

    /**
     *
     * @param {Number} index Index of the legend entry
     * @param {Misc.Size} size Icon size
     * @returns {Graphic} Icon representing the marker on the legend
     * @see {@link PlotMarker#setLegendIconSize setLegendIconSize()}
     * @see {@link PlotMarker#legendData legendData()}
     */
    this.legendIcon = function (index, size) {
      if (size.width === 0 && size.height === 0) return null;

      var graphic = new Graphic(null, size.width, size.height);

      var painter = new PaintUtil.Painter(graphic);

      if (m_style !== PlotMarker.LineStyle.NoLine) {
        painter.setPen(this.linePen());

        if (
          m_style == PlotMarker.LineStyle.HLine ||
          m_style == PlotMarker.LineStyle.Cross
        ) {
          let y = 0.5 * size.height;
          painter.drawLine(0.0, y, size.width, y);
        }

        if (
          m_style == PlotMarker.LineStyle.VLine ||
          m_style == PlotMarker.LineStyle.Cross
        ) {
          let x = 0.5 * size.width;
          painter.drawLine(x, 0.0, x, size.height);
        }
      }

      if (this.symbol()) {
        let sh = size.height / 2; // + 1;
        if (this.symbol().style() == Symbol2.Style.Ellipse) sh -= 1;
        painter.setPen(this.symbol().pen());
        this.symbol().drawGraphicSymbol(
          painter,
          new Misc.Point(size.width / 2, sh),
          size
        );
      }

      painter = null;
      return graphic;
    };

    /*!
        \return Icon representing the marker on the legend
        \param index Index of the legend entry 
                        ( usually there is only one )
        \param size Icon size
        \sa setLegendIconSize(), legendData()
        */
    /* QwtGraphic QwtPlotMarker::legendIcon( int index,
            const QSizeF &size ) const
        {
            Q_UNUSED( index );

            if ( size.isEmpty() )
                return QwtGraphic();

            QwtGraphic icon;
            icon.setDefaultSize( size );
            icon.setRenderHint( QwtGraphic::RenderPensUnscaled, true );

            QPainter painter( &icon );
            painter.setRenderHint( QPainter::Antialiasing,
                testRenderHint( QwtPlotItem::RenderAntialiased ) );

            if ( d_data->style != QwtPlotMarker::PlotMarker.LineStyle.NoLine )
            {
                painter.setPen( d_data->pen );

                if ( d_data->style == QwtPlotMarker::HLine ||
                    d_data->style == QwtPlotMarker::Cross )
                {
                    const double y = 0.5 * size.height();

                    QwtPainter::drawLine( &painter, 
                        0.0, y, size.width(), y );
                }

                if ( d_data->style == QwtPlotMarker::VLine ||
                    d_data->style == QwtPlotMarker::Cross )
                {
                    const double x = 0.5 * size.width();

                    QwtPainter::drawLine( &painter, 
                        x, 0.0, x, size.height() );
                }
            }

            if ( d_data->symbol )
            {
                const QRect r( 0.0, 0.0, size.width(), size.height() );
                d_data->symbol->drawSymbol( &painter, r );
            }

            return icon;
        }  */
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link PlotMarker.LineStyle}</div>
 *
 * Line styles.
 * @name PlotMarker.LineStyle
 * @readonly
 * @property {Number} NoLine            No line.
 * @property {Number} HLine             A horizontal line.
 * @property {Number} VLine             A vertical line.
 * @property {Number} Cross             A crosshair.
 */
Enumerator.enum("LineStyle { NoLine , HLine , VLine , Cross }", PlotMarker);

define("plotMarker", ["static","plotItem"], function(){});



/**
 * A class for SVG.
 *
 */
class Graphic {
  /**
   * Creates a SVG object
   * @param {object} e jQuery element selector
   * @param {Numbe} w Width of SVG
   * @param {Number} h Height of SVG
   */
  constructor(e, w, h) {
    this.parent = e;
    var m_width = w;
    var m_height = h;

    var m_svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    m_svg.setAttribute("width", w);
    m_svg.setAttribute("height", h);
    if (this.parent) this.parent[0].appendChild(m_svg);

    /**
     * Sets the parent element of SVG element
     * @param {object} p Parent element
     */
    this.setParent = function (p) {
      this.parent = p;
      this.parent[0].appendChild(m_svg);
    };

    /**
     *
     * @returns {object} Parent element of SVG element
     */
    this.parent = function () {
      return this.parent;
    };

    /**
     * Sets the width of the SVG element
     * @param {Number} h Width
     */
    this.setWidth = function (w) {
      m_width = w;
    };

    /**
     *
     * @returns {Number} Width of SVG element
     */
    this.width = function () {
      return m_width;
    };

    /**
     * Sets the height of the SVG element
     * @param {Number} h Height
     */
    this.setHeight = function (h) {
      m_height = h;
    };

    /**
     *
     * @returns {Number} Height of SVG element
     */
    this.height = function () {
      return m_height;
    };

    /**
     *
     * @returns {object} SVG element
     */
    this.svg = function () {
      return m_svg;
    };

    /**
     *
     * @returns {String} A string representing the object.
     */
    this.toString = function () {
      return "[Graphic]";
    };
  }
}
;
define("graphic", function(){});



/**
 * A class for drawing symbols.
 */
class Symbol2 {
  /**
   * If no arguments are passed to the constructor, the symbol is constructed with gray interior,
   * black outline with zero width, no size and style 'NoSymbol'. See example.
   * @param {Symbol2.Style} [style] Style
   * @param {Misc.Brush} [brush] Brush (Only valid if a stye is passed)
   * @param {Misc.Pen} [pen] Pen (Only valid if a stye and brush is passed)
   * @param {Misc.Size} [size] Size (Only valid if a stye, brush and pen is passed)
   *
   * @example
   * new Symbol2(); //Default construction
   * new Symbol2(style);
   * new Symbol2(style, brush);
   * new Symbol2(style, brush, pen);
   * new Symbol2(style, brush, pen, size);
   */
  constructor(style, brush, pen, size) {
    //<<<<<<<<<<<<< Helpers >>>>>>>>>>>>>>>>>>//
    function mDrawXCrossSymbols(ctx, points, symbol) {
      var size = symbol.size();
      var pen = symbol.pen();
      var brush = symbol.brush();
      var sw = size.width;
      var sh = size.height;
      ctx.beginPath();
      ctx.strokeStyle = pen.color;
      ctx.lineWidth = pen.width;

      for (var i = 0; i < points.length; i++) {
        var x = points[i].x - 0.5 * sw - 1; //pen.width*0.5;
        var y = points[i].y - 0.5 * sh - 1; //pen.width*0.5;

        ctx.moveTo(x, y);
        ctx.lineTo(x + sw, y + sh);
        ctx.moveTo(x + sw, y);
        ctx.lineTo(x, y + sh);
      }
      ctx.stroke();
    }

    function mDrawLineSymbols(ctx, orientations, points, symbol) {
      var size = symbol.size();
      var pen = symbol.pen();
      var brush = symbol.brush();
      var sw = size.width;
      var sh = size.height;
      var painter = new PaintUtil.Painter(ctx);
      painter.setPen(pen);

      painter.save();

      for (var i = 0; i < points.length; i++) {
        if (orientations & Static.Horizontal) {
          var x = points[i].x - 0.5 * sw - 1; //- pen.width*0.5;
          var y = points[i].y - 1; //- pen.width*0.5;
          painter.drawLine(x, y, x + sw, y);
        }
        if (orientations & Static.Vertical) {
          var x = points[i].x - 1; //- pen.width*0.5;
          var y = points[i].y - 0.5 * sh - 1; //- pen.width*0.5;

          painter.drawLine(x, y, x, y + sh);
        }
      }
      painter.restore();
      painter = null;
    }

    function mDrawPathSymbols(ctx, points, symbol) {
      var numPoints = points.length;
      var size = symbol.size();
      var pen = symbol.pen();
      var brush = symbol.brush();
      var sw = size.width;
      var sh = size.height;
      var painter = new PaintUtil.Painter(ctx);
      painter.setPen(pen);
      painter.setBrush(brush);

      for (var i = 0; i < numPoints; i++) {
        var x = points[i].x;
        var y = points[i].y;
        var bRc = symbol.m_path.boundingRect();
        painter.save();
        painter.translate(x, y);
        //painter.scale(sw/bRc.width(), sh/bRc.height());
        symbol.m_path.data.scale = Math.min(
          size.width / bRc.width(),
          size.height / bRc.height()
        );

        if (symbol.m_path.data.rotation) {
          painter.rotate(symbol.m_path.data.rotation);
        }
        var pinpoint = symbol.pinPoint();
        //console.log(sw/bRc.width())
        painter.translate(-1 * pinpoint.x, -1 * pinpoint.y);
        //painter.scale(sw/bRc.width(), sh/bRc.height())
        painter.drawPath(symbol.m_path);
        painter.restore();
      }
      painter = null;
    }

    function mDrawDiamondSymbols(ctx, points, symbol) {
      var painter = new PaintUtil.Painter(ctx);
      painter.save();
      painter.setBrush(symbol.brush());
      painter.setPen(symbol.pen());
      var sz = symbol.size();
      var rc = new Misc.Rect(new Misc.Point(), symbol.size());
      var numPoints = points.length;

      for (var i = 0; i < numPoints; i++) {
        painter.save();
        painter.translate(points[i].x - 1, points[i].y - 1);
        painter.rotate(45);
        painter.drawRect(
          -0.5 * sz.width,
          -0.5 * sz.height,
          sz.width,
          sz.height
        );
        painter.restore();
      }
      painter.restore();
      painter = null;
    }

    function mDrawRectSymbols(ctx, points, symbol) {
      var painter = new PaintUtil.Painter(ctx);
      painter.save();
      painter.setBrush(symbol.brush());
      painter.setPen(symbol.pen());
      var rc = new Misc.Rect(new Misc.Point(), symbol.size());
      var numPoints = points.length;

      for (var i = 0; i < numPoints; i++) {
        rc.moveCenter(points[i]);
        //painter.drawRect(rc.left()-0.5*symbol.pen().width, rc.top()-0.5*symbol.pen().width, rc.width(), rc.height());
        painter.drawRect(rc.left(), rc.top(), rc.width(), rc.height());
      }
      painter.restore();
      painter = null;
    }

    function mDrawEllipseSymbols(ctx, points, symbol) {
      var painter = new PaintUtil.Painter(ctx);
      painter.save();
      painter.setBrush(symbol.brush());
      painter.setPen(symbol.pen());
      var radius = Math.min(symbol.size().width, symbol.size().height) / 2;
      var numPoints = points.length;

      for (var i = 0; i < numPoints; i++) {
        //painter.drawCircle(points[i].x-0.5*symbol.pen().width, points[i].y-0.5*symbol.pen().width, radius);
        painter.drawCircle(points[i].x - 1, points[i].y - 1, radius);
      }
      painter.restore();
      painter = null;
    }

    function mDrawCrossGraphicSymbol(painter, point, size, symbol) {
      painter.setBrush(symbol.brush());
      painter.setPen(symbol.pen());
      var rc = new Misc.Rect(new Misc.Point(), symbol.size());
      rc.moveCenter(point);
      painter.drawLine(
        rc.left() + 0.5 * rc.width(),
        rc.top(),
        rc.left() + 0.5 * rc.width(),
        rc.bottom()
      );
      painter.drawLine(
        rc.left(),
        rc.top() + 0.5 * rc.height(),
        rc.right(),
        rc.top() + 0.5 * rc.height()
      );
    }

    function mDrawXCrossGraphicSymbol(painter, point, size, symbol) {
      painter.setBrush(symbol.brush());
      painter.setPen(symbol.pen());
      var rc = new Misc.Rect(new Misc.Point(), symbol.size());
      rc.moveCenter(point);
      painter.drawLine(rc.left(), rc.top(), rc.right(), rc.bottom());
      painter.drawLine(rc.right(), rc.top(), rc.left(), rc.bottom());
    }

    function mDrawRectGraphicSymbol(painter, point, size, symbol) {
      //console.log(symbol.brush().color)
      painter.setBrush(symbol.brush());
      //var p = new Misc.Pen(symbol.pen())
      //if(symbol.brush1()) //allow the brush to go to the center line of the pen. This is consistent with symbol on curve.
      //p.width /= 2;
      //painter.setPen( p)//symbol.pen() );
      var rc = new Misc.Rect(new Misc.Point(), symbol.size());
      rc.moveCenter(point);
      painter.drawRect(rc.left(), rc.top(), rc.width(), rc.height());
    }

    function mDrawDiamondGraphicSymbol(painter, point, size, symbol) {
      painter.setBrush(symbol.brush());
      //painter.setPen( symbol.pen() );
      var rc = new Misc.Rect(
        new Misc.Point(),
        symbol.size().width * 0.707,
        symbol.size().height * 0.707
      );
      rc.moveCenter(point);
      painter.drawRect(rc.left(), rc.top(), rc.width(), rc.height());
      painter.transform({
        rotation: 45,
        rotationX: point.x,
        rotationY: point.y,
      });
    }

    function mDrawEllipseGraphicSymbol(painter, point, size, symbol) {
      painter.setBrush(symbol.brush());
      //painter.setPen( symbol.pen() );
      var radius =
        Math.min(
          symbol.size().width - symbol.pen().width,
          symbol.size().height - symbol.pen().width
        ) / 2; //- symbol.pen().width
      painter.drawCircle(point.x, point.y, radius);
    }

    function mDrawPathGraphicSymbol(painter, point, iconSize, symbol) {
      var pen = symbol.pen();
      var pw = 0.0;
      if (pen.style !== Static.NoPen) pw = Math.max(pen.width, 1.0);
      var rc = symbol.path().boundingRect();
      rc = rc.adjusted(-pw, -pw, pw, pw);
      var data = symbol.path().data;
      data.xOffset = -1 * rc.left();
      data.yOffset = -1 * rc.top();
      data.xCenter = (rc.right() - rc.left()) / 2;
      data.yCenter = (rc.bottom() - rc.top()) / 2;
      painter.setBrush(symbol.brush());
      painter.setPen(symbol.pen());

      //painter.scale(iconSize.width/rc.width(), iconSize.height/rc.height())
      data.scale = Math.min(
        iconSize.width / rc.width(),
        iconSize.height / rc.height()
      );

      //symbol.path().data = data
      painter.drawPath(symbol.path());
    }

    //super()
    var m_style = Symbol2.Style.NoSymbol;
    var m_size = new Misc.Size(-1, -1); //{width:-1, height: -1};//invalid size
    //var m_size = new Misc.Size(10, 10);//default size
    var m_brush = new Misc.Brush("gray");
    var m_pen = new Misc.Pen(); //{color:"black", width:1, style:"solid"};
    var m_isPinPointEnabled = false;
    this.m_path = 0;

    var m_pinpoint = new Misc.Point(0, 0);

    if (typeof size !== "undefined") {
      m_style = style;
      m_brush = brush;
      m_pen = pen;
      m_size = size;
    } else if (typeof pen !== "undefined") {
      m_style = style;
      m_brush = brush;
      m_pen = pen;
    } else if (typeof brush !== "undefined") {
      m_style = style;
      m_brush = brush;
    } else if (typeof style !== "undefined") {
      m_style = style;
    }

    /**
     * Set a pin point.
     *
     * The position of a complex symbol is not always aligned to its center ( e.g. an arrow, where the peak points to a position ).
     * The pin point defines the position inside of a Pixmap, Graphic, SvgDocument or PainterPath symbol where the represented
     * point has to be aligned to.
     * @param {Misc.Point} pt Pin point
     */
    this.setPinPoint = function (pt) {
      m_pinpoint = pt;
    };

    /**
     *
     * @returns {Misc.Point} pt Pin point
     */
    this.pinPoint = function () {
      return m_pinpoint;
    };

    /**
     * Set the symbol's size
     * @param {Misc.Size} size New size
     */
    this.setSize = function (size) {
      if (size.isValid() && !size.isEqual(m_size)) {
        m_size = size;
        //invalidateCache();
      }
    };

    /**
     *
     * @returns {Misc.Size} Size
     */
    this.size = function () {
      return m_size;
    };

    /**
     * Specify the symbol style
     * @param {Symbol2.Style} style Style
     * @see {@link Symbol2#style style()}
     */
    this.setStyle = function (style) {
      if (m_style != style) {
        m_style = style;
        //invalidateCache();
      }
    };

    /**
     *
     * @returns {Symbol2.Style} Current symbol style
     * @see {@link Symbol2#setStyle setStyle()}
     */
    this.style = function () {
      return m_style;
    };

    /**
     * Set a painter path as symbol
     *
     * The symbol is represented by a painter path, where the origin ( 0, 0 ) of the path coordinate system is
     * mapped to the position of the symbol.
     * When the symbol has valid size the painter path gets scaled to fit into the size. Otherwise the symbol
     * size depends on the bounding rectangle of the path.
     *
     * The style is implicitely set to {@link Symbol2.Style}.
     * @param {Misc.MPath} path Path
     * @see {@link Symbol2#path path()}
     * @see {@link Symbol2#setSize setSize()}
     */
    this.setPath = function (path) {
      m_style = Symbol2.Style.Path;
      // d_data->path.path = path;
      // d_data->path.graphic.reset();
      this.m_path = path;
    };

    /**
     *
     * @returns {Misc.MPath} Painter path for displaying the symbol
     * @see {@link Symbol2#setPath setPath()}
     */
    this.path = function () {
      return this.m_path;
    };

    /**
     * Build and assign a pen
     * @param {Misc.Pen} pen Pen
     * @see {@link Symbol2#pen pen()}
     * @see {@link Symbol2#brush brush()}
     */
    this.setPen = function (pen) {
      //if ( brush != m_brush )
      {
        m_pen = pen;
      }
    };

    /**
     *
     * @returns {Misc.Pen} Pen
     * @see {@link Symbol2#setPen setPen()}
     * @see {@link Symbol2#brush brush()}
     */
    this.pen = function () {
      return m_pen;
    };

    /**
     * Assign a brush
     *
     * The brush is used to draw the interior of the symbol.
     * @param {Misc.Brush} brush Brush
     * @see {@link Symbol2#brush brush()}
     */
    this.setBrush = function (brush) {
      // if ( brush != m_brush )
      {
        m_brush = brush;
        //invalidateCache();

        if (m_style == Symbol2.Style.Path); //d_data->path.graphic.reset();
      }
    };

    /**
     *
     * @returns {Misc.Brush} Brush
     * @see {@link Symbol2#setBrush setBrush()}
     */
    this.brush = function () {
      return m_brush;
    };

    //Internal use only
    this.brush1 = function () {
      return m_brush.color !== "noBrush";
    };

    /**
     * Render an array of symbols
     *
     * Painting several symbols is more effective than drawing symbols one by one, as a couple of layout calculations
     * and setting of pen/brush can be done once for the complete array.
     * @param {object} ctx 2d context for the central div canvas
     * @param {Array<Misc.Point>} points Array of points
     */
    this.drawSymbols = function (ctx, points) {
      if (points.length <= 0) return;

      var useCache = false;

      //alert("drawSymbols: here")

      // Don't use the pixmap, when the paint device
      // could generate scalable vectors

      //        if ( QwtPainter::roundingAlignment( painter ) &&  !painter->transform().isScaling() )
      //        {
      //            if ( d_data->cache.policy == QwtSymbol::Cache )
      //            {
      //                useCache = true;
      //            }
      //            else if ( d_data->cache.policy == QwtSymbol::AutoCache )
      //            {
      //                if ( painter->paintEngine()->type() == QPaintEngine::Raster )
      //                {
      //                    useCache = true;
      //                }
      //                else
      //                {
      //                    switch( d_data->style )
      //                    {
      //                        case QwtSymbol::XCross:
      //                        case QwtSymbol::HLine:
      //                        case QwtSymbol::VLine:
      //                        case QwtSymbol::Cross:
      //                            break;

      //                        case QwtSymbol::Pixmap:
      //                        {
      //                            if ( !d_data->size.isEmpty() &&
      //                                d_data->size != d_data->pixmap.pixmap.size() )
      //                            {
      //                                useCache = true;
      //                            }
      //                            break;
      //                        }
      //                        default:
      //                            useCache = true;
      //                    }
      //                }
      //            }
      //        }

      if (useCache) {
        //var br = this.boundingRect();/////////////////////

        //var rect = {left:0, top:0, width:br.width(), height:br.height() };

        //            if ( d_data->cache.pixmap.isNull() )
        //            {
        //                d_data->cache.pixmap = QwtPainter::backingStore( NULL, br.size() );
        //                d_data->cache.pixmap.fill( Qt::transparent );

        //                QPainter p( &d_data->cache.pixmap );
        //                p.setRenderHints( painter->renderHints() );
        //                p.translate( -br.top()Left() );

        //                const QPointF pos;
        //                renderSymbols( &p, &pos, 1 );
        //            }

        var dx = br.left();
        var dy = br.top();

        for (var i = 0; i < numPoints; i++) {
          var left = Math.round(points[i].x) + dx;
          var top = Math.round(points[i].y) + dy;

          //painter->drawPixmap( left, top, d_data->cache.pixmap );
        }
      } else {
        //painter->save();

        this.renderSymbols(ctx, points);
        //painter->restore();
      }
    };

    /**
     * Draw a graphic symbol to the specified size at the specified position.
     * @param {PaintUtil.Painter} painter Painter
     * @param {Misc.Point} pos Position of the symbol in screen coordinates
     * @param {Misc.Size} size Size of the symbol in screen coordinates
     */
    this.drawGraphicSymbol = function (painter, pos, size) {
      this.renderGraphicSymbol(painter, pos, size);
    };

    /**
     * Draw the symbol at a specified position.
     * @param {object} ctx 2d context for the central div canvas
     * @param {Misc.Point} pos Position of the symbol in screen coordinates
     */
    this.drawSymbol = function (ctx, pos) {
      this.drawSymbols(ctx, [pos]);
    };

    /**
     * Render the symbol to series of points
     * @param {object} ctx 2d context for the central div canvas
     * @param {Array<Misc.Point>} points Positions of the symbols
     */
    this.renderSymbols = function (ctx, points) {
      var numPoints = points.length;

      switch (m_style) {
        case Symbol2.Style.Ellipse: {
          mDrawEllipseSymbols(ctx, points, this);
          break;
        }
        case Symbol2.Style.MRect: {
          mDrawRectSymbols(ctx, points, this);
          break;
        }
        case Symbol2.Style.Diamond: {
          mDrawDiamondSymbols(ctx, points, this);
          break;
        }
        case Symbol2.Style.Cross: {
          mDrawLineSymbols(
            ctx,
            Static.Horizontal | Static.Vertical,
            points,
            this
          );
          break;
        }
        case Symbol2.Style.XCross: {
          mDrawXCrossSymbols(ctx, points, this);
          break;
        }
        //            case QwtSymbol::Triangle:
        //            case QwtSymbol::UTriangle:
        //            {
        //                qwtDrawTriangleSymbols( painter, QwtTriangle::Up,
        //                    points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::DTriangle:
        //            {
        //                qwtDrawTriangleSymbols( painter, QwtTriangle::Down,
        //                    points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::RTriangle:
        //            {
        //                qwtDrawTriangleSymbols( painter, QwtTriangle::Right,
        //                    points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::LTriangle:
        //            {
        //                qwtDrawTriangleSymbols( painter, QwtTriangle::Left,
        //                    points, numPoints, *this );
        //                break;
        //            }
        case Symbol2.Style.HLine: {
          mDrawLineSymbols(ctx, Static.Horizontal, points, this);
          break;
        }
        case Symbol2.Style.VLine: {
          mDrawLineSymbols(ctx, Static.Vertical, points, this);
          break;
        }
        //            case QwtSymbol::Star1:
        //            {
        //                qwtDrawStar1Symbols( painter, points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::Star2:
        //            {
        //                qwtDrawStar2Symbols( painter, points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::Hexagon:
        //            {
        //                qwtDrawHexagonSymbols( painter, points, numPoints, *this );
        //                break;
        //            }
        case Symbol2.Style.Path: {
          // if ( d_data->path.graphic.isNull() )
          // {
          //     d_data->path.graphic = qwtPathGraphic( d_data->path.path,
          //         d_data->pen, d_data->brush );
          // }

          // qwtDrawGraphicSymbols( painter, points, numPoints,
          //     d_data->path.graphic, *this );
          mDrawPathSymbols(ctx, points, this);
          break;
        }
        //            case QwtSymbol::Pixmap:
        //            {
        //                qwtDrawPixmapSymbols( painter, points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::Graphic:
        //            {
        //                qwtDrawGraphicSymbols( painter, points, numPoints,
        //                    d_data->graphic.graphic, *this );
        //                break;
        //            }
        //            case QwtSymbol::SvgDocument:
        //            {
        //    #ifndef QWT_NO_SVG
        //                qwtDrawSvgSymbols( painter, points, numPoints,
        //                    d_data->svg.renderer, *this );
        //    #endif
        //                break;
        //            }
        default:
      }
    };

    //Helper
    this.renderGraphicSymbol = function (painter, point, size) {
      if (m_style !== Symbol2.Style.Cross || m_style !== Symbol2.Style.XCross) {
        var p = new Misc.Pen(this.pen());
        if (this.brush1())
          //allow the brush to go to the center line of the pen. This is consistent with symbol on curve.
          p.width /= 2;
        painter.setPen(p); //symbol.pen() );
      }

      switch (m_style) {
        case Symbol2.Style.Ellipse: {
          // mDrawEllipseSymbols(ctx, points, this );
          mDrawEllipseGraphicSymbol(painter, point, 0, this);
          break;
        }
        case Symbol2.Style.MRect: {
          mDrawRectGraphicSymbol(painter, point, 0, this);
          break;
        }
        case Symbol2.Style.Diamond: {
          //mDrawDiamondSymbols(ctx, points, this );
          mDrawDiamondGraphicSymbol(painter, point, 0, this);
          break;
        }
        case Symbol2.Style.Cross: {
          mDrawCrossGraphicSymbol(painter, point, 0, this);
          break;
        }
        case Symbol2.Style.XCross: {
          //mDrawXCrossSymbols(ctx, points, this );
          mDrawXCrossGraphicSymbol(painter, point, 0, this);
          break;
        }
        //            case QwtSymbol::Triangle:
        //            case QwtSymbol::UTriangle:
        //            {
        //                qwtDrawTriangleSymbols( painter, QwtTriangle::Up,
        //                    points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::DTriangle:
        //            {
        //                qwtDrawTriangleSymbols( painter, QwtTriangle::Down,
        //                    points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::RTriangle:
        //            {
        //                qwtDrawTriangleSymbols( painter, QwtTriangle::Right,
        //                    points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::LTriangle:
        //            {
        //                qwtDrawTriangleSymbols( painter, QwtTriangle::Left,
        //                    points, numPoints, *this );
        //                break;
        //            }
        case Symbol2.Style.HLine: {
          //mDrawLineSymbols( ctx, Horizontal, points, this );
          break;
        }
        case Symbol2.Style.VLine: {
          //mDrawLineSymbols( ctx, Vertical, points, this );
          break;
        }
        //            case QwtSymbol::Star1:
        //            {
        //                qwtDrawStar1Symbols( painter, points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::Star2:
        //            {
        //                qwtDrawStar2Symbols( painter, points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::Hexagon:
        //            {
        //                qwtDrawHexagonSymbols( painter, points, numPoints, *this );
        //                break;
        //            }
        case Symbol2.Style.Path: {
          //console.log(44)
          /*if ( d_data->path.graphic.isNull() )
                        {
                            d_data->path.graphic = qwtPathGraphic( d_data->path.path,
                                d_data->pen, d_data->brush );
                        }
         
                        qwtDrawGraphicSymbols( painter, points, numPoints,
                            d_data->path.graphic, *this );*/
          //mDrawRectGraphicSymbol(painter, point, size, this );
          mDrawPathGraphicSymbol(painter, point, size, this);
          break;
        }
        //            case QwtSymbol::Pixmap:
        //            {
        //                qwtDrawPixmapSymbols( painter, points, numPoints, *this );
        //                break;
        //            }
        //            case QwtSymbol::Graphic:
        //            {
        //                qwtDrawGraphicSymbols( painter, points, numPoints,
        //                    d_data->graphic.graphic, *this );
        //                break;
        //            }
        //            case QwtSymbol::SvgDocument:
        //            {
        //    #ifndef QWT_NO_SVG
        //                qwtDrawSvgSymbols( painter, points, numPoints,
        //                    d_data->svg.renderer, *this );
        //    #endif
        //                break;
        //            }
        default:
      }
    };

    /**
     * Calculates the bounding rectangle for a symbol
     * @returns {Misc.Rect} Bounding rectangle
     */
    this.boundingRect = function () {
      var rect = new Misc.Rect();

      switch (m_style) {
        case Symbol2.Style.Ellipse:
        case Symbol2.Style.MRect:
        case Symbol2.Style.Hexagon: {
          var pw = 0.0;
          if (m_pen.style != Static.NoPen) pw = Math.max(m_pen.width, 1.0);

          rect = new Misc.Rect(
            new Misc.Point(),
            m_size.width + pw,
            m_size.height + pw
          );
          rect.moveCenter(new Misc.Point());

          break;
        }
        case Symbol2.Style.XCross:
        case Symbol2.Style.Diamond:
        case Symbol2.Style.Triangle:
        case Symbol2.Style.UTriangle:
        case Symbol2.Style.DTriangle:
        case Symbol2.Style.RTriangle:
        case Symbol2.Style.LTriangle:
        case Symbol2.Style.Star1:
        case Symbol2.Style.Star2: {
          var pw = 0.0;
          if (m_pen.style !== Static.NoPen) pw = Math.max(m_pen.width, 1.0);

          rect = new Misc.Rect(
            new Misc.Point(),
            m_size.width + pw,
            m_size.height + pw
          );
          rect.moveCenter(new Misc.Point());
          break;
        }
        case Symbol2.Style.Path: {
          rect = m_path.boundingRect();
          console.log(rect.width());
          rect.moveCenter(new Misc.Point());

          break;
        }
        //            case QwtSymbol::Pixmap:
        //            {
        //                if ( d_data->size.isEmpty() )
        //                    rect.setSize( d_data->pixmap.pixmap.size() );
        //                else
        //                    rect.setSize( d_data->size );

        //                rect.moveCenter( QPointF( 0.0, 0.0 ) );

        //                // pinpoint ???
        //                break;
        //            }
        //            case QwtSymbol::Graphic:
        //            {
        //                rect = qwtScaledBoundingRect(
        //                    d_data->graphic.graphic, d_data->size );

        //                break;
        //            }
        //    #ifndef QWT_NO_SVG
        //            case QwtSymbol::SvgDocument:
        //            {
        //                if ( d_data->svg.renderer )
        //                    rect = d_data->svg.renderer->viewBoxF();

        //                if ( d_data->size.isValid() && !rect.isEmpty() )
        //                {
        //                    QSizeF sz = rect.size();

        //                    const double sx = d_data->size.width() / sz.width();
        //                    const double sy = d_data->size.height() / sz.height();

        //                    QTransform transform;
        //                    transform.scale( sx, sy );

        //                    rect = transform.mapRect( rect );
        //                }
        //                break;
        //            }
        //    #endif
        default: {
          rect = new Misc.Rect(new Misc.Point(), m_size.width, m_size.height);
          rect.moveCenter(new Misc.Point());
        }
      }

      //        if ( d_data->style == QwtSymbol::Graphic ||
      //            d_data->style == QwtSymbol::SvgDocument || d_data->style == QwtSymbol::Path )
      //        {
      //            QPointF pinPoint( 0.0, 0.0 );
      //            if ( d_data->isPinPointEnabled )
      //                pinPoint = rect.center() - d_data->pinPoint;

      //            rect.moveCenter( pinPoint );
      //        }

      var r = new Misc.Rect();
      r.setLeft(Math.floor(rect.left()));
      r.setTop(Math.floor(rect.top()));
      r.setRight(Math.ceil(rect.right()));
      r.setBottom(Math.ceil(rect.bottom()));

      //if ( m_style != Pixmap )
      //r.adjust( -1, -1, 1, 1 ); // for antialiasing

      return r;
    };
  }

  /**
   *
   * @returns {String} A string representing the object. .
   */
  toString() {
    return "[Symbol2]";
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link Symbol2.Style}</div>
 *
 * Symbol Style
 * @name Symbol2.Style
 * @readonly
 * @property {Number} NoSymbol             No symbol = -1.
 * @property {Number} Ellipse              Ellipse.
 * @property {Number} MRect                Rectangle.
 * @property {Number} Diamond              Diamond.
 * @property {Number} Triangle             Triangle.
 * @property {Number} DTriangle            Down Triangle.
 * @property {Number} UTriangle            Up Triangle.
 * @property {Number} LTriangle            Left Triangle.
 * @property {Number} RTriangle            Right Triangle.
 * @property {Number} Cross                Cross.
 * @property {Number} XCross               X Cross.
 * @property {Number} HLine                Horizontal Line.
 * @property {Number} VLine                Vertical Line.
 * @property {Number} Star1                Star1.
 * @property {Number} Star2                Star2.
 * @property {Number} Hexagon              Hexagon.
 * @property {Number} Path                 The symbol is represented by a painter path, where the origin ( 0, 0 ) of the path coordinate system is mapped to the position of the symbol. See {@link Symbol2#setPinPoint setPinPoint()}
 * @property {Number} Pixmap               The symbol is represented by a pixmap. The pixmap is centered or aligned to its pin point. See {@link Symbol2#setPinPoint setPinPoint()}
 * @property {Number} MGraphic             The symbol is represented by a graphic. The graphic is centered or aligned to its pin point. See {@link Symbol2#setPinPoint setPinPoint()}
 * @property {Number} SvgDocument          The symbol is represented by a SVG graphic. The graphic is centered or aligned to its pin point. See {@link Symbol2#setPinPoint setPinPoint()}
 * @property {Number} UserStyle            UserStyle = 1000.
 */
Enumerator.enum(
  "Style {NoSymbol = -1, Ellipse, MRect, Diamond, Triangle, DTriangle, UTriangle, LTriangle, \
    RTriangle, Cross, XCross, HLine, \
    VLine, Star1, Star2, Hexagon, Path, Pixmap, MGraphic, SvgDocument, UserStyle = 1000;}",
  Symbol2
);

/**
 * This class adds rotation to Path symbols. They are intended to be the base class for symbols that are rotatable.
 * @extends Symbol2
 */
class RotatableSymbol extends Symbol2 {
  construction(angle) {
    this.path().data.rotation = angle;
  }

  /**
   *
   * @returns {Number} Clockwise rotation in degrees
   */
  rotation() {
    return this.path().data.rotation;
  }

  /**
   * Sets the clockwise rotation in degrees.
   *
   * Rotation is about the pin point.
   * @param {number} val Clockwise rotation in degrees
   */
  setRotation(val) {
    this.path().data.rotation = val;
  }
}

/**
 * An arrow symbol
 * @extends  RotatableSymbol
 */
class PointMarkerSymbol extends Symbol2 {
  constructor(angle = 0) {
    super();
    var self = this;
    self.setStyle(Symbol2.Style.Ellipse);
    let m_pointType = "Turning point:";
    self.type = "pointMarker";
    self.setPen(new Misc.Pen("red", 2));
    self.setBrush(new Misc.Brush("rgba(0,255,255)"));
    // var path = new Misc.MPath();
    // path.moveTo(13, 30); //a
    // path.lineTo(13, 15); //b
    // path.lineTo(10, 15); //c
    // path.lineTo(7, 9.8); //d
    // path.lineTo(10, 4.6); //e
    // path.lineTo(16, 4.6); //f
    // path.lineTo(19, 9.8); //g
    // path.lineTo(16, 15); //h
    // path.lineTo(13, 15); //b.. for close
    // path.data.rotation = angle;
    // self.setPath(path);
    // self.setPinPoint(new Misc.Point(13, 9.8));

    this.pointType = function () {
      return m_pointType;
    };

    this.setPointType = function (pointType) {
      m_pointType = pointType;
    };
  }
  toString() {
    return "[PointMarkerSymbol]";
  }
}

/**
 * An arrow symbol
 * @extends  RotatableSymbol
 */
class PointMarkerSymbol2 extends RotatableSymbol {
  constructor(angle = 0) {
    super();
    var self = this;
    let m_pointType = "Turning point:";
    self.type = "pointMarker";
    self.setPen(new Misc.Pen("red", 2));
    self.setBrush(new Misc.Brush("rgba(0,255,255)"));
    var path = new Misc.MPath();
    path.moveTo(13, 30); //a
    path.lineTo(13, 15); //b
    path.lineTo(10, 15); //c
    path.lineTo(7, 9.8); //d
    path.lineTo(10, 4.6); //e
    path.lineTo(16, 4.6); //f
    path.lineTo(19, 9.8); //g
    path.lineTo(16, 15); //h
    path.lineTo(13, 15); //b.. for close
    path.data.rotation = angle;
    self.setPath(path);
    self.setPinPoint(new Misc.Point(13, 9.8));

    this.pointType = function () {
      return m_pointType;
    };

    this.setPointType = function (pointType) {
      m_pointType = pointType;
    };
  }
  toString() {
    return "[PointMarkerSymbol2]";
  }
}

/**
 * An arrow symbol
 * @extends  RotatableSymbol
 */
class ArrowSymbol extends RotatableSymbol {
  constructor(angle = 0) {
    super();
    var self = this;
    self.type = "arrow";
    self.setPen(new Misc.Pen("black"));
    self.setBrush(new Misc.Brush("red"));
    var path = new Misc.MPath();
    path.moveTo(13, 30);
    path.lineTo(13, 15);
    path.lineTo(10, 15);
    path.lineTo(13, 10);
    path.lineTo(16, 15);
    path.lineTo(13, 15);
    path.data.rotation = angle;
    self.setPath(path);
    self.setPinPoint(new Misc.Point(13, 10));
  }
  toString() {
    return "[ArrowSymbol]";
  }
}

/**
 * A symbol comprising of a line with a square dot at the front end
 * @extends  RotatableSymbol
 */
class DotOnLineSymbol extends RotatableSymbol {
  constructor(angle = 0) {
    super();
    var self = this;
    self.type = "dotOnLine";
    self.setPen(new Misc.Pen("black"));
    self.setBrush(new Misc.Brush("red"));
    var path = new Misc.MPath();
    path.moveTo(13, 30);
    path.lineTo(13, 15);
    path.addRect(new Misc.Rect(10, 9, 6, 6));
    path.data.rotation = angle;
    self.setPath(path);
    self.setPinPoint(new Misc.Point(14, 13));
    self.setSize(new Misc.Size(6, 23));
  }
}
;
define("symbol", ["static","graphic"], function(){});



"include ['static','watch', 'plotMarker', 'symbol']";

Static.accuracyFactorModerate = /* 0.004 */ 1; //moderate
Static.accuracyFactor = Static.accuracyFactorModerate;
Static.watchUpdateError = false;
Static.showWatchUpdateError = true;

Static.total_area = 0;
Static.total_volume = 0;

class CGMarker extends PlotMarker {
  constructor() {
    super("cgMarker@12345");
    var self = this;

    class CGSymbol extends Symbol2 {
      constructor() {
        super();
        var self = this;
        self.type = "arrow";
        self.setPen(new Misc.Pen("black", 2));
        self.setBrush(new Misc.Brush("red"));
        var path = new Misc.MPath();
        path.moveTo(5, 10);
        path.lineTo(5, 0);
        path.moveTo(0, 5);
        path.lineTo(10, 5);
        // path.lineTo( 13, 10 );
        // path.lineTo( 16, 15 );
        // path.lineTo( 13, 15 );
        //path.data.rotation = $("#marker_symbolAngle").val();
        self.setPath(path);
        self.setPinPoint(new Misc.Point(6, 6));
        self.setSize(new Misc.Size(12, 12));
      }
    }
    self.setSymbol(new CGSymbol());
    self.setLabel("CG");
    self.setLabelAlignment(Static.AlignCenter | Static.AlignBottom);

    var areaWatchEnabled = false;
    const watchEnabledCb = function (e, watch, on) {
      if (watch.name() === "Area below curve") {
        self.setVisible(on);
        areaWatchEnabled = on;
      }
    };
    Static.bind("watchEnabled", watchEnabledCb);

    const showSidebarCb = function (e, anchorPosition, on) {
      if (on && areaWatchEnabled) self.setVisible(true);
      else self.setVisible(false);
    };
    Static.bind("showSidebar", showSidebarCb);

    const axisChangedCb = function (e, axis, curve) {
      if (curve != undefined) self.setAxes(curve.xAxis(), curve.yAxis());
    };
    Static.bind("axisChanged", axisChangedCb);

    const currentCurveChangedCb = function (e, curve) {
      if (curve != undefined) self.setAxes(curve.xAxis(), curve.yAxis());
    };
    Static.bind("currentCurveChanged", currentCurveChangedCb);

    this.cleanUp = function () {
      // Static.unbind("watchEnabled", watchEnabledCb);
      // Static.unbind("showSidebar", showSidebarCb);
      // Static.unbind("axisChanged", axisChangedCb);
      // Static.unbind("currentCurveChanged", currentCurveChangedCb);
    };
  }

  delete() {
    this.cleanUp();
  }
}

class WatchCurveName extends Watch {
  constructor(rulerGroup) {
    super(rulerGroup);
    this.name = function () {
      return "Curve name";
    };
    this.computeWatch = function () {
      Static.watchUpdateError = false;
      if (this._value !== this._curveName) {
        this._update = true;
        this._value = this._curveName;
      } else {
        this._update = false;
      }
      this._curve = 0;
    };
  }
}

class WatchLeftRulerPosition extends Watch {
  constructor(rulerGroup) {
    super(rulerGroup);
    var self = this;
    this.name = function () {
      return "Left ruler position";
    };
    this.valueType = "number";
    this.computeWatch = function () {
      if (!this._curve.plot()) return;
      Static.watchUpdateError = false;
      this._update = true;

      if (this._rulerLeft == Number.MAX_VALUE) this._value = "Invalid";
      else {
        //this._value = this._rulerLeft// = Utility.adjustForDecimalPlaces(this._rulerLeft, this._curve.plot().axisDecimalPlaces(this._curve.xAxis()));
        this._value = Utility.adjustForDecimalPlaces(
          this._rulerLeft,
          this._curve.plot().axisDecimalPlaces(this._curve.xAxis())
        ); //this._rulerLeft;
        if (isNaN(this._value)) Static.watchUpdateError = true;
        this._value = Utility.toPrecision(
          this._value,
          this._curve.plot().axisPrecision(this._curve.xAxis())
        );
      }
      this._curve = 0;
    };
    this.cb = function () {
      var prevValue = self._value;
      var pos = self._rulerGroup.setPosition(0, $(this).val());
      /* setPosition() returns the actual position set. Because of validation, this may be different than the argument passed to setPosition() */
      if (prevValue !== pos) {
        Static.trigger("positionChanged", [self._rulerGroup.ruler(0), pos]);
      } else {
        $(this).val(pos);
      }
    };
  }
}

class WatchRightRulerPosition extends Watch {
  constructor(rulerGroup) {
    super(rulerGroup);
    var self = this;

    this.name = function () {
      return "Right ruler position";
    };
    this.valueType = "number";
    this.computeWatch = function () {
      if (!this._curve.plot()) return;
      Static.watchUpdateError = false;
      this._update = true;

      if (this._rulerRight == Number.MAX_VALUE) this._value = "Invalid";
      else {
        //this._value = this._rulerRight //= Utility.adjustForDecimalPlaces(this._rulerRight, this._curve.plot().axisDecimalPlaces(this._curve.xAxis()));
        this._value = Utility.adjustForDecimalPlaces(
          this._rulerRight,
          this._curve.plot().axisDecimalPlaces(this._curve.xAxis())
        ); //this._rulerRight;
        if (isNaN(this._value)) Static.watchUpdateError = true;
        this._value = Utility.toPrecision(
          this._value,
          this._curve.plot().axisPrecision(this._curve.xAxis())
        );
      }
      this._curve = 0;
    };
    this.cb = function () {
      var prevValue = self._value;
      var pos = self._rulerGroup.setPosition(1, $(this).val());
      /* setPosition() returns the actual position set. Because of validation, this may be different than the argument passed to setPosition() */
      //$(this).val(pos);
      //Static.trigger("positionChanged", [self._rulerGroup.ruler(1), pos]);

      if (prevValue !== pos) {
        Static.trigger("positionChanged", [self._rulerGroup.ruler(1), pos]);
      } else {
        $(this).val(pos);
      }
    };
  }
}

class WatchBottomRulerPosition extends Watch {
  constructor(rulerGroup) {
    super(rulerGroup);
    var self = this;
    this.valueType = "number";
    this.name = function () {
      return "Bottom ruler position";
    };
    this.computeWatch = function () {
      if (!this._curve.plot()) return;
      Static.watchUpdateError = false;
      this._update = true;

      if (this._rulerBottom == Number.MAX_VALUE) this._value = "Invalid";
      else {
        this._value = Utility.adjustForDecimalPlaces(
          this._rulerBottom,
          this._curve.plot().axisDecimalPlaces(this._curve.xAxis())
        ); //this._rulerBottom;
        if (isNaN(this._value)) Static.watchUpdateError = true;
        this._value = Utility.toPrecision(
          this._value,
          this._curve.plot().axisPrecision(this._curve.yAxis())
        );
      }
      this._curve = 0;
    };
    this.cb = function () {
      var prevValue = self._value;
      var pos = self._rulerGroup.setPosition(2, $(this).val());
      /* setPosition() returns the actual position set. Because of validation, this may be different than the argument passed to setPosition() */
      if (prevValue !== pos) {
        Static.trigger("positionChanged", [self._rulerGroup.ruler(2), pos]);
      } else {
        $(this).val(pos);
      }
    };
  }
}

class WatchTopRulerPosition extends Watch {
  constructor(rulerGroup) {
    super(rulerGroup);
    var self = this;
    this.valueType = "number";
    this.name = function () {
      return "Top ruler position";
    };
    this.computeWatch = function () {
      if (!this._curve.plot()) return;
      Static.watchUpdateError = false;
      this._update = true;

      if (this._rulerTop == Number.MAX_VALUE) this._value = "Invalid";
      else {
        this._value = Utility.adjustForDecimalPlaces(
          this._rulerTop,
          this._curve.plot().axisDecimalPlaces(this._curve.xAxis())
        ); //this._rulerTop;
        if (isNaN(this._value)) Static.watchUpdateError = true;
        this._value = Utility.toPrecision(
          this._value,
          this._curve.plot().axisPrecision(this._curve.yAxis())
        );
      }
      this._curve = 0;
    };
    this.cb = function () {
      var prevValue = self._value;
      var pos = self._rulerGroup.setPosition(3, $(this).val());
      /* setPosition() returns the actual position set. Because of validation, this may be different than the argument passed to setPosition() */
      if (prevValue !== pos) {
        Static.trigger("positionChanged", [self._rulerGroup.ruler(3), pos]);
      } else {
        $(this).val(pos);
      }
    };
  }
}

class WatchSlope extends Watch {
  constructor(rulerGroup) {
    super(rulerGroup);
    this.name = function () {
      return "Slope at left ruler";
    };
    this.computeWatch = function () {
      if (!this._curve.plot()) return;
      Static.watchUpdateError = false;
      if (
        self._magnifying == true ||
        this._rulerLeft == this._rulerLeftPrevious
      ) {
        this._update = false;
        this._curve = 0;
        return;
      }
      this._update = true;
      let m_value = 0;
      var precisionY = this._curve.plot().axisPrecision(this._curve.yAxis());
      var precisionX = this._curve.plot().axisPrecision(this._curve.xAxis());

      var decimalPlacesY = this._curve
        .plot()
        .axisDecimalPlaces(this._curve.yAxis());
      var decimalPlacesX = this._curve
        .plot()
        .axisDecimalPlaces(this._curve.xAxis());

      let _rulerLeft = (this._rulerLeftPrevious = this._rulerLeft);
      //Pre-calculation adjustment
      _rulerLeft = Utility.adjustForDecimalPlaces(_rulerLeft, decimalPlacesX);

      if (this._rulerLeft == Number.MAX_VALUE || !isFinite(this._rulerLeft))
        this._value = "Invalid";
      else {
        if (this._curve.expandedFn && !this._curve.expandedFn.includes("log")) {
          var fn = this._curve.expandedFn;
          if (this._curve.variable != "z") {
            while (fn.indexOf(this._curve.variable) != -1) {
              fn = fn.replace(this._curve.variable, "z");
            }
          }
          if (this._curve.coeffs) {
            for (var i = 0; i < this._curve.coeffs.length; ++i) {
              while (fn.indexOf(this._curve.coeffs[i]) != -1) {
                fn = fn.replace(
                  this._curve.coeffs[i],
                  this._curve.coeffsVal[i]
                );
              }
            }
          }
          this._value = math.derivative(fn, "z").evaluate({
            z: _rulerLeft,
          });
          this._value = Utility.adjustForDecimalPlaces(
            this._value,
            Math.max(decimalPlacesX, decimalPlacesY)
          );
          if (isNaN(this._value)) Static.watchUpdateError = true;
          this._value = Utility.toPrecision(
            this._value,
            Math.min(precisionX, precisionY)
          );
          this._curve = 0;
          return;
        }
        var numOfPoints = this._curve.dataSize();
        var x = this._rulerLeft;
        for (var i = 1; i < numOfPoints; ++i) {
          if (this._curve.sample(i).x > x) {
            var p2 = this._curve.sample(i);
            var p1 = this._curve.sample(i - 1);
            this._value = (p2.y - p1.y) / (p2.x - p1.x);

            this._value = Utility.adjustForDecimalPlaces(
              this._value,
              Math.max(decimalPlacesX, decimalPlacesY)
            );
            if (isNaN(this._value)) Static.watchUpdateError = true;
            this._value = Utility.toPrecision(
              this._value,
              Math.min(precisionX, precisionY)
            );
            this._curve = 0;
            return;
          }
        }
      }
      this._curve = 0;
    };
  }
}

class WatchAreaBelowCurve extends Watch {
  constructor(rulerGroup) {
    super(rulerGroup);

    var self = this;
    var cgMarker = null; //new CGMarker();
    var plot = null; //this._curve.plot();

    this.name = function () {
      return "Area below curve";
    };
    var set = 0;
    this.computeWatch = function () {
      if (!this._curve.plot()) return;
      Static.watchUpdateError = false;
      var autoReplot = this._curve.plot().autoReplot();
      this._curve.plot().setAutoReplot(false);
      if (
        self._magnifying == true ||
        (this._rulerLeft == this._rulerLeftPrevious &&
          this._rulerRight == this._rulerRightPrevious)
      ) {
        //self._magnifying = false;
        this._update = false;
        //this._curve = 0;
        return;
      }

      this._update = true;

      let m_value = 0;
      var precisionY = this._curve.plot().axisPrecision(this._curve.yAxis());
      var precisionX = this._curve.plot().axisPrecision(this._curve.xAxis());
      const precision = Math.min(precisionX, precisionY);

      var decimalPlacesY = this._curve
        .plot()
        .axisDecimalPlaces(this._curve.yAxis());
      var decimalPlacesX = this._curve
        .plot()
        .axisDecimalPlaces(this._curve.xAxis());

      let _rulerLeft = (this._rulerLeftPrevious = this._rulerLeft);
      let _rulerRight = (this._rulerRightPrevious = this._rulerRight);
      //Pre-calculation adjustment
      _rulerLeft = Utility.adjustForDecimalPlaces(_rulerLeft, decimalPlacesX);
      _rulerRight = Utility.adjustForDecimalPlaces(_rulerRight, decimalPlacesX);

      var widthPx =
        this._curve.plot().transform(this._curve.xAxis(), _rulerRight) -
        this._curve.plot().transform(this._curve.xAxis(), _rulerLeft);
      const step = Math.abs(
        (Static.accuracyFactor * (_rulerRight - _rulerLeft)) / widthPx
      );
      //console.log("step:" + step);
      if (isNaN(step) || step === 0) {
        this._curve = 0;
        return;
      }

      //console.log(step)
      if (!cgMarker) {
        cgMarker = new CGMarker();
        cgMarker.setAxes(this._curve.xAxis(), this._curve.yAxis());
        plot = this._curve.plot();
        cgMarker.attach(plot);
      }

      if (
        _rulerLeft == Number.MAX_VALUE ||
        !isFinite(_rulerLeft) ||
        _rulerRight == Number.MAX_VALUE ||
        !isFinite(_rulerRight)
      )
        this._value = "Invalid";
      else {
        if (this._curve.expandedFn) {
          var fn = this._curve.expandedFn;
          fn = Utility.logBaseAdjust(fn);
          // if (this._curve.variable != "z") {
          //   while (fn.indexOf(this._curve.variable) != -1) {
          //     fn = fn.replace(this._curve.variable, "z");
          //   }
          // }
          if (this._curve.coeffs) {
            for (var i = 0; i < this._curve.coeffs.length; ++i) {
              while (fn.indexOf(this._curve.coeffs[i]) != -1) {
                fn = fn.replace(
                  this._curve.coeffs[i],
                  this._curve.coeffsVal[i]
                );
              }
            }
          }

          if (_rulerLeft > _rulerRight) {
            var temp = _rulerLeft;
            _rulerLeft = _rulerRight;
            _rulerRight = temp;
          }

          this._value = math.evaluate(
            `integrate(${fn} , ${this._curve.variable}, ${_rulerLeft}, ${_rulerRight}, false, ${step})`
          );

          var twoAbarY = math.evaluate(
            `integrate((${fn})^2 , ${this._curve.variable}, ${_rulerLeft}, ${_rulerRight}, false, ${step})`
          );

          var AbarX = math.evaluate(
            `integrate(${this._curve.variable}*(${fn}) , ${this._curve.variable}, ${_rulerLeft}, ${_rulerRight}, false, ${step})`
          );

          // var twoAbarY = math.evaluate(
          //   "integrate(" +
          //     "((" +
          //     fn +
          //     ")" +
          //     "*" +
          //     "(" +
          //     fn +
          //     "))" +
          //     ", z," +
          //     _rulerLeft +
          //     "," +
          //     _rulerRight +
          //     ",false," +
          //     step +
          //     ")"
          // );
          // var AbarX = math.evaluate(
          //   "integrate(" +
          //     "z * (" +
          //     fn +
          //     ")" +
          //     ", z," +
          //     _rulerLeft +
          //     "," +
          //     _rulerRight +
          //     ",false," +
          //     step +
          //     ")"
          // );
          m_value = this._value;

          this._value = Utility.adjustForDecimalPlaces(
            this._value,
            decimalPlacesX + decimalPlacesY
          );
          if (isNaN(this._value)) Static.watchUpdateError = true;
          this._value = Utility.toPrecision(this._value, precision);

          var barY = Utility.adjustForDecimalPlaces(
            twoAbarY / (2 * m_value),
            decimalPlacesY
          );
          if (isNaN(barY)) Static.watchUpdateError = true;
          barY = Utility.toPrecision(barY, precisionY);
          //console.log(decimalPlacesX);
          var barX = Utility.adjustForDecimalPlaces(
            AbarX / m_value,
            decimalPlacesX
          );
          if (isNaN(barX)) Static.watchUpdateError = true;
          barX = Utility.toPrecision(barX, precisionX);

          if (Static.watchCentroidWithArea) {
            if (this._value == 0) {
              barX = barY = "Infinity";
            }
            this._value += " centroid:(" + barX + ", " + barY + ")";
            cgMarker.setValue(barX, barY);
            cgMarker.setVisible(true);
          } else {
            cgMarker.setVisible(false);
          }

          if (!this._curve || !this._curve.plot()) return;
          this._curve.plot().setAutoReplot(autoReplot);
          this._curve.plot().autoRefresh();
          this._curve = 0;
          return;
        }
        if (!this._curve) return;
        var numOfPoints = this._curve.dataSize();
        this._value = 0;
        var twoAbarY = 0;
        var AbarX = 0;

        for (var i = 1; i < numOfPoints; ++i) {
          var p2 = this._curve.sample(i); //point to right of the left ruler
          var p1 = this._curve.sample(i - 1); //point to left of (or at) the
          var fn = Utility.linearEquationFromPoints(p1, p2);
          var left = p1.x;
          if (p2.x < _rulerLeft) continue;
          if (p1.x > _rulerRight) continue;
          if (left < _rulerLeft) left = _rulerLeft;
          var right = p2.x;
          if (right > _rulerRight) right = _rulerRight;
          this._value += math.evaluate(
            "integrate(" +
              fn +
              ", x," +
              left +
              "," +
              right +
              ",false," +
              step +
              ")"
          );
          twoAbarY += math.evaluate(
            "integrate(" +
              "((" +
              fn +
              ")" +
              "*" +
              "(" +
              fn +
              "))" +
              ", x," +
              left +
              "," +
              right +
              ",false," +
              step +
              ")"
          );
          AbarX += math.evaluate(
            "integrate(" +
              "x * (" +
              fn +
              ")" +
              ", x," +
              left +
              "," +
              right +
              ",false," +
              step +
              ")"
          );
        }

        m_value = this._value;
        this._value = Utility.adjustForDecimalPlaces(
          this._value,
          decimalPlacesX + decimalPlacesY
        );
        if (isNaN(this._value)) Static.watchUpdateError = true;
        this._value = Utility.toPrecision(this._value, precision);
        var barY = Utility.adjustForDecimalPlaces(
          twoAbarY / (2 * m_value),
          decimalPlacesY
        );
        if (isNaN(barY)) Static.watchUpdateError = true;
        var barX = Utility.adjustForDecimalPlaces(
          AbarX / m_value,
          decimalPlacesX
        );
        if (isNaN(barX)) Static.watchUpdateError = true;
        barY = Utility.toPrecision(barY, precisionY);
        barX = Utility.toPrecision(barX, precisionX);

        if (Static.watchCentroidWithArea) {
          if (this._value == 0) {
            barX = barY = "Infinity";
          }
          this._value += " centroid:(" + barX + ", " + barY + ")";
          cgMarker.setValue(barX, barY);
          cgMarker.setVisible(true);
        } else {
          cgMarker.setVisible(false);
        }
      }
      if (!this._curve || !this._curve.plot()) return;
      this._curve.plot().setAutoReplot(autoReplot);
      this._curve.plot().autoRefresh();
      this._curve = 0;
    };
  }
}

class WatchVolumeOfRevolution extends Watch {
  constructor(rulerGroup) {
    super(rulerGroup);
    var self = this;
    function getvolume(y1, y2, w) {
      var volume = y1 * w * Math.PI * y1;
      volume =
        volume + 0.5 * (y2 - y1) * w * (y1 + (y2 - y1) / 3) * 2 * Math.PI;
      //this._curve = 0;
      return volume;
    }
    this.name = function () {
      return "Volume of revolution";
    };
    this.computeWatch = function () {
      if (!this._curve.plot()) return;
      Static.watchUpdateError = false;
      if (
        self._magnifying == true ||
        (this._rulerLeft == this._rulerLeftPrevious &&
          this._rulerRight == this._rulerRightPrevious)
      ) {
        this._update = false;
        this._curve = 0;
        return;
      }
      this._update = true;
      var precisionY = this._curve.plot().axisPrecision(this._curve.yAxis());
      var precisionX = this._curve.plot().axisPrecision(this._curve.xAxis());
      const precision = Math.min(precisionX, precisionY);

      var decimalPlacesY = this._curve
        .plot()
        .axisDecimalPlaces(this._curve.yAxis());
      var decimalPlacesX = this._curve
        .plot()
        .axisDecimalPlaces(this._curve.xAxis());
      // var step = Static.calcStep(this._curve);

      let _rulerLeft = (this._rulerLeftPrevious = this._rulerLeft);
      let _rulerRight = (this._rulerRightPrevious = this._rulerRight);

      //Pre-calculation adjustment
      _rulerLeft = Utility.adjustForDecimalPlaces(_rulerLeft, decimalPlacesX);
      _rulerRight = Utility.adjustForDecimalPlaces(_rulerRight, decimalPlacesX);

      var widthPx =
        this._curve.plot().transform(this._curve.xAxis(), _rulerRight) -
        this._curve.plot().transform(this._curve.xAxis(), _rulerLeft);
      const step = Math.abs(
        (Static.accuracyFactor * (_rulerRight - _rulerLeft)) / widthPx
      );
      if (isNaN(step) || step === 0) {
        //console.log(step);
        this._curve = 0;
        return;
      }

      if (this._rulerLeft == Number.MAX_VALUE || !isFinite(this._rulerLeft))
        this._value = "Invalid";
      else {
        if (this._curve.expandedFn) {
          var fn = this._curve.expandedFn;
          fn = Utility.logBaseAdjust(fn);
          if (this._curve.variable != "x") {
            while (fn.indexOf(this._curve.variable) != -1) {
              fn = fn.replace(this._curve.variable, "x");
            }
          }
          if (this._curve.coeffs) {
            for (var i = 0; i < this._curve.coeffs.length; ++i) {
              while (fn.indexOf(this._curve.coeffs[i]) != -1) {
                fn = fn.replace(
                  this._curve.coeffs[i],
                  this._curve.coeffsVal[i]
                );
              }
            }
          }

          if (_rulerLeft > _rulerRight) {
            var temp = _rulerLeft;
            _rulerLeft = _rulerRight;
            _rulerRight = temp;
          }
          //var decimalPlaces = 2 * this._curve.plot().axisDecimalPlaces(this._curve.yAxis()) + this._curve.plot().axisDecimalPlaces(this._curve.xAxis());
          //var step = Static.calcStep(this._curve);
          this._value = math.evaluate(
            `integrate(${fn} , ${this._curve.variable}, ${_rulerLeft}, ${_rulerRight}, true, ${step})`
          );
          // this._value = math.evaluate(
          //   "integrate(" +
          //     fn +
          //     ", x," +
          //     _rulerLeft +
          //     "," +
          //     _rulerRight +
          //     ",true," +
          //     step +
          //     ")"
          // );
          this._value = Utility.adjustForDecimalPlaces(
            this._value,
            decimalPlacesX + 2 * decimalPlacesY
          );
          if (isNaN(this._value)) Static.watchUpdateError = true;
          this._value = Utility.toPrecision(this._value, precision);

          if (isNaN(this._value)) this._value = "< 1E-300";
          this._curve = 0;
          return;
        }
        var numOfPoints = this._curve.dataSize();
        var xLeft = this._rulerLeft;
        var xRight = this._rulerRight;
        var A0 = 0;
        var An = 0;
        var Ai = 0;
        for (var i = 1; i < numOfPoints; ++i) {
          var p2 = this._curve.sample(i); //point to right of the left ruler
          var p1 = this._curve.sample(i - 1); //point to left of (or at) the
          if (!A0 && p2.x > xLeft && p2.x <= xRight) {
            var y = p1.y + ((p2.y - p1.y) * (xLeft - p1.x)) / (p2.x - p1.x); //point to left of (or at) the left ruler
            A0 = getvolume(y, p2.y, p2.x - xLeft);
            continue;
          }
          if (A0 && p2.x <= xRight) {
            Ai += getvolume(p2.y, p1.y, p2.x - p1.x);
            continue;
          }
          if (p2.x > xRight) {
            if (p1.x >= xLeft) {
              var y = p2.y + ((p2.y - p1.y) * (xRight - p2.x)) / (p2.x - p1.x);
              An = getvolume(y, p1.y, xRight - p1.x);
              break;
            } else {
              var y2 = p2.y + ((p2.y - p1.y) * (xRight - p2.x)) / (p2.x - p1.x);
              var y1 = p1.y + ((p2.y - p1.y) * (xLeft - p1.x)) / (p2.x - p1.x);
              An = getvolume(y2, y1, xRight - xLeft);
              break;
            }
          }
        }
        //var decimalPlaces = 2 * this._curve.plot().axisDecimalPlaces(this._curve.yAxis()) + this._curve.plot().axisDecimalPlaces(this._curve.xAxis());
        this._value = Utility.adjustForDecimalPlaces(
          A0 + Ai + An,
          decimalPlacesY + 2 * decimalPlacesX
        );
        if (isNaN(this._value)) Static.watchUpdateError = true;
        this._value = Utility.toPrecision(this._value, precision);

        if (isNaN(this._value)) this._value = "< 1E-300";
      }
      this._curve = 0;
    };
  }
}
;
define("basicWatch", ["static","watch","plotMarker","symbol"], function(){});

"include ['static','contextMenu']";


class LegendMenu {
  constructor(plot) {
    var self = this;
    var el = null;
    var table = null;
    let m_curve = null;

    var penWidthSubMenu = [
      {
        name: "1",
        //img:'images/top.png',
        fun: function () {
          if (
            m_curve &&
            m_curve.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve
          ) {
            m_curve.setPenWidth(1);
            Static.trigger("penAttributeChanged", m_curve);
            return;
          }
          if (!m_curve || m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
            return;
          var pen = m_curve.pen();
          pen.width = 1;
          m_curve.setPen(pen);
          Static.trigger("penAttributeChanged", m_curve);
        },
      },
      {
        name: "2",
        //img:'images/top.png',
        fun: function () {
          if (
            m_curve &&
            m_curve.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve
          ) {
            m_curve.setPenWidth(2);
            Static.trigger("penAttributeChanged", m_curve);
            return;
          }
          if (!m_curve || m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
            return;
          var pen = m_curve.pen();
          pen.width = 2;
          m_curve.setPen(pen);
          Static.trigger("penAttributeChanged", m_curve);
        },
      },
      {
        name: "3",
        //img:'images/all.png',
        fun: function () {
          if (
            m_curve &&
            m_curve.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve
          ) {
            m_curve.setPenWidth(3);
            Static.trigger("penAttributeChanged", m_curve);
            return;
          }
          if (!m_curve || m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
            return;
          var pen = m_curve.pen();
          pen.width = 3;
          m_curve.setPen(pen);
          Static.trigger("penAttributeChanged", m_curve);
        },
      },
      {
        name: "4",
        //img:'images/all.png',
        fun: function () {
          if (
            m_curve &&
            m_curve.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve
          ) {
            m_curve.setPenWidth(4);
            Static.trigger("penAttributeChanged", m_curve);
            return;
          }
          if (!m_curve || m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
            return;
          var pen = m_curve.pen();
          pen.width = 4;
          m_curve.setPen(pen);
          Static.trigger("penAttributeChanged", m_curve);
        },
      },
      {
        name: "5",
        //img:'images/all.png',
        fun: function () {
          if (
            m_curve &&
            m_curve.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve
          ) {
            m_curve.setPenWidth(5);
            Static.trigger("penAttributeChanged", m_curve);
            return;
          }
          if (!m_curve || m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
            return;
          var pen = m_curve.pen();
          pen.width = 5;
          m_curve.setPen(pen);
          Static.trigger("penAttributeChanged", m_curve);
        },
      },
    ];

    this.getPenWidthSubMenu = function () {
      return penWidthSubMenu;
    };

    var penSubMenu = [
      {
        name: "color",
        fun: function () {
          var colorSelector = $('<input type="color" style="opacity:0;">');

          if (!m_curve || m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve)
            return;
          colorSelector.val(Utility.colorNameToHex(m_curve.pen().color));
          colorSelector.change(function () {
            var pen = m_curve.pen();
            pen.color = $(this).val();
            m_curve.setPen(pen);
            Static.trigger("penAttributeChanged", m_curve);
            colorSelector.remove();
          });
          colorSelector.trigger("click");
        },
      },

      /*style
        solid
        dash : ctx.setLineDash([10, 5])
        dashDot : ctx.setLineDash([12, 5, 3, 5])
        dashDotDot : ctx.setLineDash([12, 5, 3, 5, 3, 5])
        dot : ctx.setLineDash([2, 8])
         */

      {
        name: "line style",
        //title: 'It will replace row',
        //img:'images/replace.png',
        subMenu: [
          {
            name: "solid",
            //img:'images/top.png',
            fun: function () {
              if (
                !m_curve ||
                m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve
              )
                return;
              var pen = m_curve.pen();
              pen.style = "solid";
              m_curve.setPen(pen);
              Static.trigger("penAttributeChanged", m_curve);
            },
          },
          {
            name: "dot",
            //img:'images/top.png',
            fun: function () {
              if (
                !m_curve ||
                m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve
              )
                return;
              var pen = m_curve.pen();
              pen.style = "dot";
              m_curve.setPen(pen);
              Static.trigger("penAttributeChanged", m_curve);
            },
          },
          {
            name: "dash",
            //img:'images/all.png',
            fun: function () {
              if (
                !m_curve ||
                m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve
              )
                return;
              var pen = m_curve.pen();
              pen.style = "dash";
              m_curve.setPen(pen);
              Static.trigger("penAttributeChanged", m_curve);
            },
          },
          {
            name: "dashDot",
            //img:'images/all.png',
            fun: function () {
              if (
                !m_curve ||
                m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve
              )
                return;
              var pen = m_curve.pen();
              pen.style = "dashDot";
              m_curve.setPen(pen);
              Static.trigger("penAttributeChanged", m_curve);
            },
          },
          {
            name: "dashDotDot",
            //img:'images/all.png',
            fun: function () {
              if (
                !m_curve ||
                m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve
              )
                return;
              var pen = m_curve.pen();
              pen.style = "dashDotDot";
              m_curve.setPen(pen);
              Static.trigger("penAttributeChanged", m_curve);
            },
          },
        ],
      },
      {
        name: "pen width",
        //title: 'It will replace row',
        //img:'images/replace.png',
        subMenu: penWidthSubMenu, //
      },
    ];

    this.getPenSubMenu = function () {
      return penSubMenu;
    };

    /////////////submenu1///////////////////
    var subMenu1 = [
      /*style
            solid
            dash : ctx.setLineDash([10, 5])
            dashDot : ctx.setLineDash([12, 5, 3, 5])
            dashDotDot : ctx.setLineDash([12, 5, 3, 5, 3, 5])
            dot : ctx.setLineDash([2, 8])
             */

      {
        name: "style",
        //title: 'It will replace row',
        //img:'images/replace.png',
        subMenu: [
          {
            name: "Rectangle",
            //img:'images/top.png',
            fun: function () {
              //Utility.addSymbol(getCurve(), Symbol2.Style.MRect);
              Utility.addSymbol(m_curve, Symbol2.Style.MRect);
            },
          },
          {
            name: "Cross",
            //img:'images/top.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.Cross);
            },
          },
          {
            name: "Diamond",
            //img:'images/all.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.Diamond);
            },
          },
          {
            name: "Ellipse",
            //img:'images/all.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.Ellipse);
            },
          },
          {
            name: "Diagonal cross",
            //img:'images/all.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.XCross);
            },
          },
          /*,{
                    name: 'Triangle',
                    //img:'images/all.png',
                    fun:function(){
                    Utility.addSymbol(m_curve, Triangle)
                    }
                    }*/
          {
            name: "None",
            //img:'images/all.png',
            fun: function () {
              if (
                !m_curve ||
                m_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve
              )
                return;
              m_curve.setSymbol(null);
            },
          },
        ],
      },
    ];
    ///////////////////////////////
    ////////////////////////////subMenu2
    var subMenu2 = [
      ///////////

      /*style
            solid
            dash : ctx.setLineDash([10, 5])
            dashDot : ctx.setLineDash([12, 5, 3, 5])
            dashDotDot : ctx.setLineDash([12, 5, 3, 5, 3, 5])
            dot : ctx.setLineDash([2, 8])
             */

      {
        name: "style",
        //title: 'It will replace row',
        //img:'images/replace.png',
        subMenu: [
          {
            name: "Rectangle",
            //img:'images/top.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.MRect);
            },
          },
          {
            name: "Cross",
            //img:'images/top.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.Cross);
            },
          },
          {
            name: "Diamond",
            //img:'images/all.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.Diamond);
            },
          },
          {
            name: "Ellipse",
            //img:'images/all.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.Ellipse);
            },
          },
          {
            name: "Diagonal cross",
            //img:'images/all.png',
            fun: function () {
              Utility.addSymbol(m_curve, Symbol2.Style.XCross);
            },
          },
          /*,{
                    name: 'Triangle',
                    //img:'images/all.png',
                    fun:function(){
                    Utility.addSymbol(m_curve, Triangle)
                    }
                    }*/
          {
            name: "None",
            //img:'images/all.png',
            fun: function () {
              if (!m_curve) return;
              //m_curve.setSymbol(null);
              Utility.addSymbol(m_curve, Symbol2.Style.NoSymbol);
            },
          },
        ],
      },
      {
        name: "size",
        subMenu: [
          {
            name: "5x5",
            fun: function () {
              Utility.setSymbolSize(m_curve, 5);
            },
          },
          {
            name: "6x6",
            fun: function () {
              Utility.setSymbolSize(m_curve, 6);
            },
          },
          {
            name: "8x8",
            fun: function () {
              Utility.setSymbolSize(m_curve, 8);
            },
          },
          {
            name: "10x10",
            fun: function () {
              Utility.setSymbolSize(m_curve, 10);
            },
          },
          {
            name: "12x12",
            fun: function () {
              Utility.setSymbolSize(m_curve, 12);
            },
          },
          {
            name: "15x15",
            fun: function () {
              Utility.setSymbolSize(m_curve, 15);
            },
          },
        ],
      },
      {
        name: "fill brush",
        //title: 'It will merge row',
        //img:'images/merge.png',
        //disable: true,
        fun: function () {
          var colorSelector = $('<input type="color" style="opacity:0;">');
          //self.el.append(colorSelector)

          if (!m_curve) return;
          var sym = m_curve.symbol();
          if (sym) {
            var brush = sym.brush();
            var c = brush.color;
            if (c == "noBrush") {
              c = "#000000";
            }
            colorSelector.val(Utility.colorNameToHex(c));
            colorSelector.change(function () {
              //console.log($(this).val())
              //console.log(el.text())
              //$(this).remove();

              //var pen = m_curve.pen()
              brush.color = $(this).val();
              sym.setBrush(brush);
              plot.autoRefresh();
              plot.updateLegend(m_curve);
              Static.trigger("symbolAttributeChanged", m_curve);
              colorSelector.remove();
            });
            colorSelector.trigger("click");
          }
        },
      },
      {
        name: "pen",
        //img: 'images/update.png',
        //title: 'update button',
        //disable: true,
        subMenu: [
          {
            name: "color",
            fun: function () {
              var colorSelector = $('<input type="color" style="opacity:0;">');

              if (!m_curve) return;
              var sym = m_curve.symbol();
              if (!sym) return;
              colorSelector.val(Utility.colorNameToHex(sym.pen().color));
              colorSelector.change(function () {
                var pen = sym.pen();
                pen.color = $(this).val();
                sym.setPen(pen);
                plot.autoRefresh();
                plot.updateLegend(m_curve);
                Static.trigger("symbolAttributeChanged", m_curve);
                colorSelector.remove();
              });
              colorSelector.trigger("click");
            },
          },
          {
            name: "pen width",
            subMenu: [
              {
                name: "1",
                fun: function () {
                  Utility.setSymbolPenWidth(m_curve, 1);
                },
              },
              {
                name: "2",
                fun: function () {
                  Utility.setSymbolPenWidth(m_curve, 2);
                },
              },
              {
                name: "3",
                fun: function () {
                  Utility.setSymbolPenWidth(m_curve, 3);
                },
              },
              {
                name: "4",
                fun: function () {
                  Utility.setSymbolPenWidth(m_curve, 4);
                },
              },
              {
                name: "5",
                fun: function () {
                  Utility.setSymbolPenWidth(m_curve, 5);
                },
              },
            ],
          },
        ],
      },
    ];

    var menu1 = [
      {
        pos: 0,
        name: "curve brush",
        img: "images/brush.png",
        title: "Set the fill color.",
        fun: function () {
          Utility.setCurveBrush(m_curve, function (curve) {
            Static.trigger("curveBrushChanged", curve);
          });
        },
      },
      {
        pos: 4,
        name: "remove",
        img: "images/trash.png",
        title: "Removes the curve from the plot.",
        fun: function () {
          if (!m_curve) return;
          plot.trashDlg.trash(m_curve);
          //m_curve.detach();
        },
      },
      {
        pos: 5,
        name: "rename",
        img: "images/rename.png",
        title: "Renames the curve.",
        fun: function () {
          if (!m_curve) return;
          Utility.curveRenameDlg(m_curve.title(), m_curve.plot());
        },
      },
      {
        pos: 7,
        name: "symbol",
        img: "images/symbol.png",
        title: "attach/modify curve symbol",
        subMenu: null,
      },
      {
        pos: 8,
        name: "pen",
        img: "images/pen.png",
        title: "modify/change curve pen",
        subMenu: penSubMenu,
      },
      {
        pos: 9,
        name: "copy",
        img: "images/copy.png",
        title: "Copy the curve.",
        fun: function () {
          if (!m_curve) return;
          Utility.copyCurve(m_curve);
        },
      },
    ];

    this.getCurve = function () {
      return m_curve;
    };

    var getCurve = function () {
      //el == span  if el == font el.parent().parent() == span
      if (el == undefined) {
        return null;
      }
      var txt = null;
      if (el && el[0] && el[0].tagName == "FONT") {
        txt = el.parent().parent().attr("curveName");
      } else {
        txt = el.attr("curveName");
      }
      return plot.findPlotCurve(txt);
    };

    var menuModificationCb = function () {};

    this.setMenuModificationCb = function (cb) {
      menuModificationCb = cb;
    };

    var initialize = function () {
      //plot, detachCb, curveFitCb) {
      var _menuItemName = "";

      function indexOfMenuItemCb(_name, legendMenu) {
        _menuItemName = _name;
        return legendMenu.findIndex(findIndexOfMenuItemCb);
      }

      function findIndexOfMenuItemCb(obj) {
        return obj.name == _menuItemName;
      }

      table = $(plot.getLayout().getLegendDiv().children()[0]);

      function doLegenMenu(x, y) {
        var res = [];

        var ele = document.elementFromPoint(x, y);
        while (ele && ele.tagName != "BODY" && ele.tagName != "HTML") {
          res.push(ele);
          ele.style.display = "none";
          ele = document.elementFromPoint(x, y);
        }
        for (var i = 0; i < res.length; i++) {
          res[i].style.display = "";
        }
        var _ele = null;
        for (var i = 0; i < res.length; i++) {
          if (res[i].tagName !== "LABEL" && res[i].tagName !== "FONT") continue;
          _ele = res[i];
          break;
        }
        //console.log(_ele)

        if (el && el.menuAppended !== undefined && el.menuAppended)
          el.contextMenu("destroy");
        el = $(_ele).parent();
        //el.menuAppended = true;
        m_curve = getCurve();
        if (!m_curve) return;
        menuModificationCb();
        var subMenuIndex = indexOfMenuItemCb("symbol", menu1);
        if (subMenuIndex > -1) {
          menu1[subMenuIndex].subMenu = subMenu1;
          if (
            m_curve &&
            m_curve.rtti == PlotItem.RttiValues.Rtti_PlotCurve &&
            m_curve.symbol()
          ) {
            menu1[subMenuIndex].subMenu = subMenu2;
          }
        }
        el.menuAppended = true;
        el.contextMenu(menu1, {
          triggerOn: "contextmenu",
          zIndex: 1,
          onClose: function (data, event) {
            m_curve = 0;
          },
        });
      }

      Static.bind("itemAttached", function (e, plotItem, on) {
        if (!on) m_curve = 0;
      });

      table.on("touchstart", function (e) {
        var x = e.originalEvent.touches[0].pageX;
        var y = e.originalEvent.touches[0].pageY;
        doLegenMenu(x, y);
      });

      table.on("mousedown", function (e) {
        if (!Static.isMobile && e.button != 2) {
          //not right button
          return;
        }
        var x = e.pageX;
        var y = e.pageY;
        doLegenMenu(x, y);
      });
    };

    function insertItems(list) {
      for (var i = 0; i < list.length; ++i) {
        var found = _.find(menu1, function (item) {
          return item.name == list[i].name;
        });
        if (found !== undefined) {
          //console.warn("Multiple menu items with name \"" + list[i].name + '"');
          continue;
        }
        menu1.push(list[i]);
      }
    }

    function sortItems() {
      menu1 = menu1.sort(function (a, b) {
        return a.pos - b.pos;
      });
    }

    function removeItemAtIndex(list, index) {
      if (index > -1) {
        list.splice(index, 1);
      }
    }

    this.modifyMenu = function (name, modificationDataObj) {
      if (name == null) {
        if (!_.isArray(modificationDataObj)) {
          var found = _.find(menu1, function (item) {
            return item.name == modificationDataObj.name;
          });
          if (found == undefined) {
            menu1.push(modificationDataObj);
          }
        } else {
          insertItems(modificationDataObj);
        }
        sortItems();
        return;
      }
      var index1 = -1;
      var menu1Item = _.find(menu1, function (item, ind) {
        index1 = ind;
        return item.name == name;
      });
      if (menu1Item == undefined) {
        return;
      }
      if (_.isEmpty(modificationDataObj)) {
        removeItemAtIndex(menu1, index1);
        return;
      }
      menu1Item.pos = modificationDataObj.pos || menu1Item.pos;
      menu1Item.name = modificationDataObj.name || menu1Item.name;
      menu1Item.img = modificationDataObj.img || menu1Item.img;
      menu1Item.title = modificationDataObj.title || menu1Item.title;
      menu1Item.fun = modificationDataObj.fun || menu1Item.fun;
      menu1 = sortItems(menu1);
    };

    if (plot.legend()) {
      initialize();
    } else {
      Static.bind("legendInserted", function () {
        initialize();
        Static.unbind("legendInserted");
      });
    }
  }
}
;
define("legendMenu", ["static"], function(){});


/**
 *
 * Every object has an {@link HObject#objectName objectName()}. HObjects can receive
 * events through {@link HObject#event event()} and filter the events of other objects.
 * @see {@link HObject#installEventFilter installEventFilter()}
 * @see  {@link HObject#eventFilter eventFilter()} for details.
 *
 *
 */
class HObject {
  /**
   *
   * @param {object} el jQuery element selector
   */
  constructor(el) {
    let self = this;
    let m_isEnabled = false;
    /**
     * @type {HTMLElement}
     */
    let element = $("body");
    let removed = false;
    let m_bind = false;
    this.m_objectName = "jObject";
    this.m_mouseTracking = true;
    this.m_filterObjs = [];

    if (el !== undefined) {
      if (el && el instanceof HObject) {
        element = el.getElement();
      } else {
        element = el;
      }
    }

    let clickEvent = "click";
    let mousedownEvent = "mousedown";
    let mouseupEvent = "mouseup";
    let mousemoveEvent = "mousemove";
    if (Static.isMobile()) {
      clickEvent = "tap";
      mousedownEvent = "touchstart";
      mouseupEvent = "touchend";
      mousemoveEvent = "touchmove";
    }

    /**
     * If a valid HTMLElement exists for this object, this method converts
     * a "relative to the viewport" point to a "relative to element" point.
     * @param {Misc.Point} pt
     * @returns {Misc.Point} a "relative to element" point on success or the
     * point passed as argument otherwise.
     */
    this.mapToElement = function (pt) {
      if (!element) return pt;
      let result = new Misc.Point();
      let rect = element[0].getBoundingClientRect();
      result.x = pt.x - rect.left;
      result.y = pt.y - rect.top;
      return result;
    };

    /**
     * Sets the element for this object.
     * @param {HTMLElement} el
     */
    this.setElement = function (el) {
      element = el;
    };

    /**
     *
     * @returns {HTMLElement} The element associated with this object.
     */
    this.getElement = function () {
      return element;
    };

    /**
     * En/disable the object. When enabled is true an event filter is
     * installed for the observed widget, otherwise the
     * event filter is removed.
     * @see {@link Magnifier#isEnabled isEnabled()} and
     * {@link Magnifier#eventFilter eventFilter()}
     * @param {boolean} on  true or false
     */
    this.setEnabled_1 = function (on) {
      if (m_isEnabled != on) {
        m_isEnabled = on;
        elementEvent(m_isEnabled);
        if (m_isEnabled) {
          Static.trigger("enabled");
        }
      }
    };

    /**
     * This virtual function receives events to an object and
     * should return true if the event e was recognized and processed.
     * @param {Event} event
     * @returns {boolean}
     */
    this.event = function (event) {
      return true;
    };

    this.elementEventOnCb = function (event) {
      if (self.m_filterObjs.length) {
        self.m_filterObjs.forEach(function (filterObj) {
          if (!filterObj.eventFilter(self, event)) return self.event(event);
        });
      } else {
        return self.event(event);
      }
    };

    const elementEvent = function (on) {
      if (self instanceof HObject) {
        //let self = this;
        if (on) {
          self
            .getElement()
            .on(
              mousedownEvent +
                " " +
                mouseupEvent +
                " " +
                mousemoveEvent +
                " " +
                "mouseenter mouseleave mousewheel click dblclick",
              function (event) {
                self.elementEventOnCb(event);
              }
            );
          $("body").on("keydown keyup", function (event) {
            if (self.m_filterObjs.length) {
              self.m_filterObjs.forEach(function (filterObj) {
                if (!filterObj.eventFilter(self, event))
                  return self.event(event);
              });
            } else {
              return self.event(event);
            }
          });
        } else {
          self
            .getElement()
            .off(
              mousedownEvent +
                " " +
                mouseupEvent +
                " " +
                mousemoveEvent +
                " " +
                "mouseenter mouseleave mousewheel click dblclick"
            );
          $("body").off("keydown keyup");
        }
      }
    };

    /**
     * An event filter is an object that receives all events that are
     * sent to this object. The filter can either stop the
     * event or forward it to this object. The event filter filterObj
     * receives events via its eventFilter() function. The eventFilter()
     * function must return true if the event should be filtered
     * out, (i.e. stopped); otherwise it must return false. If multiple event
     * filters are installed on a single object, the filter that was installed last is
     * activated first.
     * @param {object} filterObj
     */
    this.installEventFilter = function (filterObj) {
      this.m_filterObjs.push(filterObj);
    };

    /**
     * Removes an event filter object obj from this object. The request
     * is ignored if such an event filter has not been installed.
     * @param {object} Obj
     */
    this.removeEventFilter = function (obj) {
      let index = this.m_filterObjs.indexOf(obj);
      if (index > -1) {
        this.m_filterObjs.splice(index, 1);
      }
    };

    /**
     *
     * @returns {boolean} true / false
     */
    this.isEnabled = function () {
      return m_isEnabled;
    };

    /**
     *
     * @returns {string} a string representing the object.
     */
    this.toString = function () {
      return "[HObject]";
    };
  }

  /**
   * Filters events if this object has been installed as an event
   * filter for the watched object. In your reimplementation of this
   * function, if you want to filter the event out, i.e. stop it
   * being handled further, return true.
   * @param {boolean} watched
   * @param {Event} event
   */
  eventFilter(watched, event) {
    console.log(`eventFilter() called ${event}`);
  }

  /**
   * Turns on/off mouse tracking. If mouse tracking is on, Html element
   * associated with this object is bind to move
   * events (i.e. any move handlers will be called).
   * @param {boolean} on
   */
  setMouseTracking(on) {
    if (this.getElement() && on) {
      let self = this;
      this.getElement().on("mousemove touchmove", function (event) {
        self.elementEventOnCb(event);
      });
      this.m_mouseTracking = true;
    } else {
      this.getElement().off("mousemove touchmove");
      this.m_mouseTracking = false;
    }
  }

  /**
   *
   * @returns {boolean} true / false
   */
  hasMouseTracking() {
    return this.m_mouseTracking;
  }

  /**
   * Sets the object name.
   * @param {string} name
   */
  setObjectName(name) {
    this.m_objectName = name;
  }

  /**
   *
   * @returns {string} The object name.
   */
  objectName() {
    return this.m_objectName;
  }

  /**
   * Subclasses of HObject must implement this method and do all required clean-up work prior to item destruction. See example.
   *
   * This method is not called automatically. You must call it explicitly.
   *
   * If no clean-up work is required, you can rely on the base method, `HObject#destroy()`, which does nothing.
   * @example
   *
   * class MyHObject extends HObject{
   *    constructor(){
   *       super();
   *       ...
   *       const cb = function () {
   *          //Doing something on myCustomEvent
   *       };
   *
   *       Static.bind("myCustomEvent", cb);
   *
   *       //Do all your clean-up here
   *       this.cleanUp = function(){
   *           Static.unbind("myCustomEvent", cb);
   *       }
   *    }
   *
   *    //Implement the destroy method to remove the handler.
   *    delete() {
   *        this.cleanUp();
   *        super.delete();
   *    }
   * }
   *
   *
   * const myHObject = new MyHObject(); //creates an instance that binds `myCustomEvent` to a callback `cb`
   *
   * ...
   * myHObject.delete();
   * ...
   *
   */
  delete() {}

  /**
   * Use this method to do all required clean-up work prior to destruction of an array of objects. See example
   * @param {Array<object>} arr Array of objects
   * @example
   *
   * class MyPlotItem extends PlotItem{
   *    constructor(){
   *        super();
   *        ...
   *        const cb = function () {
   *          //Doing something on myCustomEvent
   *       };
   *
   *       Static.bind("myCustomEvent", cb);
   *
   *       //Do all your clean-up here
   *       this.cleanUp = function(){
   *           Static.unbind("myCustomEvent", cb);
   *       }
   *    }
   *    //Implement the destroy method to remove the handler.
   *    delete() {
   *        this.cleanUp();
   *        super.delete();
   *    }
   * }
   *
   * class MyClass{
   *    constructor(){
   *       super();
   *       ...
   *       let listOfPlotItems = [];
   *       for(let i=0; i<4; i++){
   *           listOfHObjects.push(new MyPlotItem());
   *       }
   *       ...
   *       //Do all your clean-up here
   *       this.cleanUp = function(){
   *           this.deleteArray(listOfPlotItems);
   *       }
   *    }
   *
   *    //Implement the destroy method to remove the handler.
   *    delete() {
   *        this.cleanUp();
   *    }
   * }
   *
   * const myClass = new MyClass();
   *
   * myClass.delete();
   *
   *
   */
  deleteArray(arr) {
    arr.forEach((element) => {
      element.delete();
    });
  }
}
;
define("hObject", function(){});



/**
 * The widget is the atom of the user interface: it receives mouse, keyboard
 * and other events from the window system, and paints a representation of
 * itself on the screen. Every widget is rectangular, and they are sorted
 * in a Z-order. A widget is clipped by its parent and by the widgets in
 * front of it.
 *
 * All widgets have a div element are associated with one of the predefined DIV element. The Ids of the predefined DIV elements are:
 * - titleDiv
 * - bottomScaleDiv
 * - footerDiv
 * - topScaleDiv
 * - leftScaleDiv
 * - rightScaleDiv
 * - centralDiv
 * - legendDiv
 *
 * Applications, generally, should use the Widget class as a base class (see example). The plot and Layout classes work together to create all widgets needed for an application. Thus there is no need for applications to extend the Widget class.
 * @extends HObject
 * @example
 *  class MyTitleWidget extends Widget {
 *      constructor(){
 *        super($("#titleDiv"))
 *      }
 *  }
 */
class Widget extends HObject {
  /**
   *
   * @param {object} el jQuery div element selector.
   */
  constructor(el) {
    super(el);
    let self = this;
    let m_visible = true;
    let m_z = 0.0;
    var m_font = new Misc.Font(12);
    let cnvs = $("<canvas />").attr({
      style: "position: absolute; background-color: transparent",
    });
    if (this.getElement()) {
      this.getElement().append(cnvs);
    }

    this.clearCanvas = function () {
      let ctx = this.getContext();
      if (!ctx) return;
      ctx.clearRect(0, 0, cnvs[0].width, cnvs[0].height);
    };

    /**
     *
     * @returns {CanvasRenderingContext2D} object representing a two-dimensional rendering context.
     */
    this.getContext = function () {
      if (!this.getElement()) return null;
      cnvs[0].width = parseFloat(this.getElement().css("width"));
      cnvs[0].height = parseFloat(this.getElement().css("height"));
      return cnvs[0].getContext("2d");
    };

    /**
     *
     * @returns {Number} canvas width
     */
    this.width = function () {
      return cnvs[0].width;
    };

    /**
     *
     * @returns {Number} canvas height
     */
    this.height = function () {
      return cnvs[0].height;
    };

    /**
     * Sets the widget canvas parent DIV
     * @param {HTMLDivElement} el Div element
     */
    this.setCanvasParent = function (el) {
      this.getElement().append(cnvs);
    };

    /**
     *
     * @returns {HTMLCanvasElement} html canvas for the widget
     */
    this.getCanvas = function () {
      return cnvs;
    };

    /**
     *
     * @returns {Misc.Rect} the area inside the widget's margins.
     */
    this.contentsRect = function () {
      let e = this.getElement();
      return new Misc.Rect(
        0,
        0,
        parseFloat(e.css("width")),
        parseFloat(e.css("height"))
      );
    };

    /**
     * En/disable widget's visibility
     * @param {Boolean} on If true, visible.
     */
    this.setVisible = function (on) {
      if (on || typeof on === "undefined") {
        this.getCanvas().show();
        m_visible = true;
      } else {
        this.getCanvas().hide();
        m_visible = false;
      }
    };

    /**
     * Sets visibility to false
     */
    this.hide = function () {
      this.setVisible(false);
    };

    /**
     * Sets visibility to true
     */
    this.show = function () {
      this.setVisible(true);
    };

    /**
     *
     * @returns {Misc.Font} Font use to draw text on the widget
     */
    this.font = function () {
      return m_font;
    };

    /**
     * Sets a ne font use to draw text on the widget
     * @param {Misc.Font} f New font
     */
    this.setFont = function (f) {
      m_font = f;
    };

    /**
     *
     * @returns {Boolean} true, if the widget is visible
     */
    this.isVisible = function () {
      return m_visible;
    };

    /**
     * Sets the z-order
     *
     * Widgets are painted accoding to the z-order
     * @param {Number} z order
     */
    this.setZ = function (z) {
      if (m_z !== z) {
        m_z = z;
        if (cnvs) {
          cnvs.css("zIndex", m_z);
        }
        //this.itemChanged()
      }
    };

    /**
     *
     * @returns {Number} the z-order
     */
    this.getZ = function () {
      return m_z;
    };

    /**
     *
     * @returns Returns a string representing the object.
     */
    this.toString = function () {
      return "[Widget]";
    };
  }

  /**
   * Sets the html element that is the widget canvas parent (container)
   * @param {HTMLDivElement} el canvas container
   */
  setElement(el) {
    this.super(el);
    this.setCanvasParent(el);
  }
}
;
define("widget", ["static","hObject"], function(){});



/**
 * An overlay for a widget.
 * 
 * The main use case of an widget overlay is to avoid heavy repaint operation of the widget below. e.g. in combination with the plot 
 * canvas an overlay avoid replots as the content of the canvas can be restored from its backing store. WidgetOverlay is an abstract 
 * base class. Deriving classes are supposed to reimplement the following method:
- {@link WidgetOverlay#drawOverlay drawOverlay()}

Internally, {@link PlotPicker} uses overlays for displaying the rubber band and the tracker text.
* @extends Widget
 */
class WidgetOverlay extends Widget {
  /**
   *
   * @param {Widget} w Parent widget, where the overlay is aligned to
   * @example
   * const plot new Plot();
   * const overlay = new WidgetOverlay(plot.getCentralWidget());
   */
  constructor(w) {
    super(w);
    const self = this;
    this.curve = null;

    Static.bind("itemAttached", function (e, plotItem, on) {
      if (!on) self.curve = 0;
    });

    //called by updateOverlay() to perform drawing
    this.draw = function () {
      let p = new PaintUtil.Painter(this);
      this.drawOverlay(p);
      p = null;
    };

    /**
     *
     * @returns Returns a string representing the object.
     */
    this.toString = function () {
      return "[WidgetOverlay]";
    };
  }

  /**
   * Recalculate and repaint the overlay
   */
  updateOverlay() {
    this.draw();
  }

  /**
   * Draw the widget overlay
   * @param {PaintUtil.Painter} painter Painter
   */
  drawOverlay(painter) {
    console.warn("drawOverlay() not reimplemented");
  }
}
;
define("widgetOverlay", ["static","widget"], function(){});



class MousePattern {
  constructor(btn, modifierCodes) {
    this.button = Static.NoButton;
    this.modifiers = Static.NoModifier;
    if (btn !== undefined) {
      this.button = btn;
    }
    if (modifierCodes !== undefined) {
      this.modifiers = modifierCodes;
    }
  }
}

//! A pattern for key events
class KeyPattern {
  constructor(keyCode, modifierCodes) {
    this.key = Static.Key_unknown;
    this.modifiers = Static.NoModifier;
    if (keyCode !== undefined) {
      this.key = keyCode;
    }
    if (modifierCodes !== undefined) {
      this.modifiers = modifierCodes;
    }
  }
}

/**
 * A collection of event patterns.
 *
 * EventPattern introduces a level of indirection for mouse and keyboard inputs. Those are represented by symbolic names, so the application code can be configured by individual mappings.
 *
 */
class EventPattern extends HObject {
  constructor(parent) {
    super(parent);
    const self = this;

    const MouseSelect1 = EventPattern.MousePatternCode.MouseSelect1;
    const MouseSelect2 = EventPattern.MousePatternCode.MouseSelect2;
    const MouseSelect3 = EventPattern.MousePatternCode.MouseSelect3;
    const MouseSelect4 = EventPattern.MousePatternCode.MouseSelect4;
    const MouseSelect5 = EventPattern.MousePatternCode.MouseSelect5;
    const MouseSelect6 = EventPattern.MousePatternCode.MouseSelect6;
    const MousePatternCount = EventPattern.MousePatternCode.MousePatternCount;

    var d_mousePattern = [];
    var d_keyPattern = [];

    /**
     * Set default mouse patterns, depending on the number of mouse buttons
     * @param {Number} numButtons Number of mouse buttons ( <= 3 )
     * @see {@link EventPattern.MousePatternCode MousePatternCode}
     */
    this.initMousePattern = function (numButtons) {
      //d_mousePattern.resize( MousePatternCount );
      for (var i = 0; i < MousePatternCount; ++i)
        d_mousePattern.push(new MousePattern());
      //console.log(d_mousePattern)

      switch (numButtons) {
        case 1: {
          this.setMousePattern(MouseSelect1, Static.LeftButton);
          this.setMousePattern(
            MouseSelect2,
            Static.LeftButton,
            Static.ControlModifier
          );
          this.setMousePattern(
            MouseSelect3,
            Static.LeftButton,
            Static.AltModifier
          );
          break;
        }
        case 2: {
          this.setMousePattern(MouseSelect1, Static.LeftButton);
          this.setMousePattern(MouseSelect2, Static.RightButton);
          this.setMousePattern(
            MouseSelect3,
            Static.LeftButton,
            Static.AltModifier
          );
          break;
        }
        default: {
          this.setMousePattern(MouseSelect1, Static.LeftButton);
          this.setMousePattern(MouseSelect2, Static.RightButton);
          this.setMousePattern(MouseSelect3, Static.MidButton);
        }
      }
      //console.log(d_mousePattern)
      this.setMousePattern(
        MouseSelect4,
        d_mousePattern[MouseSelect1].button,
        d_mousePattern[MouseSelect1].modifiers | Static.ShiftModifier
      );

      this.setMousePattern(
        MouseSelect5,
        d_mousePattern[MouseSelect2].button,
        d_mousePattern[MouseSelect2].modifiers | Static.ShiftModifier
      );

      this.setMousePattern(
        MouseSelect6,
        d_mousePattern[MouseSelect3].button,
        d_mousePattern[MouseSelect3].modifiers | Static.ShiftModifier
      );
    };

    /**
     * Set default key patterns
     * @see {@link EventPattern.KeyPatternCode KeyPatternCode}
     */
    this.initKeyPattern = function () {
      //d_keyPattern.resize( KeyPatternCount );
      for (var i = 0; i < EventPattern.KeyPatternCode.KeyPatternCount; ++i)
        d_keyPattern.push(new KeyPattern());

      this.setKeyPattern(
        EventPattern.KeyPatternCode.KeySelect1,
        Static.Key_Return
      );
      this.setKeyPattern(
        EventPattern.KeyPatternCode.KeySelect2,
        Static.Key_Space
      );
      this.setKeyPattern(
        EventPattern.KeyPatternCode.KeyAbort,
        Static.Key_Escape
      );

      this.setKeyPattern(EventPattern.KeyPatternCode.KeyLeft, Static.Key_Left);
      this.setKeyPattern(
        EventPattern.KeyPatternCode.KeyRight,
        Static.Key_Right
      );
      this.setKeyPattern(EventPattern.KeyPatternCode.KeyUp, Static.Key_Up);
      this.setKeyPattern(EventPattern.KeyPatternCode.KeyDown, Static.Key_Down);

      this.setKeyPattern(EventPattern.KeyPatternCode.KeyRedo, Static.Key_Plus);
      this.setKeyPattern(EventPattern.KeyPatternCode.KeyUndo, Static.Key_Minus);
      this.setKeyPattern(
        EventPattern.KeyPatternCode.KeyHome,
        Static.Key_Escape
      );
    };

    /**
     * Change one mouse pattern
     * @param {EventPattern.MousePatternCode} pattern Index of the pattern
     * @param {Number} button Button
     * @param {Number} modifiers=Static.NoModifier Keyboard modifiers
     */
    this.setMousePattern = function (pattern, button, modifiers) {
      if (button == undefined) {
        d_mousePattern = pattern;
      } else {
        if (modifiers == undefined) modifiers = Static.NoModifier;
        if (pattern >= 0 && pattern < MousePatternCount) {
          d_mousePattern[pattern].button = button;
          d_mousePattern[pattern].modifiers = modifiers;
        }
      }
    };

    /**
     * Change one key pattern
     * @param {EventPattern.KeyPatternCode} pattern Index of the pattern
     * @param {Number} key Key
     * @param {Number} modifiers Keyboard modifiers
     */
    this.setKeyPattern = function (pattern, key, modifiers) {
      if (key == undefined) {
        d_mousePattern = pattern;
      } else {
        if (modifiers == undefined) modifiers = Static.NoModifier;
        if (
          pattern >= 0 &&
          pattern < EventPattern.KeyPatternCode.KeyPatternCount
        ) {
          d_keyPattern[pattern].key = key;
          d_keyPattern[pattern].modifiers = modifiers;
        }
      }
    };

    /**
     * Compare a mouse event with an event pattern.
     *
     * A mouse event matches the pattern when both have the same button value and in the state value the same key flags(Qt::KeyButtonMask) are set.
     * @param {EventPattern.MousePatternCode} code Index of the event pattern
     * @param {Event} event Mouse event
     * @returns {Boolean} true if matches
     * @see {@link EventPattern#keyMatch keyMatch()}
     */
    this.mouseMatch = function (/*MousePatternCode*/ code, event) {
      if (code >= 0 && code < MousePatternCount)
        return mouseMatch2(d_mousePattern[code], event);

      return false;
    };

    const mouseMatch2 = function (pattern, event) {
      if (event == null) return false;
      return (
        pattern.button == Utility.button(event) &&
        pattern.modifiers == Utility.modifiers(event)
      );
    };

    /**
     *
     * @returns {Array<EventPattern.KeyPatternCode>} Key pattern
     */
    this.keyPattern = function () {
      return d_keyPattern;
    };

    /**
     *
     * @returns {Array<EventPattern.MousePatternCode>} Mouse pattern
     */
    this.mousePattern = function () {
      return d_mousePattern;
    };

    /**
     *
     * @param {Event} event Key event
     * @returns {Number} Key code
     */
    this.key = function (event) {
      if (event == null) return false;
      return event.keyCode;
    };

    /**
     * Compare a key event with an event pattern.
     * @param {EventPattern.KeyPatternCode} code Index of the event pattern
     * @param {Event} event Key event
     * @returns {Boolean} true if matches
     * @see {@link EventPattern#mouseMatch mouseMatch()}
     */
    this.keyMatch = function (/*KeyPatternCode*/ code, event) {
      if (code >= 0 && code < EventPattern.KeyPatternCode.KeyPatternCount)
        return keyMatch2(d_keyPattern[code], event);

      return false;
    };

    const keyMatch2 = function (/*KeyPattern*/ pattern, event) {
      if (event == null) return false;

      //const KeyPattern keyPattern( event->key(), event->modifiers() );
      //return keyPattern == pattern;
      return (
        pattern.key == self.key(event) &&
        pattern.modifiers == Utility.modifiers(event)
      );
    };

    this.initKeyPattern();
    this.initMousePattern(3);
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link EventPattern.KeyPatternCode}</div>
 *
 * Symbolic keyboard input codes.
 * @name EventPattern.KeyPatternCode
 * @readonly
 * @property {Number} KeySelect1                Static.Key_Return.
 * @property {Number} KeySelect2                Static.Key_Space.
 * @property {Number} KeyAbort                  Static.Key_Escape.
 * @property {Number} KeyLeft                   Static.Key_Left.
 * @property {Number} KeyRight                  Static.Key_Right.
 * @property {Number} KeyUp                     Static.Key_Up.
 * @property {Number} KeyDown                   Static.Key_Down.
 * @property {Number} KeyRedo                   Static.Key_Plus.
 * @property {Number} KeyUndo                   Static.Key_Minus.
 * @property {Number} KeyHome                   Static.Key_Escape
 * @property {Number} KeyPatternCount           Number of key patterns.
 *
 */
Enumerator.enum(
  "KeyPatternCode {KeySelect1, KeySelect2, KeyAbort, KeyLeft, KeyRight, KeyUp, KeyDown, KeyRedo, KeyUndo, KeyHome, KeyPatternCount}",
  EventPattern
);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link EventPattern.MousePatternCode}</div>
 *
 * Symbolic mouse input codes.
 * @name EventPattern.MousePatternCode
 * @readonly
 * @property {Number} MouseSelect1             The default setting for 1, 2 and 3 button mice is:
 * - Static.LeftButton
 * - Static.LeftButton
 * - Static.LeftButton
 * @property {Number} MouseSelect2              The default setting for 1, 2 and 3 button mice is:
 * - Static.LeftButton + Static.ControlModifier
 * - Static.RightButton
 * - Static.RightButton
 * @property {Number} MouseSelect3              The default setting for 1, 2 and 3 button mice is:
 * - Static.LeftButton + Static.AltModifier
 * - Static.LeftButton + Static.AltModifier
 * - Static.MidButton
 * @property {Number} MouseSelect4              The default setting for 1, 2 and 3 button mice is:
 * - Static.LeftButton + Static.ShiftModifier
 * - Static.LeftButton + Static.ShiftModifier
 * - Static.LeftButton + Static.ShiftModifier
 * @property {Number} MouseSelect5              The default setting for 1, 2 and 3 button mice is:
 * - Static.LeftButton + Static.ControlButton | Static.ShiftModifier
 * - Static.RightButton + Static.ShiftModifier
 * - Static.RightButton + Static.ShiftModifier
 * @property {Number} MouseSelect6              The default setting for 1, 2 and 3 button mice is:
 * - Static.LeftButton + Static.AltModifier + Static.ShiftModifier
 * - Static.LeftButton + Static.AltModifier | Static.ShiftModifier
 * - Static.MidButton + Static.ShiftModifier
 * @property {Number} MousePatternCount         Number of mouse patterns.
 */
Enumerator.enum(
  "MousePatternCode {MouseSelect1, MouseSelect2, MouseSelect3, MouseSelect4, MouseSelect5, MouseSelect6, MousePatternCount}",
  EventPattern
);

define("eventpattern", function(){});



/**
 * A state machine for Picker selections.
 *
 * PickerMachine accepts key and mouse events and translates them into selection commands.
 */
class PickerMachine {
  /**
   *
   * @param {PlotItem.SelectionType} type the selection type
   */
  constructor(type) {
    Static.Begin = 0;
    Static.Append = 1;
    Static.Move = 2;
    Static.Remove = 3;
    Static.End = 4;
    var d_selectionType = type;
    var d_state = 0;

    /**
     *
     * @returns {PlotItem.SelectionType} the selection type
     */
    this.selectionType = function () {
      return d_selectionType;
    };

    /**
     *
     * @returns {Number} the current state
     */
    this.state = function () {
      return d_state;
    };

    /**
     * Change the current state.
     * @param {Number} state New state
     */
    this.setState = function (/* int*/ state) {
      d_state = state;
    };

    /**
     * Set the current state to 0.
     */
    this.reset = function () {
      this.setState(0);
    };

    /**
     * Transition
     * @param {EventPattern} p pattern
     * @param {Event} e event
     */
    this.transition = function (p, e) {
      console.warn("Subclass must reimplement");
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerMachine]";
  }
}
/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link ClassName.SelectionType}</div>
 *
 * Type of a selection.
 * @name PickerMachine.SelectionType
 * @readonly
 * @property {Number} NoSelection             The state machine not usable for any type of selection.
 * @property {Number} PointSelection          The state machine is for selecting a single point.
 * @property {Number} RectSelection           The state machine is for selecting a rectangle (2 points).
 * @property {Number} PolygonSelection        The state machine is for selecting a polygon (many points).
 */
Enumerator.enum(
  "SelectionType { NoSelection = -1 , PointSelection , RectSelection , PolygonSelection }",
  PickerMachine
);

/**
 * A state machine for indicating mouse movements.
 * @extends PickerMachine
 */
class PickerTrackerMachine extends PickerMachine {
  constructor() {
    super(PickerMachine.SelectionType.NoSelection);

    //Documented in base class
    this.transition = function (/*QwtEventPattern*/ p, /*const QEvent*/ e) {
      var cmdList = [];

      switch (e.type) {
        //case QEvent::Enter:
        //case QEvent::MouseMove:
        case "mouseenter":
        case "mousemove":
        case "touchmove": {
          if (this.state() == 0) {
            cmdList.push(Static.Begin);
            cmdList.push(Static.Append);
            this.setState(1);
          } else {
            cmdList.push(Static.Move);
          }
          break;
        }
        //case QEvent::Leave:
        case "mouseleave": {
          cmdList.push(Static.Remove);
          cmdList.push(Static.End);
          this.setState(0);
        }
        default:
          break;
      }

      return cmdList;
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerTrackerMachine]";
  }
}

/**
 * A state machine for point selections.
 * @extends PickerMachine
 */
class PickerClickPointMachine extends PickerMachine {
  constructor() {
    super(PickerMachine.SelectionType.PointSelection);
    const Enum = Enumerator.getDefaultEnumNampespace();

    //Documented in base class
    this.transition = function (/*QwtEventPattern*/ eventPattern, event) {
      var cmdList = [];

      switch (event.type) {
        //case QEvent::MouseButtonPress:
        case "mousedown":
        case "touchstart": {
          if (
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect1,
              event
            )
          ) {
            cmdList.push(Static.Begin);
            cmdList.push(Static.Append);
            cmdList.push(Static.End);
          }
          break;
        }
        //case QEvent::KeyPress:
        case "keydown": {
          var keyEvent = event;
          if (
            eventPattern.keyMatch(
              EventPattern.KeyPatternCode.KeySelect1,
              keyEvent
            )
          ) {
            //if ( !keyEvent->isAutoRepeat() )
            {
              cmdList.push(Static.Begin);
              cmdList.push(Static.Append);
              cmdList.push(Static.End);
            }
          }
          break;
        }
        default:
          break;
      }

      return cmdList;
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerClickPointMachine]";
  }
}

/**
 * A state machine for point selections.
 * @extends PickerMachine
 */
class PickerDblClickPointMachine extends PickerMachine {
  constructor() {
    super(PickerMachine.SelectionType.PointSelection);
    const Enum = Enumerator.getDefaultEnumNampespace();

    //Documented in base class
    this.transition = function (/*QwtEventPattern*/ eventPattern, event) {
      var cmdList = [];

      switch (event.type) {
        //case QEvent::MouseButtonPress:
        case "dblclick":
        case "touchstart": {
          if (
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect1,
              event
            )
          ) {
            cmdList.push(Static.Begin);
            cmdList.push(Static.Append);
            cmdList.push(Static.End);
          }
          break;
        }
        //case QEvent::KeyPress:
        case "keydown": {
          var keyEvent = event;
          if (
            eventPattern.keyMatch(
              EventPattern.KeyPatternCode.KeySelect1,
              keyEvent
            )
          ) {
            //if ( !keyEvent->isAutoRepeat() )
            {
              cmdList.push(Static.Begin);
              cmdList.push(Static.Append);
              cmdList.push(Static.End);
            }
          }
          break;
        }
        default:
          break;
      }

      return cmdList;
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerDblClickPointMachine]";
  }
}

/**
 * A state machine for point selections.
 * @extends PickerMachine
 */
class PickerDragPointMachine extends PickerMachine {
  constructor() {
    super(PickerMachine.SelectionType.PointSelection);

    //Documented in base class
    this.transition = function (/*QwtEventPattern*/ eventPattern, event) {
      var cmdList = [];

      switch (event.type) {
        //case QEvent::MouseButtonPress:
        case "mousedown":
        case "touchstart": {
          if (
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect1,
              event
            )
          ) {
            if (this.state() == 0) {
              cmdList.push(Static.Begin);
              cmdList.push(Static.Append);
              this.setState(1);
            }
          }
          break;
        }
        //case QEvent::MouseMove:
        case "mousemove":
        case "touchmove":
        //case QEvent::Wheel:
        case "mousewheel": {
          if (this.state() != 0) cmdList.push(Static.Move);
          break;
        }
        //case QEvent::MouseButtonRelease:
        case "mouseup":
        case "touchend": {
          if (this.state() != 0) {
            cmdList.push(Static.End);
            this.setState(0);
          }
          break;
        }
        //case QEvent::KeyPress:
        case "keydown": {
          var keyEvent = event;
          if (
            eventPattern.keyMatch(
              EventPattern.KeyPatternCode.KeySelect1,
              keyEvent
            )
          ) {
            //if ( !keyEvent->isAutoRepeat() )
            {
              if (this.state() == 0) {
                cmdList.push(Static.Begin);
                cmdList.push(Static.Append);
                this.setState(1);
              } else {
                cmdList.push(Static.End);
                this.setState(0);
              }
            }
          }
          break;
        }
        default:
          break;
      }

      return cmdList;
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerDragPointMachine]";
  }
}

/**
 * A state machine for point selections.
 *
 * Pressing EventPattern.MousePatternCode.MouseSelect1 or EventPattern.KeyPatternCode.KeySelect1 selects a point.
 * @extends PickerMachine
 */
class PickerClickRectMachine extends PickerMachine {
  constructor() {
    super(PickerMachine.SelectionType.RectSelection);

    //Documented in base class
    this.transition = function (/*QwtEventPattern*/ eventPattern, event) {
      var cmdList = [];

      switch (event.type) {
        //case QEvent::MouseButtonPress:
        case "mousedown":
        case "touchstart": {
          if (
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect1,
              event
            )
          ) {
            switch (this.state()) {
              case 0: {
                cmdList.push(Static.Begin);
                cmdList.push(Static.Append);
                this.setState(1);
                break;
              }
              case 1: {
                // Uh, strange we missed the MouseButtonRelease
                break;
              }
              default: {
                cmdList.push(Static.End);
                this.setState(0);
              }
            }
          }
          break;
        }
        //case QEvent::MouseMove:
        case "mousemove":
        case "touchmove":
        //case QEvent::Wheel:
        case "mousewheel": {
          if (this.state() != 0) cmdList.push(Static.Move);
          break;
        }
        //case QEvent::MouseButtonRelease:
        case "mouseup":
        case "touchend": {
          if (
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect1,
              event
            )
          ) {
            if (this.state() == 1) {
              cmdList.push(Static.Append);
              this.setState(2);
            }
          }
          break;
        }
        //case QEvent::KeyPress:
        case "keydown": {
          var keyEvent = event;
          if (
            eventPattern.keyMatch(
              EventPattern.KeyPatternCode.KeySelect1,
              keyEvent
            )
          ) {
            //if ( !keyEvent->isAutoRepeat() )
            {
              if (this.state() == 0) {
                cmdList.push(Static.Begin);
                cmdList.push(Static.Append);
                this.setState(1);
              } else {
                if (this.state() == 1) {
                  cmdList.push(Static.Append);
                  this.setState(2);
                } else if (this.state() == 2) {
                  cmdList.push(Static.End);
                  this.setState(0);
                }
              }
            }
          }
          break;
        }
        default:
          break;
      }

      return cmdList;
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerClickRectMachine]";
  }
}

/**
 * A state machine for rectangle selections.
 * @extends PickerMachine
 */
class PickerDragRectMachine extends PickerMachine {
  constructor() {
    super(PickerMachine.SelectionType.RectSelection);

    //Documented in base class
    this.transition = function (/*QwtEventPattern*/ eventPattern, event) {
      var cmdList = [];

      switch (event.type) {
        //case QEvent::MouseButtonPress:
        case "mousedown":
        case "touchstart": {
          if (
            event.type == "touchstart" ||
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect1,
              event
            )
          ) {
            if (this.state() == 0) {
              cmdList.push(Static.Begin);
              cmdList.push(Static.Append);
              cmdList.push(Static.Append);
              this.setState(2);
            }
          }
          break;
        }
        //case QEvent::MouseMove:
        case "mousemove":
        case "touchmove":
        //case QEvent::Wheel:
        case "mousewheel": {
          if (this.state() != 0) cmdList.push(Static.Move);
          break;
        }
        //case QEvent::MouseButtonRelease:
        case "mouseup":
        case "touchend": {
          if (this.state() == 2) {
            cmdList.push(Static.End);
            this.setState(0);
          }
          break;
        }
        //case QEvent::KeyPress:
        case "keydown": {
          if (
            eventPattern.keyMatch(EventPattern.KeyPatternCode.KeySelect1, event)
          ) {
            if (this.state() == 0) {
              cmdList.push(Static.Begin);
              cmdList.push(Static.Append);
              cmdList.push(Static.Append);
              this.setState(2);
            } else {
              cmdList.push(Static.End);
              this.setState(0);
            }
          }
          break;
        }
        default:
          break;
      }

      return cmdList;
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerDragRectMachine]";
  }
}

/**
 * A state machine for polygon selections.
 * @extends PickerMachine
 */
class PickerPolygonMachine extends PickerMachine {
  constructor() {
    super(PickerMachine.SelectionType.PolygonSelection);

    //Documented in base class
    this.transition = function (/*QwtEventPattern*/ eventPattern, event) {
      var cmdList = [];

      switch (event.type) {
        //case QEvent::MouseButtonPress:
        case "mousedown":
        case "touchstart": {
          if (
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect1,
              event
            )
          ) {
            if (this.state() == 0) {
              cmdList.push(Static.Begin);
              cmdList.push(Static.Append);
              cmdList.push(Static.Append);
              this.setState(1);
            } else {
              cmdList.push(Static.Append);
            }
          }
          if (
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect2,
              event
            )
          ) {
            if (this.state() == 1) {
              cmdList.push(Static.End);
              this.setState(0);
            }
          }
          break;
        }
        //case QEvent::MouseMove:
        case "mousemove":
        case "touchmove":
        //case QEvent::Wheel:
        case "mousewheel": {
          if (this.state() != 0) cmdList.push(Static.Move);
          break;
        }
        //case QEvent::KeyPress:
        case "keydown": {
          var keyEvent = event;
          if (
            eventPattern.keyMatch(
              EventPattern.KeyPatternCode.KeySelect1,
              keyEvent
            )
          ) {
            //if ( !keyEvent->isAutoRepeat() )
            {
              if (this.state() == 0) {
                cmdList.push(Static.Begin);
                cmdList.push(Static.Append);
                cmdList.push(Static.Append);
                this.setState(1);
              } else {
                cmdList.push(Static.Append);
              }
            }
          } else if (
            eventPattern.keyMatch(
              EventPattern.KeyPatternCode.KeySelect2,
              keyEvent
            )
          ) {
            //if ( !keyEvent->isAutoRepeat() )
            {
              if (this.state() == 1) {
                cmdList.push(Static.End);
                this.setState(0);
              }
            }
          }
          break;
        }
        default:
          break;
      }

      return cmdList;
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerPolygonMachine]";
  }
}

/**
 * A state machine for line selections.
 * @extends PickerMachine
 */
class PickerDragLineMachine extends PickerMachine {
  constructor() {
    super(PickerMachine.SelectionType.PolygonSelection);

    //Documented in base class
    this.transition = function transition(
      /*QwtEventPattern*/ eventPattern,
      event
    ) {
      var cmdList = [];

      switch (event.type) {
        //case QEvent::MouseButtonPress:
        case "mousedown":
        case "touchstart": {
          if (
            eventPattern.mouseMatch(
              EventPattern.MousePatternCode.MouseSelect1,
              event
            )
          ) {
            if (this.state() == 0) {
              cmdList.push(Static.Begin);
              cmdList.push(Static.Append);
              cmdList.push(Static.Append);
              this.setState(1);
            }
          }
          break;
        }
        //case QEvent::KeyPress:
        case "keydown": {
          if (
            eventPattern.keyMatch(EventPattern.KeyPatternCode.KeySelect1, event)
          ) {
            if (this.state() == 0) {
              cmdList.push(Static.Begin);
              cmdList.push(Static.Append);
              cmdList.push(Static.Append);
              this.setState(1);
            } else {
              cmdList.push(Static.End);
              this.setState(0);
            }
          }
          break;
        }
        //case QEvent::MouseMove:
        case "mousemove":
        case "touchmove":
        //case QEvent::Wheel:
        case "mousewheel": {
          if (this.state() != 0) cmdList.push(Static.Move);

          break;
        }
        //case QEvent::MouseButtonRelease:
        case "mouseup":
        case "touchend": {
          if (this.state() != 0) {
            cmdList.push(Static.End);
            this.setState(0);
          }
        }
        default:
          break;
      }

      return cmdList;
    };
  }

  /**
   *
   * @returns Returns a string representing the object.
   */
  toString() {
    return "[PickerDragLineMachine]";
  }
}
;
define("pickermachine", ["static","eventpattern"], function(){});



class PickerRubberband extends WidgetOverlay {
  constructor(/*QwtPicker*/ picker, /*QWidget*/ parent) {
    super(parent);

    this.setZ(30); //ensure the rubberband is drawn above everything

    var d_picker = picker;

    this.drawOverlay = function (painter) {
      //d_picker.rubberBandOverlay().clearCanvas()
      //painter.save()
      painter.setPen(d_picker.rubberBandPen());
      painter.setBrush(Static.NoBrush);
      d_picker.drawRubberBand(painter);
      //painter.restore()
    };
  }
}

class PickerTracker extends WidgetOverlay {
  constructor(/*QwtPicker*/ picker, /*QWidget*/ parent) {
    super(parent);
    this.setZ(30); //ensure the tracker is drawn above everything

    var d_picker = picker;

    this.drawOverlay = function (painter) {
      d_picker.trackerOverlay().clearCanvas();
      painter.save();
      painter.setPen(d_picker.trackerPen()); //This has no effect. trackerFont does it.
      d_picker.drawTracker(painter);
      painter.restore();
    };
  }
}

class PickerPrivateData {
  constructor() {
    this.enabled = false;

    this.stateMachine = null;

    this.resizeMode; //= QwtPicker::Stretch;

    this.rubberBand = Picker.RubberBand.NoRubberBand;
    this.rubberBandPen = new Misc.Pen("red", 1, "solid");

    this.trackerMode = Picker.DisplayMode.AlwaysOff;
    this.trackerPen = new Misc.Pen("red");
    this.trackerFont;

    this.pickedPoints = [];
    this.isActive = false;
    /*QPoint*/
    this.trackerPosition = new Misc.Point();

    this.mouseTracking = false; // used to save previous value

    /*QPointer< QwtPickerRubberband >*/
    this.rubberBandOverlay = null;
    /*QPointer< QwtPickerTracker>*/
    this.trackerOverlay = null;
  }
}

/**
 * Picker provides selections on a widget.
 *
 * Picker filters all enter, leave, mouse and keyboard events of a widget and translates them into an array of selected points.
 * The way how the points are collected depends on type of state machine that is associated with the picker. js-Qwt offers a few
 * predefined state machines for selecting:
 *
 * <b><i>Nothing - PickerTrackerMachine</i></b>
 *
 * <b><i>Single points - PickerClickPointMachine, PickerDragPointMachine</i></b>
 *
 * <b><i>Rectangles - PickerClickRectMachine, PickerDragRectMachine</i></b>
 *
 * <b><i>Polygons - PickerPolygonMachine</i></b>
 *
 * While these state machines cover the most common ways to collect points it is also possible to implement individual
 * machines as well. Picker translates the picked points into a selection using the adjustedPoints() method. adjustedPoints()
 * is intended to be reimplemented to fix up the selection according to application specific requirements. (e.g. when an
 * application accepts rectangles of a fixed aspect ratio only.)
 *
 * Optionally Picker support the process of collecting points by a rubber band and tracker displaying a text for the
 * current mouse position.
 *
 * @extends EventPattern
 */
class Picker extends EventPattern {
  /**
   * Creates a Picker. See example for usage.
   * @param {Picker.RubberBand} [rubberBand] Rubber band style
   * @param {Picker.DisplayMode} [trackerMode] Tracker mode
   * @param {Widget} parent Central widget, that will be observed
   * @example
   * const plot = new Plot();
   * ...
   * const picker = new Picker(plot); //Creates an picker that is enabled, but without a state machine. rubber band and tracker are disabled.
   * const picker = new Picker(Picker.RubberBand.RectRubberBand, Picker.DisplayMode.ActiveOnly, plot);
   */
  constructor(rubberBand, trackerMode, parent) {
    super(parent);
    const self = this;

    let clickEvent = "click";
    let mousedownEvent = "mousedown";
    let mouseupEvent = "mouseup";
    let mousemoveEvent = "mousemove";
    if (Static.isMobile()) {
      clickEvent = "tap";
      mousedownEvent = "touchstart";
      mouseupEvent = "touchend";
      mousemoveEvent = "touchmove";
    }

    var d_data;
    var m_pickedPoints = [];

    var m_parent = null;

    if (parent !== undefined && parent.toString() == "[Widget]") {
      m_parent = parent;
    }
    //console.log(m_parent.getElement());
    //m_parent.getElement()[0].focus();

    //! Initialize the picker - used by the constructors
    this.init = function (parent, rubberBand, trackerMode) {
      d_data = new PickerPrivateData();

      d_data.rubberBand = rubberBand;

      if (parent) {
        //if ( parent->focusPolicy() == Qt::NoFocus )
        //parent->setFocusPolicy( Qt::WheelFocus );

        //d_data->openGL = parent->inherits( "QGLWidget" );
        d_data.trackerFont = new Misc.Font(12);
        //d_data->mouseTracking = parent->hasMouseTracking();

        this.setEnabled_1(true);
      }

      this.setTrackerMode(trackerMode);
      Picker.pickers.push(this);
    };

    //For internal use
    this.getPickerData = function () {
      return d_data;
    };

    /**
     * Sets a state machine and delete the previous one
     * @param {PickerMachine} stateMachine State machine
     * @see {@link Picker#stateMachine stateMachine()}
     */
    this.setStateMachine = function (/*QwtPickerMachine*/ stateMachine) {
      if (d_data.stateMachine != stateMachine) {
        this.reset();

        //delete d_data->stateMachine;
        d_data.stateMachine = stateMachine;

        if (d_data.stateMachine) d_data.stateMachine.reset();
      }
    };

    /**
     *
     * @returns {PickerMachine} Assigned state machine
     * @see {@link Picker#setStateMachine setStateMachine()}
     */
    this.stateMachine = function () {
      return d_data.stateMachine;
    };

    /**
     *
     * @returns {Widget} the parent widget, where the selection happens
     */
    this.parentWidget = function () {
      return m_parent;
    };

    /**
     *
     * @param {Picker.RubberBand} rubberBand Rubber band style
     * @see {@link Picker#rubberBand rubberBand()}
     * @see {@link Picker.RubberBand RubberBand}
     */
    this.setRubberBand = function (rubberBand) {
      d_data.rubberBand = rubberBand;
    };

    /**
     *
     * @returns {Picker.RubberBand} Rubber band style
     * @see {@link Picker#setRubberBand setRubberBand()}
     * @see {@link Picker.RubberBand RubberBand}
     */
    this.rubberBand = function () {
      return d_data.rubberBand;
    };

    /**
     * Sets the display mode of the tracker.
     *
     * A tracker displays information about current position of the cursor as a string. The display mode controls
     * if the tracker has to be displayed whenever the observed widget has focus and cursor (AlwaysOn), never (AlwaysOff), or
     * only when the selection is active (ActiveOnly).
     * @param {Picker.DisplayMode} mode Tracker display mode
     */
    this.setTrackerMode = function (/*DisplayMode*/ mode) {
      if (d_data.trackerMode != mode) {
        d_data.trackerMode = mode;
        //this.setMouseTracking(d_data.trackerMode == Picker.DisplayMode.AlwaysOn);
      }
    };

    /**
     *
     * @returns {Picker.DisplayMode} Tracker display mode
     */
    this.trackerMode = function () {
      return d_data.trackerMode;
    };

    /**
     * En/disable the picker
     *
     * When enabled is true an event filter is installed for the observed widget, otherwise the event filter is removed.
     * @param {Boolean} enabled true or false
     */
    this.setEnabled = function (enabled) {
      if (d_data.enabled != enabled) {
        d_data.enabled = enabled;

        /*QWidget*/
        var w = self.parentWidget();
        if (w) {
          if (enabled) {
            w.installEventFilter(this);
          } else {
            w.removeEventFilter(this);
          }
        }

        self.updateDisplay();
      }
    };

    /**
     *
     * @returns {Boolean} true when enabled, false otherwise
     */
    this.isEnabled = function () {
      return d_data.enabled;
    };

    /**
     * Sets the font for the tracker
     * @param {Misc.Font} font Tracker font
     */
    this.setTrackerFont = function (font) {
      //if (font != d_data.trackerFont) {
      if (!font.isEqual(d_data.trackerFont)) {
        d_data.trackerFont = font;
        this.updateDisplay();
      }
    };

    /**
     *
     * @returns {Misc.Font} Tracker font
     */
    this.trackerFont = function () {
      return d_data.trackerFont;
    };

    /**
     * Sets the pen for the tracker
     * @param {Misc.Pen} pen Tracker pen
     */
    this.setTrackerPen = function (pen) {
      //if (pen != d_data.trackerPen) {
      if (!pen.isEqual(d_data.trackerPen)) {
        d_data.trackerPen = pen;
        this.updateDisplay();
      }
    };

    /**
     *
     * @returns {Misc.Pen} Tracker pen
     */
    this.trackerPen = function () {
      return d_data.trackerPen;
    };

    /**
     * Sets the pen for the rubberband
     * @param {Misc.Pen} pen Rubber band pen
     */
    this.setRubberBandPen = function (pen) {
      //if (pen != d_data.rubberBandPen) {
      if (!pen.isEqual(d_data.rubberBandPen)) {
        d_data.rubberBandPen = pen;
        this.updateDisplay();
      }
    };

    /**
     *
     * @returns {Misc.Pen} Rubber band pen
     */
    this.rubberBandPen = function () {
      return d_data.rubberBandPen;
    };

    /**
     * Draws a rubber band, depending on rubberBand()
     * @param {PaintUtil.Painter} painter Painter
     */
    this.drawRubberBand = function (painter) {
      if (
        !this.isActive() ||
        this.rubberBand() == Picker.RubberBand.NoRubberBand ||
        this.rubberBandPen().style == Static.NoPen
      ) {
        return;
      }

      /*const QPolygon*/
      var pa = this.adjustedPoints(d_data.pickedPoints);

      var selectionType = PickerMachine.SelectionType.NoSelection;

      if (d_data.stateMachine)
        selectionType = d_data.stateMachine.selectionType();

      switch (selectionType) {
        case PickerMachine.SelectionType.NoSelection:
        case PickerMachine.SelectionType.PointSelection: {
          if (pa.length < 1) return;

          /*const QPoint*/
          var pos = pa[0];

          ///*const QRect*/ var pRect = this.pickArea().boundingRect().toRect();
          /*const QRect*/
          var pRect = this.pickArea();
          switch (this.rubberBand()) {
            case Picker.RubberBand.VLineRubberBand: {
              painter.drawLine(pos.x, pRect.top(), pos.x, pRect.bottom());
              break;
            }
            case Picker.RubberBand.HLineRubberBand: {
              painter.drawLine(pRect.left(), pos.y, pRect.right(), pos.y);
              break;
            }
            case Picker.RubberBand.CrossRubberBand: {
              painter.drawLine(pos.x, pRect.top(), pos.x, pRect.bottom());
              painter.drawLine(pRect.left(), pos.y, pRect.right(), pos.y);
              break;
            }
            default:
              break;
          }
          break;
        }
        case PickerMachine.SelectionType.RectSelection: {
          if (pa.length < 2) return;

          //console.log(pa.toString());
          ///*const QRect*/ var rect = ( pa[0], pa[pa.length-1] ).normalized();
          /*const QRect*/
          var rect = new Misc.Rect(pa[0], pa[pa.length - 1]);
          rect = rect.normalized();
          switch (this.rubberBand()) {
            case Picker.RubberBand.EllipseRubberBand: {
              painter.drawEllipse(rect);
              break;
            }
            case Picker.RubberBand.RectRubberBand: {
              painter.drawRect(rect);
              break;
            }
            default:
              break;
          }
          break;
        }
        case PickerMachine.SelectionType.PolygonSelection: {
          if (pa.length < 2) return;
          if (this.rubberBand() == Picker.RubberBand.PolygonRubberBand) {
            painter.drawPolyline(pa);
            //console.log(pa)
          }
          break;
        }
        default:
          break;
      }
    };

    /**
     * Draws the tracker
     * @param {PaintUtil.Painter} painter Painter
     */
    this.drawTracker = function (painter) {
      var textRect = this.trackerRect(this.trackerFont());
      if (textRect !== null) {
        //this.clearTrackerCanvas();
        var label = this.trackerText(d_data.trackerPosition);
        if (label !== "") {
          //var trackerPainter = new PaintUtil.Painter(trackerCtx);
          //painter.save();
          //trackerPainter.setFont(m_trackerFont);
          //console.log(textRect.left())
          painter.setFont(d_data.trackerFont);
          painter.drawText(label, textRect.left(), textRect.bottom());
          //trackerPainter.save();
        }
        //painter.drawText(label, d_data.trackerPosition.x, d_data.trackerPosition.y, Static.AlignLeft)
      }
    };

    /**
     *
     * @returns {Array<Misc.Point>} Selected points
     */
    this.selection = function () {
      return this.adjustedPoints(d_data.pickedPoints);
    };

    /**
     *
     * @returns {Misc.Point} Current position of the tracker
     */
    this.trackerPosition = function () {
      return d_data.trackerPosition;
    };

    /**
     * Calculate the bounding rectangle for the tracker text from the current position of the tracker
     * @param {Misc.Font} font Font of the tracker text
     * @returns {Misc.Rect} Bounding rectangle of the tracker text
     * @see {@link Picker#trackerPosition trackerPosition()}
     */
    this.trackerRect = function (font) {
      if (this.trackerMode() === Picker.DisplayMode.AlwaysOff) {
        return null;
      }

      if (this.trackerPosition().x < 0 || this.trackerPosition().y < 0)
        return null;

      var text = this.trackerText(this.trackerPosition());

      if (text == "") return null;

      var textSize = font.textSize(text);

      var textRect = new Misc.Rect(
        new Misc.Point(),
        textSize.width,
        textSize.height
      );
      var pos = this.trackerPosition();

      var alignment = 0;

      //if (/*isActive() &&*/ this.trackerPosition().length > 1 && this.rubberBand() != Picker.RubberBand.NoRubberBand) {
      if (
        /*isActive() &&*/ m_pickedPoints.length.length > 1 &&
        this.rubberBand() != Picker.RubberBand.NoRubberBand
      ) {
        var last = m_pickedPoints[0];

        alignment |= pos.x >= last.x ? Static.AlignRight : Static.AlignLeft;
        alignment |= pos.y > last.y ? Static.AlignBottom : Static.AlignTop;
      } else alignment = Static.AlignTop | Static.AlignRight;

      var margin = 5;

      var x = pos.x;
      if (alignment & Static.AlignLeft) x -= textRect.width() + margin;
      else if (alignment & Static.AlignRight) x += margin;

      var y = pos.y;
      if (alignment & Static.AlignBottom) y += margin;
      else if (alignment & Static.AlignTop) y -= textRect.height() + margin;

      textRect.moveTopLeft(new Misc.Point(x, y));

      var pickRect = new Misc.Rect(
        new Misc.Point(),
        this.trackerOverlay().width(),
        this.trackerOverlay().height()
      );
      var right = Math.min(textRect.right(), pickRect.right() - margin);
      var bottom = Math.min(textRect.bottom(), pickRect.bottom() - margin);
      textRect.moveBottomRight(new Misc.Point(right, bottom));

      var left = Math.max(textRect.left(), pickRect.left() + margin);
      var top = Math.max(textRect.top(), pickRect.top() + margin);
      textRect.moveTopLeft(new Misc.Point(left, top));

      return textRect;
    };

    /**
     * Event filter
     *
     * When isEnabled() is true all events of the observed widget are filtered.
     * Mouse and keyboard events are translated into widgetMouse- and widgetKey- and widgetWheel-events. Paint and
     * Resize events are handled to keep rubber band and tracker up to date.
     * @param {HObject} object Object to be filtered
     * @param {Event} event Event
     * @returns {Boolean} Always false.
     */
    this.eventFilter = function (/*QObject*/ object, event) {
      //console.log('eventFilter() called in qwtpicker')
      if (!this.isEnabled()) return false;
      if (object && object == this.parentWidget()) {
        switch (event.type) {
          /*case QEvent::Resize:{
					const QResizeEvent *re = static_cast<QResizeEvent *>( event );


					// Adding/deleting additional event filters inside of an event filter
					//is not safe dues to the implementation in Qt ( changing alist while iterating ).
					//So we create the overlays in a way, that they don't install en event filter
					//( parent set to NULL ) and do the resizing here.

					if ( d_data->trackerOverlay )
					d_data->trackerOverlay->resize( re->size() );

					if ( d_data->rubberBandOverlay )
					d_data->rubberBandOverlay->resize( re->size() );

					if ( d_data->resizeMode == Stretch )
					stretchSelection( re->oldSize(), re->size() );

					updateDisplay();
					break;
					}*/
          //case QEvent::Enter:
          case "mouseenter": {
            this.widgetEnterEvent(event);
            break;
          }
          //case QEvent::Leave:
          case "mouseleave": {
            this.widgetLeaveEvent(event);
            break;
          }
          //case QEvent::MouseButtonPress:
          case mousedownEvent: {
            this.widgetMousePressEvent(event);
            break;
          }
          //case QEvent::MouseButtonRelease:
          case mouseupEvent: {
            this.widgetMouseReleaseEvent(event);
            break;
          }
          //QEvent::MouseButtonClick:
          case "click": {
            this.widgetMouseClickEvent(event);
            break;
          }
          //QEvent::MouseButtonDblClick:
          case "dblclick": {
            this.widgetMouseDoubleClickEvent(event);
            break;
          }
          //case QEvent::MouseMove:
          case mousemoveEvent: {
            //console.log(event.clientX)
            this.widgetMouseMoveEvent(event);
            break;
          }
          //case QEvent::KeyPress:
          case "keydown": {
            this.widgetKeyPressEvent(event);
            break;
          }
          //case QEvent::KeyRelease:
          case "keyup": {
            this.widgetKeyReleaseEvent(event);
            break;
          }
          //case QEvent::Wheel:
          case "mousewheel": {
            this.widgetWheelEvent(event);
            break;
          }
          default:
            break;
        }
      }
      return false;
    };

    /**
     * Passes an event to the state machine and executes the resulting commands. Append and Move commands use the current
     * position of the cursor.
     * @param {Event} event Event
     *
     */
    this.transition = function (event) {
      if (!d_data.stateMachine) return;

      /*const QList<QwtPickerMachine::Command>*/
      var commandList = d_data.stateMachine.transition(this, event);

      var pos;
      switch (event.type) {
        case "click":
        //case QEvent::MouseButtonDblClick:
        case "dblclick":
        case mousedownEvent:
        //case QEvent::MouseButtonRelease:
        case mouseupEvent:
        //case QEvent::MouseMove:
        case mousemoveEvent: {
          var me = event;

          var pos = new Misc.Point(me.clientX, me.clientY);
          //var pos = new Misc.Point(mouseEvent.clientX, mouseEvent.clientY)

          if (Static.isMobile()) {
            pos = new Misc.Point(
              event.originalEvent.changedTouches[0].clientX,
              event.originalEvent.changedTouches[0].clientY
            );
            //pos = new Misc.Point(event.originalEvent.touches[0].clientX, event.originalEvent.touches[0].clientY)
          }

          //pos = this.parentWidget().mapToElement( new Misc.Point(me.clientX, me.clietY) );
          //console.log(me.clientY)
          pos = this.parentWidget().mapToElement(pos);
          break;
        }
        default:
          //pos = this.parentWidget()->mapFromGlobal( QCursor::pos() );
          pos = this.parentWidget().mapToElement(new Misc.Point(0, 0));
      }

      for (var i = 0; i < commandList.length; i++) {
        switch (commandList[i]) {
          case Static.Begin: {
            this.begin();
            break;
          }
          case Static.Append: {
            this.append(pos);
            break;
          }
          case Static.Move: {
            this.move(pos);
            break;
          }
          case Static.Remove: {
            this.remove();
            break;
          }
          case Static.End: {
            this.end();
            break;
          }
        }
      }
    };

    /**
     * Reset the state machine and terminate ( end(false) ) the selection
     */
    this.reset = function () {
      if (d_data.stateMachine) d_data.stateMachine.reset();

      if (this.isActive()) this.end(false);
    };

    /**
     * Append a point to the selection and update rubber band and tracker.
     *
     * The appended() signal is emitted.
     * @param {Misc.Point} pos Additional point
     * @see {@link Picker#isActive isActive()}
     * @see {@link Picker#begin begin()}
     * @see {@link Picker#end end()}
     */
    this.append = function (pos) {
      if (d_data.isActive) {
        d_data.pickedPoints.push(pos);
        this.updateDisplay();
        Static.trigger("appended", pos);
      }
    };

    /**
     * Move the last point of the selection
     *
     * The moved event is emitted.
     * @param {Misc.Point} pos New position
     * @see {@link Picker#isActive isActive()}
     * @see {@link Picker#begin begin()}
     * @see {@link Picker#append append()}
     * @see {@link Picker#end end()}
     */
    this.move = function (/*const QPoint*/ pos) {
      if (d_data.isActive) {
        var idx = d_data.pickedPoints.length - 1;
        if (idx >= 0) {
          if (d_data.pickedPoints[idx] != pos) {
            d_data.pickedPoints[idx] = pos;

            this.updateDisplay();

            //Q_EMIT moved( pos );
            Static.trigger("moved", pos);
          }
        }
      }
    };

    /**
     * Remove the last point of the selection
     *
     * The removed event is triggered.
     * @see {@link Picker#isActive isActive()}
     * @see {@link Picker#begin begin()}
     * @see {@link Picker#append append()}
     * @see {@link Picker#move move()}
     */
    this.remove = function () {
      if (d_data.isActive) {
        var idx = d_data.pickedPoints.length - 1;
        if (idx > 0) {
          //var idx = d_data.pickedPoints.length;

          //var pos = d_data.pickedPoints[idx - 1];
          var pos = d_data.pickedPoints.pop();
          //d_data.pickedPoints.resize( idx - 1 );

          this.updateDisplay();
          Static.trigger("removed", pos);
        }
      }
    };

    /**
     * Validate and fix up the selection
     *
     * Accepts all selections unmodified
     * @param {Array<Misc.Point>} selection Selection to validate and fix up
     * @returns {Boolean} true, when accepted, false otherwise
     */
    this.accept = function (/*QPolygon &*/ selection) {
      return true;
    };

    /**
     * A picker is active between begin() and end().
     * @returns {Boolean} true if the selection is active.
     */
    this.isActive = function () {
      return d_data.isActive;
    };

    /**
     * Return the points, that have been collected so far. The selection() is calculated from the pickedPoints() in adjustedPoints().
     * @returns {Array<Misc.Point>} Picked points
     */
    this.pickedPoints = function () {
      return d_data.pickedPoints;
    };

    /**
     * Sets mouse tracking for the observed widget.
     *
     * In case of enable is true, the previous value is saved, that is restored when enable is false.
     * @param {Boolean} enable
     *
     */
    this.setMouseTracking = function (enable) {
      var widget = this.parentWidget();
      if (!widget) return;

      if (enable) {
        d_data.mouseTracking = widget.hasMouseTracking();
        widget.setMouseTracking(true);
      } else {
        widget.setMouseTracking(d_data.mouseTracking);
      }
    };

    /**
     * Find the area of the observed widget, where selection might happen.
     * @returns {Misc.Rect} widget.contentsRect();
     */
    this.pickArea = function () {
      //QPainterPath path;

      var widget = this.parentWidget();
      if (widget) return widget.contentsRect();
      return null;

      //return path;
    };

    /**
     * Update the state of rubber band and tracker label
     */
    this.updateDisplay = function () {
      /*QWidget*/
      var w = self.parentWidget();

      var showRubberband = false;
      var showTracker = false;

      if (w && w.isVisible() && d_data.enabled) {
        //console.log("self.isActive(): "+self.isActive())
        if (
          self.rubberBand() !== Picker.RubberBand.NoRubberBand &&
          self.isActive() &&
          self.rubberBandPen().style !== Static.NoPen
        ) {
          showRubberband = true;
        }

        if (
          self.trackerMode() == Picker.DisplayMode.AlwaysOn ||
          (self.trackerMode() == Picker.DisplayMode.ActiveOnly &&
            self.isActive())
        ) {
          if (self.trackerPen().color != Static.NoPen) {
            //&& !self.trackerRect( QFont() ).isEmpty() )
            showTracker = true;
          }
        }
      }

      /*QPointer< QwtPickerRubberband >*/
      var rw = d_data.rubberBandOverlay;
      if (showRubberband) {
        //if ( rw.isNull() )
        if (rw == null) {
          //rw = new PickerRubberband( self, null ); // NULL -> no extra event filter
          rw = new PickerRubberband(self, w);
          //console.log("rubberBandOverlay created")
          rw.setObjectName("PickerRubberBand");
          d_data.rubberBandOverlay = rw;
          //rw.setParent( w );
          //rw->resize( w->size() );
        }

        //if ( d_data.rubberBand <= Picker.RubberBand.RectRubberBand )
        //rw->setMaskMode( QwtWidgetOverlay::MaskHint );
        //else
        //rw->setMaskMode( QwtWidgetOverlay::AlphaMask );

        rw.updateOverlay();
      } else {
        /*if ( d_data->openGL ){
				// Qt 4.8 crashes for a delete
				if ( !rw.isNull() ){
				rw->hide();
				rw->deleteLater();
				rw = NULL;
				}
				}
				else{
				delete rw;
				}*/
        if (rw) {
          d_data.rubberBandOverlay.getCanvas().hide();
          delete d_data.rubberBandOverlay.getCanvas();
          d_data.rubberBandOverlay = null;
        }
      }

      /*QPointer< QwtPickerTracker >*/
      var tw = d_data.trackerOverlay;
      if (showTracker) {
        //if ( tw.isNull() )
        if (tw == null) {
          //tw = new PickerTracker( self, null ); // NULL -> no extra event filter
          tw = new PickerTracker(self, w);
          //console.log("trackerOverlay created")
          tw.setObjectName("PickerTracker");
          d_data.trackerOverlay = tw;
          //tw.setParent( w );
          // tw->resize( w->size() );
        }
        tw.setFont(d_data.trackerFont);
        tw.updateOverlay();
      } else {
        /*if ( d_data->openGL ){
				// Qt 4.8 crashes for a delete
				if ( !tw.isNull() ){
				tw->hide();
				tw->deleteLater();
				tw = NULL;
				}
				}*/
        /* else
			{
				delete tw;
				}*/

        if (tw) {
          //d_data.trackerOverlay.clearCanvas()
          //d_data.trackerOverlay = null
          d_data.trackerOverlay.getCanvas().hide();
          delete d_data.trackerOverlay.getCanvas();
          d_data.trackerOverlay = null;
        }
      }
    };

    /**
     *
     * @returns {WidgetOverlay} Overlay displaying the rubber band
     */
    this.rubberBandOverlay = function () {
      return d_data.rubberBandOverlay;
    };

    /**
     *
     * @returns {WidgetOverlay} Overlay displaying the tracker text
     */
    this.trackerOverlay = function () {
      return d_data.trackerOverlay;
    };

    /*this.widgetMouseReleaseEvent = function( mouseEvent ) {
		this.transition( mouseEvent );
		}*/

    if (rubberBand == undefined && trackerMode == undefined)
      this.init(
        parent,
        Picker.RubberBand.NoRubberBand,
        Picker.DisplayMode.AlwaysOff
      );
    else this.init(parent, rubberBand, trackerMode);
  }

  /**
     * Map the pickedPoints() into a selection()
     * 
     * adjustedPoints() maps the points, that have been collected on Widget into a selection(). The default implementation 
     * simply returns the points unmodified. The reason, why a selection() differs from the picked points depends on the 
     * application requirements. e.g. : 
     * 
     * - A rectangular selection might need to have a specific aspect ratio only.
     * 
     * - A selection could accept non intersecting polygons only.
     * 
     * - ...
     * 
     * The example below is for a rectangular selection, where the first point is the center of the selected rectangle.
     * 
            Example
            MyPicker#adjustedPoints(points){
              let adjusted = [];
              if ( points.length == 2 ){
                const width = Math.abs(points[1].x - points[0].x);
                const height = Math.abs(points[1].y - points[0].y);

                const rect = new Misc.Rect(0, 0, 2 * width, 2 * height);
                rect.moveCenter(points[0]);

                adjusted.push(rect.topLeft());
                adjusted.push(rect.bottomRight());
              }
              return adjusted;
            }
     * @param {Array<Misc.Point>} points Selected points
     * @returns {Array<Misc.Point>} Selected points unmodified
     */
  adjustedPoints(points) {
    return points;
  }

  /**
   * Handle a enter event for the observed widget.
   * @param {Event} event event
   */
  widgetEnterEvent(event) {
    this.transition(event);
  }

  /**
   * Handle a leave event for the observed widget.
   * @param {Event} event event
   */
  widgetLeaveEvent(event) {
    this.transition(event);

    this.getPickerData().trackerPosition = new Misc.Point(-1, -1);
    if (!this.isActive()) this.updateDisplay();
  }

  /**
   * Handle a key release event for the observed widget.
   *
   * Passes the event to the state machine.
   * @param {Event} keyEvent Key event
   */
  widgetKeyReleaseEvent(keyEvent) {
    this.transition(keyEvent);
  }

  /**
   * Handle a wheel event for the observed widget.
   *
   * Move the last point of the selection in case of isActive() == true
   * @param {Event} wheelEvent Wheel event
   */
  widgetWheelEvent(wheelEvent) {
    var pos = new Misc.Point(wheelEvent.clientX, wheelEvent.clientY);
    if (this.pickArea().contains(pos))
      this.getPickerData().trackerPosition = pos;
    else this.getPickerData().trackerPosition = new Misc.Point(-1, -1);

    this.updateDisplay();

    this.transition(wheelEvent);
  }

  /**
   * Handle mouse click event for the observed widget.
   * @param {Event} mouseEvent  Mouse event
   */
  widgetMouseClickEvent(mouseEvent) {
    this.transition(mouseEvent);
  }

  /**
   * Handle mouse double click event for the observed widget.
   * @param {Event} mouseEvent  Mouse event
   */
  widgetMouseDoubleClickEvent(mouseEvent) {
    this.transition(mouseEvent);
  }

  /**
   * Handle a mouse move event for the observed widget.
   * @param {Event} mouseEvent  Mouse event
   */
  widgetMouseMoveEvent(mouseEvent) {
    var pos = new Misc.Point(mouseEvent.clientX, mouseEvent.clientY);
    //var pos = new Misc.Point(mouseEvent.clientX, mouseEvent.clientY)

    if (Static.isMobile()) {
      pos = new Misc.Point(
        mouseEvent.originalEvent.changedTouches[0].clientX,
        mouseEvent.originalEvent.changedTouches[0].clientY
      );
      //pos = new Misc.Point(mouseEvent.originalEvent.touches[0].clientX, mouseEvent.originalEvent.touches[0].clientY)
    }
    pos = this.mapToElement(pos);

    if (this.pickArea().contains(pos))
      this.getPickerData().trackerPosition = pos;
    else this.getPickerData().trackerPosition = new Misc.Point(-1, -1);

    if (!this.isActive()) this.updateDisplay();

    this.transition(mouseEvent);
  }

  /**
   * Handle a mouse press event for the observed widget.
   * @param {Event} mouseEvent Mouse event
   */
  widgetMousePressEvent(mouseEvent) {
    this.transition(mouseEvent);
  }

  /* void QwtPicker::widgetKeyPressEvent( QKeyEvent* keyEvent )
 {
     int dx = 0;
     int dy = 0;
  
     int offset = 1;
     if ( keyEvent->isAutoRepeat() )
         offset = 5;
  
     if ( keyMatch( KeyLeft, keyEvent ) )
         dx = -offset;
     else if ( keyMatch( KeyRight, keyEvent ) )
         dx = offset;
     else if ( keyMatch( KeyUp, keyEvent ) )
         dy = -offset;
     else if ( keyMatch( KeyDown, keyEvent ) )
         dy = offset;
     else if ( keyMatch( KeyAbort, keyEvent ) )
     {
         reset();
     }
     else
         transition( keyEvent );
  
     if ( dx != 0 || dy != 0 )
     {
         const QRect rect = pickArea().boundingRect().toRect();
         const QPoint pos = parentWidget()->mapFromGlobal( QCursor::pos() );
  
         int x = pos.x() + dx;
         x = qMax( rect.left(), x );
         x = qMin( rect.right(), x );
  
         int y = pos.y() + dy;
         y = qMax( rect.top(), y );
         y = qMin( rect.bottom(), y );
  
         QCursor::setPos( parentWidget()->mapToGlobal( QPoint( x, y ) ) );
     }
 }
  
 void QwtPicker::widgetKeyReleaseEvent( QKeyEvent* keyEvent )
 {
     transition( keyEvent );
 } */

  /**
   * Handle a key press event for the observed widget.
   *
   * Selections can be completely done by the keyboard. The arrow keys
   * move the cursor, the abort key aborts a selection. All other keys are handled by the current state machine.
   * @param {Event} keyEvent Key event
   */
  widgetKeyPressEvent(keyEvent) {
    var dx = 0;
    var dy = 0;

    var offset = 1;
    // if ( keyEvent->isAutoRepeat() )
    //offset = 5;
    //const Enum = Enumerator.getDefaultEnumNampespace();
    if (this.keyMatch(EventPattern.KeyPatternCode.KeyLeft, keyEvent))
      dx = -offset;
    else if (this.keyMatch(EventPattern.KeyPatternCode.KeyRight, keyEvent))
      dx = offset;
    else if (this.keyMatch(EventPattern.KeyPatternCode.KeyUp, keyEvent))
      dy = -offset;
    else if (this.keyMatch(EventPattern.KeyPatternCode.KeyDown, keyEvent))
      dy = offset;
    else if (this.keyMatch(EventPattern.KeyPatternCode.KeyAbort, keyEvent)) {
      this.reset();
    } else this.transition(keyEvent);

    if (dx !== 0 || dy !== 0) {
      ///*const QRect* rect = pickArea().boundingRect().toRect();
      /*const QRect*/
      var rect = this.pickArea(); //.boundingRect().toRect();
      /*const QPoint*/

      // var pos = this.parentWidget().mapToElement(
      //   new Misc.Point(clientX, clientY)
      // );

      // var x = pos.x + dx;
      // x = Math.max(rect.left(), x);
      // x = Math.min(rect.right(), x);

      // var y = pos.y + dy;
      // y = Math.max(rect.top(), y);
      // y = Math.min(rect.bottom(), y);

      //console.log(dx, dy);

      //QCursor::setPos( parentWidget()->mapToGlobal( QPoint( x, y ) ) );
      ////////////////////////////
      //console.log(keyEvent);
    }
  }

  /**
   * Handle a mouse release event for the observed widget.
   * @param {Event} mouseEvent Mouse event
   */
  widgetMouseReleaseEvent(mouseEvent) {
    this.transition(mouseEvent);
  }

  /**
   * Close a selection setting the state to inactive.
   *
   * The selection is validated and maybe fixed by accept().
   * @param {Boolean} ok If true, complete the selection and trigger a appropriate event
   * @returns {Boolean} true if the selection is accepted, false otherwise
   * @see {@link Picker#isActive isActive()}
   * @see {@link Picker#begin begin()}
   * @see {@link Picker#append append()}
   * @see {@link Picker#move move()}
   * @see {@link Picker#accept accept()}
   */
  end(ok) {
    var d = this.getPickerData();
    if (d.isActive) {
      this.setMouseTracking(false);

      d.isActive = false;

      Static.trigger("activated", false);

      if (this.trackerMode() == Picker.DisplayMode.ActiveOnly)
        d.trackerPosition = new Misc.Point(-1, -1);

      if (ok) ok = this.accept(d.pickedPoints);

      if (
        ok //Static.trigger("selected", d.pickedPoints);
      );
      else d.pickedPoints = [];

      this.updateDisplay();
    } else ok = false;

    return ok;
  }

  /**
   * Open a selection setting the state to active
   * @see {@link Picker#isActive isActive()}
   * @see {@link Picker#end end()}
   * @see {@link Picker#move move()}
   */
  begin() {
    var d = this.getPickerData();
    if (!d) return;
    if (d.isActive) return;

    d.pickedPoints = []; //.resize( 0 );
    d.isActive = true;

    Static.trigger("activated", true);

    if (this.trackerMode() !== Picker.DisplayMode.AlwaysOff) {
      if (d.trackerPosition.x < 0 || d.trackerPosition.y < 0) {
        var w = this.parentWidget();
        if (w)
          //d_data.trackerPosition = w->mapFromGlobal( QCursor::pos() );
          d.trackerPosition = w.mapToElement(new Misc.Point(0, 0));
      }
    }

    this.updateDisplay();
    this.setMouseTracking(true);
  }

  /**
   * Return the label for a position
   *
   * In case of HLineRubberBand the label is the value of the y position, in case of VLineRubberBand the value of the x position.
   * Otherwise the label contains x and y position separated by a ','.
   * @param {Number} pos Position
   * @returns {String} Converted position as string
   */
  trackerText(pos) {
    //pos =  this.invTransform( pos )
    var label; //= "";

    switch (this.rubberBand()) {
      case Picker.RubberBand.HLineRubberBand:
        label = pos.y.toString();
        break;
      case Picker.RubberBand.VLineRubberBand:
        label = pos.x.toString();
        break;
      default:
        label = pos.x.toString() + ", " + pos.y.toString();
    }
    return label;
  }
}

Picker.pickers = [];

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link Picker.RubberBand}</div>
 *
 * Rubber band style
 *
 * The default value is Picker.NoRubberBand.
 * @name Picker.RubberBand
 * @readonly
 * @property {Number} NoRubberBand             	No rubberband.
 * @property {Number} HLineRubberBand          	A horizontal line ( only for PickerMachine.SelectionType.PointSelection )
 * @property {Number} VLineRubberBand          	A vertical line ( only for PickerMachine.SelectionType.PointSelection )
 * @property {Number} CrossRubberBand          	A crosshair ( only for PickerMachine.SelectionType.PointSelection )
 * @property {Number} RectRubberBand           	A rectangle ( only for PickerMachine.SelectionType.RectSelection )
 * @property {Number} EllipseRubberBand         An ellipse ( only for PickerMachine.SelectionType.PointSelection )
 * @property {Number} PolygonRubberBand         A polygon line ( only for PickerMachine.SelectionType.PolygonSelection )
 * @property {Number} UserRubberBand         	Values >= UserRubberBand(100) can be used to define additional rubber bands.
 */
Enumerator.enum(
  "RubberBand {\
	NoRubberBand = 0 , HLineRubberBand , VLineRubberBand , CrossRubberBand ,\
	RectRubberBand , EllipseRubberBand , PolygonRubberBand , UserRubberBand = 100\
  }",
  Picker
);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link Picker.DisplayMode}</div>
 *
 * Display mode.
 * @name Picker.DisplayMode
 * @readonly
 * @property {Number} AlwaysOff               Display never.
 * @property {Number} AlwaysOn                Display always.
 * @property {Number} ActiveOnly              Display only when the selection is active.
 */
Enumerator.enum("DisplayMode { AlwaysOff , AlwaysOn , ActiveOnly }", Picker);

define("picker", ["underscore","static","widgetOverlay","pickermachine"], function(){});



/**
 * PlotPicker provides selections on a plot canvas
 *
 * PlotPicker is a Picker tailored for selections on a plot canvas.
 * It is set to a x-Axis and y-Axis and translates all pixel coordinates
 * into this coordinate system.
 * @extends Picker
 */
class PlotPicker extends Picker {
  /**
   * Create a plot picker. See example for how to use the oveloaded constructor
   *
   * The picker is set to those x- and y-axis of the plot that are enabled. If both or no x-axis are enabled, the picker is set
   * to {@link Axis.AxisId Axis.AxisId.xBottom}. If both or no y-axis are enabled, it is set to {@link Axis.AxisId Axis.AxisId.yLeft}.
   * @param {Axis.AxisId} [xAxis] axis of the picker
   * @param {Axis.AxisId} [yAxis] axis of the picker
   * @param {Picker.RubberBand} [rubberBand]
   * @param {Picker.DisplayMode} [trackerMode]
   * @param {Widget} canvas
   * @example
   * const plot = new Plot();
   * ...
   * const picker = new PlotPicker(plot);
   * or
   * const picker = new PlotPicker(Axis.AxisId.xTop, Axis.AxisId.yRight, plot);
   * or
   * const picker = new PlotPicker(Axis.AxisId.xTop, Axis.AxisId.yRight, Picker.RubberBand.RectRubberBand, Picker.DisplayMode.AlwaysOff, plot);
   */
  constructor(xAxis, yAxis, rubberBand, trackerMode, /*QWidget **/ canvas) {
    var _constructor = 0;

    if (typeof xAxis !== "number") {
      //constructor 1
      /*PlotPicker( QWidget *canvas );*/
      canvas = xAxis;
      xAxis = -1;
      yAxis = -1;
      rubberBand = Picker.RubberBand.NoRubberBand;
      trackerMode = Picker.DisplayMode.AlwaysOff;
      _constructor = 1; //indicate the constructor to use
    }
    if (typeof rubberBand !== "number") {
      //constructor 2
      /*PlotPicker( int xAxis, int yAxis,/* QWidget */ /*canvas)*/
      canvas = rubberBand;
      rubberBand = Picker.RubberBand.NoRubberBand;
      trackerMode = Picker.DisplayMode.AlwaysOff;
      _constructor = 2; //indicate the constructor to use
    }

    if (canvas instanceof Plot) canvas = canvas.getCentralWidget();

    super(rubberBand, trackerMode, canvas);
    this.d_xAxis = -1;
    this.d_yAxis = -1;

    if (_constructor == 1) {
      var plot = this.plot();
      var xAxis = Axis.AxisId.xBottom;
      if (
        plot &&
        !plot.axisEnabled(Axis.AxisId.xBottom) &&
        plot.axisEnabled(Axis.AxisId.xTop)
      ) {
        xAxis = Axis.AxisId.xTop;
      }

      var yAxis = Axis.AxisId.yLeft;
      if (
        plot &&
        !plot.axisEnabled(Axis.AxisId.yLeft) &&
        plot.axisEnabled(Axis.AxisId.yRight)
      ) {
        yAxis = Axis.AxisId.yRight;
      }

      this.setAxis(xAxis, yAxis);
    } else {
      this.d_xAxis = xAxis;
      this.d_yAxis = yAxis;
    }

    this.setEnabled(true);
    if (canvas) canvas.setEnabled_1(true);
  }

  /**
   * Set the x and y axes of the picker
   * @param {Axis.AxisId} xAxis X axis
   * @param {Axis.AxisId} yAxis Y axis
   *
   */
  setAxis(xAxis, yAxis) {
    var plt = this.plot();
    if (!plt) return;

    if (xAxis != this.d_xAxis || yAxis != this.d_yAxis) {
      this.d_xAxis = xAxis;
      this.d_yAxis = yAxis;
    }
  }

  /**
   *
   * @returns {Axis.AxisId} Return x axis.
   */
  xAxis() {
    return this.d_xAxis;
  }

  /**
   *
   * @returns {Axis.AxisId} Return y axis.
   */
  yAxis() {
    return this.d_yAxis;
  }

  /**
   *
   * @returns {Plot} Plot widget, containing the observed plot canvas
   */
  plot() {
    var w = this.parentWidget();
    if (!w) return null;
    return w.plot;
  }

  /**
   *
   * @returns {Widget} Observed plot canvas
   */
  canvas() {
    return this.parentWidget();
  }

  /**
   * @returns {Misc.Rect} Normalized bounding rectangle of the axes
   */
  scaleRect() {
    var rect = null;
    if (this.plot()) {
      var xs = this.plot().axisScaleDiv(this.xAxis());
      var ys = this.plot().axisScaleDiv(this.yAxis());

      rect = new Misc.Rect(
        xs.lowerBound(),
        ys.lowerBound(),
        xs.range(),
        ys.range()
      );
      rect = rect.normalized();
    }

    return rect;
  }

  /**
   * Translate a rectangle from pixel into plot coordinates
   * @param {Misc.Rect} rect
   * @returns {Misc.Rect} Rectangle in plot coordinates
   * @see {@link PlotPicker#transform transform()}
   */
  /*QRectF */ invTransform(/*const QRect &*/ rect) {
    var xMap = this.plot().canvasMap(this.d_xAxis);
    var yMap = this.plot().canvasMap(this.d_yAxis);
    if (_.has(rect, "x") && _.has(rect, "y")) {
      //argument is a point
      var pos = rect;
      return new Misc.Point(xMap.invTransform(pos.x), yMap.invTransform(pos.y));
    } else {
      //argument is a rect
      return ScaleMap.invTransform_Rect(xMap, yMap, rect);
    }
  }

  /**
   * Translate a rectangle from plot into pixel coordinates
   * @param {Misc.Rect} rect
   * @returns {Misc.Rect} Rectangle in pixel coordinates
   * @see {@link PlotPicker#invTransform invTransform()}
   */
  /*QRect */ transform(/* const QRectF &*/ rect) {
    var xMap = this.plot().canvasMap(this.d_xAxis);
    var yMap = this.plot().canvasMap(this.d_yAxis);
    if (rect.x !== undefined) {
      //argument is a point
      var pos = rect;
      var p = new Misc.Point(xMap.transform(pos.x), yMap.transform(pos.y));

      return p;
    } else {
      //return QwtScaleMap::transform( xMap, yMap, rect ).toRect();
      return Static.mTransform(xMap, yMap, rect);
    }
  }

  /**
   * Translate a pixel position into a position string
   * @param {Misc.Point} pos Position in pixel coordinates
   * @returns {String} Position string
   */
  /*virtual QwtText */ trackerText(/* const QPointF &*/ pos) {
    pos = this.invTransform(pos);
    var label; //= "";

    switch (this.rubberBand()) {
      case Picker.RubberBand.HLineRubberBand:
        label = pos.y.toString();
        break;
      case Picker.RubberBand.VLineRubberBand:
        label = pos.x.toString();
        break;
      default:
        label = pos.x.toString() + ", " + pos.y.toString();
    }
    return label;
  }

  /**
   * Move the last point of the selection
   * @param {Misc.Point} pos New position
   * @see {@link PlotPicker#isActive isActive()}
   * @see {@link PlotPicker#begin begin()}
   * @see {@link PlotPicker#end end()}
   * @see {@link PlotPicker#append append()}
   */
  move(/*const QPoint &*/ pos) {
    super.method(move(pos));
    Static.trigger("moved", invTransform(pos));
  }

  /**
   * Append a point to the selection and update rubber band and tracker.
   * @param {Misc.Point} pos New position
   * @see {@link PlotPicker#isActive isActive()}
   * @see {@link PlotPicker#begin begin()}
   * @see {@link PlotPicker#end end()}
   */
  append(/*const QPoint & */ pos) {
    super.method(append(pos));
    Static.trigger("appended", invTransform(pos));
  }

  /**
   * Close a selection setting the state to inactive.
   * @param {Boolean} ok If true, complete the selection and emit selected signals otherwise discard the selection.
   * @returns {Boolean} True if the selection has been accepted, false otherwise
   */
  /*virtual bool*/ end(ok = true) {
    ok = super.end(ok);
    if (!ok) return false;

    var plot = this.plot();
    if (!plot) return false;

    var points = this.selection();
    if (points.length == 0) return false;

    var selectionType = PickerMachine.SelectionType.NoSelection;

    if (this.stateMachine())
      selectionType = this.stateMachine().selectionType();

    switch (selectionType) {
      case PickerMachine.SelectionType.PointSelection: {
        var pos = this.invTransform(points[0]);
        Static.trigger("selected", pos);
        break;
      }
      case PickerMachine.SelectionType.RectSelection: {
        if (points.length >= 2) {
          var p1 = points[0];
          var p2 = points[points.length - 1];

          var rect = new Misc.Rect(p1, p2).normalized();
          Static.trigger("selected", this.invTransform(rect));
        }
        break;
      }
      case PickerMachine.SelectionType.PolygonSelection: {
        var dpa = [];
        for (var i = 0; i < points.length; i++)
          dpa.push(this.invTransform(points[i]));

        Static.trigger("selected", dpa);
      }
      default:
        break;
    }

    return true;
  }
}
;
define("plotpicker", ["static","picker"], function(){});



"include ['static', 'plotpicker']";

class MPicker extends PlotPicker {
  constructor(plot, rulerPos, ruler) {
    super(plot);
    var self = this;
    this._rulerPos = rulerPos;
    this._ruler = ruler;
    var _zoomer = null,
      _panner = null,
      _magnifier = null;
    var _qwtPlotCursorShape = "";
    var _cursorOld = null;
    var _cursorDrag = null;
    var _preventDragging = false;
    var _controlFlags = 0;

    var _mouseDown = false;

    //At this stage, no current curve is set. Thus, we could live with whatever axes the base class (QwtPlotPicker) sets.
    //We make the adjustment when we set a valid current curve that is visible.
    if (this._ruler) {
      this._ruler.setAxes(this.xAxis(), this.yAxis());
    }

    var _trackingTextStyle = MPicker.TrackingExtent.FullTrackingText;
    if (this.plot()) {
      _qwtPlotCursorShape = this.plot().cursor();
    }

    this.preventDragging = function (on) {
      _preventDragging = on;
    };

    this.controlFlag = function (flag) {
      return Boolean(_controlFlags & flag);
    };

    this.setControlFlag = function (flag, set) {
      if (set) _controlFlags |= flag;
      else _controlFlags &= ~flag;
    };

    this.prohibit = function () {
      if (_zoomer && this.controlFlag(MPicker.DisplayChange.ZoomerSearch)) {
        this.setControlFlag(
          MPicker.DisplayChange.ZoomEnabled,
          _zoomer.isEnabled()
        );
        if (this.controlFlag(MPicker.DisplayChange.ZoomEnabled))
          _zoomer.setEnabled(false);
      }
      if (_panner && this.controlFlag(MPicker.DisplayChange.PannerSearch)) {
        this.setControlFlag(
          MPicker.DisplayChange.PanEnabled,
          _panner.isEnabled()
        );
        if (this.controlFlag(MPicker.DisplayChange.PanEnabled))
          _panner.setEnabled(false);
      }

      if (
        _magnifier &&
        this.controlFlag(MPicker.DisplayChange.MagnifierSearch)
      ) {
        this.setControlFlag(
          MPicker.DisplayChange.MagnifierEnabled,
          _magnifier.isEnabled()
        );
        if (this.controlFlag(MPicker.DisplayChange.MagnifierEnabled))
          _magnifier.setEnabled(false);
      }
    };

    this.restore = function () {
      if (_zoomer && this.controlFlag(MPicker.DisplayChange.ZoomEnabled)) {
        //Zooming was disable before dragging.
        _zoomer.setEnabled(true); //Dragging has ended. Re-enable zooming.
        this.setControlFlag(MPicker.DisplayChange.ZoomEnabled, false);
      }
      if (_panner && this.controlFlag(MPicker.DisplayChange.PanEnabled)) {
        //Panning was disable before dragging.
        _panner.setEnabled(true); //Dragging has ended. Re-enable panning.
        this.setControlFlag(MPicker.DisplayChange.PanEnabled, false);
      }
      if (
        _magnifier &&
        this.controlFlag(MPicker.DisplayChange.MagnifierEnabled)
      ) {
        //Panning was disable before dragging.
        _magnifier.setEnabled(true); //Dragging has ended. Re-enable magnifier.
        this.setControlFlag(MPicker.DisplayChange.MagnifierEnabled, false);
      }
    };

    this.setDragCursor = function () {
      if (_preventDragging) return;
      if (this.controlFlag(MPicker.DisplayChange.DragCursor)) return;
      if (plot.cursor() != _qwtPlotCursorShape) return;
      _cursorOld = plot.cursor();
      _cursorDrag = this._dragCursorShape;
      plot.setCursor(_cursorDrag);
      this.setControlFlag(MPicker.DisplayChange.DragCursor, true);
      //We prohibit magnifying, zooming and/or panning during dragging.
      this.prohibit();

      Static.trigger("rulerSelected", self._ruler);
    };

    this.clearDragCursor = function () {
      if (!this.controlFlag(MPicker.DisplayChange.DragCursor)) return;
      this._ruler.plot().setCursor(_cursorOld);
      this.setControlFlag(MPicker.DisplayChange.DragCursor, false);
      this.restore();
      Static.trigger("rulerDeselected", self._ruler);
    };

    this.setTrackingTextStyle = function (trackingTextStyle) {
      _trackingTextStyle = trackingTextStyle;
    };

    this.trackerText = function (pos) {
      if (
        this._ruler.lock() ||
        _trackingTextStyle == MPicker.TrackingExtent.NoTrackingText ||
        (!this.controlFlag(MPicker.DisplayChange.LeftButtonDown) &&
          !this.controlFlag(MPicker.DisplayChange.ZoomEnabled))
      )
        return "";

      if (_trackingTextStyle == MPicker.TrackingExtent.FullTrackingText) {
        var xTitle = this.axisTitle();
        if (!xTitle.length) return this._rulerPos;
        return xTitle + "=" + this._rulerPos;
      }
      if (_trackingTextStyle == MPicker.TrackingExtent.PartialTrackingText) {
        return this._rulerPos;
      }
      return "";
    };

    this.panningFinished = function () {
      this.setControlFlag(MPicker.DisplayChange.PanningInProgress, false);
    };

    this.panningStarted = function () {
      this.setControlFlag(MPicker.DisplayChange.PanningInProgress, true);
    };

    var plotDivParent = plot.getLayout().getPlotDiv().parent();
    plotDivParent.on("mouseup", function () {
      if (MPicker.DisplayChange.LeftButtonDown) {
        if (Static.isMobile()) {
          self.clearDragCursor();
        }
        self.setControlFlag(MPicker.DisplayChange.LeftButtonDown, false);
      }
    });

    this.initMagnifier = function () {
      if (
        !this.controlFlag(MPicker.DisplayChange.MagnifierSearch) ||
        _magnifier
      )
        return;
      if (plot.magnifier) {
        _magnifier = plot.magnifier;
      }
    };

    this.initZoomer = function () {
      if (!this.controlFlag(MPicker.DisplayChange.ZoomerSearch) && _zoomer) {
        //_zoomer = null
        return;
      }
      if (plot.zoomer) {
        _zoomer = plot.zoomer;
      }
    };

    this.initPanner = function () {
      if (!this.controlFlag(MPicker.DisplayChange.PannerSearch) && _panner)
        return;
      if (plot.panner) {
        _panner = plot.panner;
      }
    };

    this.doMouseReleaseEvent = function (event) {
      if (
        !this._ruler.isVisible() ||
        this.controlFlag(MPicker.DisplayChange.PanningInProgress)
      )
        return;
      if (event.button == Static.LeftButton) {
        if (this.controlFlag(MPicker.DisplayChange.LeftButtonDown)) {
          Static.trigger("positionChanged", [this._ruler, this._rulerPos]);
        }
        this.setControlFlag(MPicker.DisplayChange.LeftButtonDown, false);
      }

      if (Static.isMobile()) {
        if (this.controlFlag(MPicker.DisplayChange.LeftButtonDown)) {
          Static.trigger("positionChanged", [this._ruler, this._rulerPos]);
        }
        this.setControlFlag(MPicker.DisplayChange.LeftButtonDown, false);
      }
    };

    this.doMouseLeaveEvent = function (event) {
      if (plot.rv._curve && _mouseDown) {
        Static.trigger("positionChanged", [self._ruler, self._rulerPos]);
      }
    };

    $(window).mouseup(function (event) {
      // if (plot.rv._curve)
      //   Static.trigger("positionChanged", [self._ruler, self._rulerPos]);
      _mouseDown = false;
    });

    $(window).mousedown(function (event) {
      _mouseDown = true;
    });
  }

  widgetMouseReleaseEvent(event) {
    this.doMouseReleaseEvent(event);
    //super.widgetMouseReleaseEvent(event);
  }

  widgetLeaveEvent(event) {
    this.doMouseLeaveEvent(event);
    //super.widgetMouseReleaseEvent(event);
  }
}
Enumerator.enum(
  "DisplayChange{MagnifierEnabled = 1,\
  ZoomEnabled = 2,\
  PanEnabled = 4,\
  Locked = 8,\
  LeftButtonDown = 16,\
  DragCursor = 32,\
  PanningInProgress = 64,\
  MagnifierSearch = 128,\
  ZoomerSearch = 256,\
  PannerSearch = 512,\
  NoRuler = 1024;}",
  MPicker
);

Enumerator.enum(
  "TrackingExtent{NoTrackingText, FullTrackingText, PartialTrackingText}",
  MPicker
);

class PickerV extends MPicker {
  constructor(plot, rulerPos, ruler) {
    super(plot, rulerPos, ruler);
    this._dragCursorShape = "w-resize";

    this.axisTitle = function () {
      return this._ruler.plot().axisTitle(this.xAxis());
    };
  }

  widgetMousePressEvent(event) {
    //event.preventDefault();

    if (
      !this._ruler.isVisible() ||
      this.controlFlag(MPicker.DisplayChange.PanningInProgress)
    )
      return;
    if (event.button == 2) {
      if (this.controlFlag(MPicker.DisplayChange.DragCursor)) {
      }
      return true;
    }

    if (Static.isMobile()) {
      if (Static.isMobile()) {
        this.clearDragCursor();
      }
      var _rulerPosVal = this._ruler
        .plot()
        .transform(this.xAxis(), this._rulerPos);
      var clientX = event.originalEvent.touches[0].clientX;
      var clientY = event.originalEvent.touches[0].clientY;
      var pt = this.mapToElement(new Misc.Point(clientX, clientY));
      var val = pt.x;
      if (
        !this.controlFlag(MPicker.DisplayChange.LeftButtonDown) &&
        val < _rulerPosVal + 12 &&
        val > _rulerPosVal - 12
      ) {
        this.setDragCursor();
        this.setControlFlag(MPicker.DisplayChange.LeftButtonDown, true);
      }
    } else if (event.button == Static.LeftButton || Static.isMobile()) {
      if (this.controlFlag(MPicker.DisplayChange.DragCursor)) {
        this.setControlFlag(MPicker.DisplayChange.LeftButtonDown, true);
      }
      return true;
    }
    return;
  }

  widgetMouseMoveEvent(event) {
    //event.preventDefault();

    var plot = this._ruler.plot();
    if (!plot.rv._curve) {
      return;
    }
    var clientX = event.clientX;
    var clientY = event.clientY;
    if (Static.isMobile()) {
      var touchobj = event.originalEvent.changedTouches[0]; // reference first touch point for this event
      clientX = parseInt(touchobj.clientX);
      clientY = parseInt(touchobj.clientY);
    }

    var pt = this.mapToElement(new Misc.Point(clientX, clientY));
    var pw = this._ruler.linePen().width;
    var inRect = plot
      .getCentralWidget()
      .contentsRect()
      .adjusted(pw + 1, 0, -(pw + 1), 0)
      .contains(pt);
    if (!inRect) {
      return;
    }

    if (
      !this._ruler.isVisible() ||
      this.controlFlag(MPicker.DisplayChange.PanningInProgress)
    )
      return;
    if (!this.controlFlag(MPicker.DisplayChange.Locked)) {
      // if (Static.isMobile()) {
      //   var touchobj = event.originalEvent.changedTouches[0]; // reference first touch point for this event
      //   clientX = parseInt(touchobj.clientX);
      //   clientY = parseInt(touchobj.clientY);
      // }
      var val = pt.x;
      var _rulerPosVal = this._ruler
        .plot()
        .transform(this.xAxis(), this._rulerPos);
      if (this.controlFlag(MPicker.DisplayChange.LeftButtonDown)) {
        this._rulerPos = plot.invTransform(this.xAxis(), val);
        this._rulerPos = this._ruler._rulers.setPosition(
          this._ruler._rulers.rulerId(this._ruler),
          this._rulerPos
        );
        //this._rulerPos = this._ruler._pos;
        Static.trigger("positionChanging", [this._ruler, this._ruler._pos]);
      }
      if (
        !this.controlFlag(MPicker.DisplayChange.LeftButtonDown) &&
        val < _rulerPosVal + 2 &&
        val > _rulerPosVal - 2
      ) {
        this.setDragCursor();
      }
      if (
        !this.controlFlag(MPicker.DisplayChange.LeftButtonDown) &&
        !(val < _rulerPosVal + 2 && val > _rulerPosVal - 2)
      ) {
        this.clearDragCursor();
      }
    }
  }
}

class PickerH extends MPicker {
  constructor(plot, rulerPos, ruler) {
    super(plot, rulerPos, ruler);

    this._dragCursorShape = "s-resize";

    this.axisTitle = function () {
      return this._ruler.plot().axisTitle(this.yAxis());
    };
  }

  widgetMousePressEvent(event) {
    //event.preventDefault();

    if (
      !this._ruler.isVisible() ||
      this.controlFlag(MPicker.DisplayChange.PanningInProgress)
    )
      return;
    if (event.button == 2) {
      if (this.controlFlag(MPicker.DisplayChange.DragCursor)) {
      }
      return true;
    }

    if (Static.isMobile()) {
      var _rulerPosVal = this._ruler
        .plot()
        .transform(this.yAxis(), this._rulerPos);
      var clientX = event.originalEvent.touches[0].clientX;
      var clientY = event.originalEvent.touches[0].clientY;
      var pt = this.mapToElement(new Misc.Point(clientX, clientY));
      var val = pt.y;
      if (
        !this.controlFlag(MPicker.DisplayChange.LeftButtonDown) &&
        val < _rulerPosVal + 12 &&
        val > _rulerPosVal - 12
      ) {
        this.setDragCursor();
        this.setControlFlag(MPicker.DisplayChange.LeftButtonDown, true);
      }
    } else if (event.button == Static.LeftButton || Static.isMobile()) {
      if (this.controlFlag(MPicker.DisplayChange.DragCursor)) {
        this.setControlFlag(MPicker.DisplayChange.LeftButtonDown, true);
      }
      return true;
    }
    return;
  }

  widgetMouseMoveEvent(event) {
    //event.preventDefault();

    var plot = this._ruler.plot();
    if (!plot.rv._curve) {
      return;
    }
    var clientX = event.clientX;
    var clientY = event.clientY;
    if (Static.isMobile()) {
      var touchobj = event.originalEvent.changedTouches[0]; // reference first touch point for this event
      clientX = parseInt(touchobj.clientX);
      clientY = parseInt(touchobj.clientY);
    }
    var pt = this.mapToElement(new Misc.Point(clientX, clientY));
    var pw = this._ruler.linePen().width;
    var inRect = plot
      .getCentralWidget()
      .contentsRect()
      .adjusted(0, pw + 1, 0, -(pw + 1))
      .contains(pt);

    if (!inRect) return;

    if (
      !this._ruler.isVisible() ||
      this.controlFlag(MPicker.DisplayChange.PanningInProgress)
    )
      return;
    if (!this.controlFlag(MPicker.DisplayChange.Locked)) {
      // if (Static.isMobile()) {
      //   var touchobj = event.originalEvent.changedTouches[0]; // reference first touch point for this event
      //   clientX = parseInt(touchobj.clientX);
      //   clientY = parseInt(touchobj.clientY);
      // }

      var val = pt.y;
      var _rulerPosVal = this._ruler
        .plot()
        .transform(this.yAxis(), this._rulerPos);

      if (this.controlFlag(MPicker.DisplayChange.LeftButtonDown)) {
        this._rulerPos = plot.invTransform(this.yAxis(), val);
        this._rulerPos = this._ruler._rulers.setPosition(
          this._ruler._rulers.rulerId(this._ruler),
          this._rulerPos
        );
        Static.trigger("positionChanging", [this._ruler, this._ruler._pos]);
      }
      if (
        !this.controlFlag(MPicker.DisplayChange.LeftButtonDown) &&
        val < _rulerPosVal + 2 &&
        val > _rulerPosVal - 2
      ) {
        this.setDragCursor();
      }
      if (
        !this.controlFlag(MPicker.DisplayChange.LeftButtonDown) &&
        !(val < _rulerPosVal + 2 && val > _rulerPosVal - 2)
      ) {
        this.clearDragCursor();
      }
    }
  }
}
;
define("mpicker", ["static","plotpicker"], function(){});



"include ['static', 'plotMarker']" 
/////////////////Ruler - subclass of PlotMarker//////////start
//Ruler.inheritsFrom( PlotMarker );
class Ruler extends PlotMarker{
//Define the Ruler constructor
//function Ruler(plot, name, lineStyle) {
    constructor(plot, name, lineStyle){
	// Call the parent constructor, making sure (using Function#call)
    // that "this" is set correctly during the call
    
    //PlotMarker.call(this, name);
    super(name);
    this._picker = 0 
    this._pos = Number.MAX_VALUE; 
    this._rightClickMenu = 0;
	
	
    
    this._rulers = null;

    if(lineStyle == PlotMarker.LineStyle.VLine || lineStyle == PlotMarker.LineStyle.HLine)
     {
        this.setLineStyle(lineStyle);
        this.setLinePen(new Misc.Pen("blue"));
	
     }
    
    this.attach(plot);
    //console.log(plot, 25)

    this.setMouseTracking = function (enable) {
        this._picker.setMouseTracking(enable);
    }
}

/*scaleRect(){
        var rect = null;
        if ( this.plot() )
        {
            var xs = this.plot().axisScaleDiv( this.xAxis() );
            var ys = this.plot().axisScaleDiv( this.yAxis() );

            rect = new Misc.Rect( xs.lowerBound(), ys.lowerBound(),
                xs.range(), ys.range() );
            rect = rect.normalized();
        }

        return rect;
    }*/
     
}
//Ruler.prototype = Object.create(PlotMarker.prototype);
// Set the "constructor" property to refer to Ruler
//Ruler.prototype.constructor = Ruler;

Ruler.prototype.toString = function () {
	return '[Ruler]';
}

Ruler.prototype.setPicker = function (pick) {
	if(!pick)
        return false;
    //if(_picker)
        //delete _picker;
    this._picker = pick;
    return true;
}

Ruler.prototype.setZoomerSearch = function(on)
{
    //_picker.setControlFlag(Picker::ZoomerSearch, on);
    this._picker.setControlFlag(MPicker.DisplayChange.ZoomerSearch, on);
    this._picker.initZoomer();
}

Ruler.prototype.setPannerSearch = function(on)
 {
//     _picker->setControlFlag(Picker::PannerSearch, on);
	this._picker.setControlFlag(MPicker.DisplayChange.PannerSearch, on);     
}

//Ruler.prototype.setLockAt = function(val)
//{
     /*this._picker.setControlFlag(MPicker.DisplayChange.Locked, lock);
     this._picker.clearDragCursor()*/     
     //console.log("position: "+ val)
//}

Ruler.prototype.setLock = function(lock)
{
     this._picker.setControlFlag(MPicker.DisplayChange.Locked, lock);
     this._picker.clearDragCursor()
}

Ruler.prototype.lock = function()
{
     return this._picker.controlFlag(MPicker.DisplayChange.Locked);
}

Ruler.prototype.setTrackingTextStyle = function(trackingTextStyle)
{
     this._picker.setTrackingTextStyle(trackingTextStyle);
}

Ruler.prototype.trackingTextStyle = function()
{
     return this._picker.trackingTextStyle();
}

Ruler.prototype.setTrackingTextFont = function(f)
{
     this._picker.setTrackerFont(f);
}

Ruler.prototype.trackingTextFont = function()
{
     return this._picker.trackerFont();
}

Ruler.prototype.setTrackingTextColor = function(c)
{
    var font = this._picker.trackerFont();
    font.fontColor = c;
    this._picker.setTrackerFont(font);
}

Ruler.prototype.trackingTextColor = function()
{
     return this._picker.trackerFont().color;
}

Ruler.prototype.validatePosition = function(min, max)
{

}

Ruler.prototype.dragCursorShape = function()
{
     return this._picker.dragCursorShape();
}

Ruler.prototype.setDragCursorShape = function(shape)
{
     this._picker.setDragCursorShape(shape);
}

Ruler.prototype.setRightClickMenu = function(menu)
{
//     if(_rightClickMenu)
//     {
//         delete _rightClickMenu;
//         if(!menu)
//             menu = new DummyMenu(this);
//     }
//     _rightClickMenu = menu;
}
////////////////////////////////////////////////////////
/////////////////RulerV - subclass of PlotMarker//////////start
//RulerV.inheritsFrom( Ruler );
class RulerV extends Ruler{
//Define the RulerV constructor
//function RulerV(plot, name) {
    constructor(plot, name, rulerGroup){
	// Call the parent constructor, making sure (using Function#call)
    // that "this" is set correctly during the call
    //Ruler.call(this, plot, name, VLine);
    super(plot, name, PlotMarker.LineStyle.VLine);
    if(rulerGroup)
        this._rulers = rulerGroup
    //if(plot){
	    this._picker = new PickerV(plot, this._pos, this);
	    //this._picker.setEnabled_2(true)
	//}
    }
}
//RulerV.prototype = Object.create(Ruler.prototype);
// Set the "constructor" property to refer to Ruler
//RulerV.prototype.constructor = RulerV;



RulerV.prototype.setPosition = function(pos)
{
    this._pos = pos;
    this._picker._rulerPos = pos
	this.setXValue(this._pos);    
}

/*RulerV.prototype.setLockAt = function(val)
{
     this.setPosition(val)
     this.setLock(true)
}*/

////////////////////////////////////
/////////////////RulerH - subclass of PlotMarker//////////start
//RulerH.inheritsFrom( Ruler );
class RulerH extends Ruler{
//Define the RulerV constructor
//function RulerH(plot, name) {
    constructor(plot, name, rulerGroup){
	// Call the parent constructor, making sure (using Function#call)
    // that "this" is set correctly during the call
    //Ruler.call(this, plot, name, HLine);
    super(plot, name, PlotMarker.LineStyle.HLine);
    
    if(rulerGroup)
        this._rulers = rulerGroup
    //if(plot){
	    this._picker = new PickerH(plot, this._pos, this);
	    //this._picker.setEnabled_2(true)
	//}
    }
}
//RulerH.prototype = Object.create(Ruler.prototype);
// Set the "constructor" property to refer to Ruler
//RulerH.prototype.constructor = RulerH;


RulerH.prototype.setPosition = function(pos)
{
    this._pos = pos;
    this._picker._rulerPos = pos
	this.setYValue(this._pos);
}

/*RulerH.prototype.setLockAt = function(val)
{
     this.setPosition(val)//new Misc.Point(0, val))
     this.setLock(true)

}*/
////////////////////////////////////



;
define("ruler", ["static","plotMarker"], function(){});

"include ['static', 'mpicker', 'ruler']";


class MRulerV extends RulerV {
  constructor(plot, name, rulerGroup) {
    super(plot, name, rulerGroup);
    this.rulers = function () {
      return this._rulers;
    };

    this.validatePosition = function () {
      var changed = false;
      var inverted = false;
      var plot = this.plot();
      var intv = plot.axisInterval(this.xAxis());

      var min = intv.minValue();
      var max = intv.maxValue();

      var minVal = plot.transform(this._picker.xAxis(), min);
      var maxVal = plot.transform(this._picker.xAxis(), max);
      var rulerPosVal = plot.transform(this._picker.xAxis(), this._pos);
      var minX = this._rulers.minX();
      var maxX = this._rulers.maxX();

      if (min > max) {
        inverted = true;
        // var temp = minX;
        // minX = maxX;
        // maxX = temp;
      }

      var space = 2;
      if (Static.isMobile()) {
        space = 12;
      }

      var separationX =
        0.5 *
          (this.rulers().ruler(0).linePen().width +
            this.rulers().ruler(1).linePen().width) +
        space;

      var n = this._rulers.rulerId(this);
      if (n == 0) {
        if (this._rulers.ruler(1).isVisible()) {
          var val = plot.transform(
            this._picker.xAxis(),
            this._rulers.ruler(1)._pos
          );
          if (rulerPosVal >= val - separationX) {
            this._pos = plot.invTransform(
              this._picker.xAxis(),
              val - separationX
            );
            changed = true;
          }
          if (rulerPosVal < minVal) {
            this._pos = plot.invTransform(this._picker.xAxis(), minVal);
            changed = true;
          }
          if (!inverted) {
            // var val = plot.transform(this._picker.xAxis(), this._rulers.ruler(1)._pos);
            // if (rulerPosVal >= val - separationX) {
            //     this._pos = plot.invTransform(this._picker.xAxis(), val - separationX);
            //     changed = true;
            // }
            // if (rulerPosVal < minVal) {
            //     this._pos = plot.invTransform(this._picker.xAxis(), minVal);
            //     changed = true;
            // }
            if (this._rulers._curve && this._pos < minX) {
              this._pos = minX;
              changed = true;
            }
          } else {
            // var val = plot.transform(this._picker.xAxis(), this._rulers.ruler(1)._pos);
            // if (rulerPosVal >= val - separationX) {
            //     this._pos = plot.invTransform(this._picker.xAxis(), val - separationX);
            //     changed = true;
            // }
            // if (rulerPosVal < minVal) {
            //     this._pos = plot.invTransform(this._picker.xAxis(), minVal);
            //     changed = true;
            // }
            if (this._rulers._curve && this._pos > maxX) {
              this._pos = maxX;
              changed = true;
            }
          }
        } else {
          if (rulerPosVal < minVal) {
            this._pos = plot.invTransform(this._picker.xAxis(), minVal);
            changed = true;
          }
          if (rulerPosVal > maxVal) {
            this._pos = plot.invTransform(this._picker.xAxis(), maxVal);
            changed = true;
          }
          if (this._rulers._curve && this._pos < minX) {
            this._pos = minX;
            changed = true;
          }
          if (this._rulers._curve && this._pos > maxX) {
            this._pos = maxX;
            changed = true;
          }
        }
      }
      if (n == 1) {
        if (this._rulers.ruler(0).isVisible()) {
          var val = plot.transform(
            this._picker.xAxis(),
            this._rulers.ruler(0)._pos
          );
          if (rulerPosVal <= val + separationX) {
            this._pos = plot.invTransform(
              this._picker.xAxis(),
              val + separationX
            );
            changed = true;
          }
          if (rulerPosVal > maxVal) {
            this._pos = plot.invTransform(this._picker.xAxis(), maxVal);
            changed = true;
          }
          if (!inverted) {
            // var val = plot.transform(this._picker.xAxis(), this._rulers.ruler(0)._pos);
            // if (rulerPosVal <= val + separationX) {
            //     this._pos = plot.invTransform(this._picker.xAxis(), val + separationX);
            //     changed = true;
            // }
            // if (rulerPosVal > maxVal) {
            //     this._pos = plot.invTransform(this._picker.xAxis(), maxVal);
            //     changed = true;
            // }
            if (this._rulers._curve && this._pos > maxX) {
              this._pos = maxX;
              changed = true;
            }
          } else {
            // var val = plot.transform(this._picker.xAxis(), this._rulers.ruler(0)._pos);
            // if (rulerPosVal <= val + separationX) {
            //     this._pos = plot.invTransform(this._picker.xAxis(), val + separationX);
            //     changed = true;
            // }
            // if (rulerPosVal > maxVal) {
            //     this._pos = plot.invTransform(this._picker.xAxis(), maxVal);
            //     changed = true;
            // }
            if (this._rulers._curve && this._pos < minX) {
              this._pos = minX;
              changed = true;
            }
          }
        } else {
          if (rulerPosVal < minVal) {
            this._pos = plot.invTransform(this._picker.xAxis(), minVal);
            changed = true;
          }
          if (rulerPosVal > maxVal) {
            this._pos = plot.invTransform(this._picker.xAxis(), maxVal);
            changed = true;
          }
          if (this._rulers._curve && this._pos < minX) {
            this._pos = minX;
            changed = true;
          }
          if (this._rulers._curve && this._pos > maxX) {
            this._pos = maxX;
            changed = true;
          }
        }
      }
      if (changed) this.setPosition(this._pos);

      return changed;
    };
  }
  setVisible(visible) {
    super.setVisible(visible);
    if (visible && this._rulers) {
      var n = this._rulers.rulerId(this);
      if (
        (n == 0 && this._rulers.ruler(1).isVisible()) ||
        (n == 1 && this._rulers.ruler(0).isVisible())
      ) {
        //this._rulers.resetXPositions();
      }
    } else {
      this._pos = Number.MAX_VALUE;
      this._rulers.updateWatchesAndTable();
    }
  }

  setLockAt(val) {
    //console.log(this.title())//v_ruler1
    this.setPosition(val);
    this.validatePosition(); //this method may reset the position

    this.setLock(true);
    Static.trigger("positionChanged", [this, val]);
    //Static.trigger("shapeItemValueChanged")
  }
}

class MRulerH extends RulerH {
  //Define the MRulerH constructor
  //function MRulerH(plot, name, rulerGroup) {
  constructor(plot, name, rulerGroup) {
    // Call the parent constructor, making sure (using Function#call)
    // that "this" is set correctly during the call
    //RulerH.call(this, plot, name);
    super(plot, name, rulerGroup);
    //this._rulers = null

    //if(rulerGroup)
    // this._rulers = rulerGroup

    this.rulers = function () {
      return this._rulers;
    };

    this.validatePosition = function () {
      var changed = false;
      var inverted = false;
      var plot = this.plot();
      var intv = plot.axisInterval(this.yAxis());
      var min = intv.minValue();
      var max = intv.maxValue();

      var minVal = plot.transform(this.yAxis(), min);
      var maxVal = plot.transform(this.yAxis(), max);
      var rulerPosVal = plot.transform(this.yAxis(), this._pos);
      var minY = this._rulers.minY();
      var maxY = this._rulers.maxY();

      if (min > max) {
        inverted = true;
        // var temp = minX;
        // minX = maxX;
        // maxX = temp;
      }

      var space = 2;
      if (Static.isMobile()) {
        space = 12;
      }

      var separationY =
        0.5 *
          (this.rulers().ruler(2).linePen().width +
            this.rulers().ruler(3).linePen().width) +
        space;

      var n = this._rulers.rulerId(this);
      if (n == 2) {
        if (this._rulers.ruler(3).isVisible()) {
          var val = plot.transform(this.yAxis(), this._rulers.ruler(3)._pos);
          if (rulerPosVal <= val + separationY) {
            this._pos = plot.invTransform(this.yAxis(), val + separationY);
            changed = true;
          }
          if (rulerPosVal > minVal) {
            this._pos = plot.invTransform(this.yAxis(), minVal);
            changed = true;
          }
          if (!inverted) {
            // var val = plot.transform(this.yAxis(), this._rulers.ruler(3)._pos);
            // if (rulerPosVal <= val + separationY) {
            //     this._pos = plot.invTransform(this.yAxis(), val + separationY);
            //     changed = true;
            // }
            // if (rulerPosVal > minVal) {
            //     this._pos = plot.invTransform(this.yAxis(), minVal);
            //     changed = true;
            // }
            if (this._rulers._curve && this._pos < minY) {
              this._pos = minY;
              changed = true;
            }
          } else {
            // var val = plot.transform(this.yAxis(), this._rulers.ruler(3)._pos);
            // if (rulerPosVal <= val + separationY) {
            //     this._pos = plot.invTransform(this.yAxis(), val + separationY);
            //     changed = true;
            // }
            // if (rulerPosVal > minVal) {
            //     this._pos = plot.invTransform(this.yAxis(), minVal);
            //     changed = true;
            // }
            if (this._rulers._curve && this._pos > maxY) {
              this._pos = maxY;
              changed = true;
            }
          }
        } else {
          if (rulerPosVal < maxVal) {
            this._pos = plot.invTransform(this.yAxis(), maxVal);
            changed = true;
          }
          if (rulerPosVal > minVal) {
            this._pos = plot.invTransform(this.yAxis(), minVal);
            changed = true;
          }
          if (this._rulers._curve && this._pos < minY) {
            this._pos = minY;
            changed = true;
          }
          if (this._rulers._curve && this._pos > maxY) {
            this._pos = maxY;
            changed = true;
          }
        }
      }
      if (n == 3) {
        if (this._rulers.ruler(2).isVisible()) {
          var val = plot.transform(this.yAxis(), this._rulers.ruler(2)._pos);
          if (rulerPosVal >= val - separationY) {
            this._pos = plot.invTransform(this.yAxis(), val - separationY);
            changed = true;
          }
          if (rulerPosVal < maxVal) {
            this._pos = plot.invTransform(this.yAxis(), maxVal);
            changed = true;
          }
          if (!inverted) {
            // var val = plot.transform(this.yAxis(), this._rulers.ruler(2)._pos);
            // if (rulerPosVal >= val - separationY) {
            //     this._pos = plot.invTransform(this.yAxis(), val - separationY);
            //     changed = true;
            // }
            // if (rulerPosVal < maxVal) {
            //     this._pos = plot.invTransform(this.yAxis(), maxVal);
            //     changed = true;
            // }
            if (this._rulers._curve && this._pos > maxY) {
              this._pos = maxY;
              changed = true;
            }
          } else {
            // var val = plot.transform(this.yAxis(), this._rulers.ruler(2)._pos);
            // if (rulerPosVal >= val - separationY) {
            //     this._pos = plot.invTransform(this.yAxis(), val - separationY);
            //     changed = true;
            // }
            // if (rulerPosVal < maxVal) {
            //     this._pos = plot.invTransform(this.yAxis(), maxVal);
            //     changed = true;
            // }
            if (this._rulers._curve && this._pos < minY) {
              this._pos = minY;
              changed = true;
            }
          }
        } else {
          if (rulerPosVal > minVal) {
            this._pos = plot.invTransform(this.yAxis(), minVal);
            changed = true;
          }
          if (rulerPosVal < maxVal) {
            this._pos = plot.invTransform(this.yAxis(), maxVal);
            changed = true;
          }
          if (this._rulers._curve && this._pos < minY) {
            this._pos = minY;
            changed = true;
          }
          if (this._rulers._curve && this._pos > maxY) {
            this._pos = maxY;
          }
        }
      }
      if (changed) this.setPosition(this._pos);

      return changed;
    };
  }

  setVisible(visible) {
    super.setVisible(visible);
    if (visible && this._rulers) {
      var n = this._rulers.rulerId(this);
      if (
        (n == 2 && this._rulers.ruler(3).isVisible()) ||
        (n == 3 && this._rulers.ruler(2).isVisible())
      ) {
        //this._rulers.resetYPositions();
      }
    } else {
      this._pos = Number.MAX_VALUE;
      this._rulers.updateWatchesAndTable();
    }
  }

  setLockAt(val) {
    this.setPosition(val);
    this.validatePosition(); //this method may reset the position

    this.setLock(true);
    Static.trigger("positionChanged", [this, val]);
    //Static.trigger("shapeItemValueChanged")
  }
}
//MRulerH.prototype = Object.create(RulerH.prototype);
// Set the "constructor" property to refer to Ruler
//MRulerH.prototype.constructor = MRulerH;

/* MRulerH.prototype.setVisible = function (visible) {
    PlotMarker.prototype.setVisible.call(visible);
    if (visible && this._rulers) {
        var n = this._rulers.rulerId(this);
        if ((n == 2 && this._rulers.ruler(3).isVisible()) || (n == 3 && this._rulers.ruler(2).isVisible())) {
            this._rulers.resetYPositions();
        }
    }else{
        this._pos = Number.MAX_VALUE;
    }
}

MRulerH.prototype.setLockAt = function (val) {
    this.setPosition(val)
    this.setLock(true)
    Static.trigger("positionChanged", [this, val])
    //Static.trigger("shapeItemValueChanged")

} */
/////////////////////////////////////////////////////////////
class Rulers {
  constructor(plot, /*vRulerConstructor, hRulerConstructor,*/ flags) {
    var self = this;
    var _menu = [
      {
        name: "hide...",
        img: "images/hide.png",
        title: "hide the ruler.",
        fun: function () {
          plot.rv.currentRuler.setVisible(false);
          plot.rv.currentRuler._picker.clearDragCursor();
          if (!plot.rv.hasVisibleRuler()) {
          } else {
          }
        },
      },
      {
        name: "lock...",
        img: "images/lock.png",
        title: "lock the ruler in its current position.",
        fun: function () {
          plot.rv.currentRuler.setLock(true);
          if (!plot.rv.hasLockedRuler()) {
            //all rulers locked
          } else {
          }
        },
      },
      {
        name: "lock at...",
        img: "images/lockAt.png",
        title: "lock the ruler at a specific position.",
        fun: function () {
          var currentRulerPosition = 0;
          if (plot.rv.currentRuler instanceof RulerH) {
            currentRulerPosition = plot.rv.currentRuler.yValue();
          } else {
            currentRulerPosition = plot.rv.currentRuler.xValue();
          }

          Utility.prompt(
            "Enter a position",
            currentRulerPosition,
            function (val) {
              plot.rv.currentRuler.setLockAt(parseFloat(val));
              return true;
            },
            "small"
          );
        },
      },
    ];

    var rulerDeselectMenu = [
      {
        name: "Hide rulers",
        img: "images/hide.png",
        title: "Hide all rulers",
        fun: function () {
          plot.rv.setVisible(false);
        },
      },
      {
        name: "Show rulers",
        img: "images/show.png",
        title: "Show any hidden rulers",
        //disable: true,
        fun: function () {
          plot.rv.setVisible(true);
        },
      },
      {
        name: "Unlock rulers",
        img: "images/unlock.png",
        title: "Unlock any locked rulers",
        //disable: true,
        fun: function () {
          plot.rv.unlockAllRulers();
        },
      },
    ];

    this.setRulerDeselectMenu = function (menu) {
      if (!menu) {
        rulerDeselectMenu = [];
      } else {
        rulerDeselectMenu = menu;
      }
    };

    this._curve = 0;
    this._watchTable = new WatchTable(this);
    this._editor = 0;
    //this._flags = flags;
    this._curveShapeItem = 0;
    this._watchSetter = 0;
    this._rulerList = null;

    this._watchList = [];
    this.sidebarVisible = false;

    /*var vRulerConst = vRulerConstructor || MRulerV
        var hRulerConst = hRulerConstructor || MRulerH*/

    plot.setAutoReplot(true);

    //if(!this._rulerList){
    this._rulerList = [
      new MRulerV(plot, "v_ruler1", self),
      new MRulerV(plot, "v_ruler2", self),
      new MRulerH(plot, "h_ruler1", self),
      new MRulerH(plot, "h_ruler2", self),
    ];
    //}

    //console.log(this._rulerList)
    if (Static.isMobile()) {
      for (var i = 0; i < 4; ++i) {
        var p = this._rulerList[i].linePen();
        p.width = 2 * p.width;
        // this._rulerList[i].setLinePen(p)
      }
    }

    this._minX = 0;
    this._maxX = 0;
    this._minY = 0;
    this._maxY = 0;

    this.minX = function () {
      return this._minX;
    };
    this.maxX = function () {
      return this._maxX;
    };
    this.minY = function () {
      return this._minY;
    };
    this.maxY = function () {
      return this._maxY;
    };

    this.currentRuler = null;

    //var _menu = null;

    var el = plot.getLayout().getCentralDiv();
    var menuAppended = false;
    Static.bind("rulerSelected", function (e, ruler) {
      self.currentRuler = ruler;
      //ensure 'contextMenu' is included
      if (menuAppended) el.contextMenu("destroy");
      menuAppended = true;
      el.contextMenu(_menu, {
        triggerOn: "contextmenu",
        zIndex: 1,
      });
    });

    Static.bind("rulerDeselected", function () {
      // console.log(44)
      if (menuAppended) el.contextMenu("destroy");
      menuAppended = true;
      el.contextMenu(rulerDeselectMenu, {
        triggerOn: "contextmenu",
        zIndex: 1,
      });
    });

    /* this.setMenu = function (menu) {
            _menu = menu;
        } */

    this.init(plot);

    this.position = function (rulerId) {
      if (rulerId > -1 && rulerId < 4) {
        if (!this._rulerList[rulerId].isVisible()) return Number.MAX_VALUE; //error
        return this._rulerList[rulerId]._pos;
      }
      return Number.MAX_VALUE; //error
    };

    this.watch = function (id) {
      if (id >= 0 && id < this._watchList.length) return this._watchList[id];
      return null;
    };

    this.addToWatchList = function (watch) {
      this._watchList.push(watch);
      return this._watchList.length - 1;
    };

    this.setWatchEnabled = function (id, set) {
      if (id >= 0 && id < this._watchList.length) {
        if (this._watchList[id].isEnable() == set) return;
        this._watchList[id].setEnable(set);
        //To account for any changes that occurred during the disabled state, we updateWatch().
        if (set) this.updateWatch(this._watchList[id]);
        this._watchTable.updateWatchTable();
      }
    };

    this.isWatchEnabled = function (id) {
      if (id >= 0 && id < this._watchList.length) {
        return this._watchList[id].isEnable();
      }
      return false;
    };

    Static.bind("showSidebar", function (e, anchorPosition, on) {
      if (anchorPosition == "right") self.sidebarVisible = on;
    });

    this.updateWatchesAndTable = function () {
      //wwwwwwwww
      if (!self.sidebarVisible) return;
      if (!this._curve) return;
      this.updateWatches();
      if (this._watchTable) this._watchTable.updateWatchTable();

      /*$("#watchTableBody").hide()//
            $("#watchTableBody").show()//*/
      //this._valid = true;
    };

    this.setVisible = function (on) {
      this._rulerList.forEach(function (ruler) {
        ruler.setVisible(on);
      });
      if (on) {
        Static.trigger("curveAdjusted"); //Force sidebar update
        //this.updateWatchesAndTable();
      }
      this.refresh();
    };

    this.hasVisibleRuler = function () {
      for (var i = 0; i < 4; ++i) {
        if (this._rulerList[i].isVisible()) {
          return true;
        }
      }
      return false;
    };

    this.hasLockedRuler = function () {
      for (var i = 0; i < 4; ++i) {
        if (this._rulerList[i].lock()) {
          return true;
        }
      }
      return false;
    };

    /*this.allRulersHidden = function(){
        return !this.hasVisibleRuler
        }*/

    this.updateWatch = function (w) {
      if (w.isEnable()) {
        //var doReplot = plot.autoReplot();
        //plot.setAutoReplot(false);
        w.setCurveName(this._curve.title());
        w.setRulerLeft(this.position(0));
        w.setRulerRight(this.position(1));
        w.setRulerBottom(this.position(2));
        w.setRulerTop(this.position(3));
        if (this._curve) {
          w.setCurve(this._curve);
        }
        //plot.setAutoReplot(doReplot);
        //plot.autoRefresh();
        w.computeWatch();
      }
    };

    this.updateWatches = function () {
      var doReplot = plot.autoReplot();
      plot.setAutoReplot(false);
      this._watchList.forEach(function (w) {
        self.updateWatch(w);
      });
      plot.setAutoReplot(doReplot);
      plot.autoRefresh();
    };

    this.setEnabled = function (enable) {
      this._rulerList.forEach(function (ruler) {
        ruler._picker.setEnabled(enable);
      });
    };

    this.setMouseTracking = function (enable) {
      this._rulerList.forEach(function (ruler) {
        ruler._picker.setMouseTracking(enable);
      });
    };

    this.setZoomerSearch(true);
    this.setPannerSearch(true);

    //plot.setAutoReplot(true);
    this.setMouseTracking(true);

    Static.bind("zoomerAdded", function (e, zoomer) {
      //self.initZoomer()
      self.setZoomerSearch(
        self._rulerList[0]._picker.controlFlag(
          MPicker.DisplayChange.ZoomerSearch
        )
      );
      self.setMouseTracking(true);
    });

    Static.bind("pannerAdded", function (e, panner) {
      //self.initPanner()
      self.setPannerSearch(
        self._rulerList[0]._picker.controlFlag(
          MPicker.DisplayChange.PannerSearch
        )
      );
      self.setMouseTracking(true);
    });

    Static.bind("currentCurveChanged", function (e, curve) {
      self.setCurrentCurve(curve);
    });

    //this.setEnabled(true)
    //this.setMenu(menu1);

    plot.rv = this;

    Static.trigger("rulerDeselected");
  }

  ////////////////////////////////////////////////
  unlockAllRulers() {
    for (var i = 0; i < this._rulerList.length; ++i) {
      this._rulerList[i].setLock(false);
      //this._rulerList[i]._picker.setControlFlag(MPicker.DisplayChange.Locked, false);
    }
  }

  // setCurrentCurve(curve) {
  //   if (this._curve == curve) return;
  //   this.doSetCurrentCurve(curve);
  // }

  refresh() {
    var p = this._rulerList[0].plot();
    //p.replot(); //ensure scales are freshly computed. //Out1
    p.autoRefresh();
    if (
      this._curve &&
      this._curve.rtti == PlotItem.RttiValues.Rtti_PlotCurve &&
      this._curve.isVisible()
    ) {
      if (this._curve.isVisible()) {
        this._minX = this._curve.minXValue();
        this._maxX = this._curve.maxXValue();
        this._minY = this._curve.minYValue();
        this._maxY = this._curve.maxYValue();
      }

      var axis = this._rulerList[0].xAxis();
      var intvX = p.axisInterval(this._rulerList[0].xAxis());
      var minX = intvX.minValue();
      var maxX = intvX.maxValue();
      var intvY = p.axisInterval(this._rulerList[0].yAxis());
      var minY = intvY.minValue();
      var maxY = intvY.maxValue();

      //minX = this._minX < minX ? minX : this._minX;

      if (minX > maxX) {
        //inverted
        minX = this._maxX < maxX ? maxX : this._maxX;
        this._rulerList[0].setPosition(minX);
      } else {
        minX = this._minX < minX ? minX : this._minX;
        this._rulerList[0].setPosition(minX);
      }

      //maxX = this._maxX < maxX ? this._maxX : maxX;

      if (minX > maxX) {
        //inverted
        maxX = this._minX < minX ? this._minX : minX;
        this._rulerList[1].setPosition(maxX);
      } else {
        maxX = this._maxX < maxX ? this._maxX : maxX;
        this._rulerList[1].setPosition(maxX);
      }

      //minY = this._minY < minY ? minY : this._minY;
      if (minY > maxY) {
        //inverted
        minY = this._maxY < maxY ? maxY : this._maxY;
        this._rulerList[2].setPosition(minY);
      } else {
        minY = this._minY < minY ? minY : this._minY;
        this._rulerList[2].setPosition(minY);
      }

      //this._rulerList[2].setPosition(minY);

      //maxY = this._maxY < maxY ? this._maxY : maxY;
      if (minY > maxY) {
        //inverted
        maxY = this._minY < minY ? this._minY : minY;
        this._rulerList[3].setPosition(maxY);
      } else {
        maxY = this._maxY < maxY ? this._maxY : maxY;
        this._rulerList[3].setPosition(maxY);
      }

      //this._rulerList[3].setPosition(maxY);
      //unlockAllRulers();
      this.updateWatchesAndTable();
    } else {
      // if(this._watchTable)
      //     this._watchTable.setEnabled(false);
      this.resetXPositions();
      this.resetYPositions();
      // if(_curveShapeItem && _curveShapeItem.isVisible())
      // {
      //     _curveShapeItem.setVisible(false);
      //     _curveShapeItem.setVisibilityToBerestored(true);// note that visibility is to restored
      // }
    }
  }

  doSetRulersAxes(xAxis, yAxis) {
    var plot = this._rulerList[0].plot();
    var doReplot = plot.autoReplot();
    plot.setAutoReplot(false);
    var oldXAxis = this._rulerList[0].xAxis();
    var oldYAxis = this._rulerList[0].yAxis();
    for (var i = 0; i < this._rulerList.length; ++i) {
      this._rulerList[i].setAxes(xAxis, yAxis);
      this._rulerList[i]._picker.setAxis(xAxis, yAxis);
    }
    //if(this._curveShapeItem)
    //this._curveShapeItem.setAxes(xAxis, yAxis);
    //updateConnectionOnXAxisChange(oldXAxis);
    //updateConnectionOnYAxisChange(oldYAxis);
    plot.setAutoReplot(doReplot);
    plot.autoRefresh();
  }

  adjustToCurve(curve) {
    this._curve = curve;
    //console.log(curve)
    if (this._curve) {
      /* if (this._curve.isVisible()) {
                this._minX = this._curve.minXValue();
                this._maxX = this._curve.maxXValue();
                this._minY = this._curve.minYValue();
                this._maxY = this._curve.maxYValue();
            } */
      this.doSetRulersAxes(this._curve.xAxis(), this._curve.yAxis()); //rulers reference these axes.
      if (this._curveShapeItem) {
        //this._curveShapeItem.setCurve(_curve);
        //this._curveShapeItem.setAbcissaValues(_minX, _maxX);
      }
    }
    this.refresh();
  }

  doSetCurrentCurve(curve) {
    //var oldCurve = this._curve;
    if (curve && curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve) {
      //console.log(456);
      $("#watchTableContainer").hide();
    } else {
      $("#watchTableContainer").show();
    }
    this.adjustToCurve(curve);
    //Static.trigger("currentCurveChanged", curve);
  }

  setCurrentCurve(curve) {
    if (this._curve == curve) return;
    this.doSetCurrentCurve(curve);
  }

  currentCurve() {
    return this._curve;
  }

  init(plot) {
    var self = this;
    var _rulerList = this._rulerList; //Static.trigger("decimalPlacesChanged");

    Static.bind(
      "positionChanged decimalPlacesChanged calculationAccuracy",
      function (e, ruler, rulerPos) {
        self.updateWatchesAndTable();
      }
    );

    Static.bind("curveAdjusted", function () {
      ///Added 06/17/2020
      self.refresh();
    });

    Static.bind("rescaled", function () {
      //self.refresh();
      Static.trigger("curveAdjusted"); //shapeItem update
    });

    Static.bind("pointAdded pointRemoved", function (e, curve) {
      self.doSetCurrentCurve(curve);
    });

    Static.bind("axisChanged", function (e, axis, curve) {
      if (self.currentCurve() === curve) {
        self.adjustToCurve(curve);
      }
    });

    //this._rulerList[0].setLinePen(new Misc.Pen("red"));
    //this._rulerList[2].setLinePen(new Misc.Pen("red"));
    this._rulerList[0].linePen().color = "red";
    this._rulerList[2].linePen().color = "red";

    this.resetXPositions();
    this.resetYPositions();
  }

  setZoomerSearch(on) {
    this._rulerList.forEach(function (ruler) {
      ruler.setZoomerSearch(on);
      ruler._picker.initZoomer();
    });
  }

  setPannerSearch(on) {
    this._rulerList.forEach(function (ruler) {
      ruler.setPannerSearch(on);
      ruler._picker.initPanner();
    });
  }

  setPosition(rulerId, pos) {
    pos = parseFloat(pos);
    if (this._rulerList[rulerId]._pos == pos) return pos;
    var initialPos = this._rulerList[rulerId]._pos;
    this._rulerList[rulerId]._pos = pos;
    this._rulerList[rulerId].validatePosition();
    var changed = this._rulerList[rulerId]._pos !== initialPos;
    if (changed) {
      this._rulerList[rulerId].setPosition(this._rulerList[rulerId]._pos);
      //Static.trigger("positionChanged", [this._rulerList[rulerId], this._rulerList[rulerId]._pos]);
    }
    return this._rulerList[rulerId]._pos;
  }

  resetXPositions() {
    var plot = this._rulerList[0].plot();
    var doReplot = plot.autoReplot();
    plot.setAutoReplot(false);
    var intv = plot.axisInterval(this._rulerList[0].xAxis());
    if (!this._curve || !this._curve.isVisible()) {
      this._rulerList[0].setPosition(intv.minValue());
      this._rulerList[1].setPosition(intv.maxValue());
    } else {
      if (intv.minValue() > this._minX)
        this._rulerList[0].setPosition(intv.minValue());
      else this._rulerList[0].setPosition(this._minX);
      if (intv.maxValue() < this._maxX)
        this._rulerList[1].setPosition(intv.maxValue());
      else this._rulerList[1].setPosition(this._maxX);
    }
    plot.setAutoReplot(doReplot);
    plot.autoRefresh();
  }

  resetYPositions() {
    var plot = this._rulerList[0].plot();
    var doReplot = plot.autoReplot();
    plot.setAutoReplot(false);
    var intv = plot.axisInterval(this._rulerList[0].yAxis());
    if (!this._curve || !this._curve.isVisible()) {
      this._rulerList[2].setPosition(intv.minValue());
      this._rulerList[3].setPosition(intv.maxValue());
    } else {
      this._rulerList[2].setPosition(this._minY);
      this._rulerList[3].setPosition(this._maxY);

      if (intv.minValue() > this._minY)
        this._rulerList[2].setPosition(intv.minValue());
      else this._rulerList[2].setPosition(this._minY);
      if (intv.maxValue() < this._maxY)
        this._rulerList[3].setPosition(intv.maxValue());
      else this._rulerList[3].setPosition(this._maxY);
    }
    plot.setAutoReplot(doReplot);
    plot.autoRefresh();
  }

  ruler(rulerId) {
    if (rulerId < 4 && rulerId >= 0) return this._rulerList[rulerId];
    return 0;
  }

  rulerId(r) {
    if (!r) return -1;
    return this._rulerList.indexOf(r);
  }

  preventDragging(on) {
    for (var i = 0; i < this._rulerList.length; ++i) {
      this._rulerList[i]._picker.preventDragging(on);
    }
  }

  setRulersXAxis(axis) {
    var plot = this._rulerList[0].plot();
    var doReplot = plot.autoReplot();
    plot.setAutoReplot(false);
    //var oldAxis = this._rulerList[0].xAxis();
    for (var i = 0; i < this._rulerList.length; ++i) {
      this._rulerList[i].setXAxis(axis);
      this._rulerList[i]._picker.setAxis(axis, this._rulerList[i].yAxis());
    }
    if (this._curveShapeItem)
      this._curveShapeItem.setAxes(axis, this._rulerList[0].yAxis());
    //updateConnectionOnXAxisChange(oldAxis);
    plot.setAutoReplot(doReplot);
    plot.autoRefresh();
  }

  setRulersYAxis(axis) {
    var plot = this._rulerList[0].plot();
    var doReplot = plot.autoReplot();
    plot.setAutoReplot(false);
    //var oldAxis = this._rulerList[0].xAxis();
    for (var i = 0; i < this._rulerList.length; ++i) {
      this._rulerList[i].setYAxis(axis);
      this._rulerList[i]._picker.setAxis(this._rulerList[i].xAxis(), axis);
    }
    if (this._curveShapeItem)
      this._curveShapeItem.setAxes(_rulerList[0].xAxis(), axis);
    //updateConnectionOnYAxisChange(oldAxis);
    plot.setAutoReplot(doReplot);
    plot.autoRefresh();
  }
}

///////////////////////////////////////////////////
class WatchTable {
  constructor(_rulerGroup) {
    let self = this;
    var firstUpdate = true;

    function makeRow(watch) {
      var watchVariable = watch.name();
      var value = watch.value();

      if (watch.valueType == "number" || watch.valueType == "text") {
        var elemId = watchVariable;
        while (elemId.indexOf(" ") != -1) {
          elemId = elemId.replaceAll(" ", "");
        }
        var row = $("<tr><td>" + watchVariable + "</td></tr>");
        $("#watchTableBody").append(row);
        var valueElem = $(
          "<td><input id=" +
            elemId +
            " type=" +
            watch.valueType +
            '  style="width:100%" value=' +
            value +
            " /></td>"
        );
        row.append(valueElem);
        $("#" + elemId).on("change", watch.cb);
      } else {
        var row2 = $(
          "<tr><td>" + watchVariable + "</td><td>" + value + "</td></tr>"
        );
        $("#watchTableBody").append(row2);
      }
    }

    this.insertInfoRow = function (watch) {
      makeRow(watch);
    };

    function updateRow(row, watch) {
      var watchVariable = watch.name();
      var value = watch.value();

      if (watch.valueType == "number" || watch.valueType == "text") {
        $(row[0].children[1].children).val(value);
      } else {
        row[0].children[1].innerText = value;
      }
    }

    this.updateWatchTable = function () {
      //Static.watchUpdateError; // = false;
      var wl = _rulerGroup._watchList;
      if (firstUpdate && _rulerGroup._curve && _rulerGroup._curve.isVisible()) {
        for (var i = 0; i < wl.length; ++i) {
          var w = wl[i];
          this.insertInfoRow(w);
          if (!w.isEnable()) {
            var rows = $("#watchTableBody")[0].children;
            $(rows[i]).hide();
          }
        }
        firstUpdate = false;
        return;
      }

      if (_rulerGroup._curve && _rulerGroup._curve.isVisible()) {
        var rows = $("#watchTableBody")[0].children;
        for (var i = 0; i < wl.length; ++i) {
          var w = _rulerGroup.watch(i);
          if (!w.isEnable()) {
            $(rows[i]).hide();
          } else {
            if (w._update) updateRow($(rows[i]), w);
            $(rows[i]).show();
          }
        }
      }

      if (Static.showWatchUpdateError && Static.watchUpdateError) {
        if (
          confirm(
            "The application encountered extremely small values that may affect the computation of one or more watches. This may be due to incorrect axes decimal places setup (Plot Property pane: Watch Settings -> Calculation accuracy -> Decimal places in calculation).\n\nWould you like to prevent this message ?"
          )
        ) {
          Static.showWatchUpdateError = false;
        }
      }
    };

    Static.bind("titleChange", function (e, plotItem, title) {
      //Force update of watchTable
      Static.trigger("positionChanged");
    });
  }
}
;
define("rulers", ["static","mpicker","ruler"], function(){});

"include []"


class SideBar {
    constructor(parent, plotDiv, gridItems, anchorPosition) { //
        var self = this;
        this.plotDiv = plotDiv;
        var sideBarWidth = 20; //As percentage
        self.sideBarVisible = false;
        var m_anchorPosition = anchorPosition || "right";

        var m_html = null; // background-color:#ffc9ae;

        var sideBarDlg =
            $('<div class="grid-container noprint" style="position: absolute; border: 1px solid lightgray;"/>');

        parent.append(sideBarDlg);
        sideBarDlg.css('bottom', 0);
        sideBarDlg.css('top', 0);

        class GridItem {
            constructor() {
                this.visible = true;
                this.headerElement = null;
                this.bodyElement = null;
                this.element = null;
                this.anchorPosition = "";
            }
        }
        var gridItemsList = [];
        var numOfVisibleGridItems = 0;

        for (var i = 0; i < gridItems; ++i) {
            var gridItem = new GridItem();
            gridItem.anchorPosition = m_anchorPosition;
            gridItem.element = $('<div class="grid-item"></div>');
            sideBarDlg.append(gridItem.element);
            gridItem.headerElement = $('<div class="grid-item-header"></div>');
            gridItem.element.append(gridItem.headerElement);
            gridItem.bodyElement = $('<div class="grid-item-body"></div>');
            gridItem.element.append(gridItem.bodyElement);
            gridItemsList.push(gridItem);

            ++numOfVisibleGridItems;
        }

        this.hideAllGridItems = function () {
            for (var i = 0; i < gridItems; ++i) {
                this.doShowGridItem(i, false);
            }
        }



        this.setHeaderElement = function (gridIndex, val) {
            gridItemsList[gridIndex].headerElement.css("height", val + "px");
            this.setGridItemHeigth();
        }

        this.setGridItemHeigth = function () {//divide available height evenly
            var availableHeight = parseInt(sideBarDlg.css('height'));
            var gridItemHeightPercent = (1 / numOfVisibleGridItems) * 100;
            for (var i = 0; i < gridItemsList.length; ++i) {
                if (!gridItemsList[i].visible)
                    continue;
                gridItemsList[i].element.css("height", gridItemHeightPercent + "%");
                var itemHeight = parseInt(gridItemsList[i].element.css("height"));
                var headerHeight = parseInt(gridItemsList[i].headerElement.css("height"));
                var gridItemBodyHeightPercent = (1 - (headerHeight) / itemHeight) * 100;
                gridItemsList[i].bodyElement.css("height", gridItemBodyHeightPercent + "%");
            }
        }

        this.doShowGridItem = function (gridIndex, on) {
            if (gridItemsList[gridIndex].visible == on)
                return;
            if (on) {
                if (!this.sideBarVisible)
                    this.showSidebar(true);
                gridItemsList[gridIndex].element.show();
                ++numOfVisibleGridItems;
            } else {
                gridItemsList[gridIndex].element.hide();
                --numOfVisibleGridItems;
                if (numOfVisibleGridItems === 0)
                    this.showSidebar(false);
            }
            gridItemsList[gridIndex].visible = on;
            this.setGridItemHeigth();
            Static.trigger("showGridItem", [m_anchorPosition, gridIndex, on]);
            return numOfVisibleGridItems;
        }

        this.doIsGridItemVisible = function(gridIndex){
            return gridItemsList[gridIndex].visible;
        }


        this.gridItem = function (gridIndex) {
            if (gridIndex < gridItemsList.length)
                return gridItemsList[gridIndex];
            return null;
        }

        this.gridItemCount = function () {
            return gridItemsList.length;
        }

        this.setGridItemHeigth();
        sideBarDlg.css("width", (sideBarWidth) + "%");

        this.isSideBarVisible = function () {
            return self.sideBarVisible;
        }

        this.sideBarWidth = function () {
            return sideBarWidth;
        }

        this.setTop = function (top) {
            sideBarDlg.css('top', top);
        }

        /*none	Default value. Specifies no border
        hidden	The same as "none", except in border conflict resolution for table elements
        dotted	Specifies a dotted border
        dashed	Specifies a dashed border
        solid	Specifies a solid border
        double	Specifies a double border
        groove	Specifies a 3D grooved border. The effect depends on the border-color value
        ridge	Specifies a 3D ridged border. The effect depends on the border-color value
        inset	Specifies a 3D inset border. The effect depends on the border-color value
        outset	Specifies a 3D outset border. The effect depends on the border-color value
        initial	Sets this property to its default value. Read about initial
        inherit	Inherits this property from its parent element. Read about inherit*/
        this.setBorderStyle = function (style) {
            sideBarDlg.css('border-style', style);
        }

        this.setBorderWidth = function (width) {
            sideBarDlg.css('border-width', width);
        }

        this.setBackgroundColor = function (color) {
            sideBarDlg.css('background-color', color);
        }

        this.html = function () {
            return sideBarDlg;
        }

        //var visible = false;
        // Static.bind("beforePrint", function () {
        //     // if (self.sideBarVisible) {
        //     //     visible = true;
        //     //     self.showSidebar(false);
        //     // }

        // })

        // Static.bind("afterPrint", function () {
        //     // if (visible) {
        //     //     visible = false;
        //     //     self.showSidebar(true);
        //     // }
        // });



        this.anchorPosition = function () {
            return m_anchorPosition;
        }

        this.getIndexFromHeaderElement = function (headerElement) {
            for (var i = 0; i < self.gridItemCount(); ++i) {
                if ((self.gridItem(i).headerElement[0].offsetTop == headerElement.offsetTop) &&
                    (self.gridItem(i).headerElement[0].innerText == headerElement.innerText)) {
                    return i;
                }
            }
            return -1;
        }

        this.hideGridItemWithHeaderElement = function (headerElement) {
            //headerElement = headerElement[0];
            for (var i = 0; i < self.gridItemCount(); ++i) {
                if ((self.gridItem(i).headerElement[0].offsetTop == headerElement.offsetTop) &&
                    (self.gridItem(i).headerElement[0].innerText == headerElement.innerText)) {
                    return self.showGridItem(i, false);
                }
            }
            return -1;
        }

        var tbarDiv = null;
        Static.bind("toolBarResized", function (e, tbDiv, changeOfHeight) {
            tbarDiv = tbDiv;
            //maintain the 2px vertical spacing between toolbar and sidebar
            self.html().css("top", parseFloat(tbarDiv.css("height")) + 2)
        });


        //var plotDiv = null;
        Static.bind("resize", function () {
            //leftSidebar visible
            if (m_anchorPosition === "left" && self.isSideBarVisible()) {
                plotDiv.css("left", parseFloat(self.html().css("width")));
            }
            //Recalculate gridItems height     
            self.setGridItemHeigth();

        });

        // Static.bind("plotDivResized", function (e, el, changeInHeight) {
        //     plotDiv = el;
        // });

        this.hideAllGridItems();
        //this.showSidebar(false)
        sideBarDlg.hide();

    }

    showSidebar(on) {
        if (this.isSideBarVisible() == on)
            return;
        this.sideBarVisible = on;
        //Static.trigger("showSidebar", on);
        if (on) {
            this.html().show();
            if (this.anchorPosition() == "right") {
                this.html().css("right", 0.5 + "%");
            } else if (this.anchorPosition() == "left") {
                this.html().css("left", 0.5 + "%");
            }
        } else {
            this.html().hide();
        }
        var plotDivWidthAsPercentage = (parseFloat(this.plotDiv.css("width")) / parseFloat(this.plotDiv.parent().css("width"))) * 100;
        if (on) {
            if (this.anchorPosition() == "right") {
                this.plotDiv.css("width", (plotDivWidthAsPercentage - this.sideBarWidth()) + "%");
            }
            else if (this.anchorPosition() == "left") {
                this.plotDiv.css("left", this.sideBarWidth() + "%");
                this.plotDiv.css("width", (plotDivWidthAsPercentage - this.sideBarWidth()) + "%");
            }
            //this.showGridItem(1, true)
        } else {
            this.plotDiv.css("width", (plotDivWidthAsPercentage + this.sideBarWidth()) + "%");
            if (this.anchorPosition() == "left") {
                this.plotDiv.css("left", 0 + "%");
            }
        }
        Static.trigger("showSidebar", [this.anchorPosition(), on]);
    }

    showGridItem(gridIndex, on) {
        this.doShowGridItem(gridIndex, on);
    }

    isGridItemVisible(gridIndex) {
        return this.doIsGridItemVisible(gridIndex);
    }
}
;
define("sideBar", function(){});

"include ['sideBar']"




 class InfoSideBar extends SideBar{
    constructor(plot, plotDiv) {//
		super(plotDiv.parent(), plotDiv, 1, "right");
		var self = this;
        var m_plot = plot;
		this.plot = function(){
			return m_plot;
		}		
		Static.bind("paneClose", function(e, headerElement){
		   self.hideGridItemWithHeaderElement(headerElement);
		   
		});
		this.setHeaderElement(0, 40)
		
	}
	
	showGridItem (gridIndex, on) {
      this.doShowGridItem (gridIndex, on);
    }
   
	showSidebar(on) {
		if(this.isSideBarVisible() == on)
			return;	
       super.showSidebar(on);
        	
		this.plot().autoRefresh();           
	}

	

	
} 
;
define("infoSidebar", ["sideBar"], function(){});

"include []";


class Pane {
  constructor(_parent) {
    var self = this;
    self.paneParent = $("<div/>");
    _parent.append(self.paneParent);
    _parent.parent().css("border", "4px ridge white");

    this.setPaneHeight = function (percent) {
      //param e.g "50%"
      self.paneParent.css("height", percent);
    };

    this.setHeader = function (headerElement, caption, close) {
      var close = close || false;
      var _header = this.header(caption);
      if (close) {
        var closeButton = $(
          '<div><button class="closeButton" style="position: absolute; right:5px" title="Close">X</button></div>'
        );
        headerElement.append(closeButton);
        closeButton.on("click", function () {
          Static.trigger("paneClose", headerElement);
        });
      }
      headerElement.append(_header);
    };
  }
  //subclass can re-implement
  header(caption) {
    var hdr = $(
      '<div style="text-align:center; padding-top: 10px; border-style: solid; border-width:1px; border-color:#666666; font-size: 16px; color:#666666"/>'
    );
    hdr.append("<label>" + caption + "</label>");
    return hdr;
  }
}
;
define("pane", function(){});

"include ['pane']";


class InfoPropertiesPane extends Pane {
  constructor(_parent, plot) {
    super(_parent);
    var self = this;
    var m_sidebarReDisplay = false;
    let playImgSrc = "images/play.png";

    let domainMin = 0;
    let domainMax = 0;

    self.setHeader(
      plot.rightSidebar.gridItem(0).headerElement,
      "Sidebar",
      true
    );

    var sideBarDlg = $(
      '<div style="background-color:rgba(249, 251, 221, 0.8);  ">\
                <div style="margin:4px">\
                <select id="currentCurve" style="width:100%">\
                </select></div>\
                <!--div><input type="text" id="fnDisplay" style="width:100%; background-color:rgba(255, 255, 255, 0.8); padding-left:6px" readonly /></div-->\
                <div><button id="copyText" title="Copy to clipboard"><img src="images/copy.png" style="width:15px;height:15px;padding=0px;margin=0px"></button><span id="fnDisplay" style="background-color:rgba(255, 255, 255, 0.8); margin:0px 4px 0px 4px; padding-left:6px;"></span></button></div>\
                <!--div style="white-space: nowrap;"><label style="padding-left:6px">onchange: <input id="onchange" type="checkbox" readonly /> </label>\
				damp: <input id="damp" style="width:30%" type="number" min="1" value="30000" step="500"/>\
				</div-->\
                \
                <div style="height:30%; overflow: auto">\
                  <div id="coeff_cont0" style="background-color:lightBlue; margin:2px; border-radius:4px">\
                  <div style="">Parameter:<b><span id="coeff0">?</span></b></div>\
                  <div style="margin:0px">\
                  <div style="white-space: nowrap;">\
                  <button id="coeff_val0_playButton" style="padding:0"><img src="images/play.png" alt="play button" width="20" height="20" title="Animate the function over the domain"></button><input id="coeff_val0_min" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Minimum value of coefficient"/><input id="coeff_val0" style="width:52%" type="number" value="1" title="A coefficient in the function that could be ajusted"/><input id="coeff_val0_max" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Maximum value of coefficient"/>\
                  </div>\
                  </div>\
                  </div>\
                  <br>\
                  <div id="coeff_cont1" style="background-color:lightBlue; margin:2px; border-radius:4px">\
                  <div style="">Parameter:<b><span id="coeff1">?</span></b></div>\
                  <div style="margin:0px">\
                  <div style="white-space: nowrap;">\
                  <button id="coeff_val1_playButton" style="padding:0"><img src="images/play.png" alt="play button" width="20" height="20" title="Animate the function over the domain"></button><input id="coeff_val1_min" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Minimum value of coefficient"/><input id="coeff_val1" style="width:52%" type="number" value="1" title="A coefficient in the function that could be ajusted"/><input id="coeff_val1_max" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Maximum value of coefficient"/>\
                  </div>\
                  </div>\
                  </div>\
                  <br>\
                  <div id="coeff_cont2" style="background-color:lightBlue; margin:2px; border-radius:4px">\
                  <div style="">Parameter:<b><span id="coeff2">?</span></b></div>\
                  <div style="margin:0px">\
                  <div style="white-space: nowrap;">\
                  <button id="coeff_val2_playButton" style="padding:0"><img src="images/play.png" alt="play button" width="20" height="20" title="Animate the function over the domain"></button><input id="coeff_val2_min" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Minimum value of coefficient"/><input id="coeff_val2" style="width:52%" type="number" value="1" title="A coefficient in the function that could be ajusted"/><input id="coeff_val2_max" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Maximum value of coefficient"/>\
                  </div>\
                  </div>\
                  </div>\
                  <br>\
                  <div id="coeff_cont3" style="background-color:lightBlue; margin:2px; border-radius:4px">\
                  <div style="">Parameter:<b><span id="coeff3">?</span></b></div>\
                  <div style="margin:0px">\
                  <div style="white-space: nowrap;">\
                  <button id="coeff_val3_playButton" style="padding:0"><img src="images/play.png" alt="play button" width="20" height="20" title="Animate the function over the domain"></button><input id="coeff_val3_min" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Minimum value of coefficient"/><input id="coeff_val3" style="width:52%" type="number" value="1" title="A coefficient in the function that could be ajusted"/><input id="coeff_val3_max" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Maximum value of coefficient"/>\
                  </div>\
                  </div>\
                  </div>\
                  <br>\
                  <div id="coeff_cont4" style="background-color:lightBlue; margin:2px; border-radius:4px">\
                  <div style="">Parameter:<b><span id="coeff4">?</span></b></div>\
                  <div style="margin:0px">\
                  <div style="white-space: nowrap;">\
                  <button id="coeff_val4_playButton" style="padding:0"><img src="images/play.png" alt="play button" width="20" height="20" title="Animate the function over the domain"></button><input id="coeff_val4_min" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Minimum value of coefficient"/><input id="coeff_val4" style="width:52%" type="number" value="1" title="A coefficient in the function that could be ajusted"/><input id="coeff_val4_max" class="noInputArrows no-outline noInputBorders" type="number" style="width:20%" title="Maximum value of coefficient"/>\
                  </div>\
                  </div>\
                  </div>\
                </div>\
                \
                <div id="watchTableContainer">\
                <div style="text-align:center"><h4>Watches</h4></div>\
                <div class="table-responsive" style="height: 47%">\
                \
                \
                <table class="table table-bordered" id="watchTable">\
                <thead>\
                <tr>\
                <th>Watch</th>\
                <th>Value</th>\
                </tr>\
                </thead>\
                <tbody id="watchTableBody">\
                </tbody>\
                </table>\
                </div>\
                \
                \
                </div>\
                </div>'
    );

    self.paneParent.append(sideBarDlg);
    plot.sidebar = self;

    this.sidebarDlg = function () {
      return sideBarDlg;
    };

    let parameterLimitsMap = new Map(); //parameterLimitsMap.set(curve, {})

    /* for (var i = 0; i < 5; ++i) {
      $("#coeff_val" + i + "_min").val(1);
      $("#coeff_val" + i + "_min").attr("title", `Minimum value: ${1}`);
      $("#coeff_val" + i + "_max").val(2);
      $("#coeff_val" + i + "_max").attr("title", `Maximum value: ${2}`);
    } */

    function initSidebarSelect() {
      var opts = $("#currentCurve").children();
      for (var i = 0; i < opts.length; ++i) {
        $("#currentCurve")[0].removeChild(opts[i]);
      }
      var curves = plot
        .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
        .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
        .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
        .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotZone));
      for (var i = 0; i < curves.length; ++i) {
        if (curves[i].isVisible()) {
          var opt = $("<option>" + curves[i].title() + "</option>");
          opt.attr("value", curves[i].title());
          $("#currentCurve").append(opt);
        }
      }
    }

    function hideAllInputs() {
      for (var i = 0; i < 5; ++i) {
        $("#coeff_cont" + i).hide();
      }
    }

    var damp = 30000;
    //Utility.alert("You have more than 5 unknown coefficients. Only the first 5 coefficients could be adjusted from the sidebar. The value of each remaining will be 1.")
    function initSidebarInput() {
      var curves = plot
        .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
        .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
        .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
        .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotZone));
      hideAllInputs();
      var curCurve = plot.findPlotCurve($("#currentCurve").val());
      if (!curCurve) {
        return;
      }
      /* $("#fnDisplay").val("");
      //console.log(curCurve);
      if (curCurve.functionDlgData && curCurve.fn) {
        if (curCurve.functionDlgData.variableY) {
          $("#fnDisplay").val(
            "f(" +
              curCurve.functionDlgData.variable +
              "," +
              curCurve.functionDlgData.variableY +
              ")=" +
              curCurve.fn
          );
        } else {
          $("#fnDisplay").val("f(" + curCurve.variable + ")=" + curCurve.fn);
        }
      } */

      const mj = function (tex) {
        return MathJax.tex2svg(tex, { em: 16, ex: 6, display: false });
      };

      $("#fnDisplay").html("");
      //console.log(curCurve);
      let m_html = null;
      if (curCurve.functionDlgData && curCurve.fn) {
        if (curCurve.functionDlgData.variableY) {
          m_html =
            "f(" +
            curCurve.functionDlgData.variable +
            "," +
            curCurve.functionDlgData.variableY +
            ")=" +
            curCurve.fn;
        } else {
          m_html = "f(" + curCurve.variable + ")=" + curCurve.fn;
        }
        m_html = m_html.replaceAll("mod", " mod ");
        //Utility.adjustLatexLogBaseDecimalPlaces(decimalPlacesX);
        // m_html = math
        //   .parse(m_html)
        //   .toTex({ parenthesis: "auto", implicit: "hide" });
        //Utility.restoreLatexLogBaseDecimalPlaces();

        // m_html = Utility.tex2svgMultiline(
        //   math.parse(m_html).toTex({ parenthesis: "auto", implicit: "hide" }),
        //   60,
        //   {
        //     em: 16,
        //     ex: 6,
        //     display: false,
        //   }
        // );

        try {
          // display and re-render the expression
          MathJax.typesetClear();
          $("#fnDisplay")[0].innerHTML = "";
          //let child = mj(m_html);
          let child = Utility.tex2svgMultiline(
            math.parse(m_html).toTex({ parenthesis: "auto", implicit: "hide" }),
            60,
            {
              em: 16,
              ex: 6,
              display: false,
            }
          );
          $("#fnDisplay")[0].appendChild(child);
        } catch (err) {}
      }

      $("#copyText").click(function () {
        //console.log(curCurve.title(), curCurve.fn);
        navigator.clipboard.writeText(
          math
            .parse(curCurve.fn.replaceAll("mod", " mod "))
            .toTex({ em: 16, ex: 6, display: false })
        );
      });

      var widthX = curCurve.upperX - curCurve.lowerX;
      var step = widthX / (damp / 10000);
      var coeffs = curCurve.coeffs || [];
      var numOfCoeffs = coeffs.length;
      for (var i = 0; i < numOfCoeffs; ++i) {
        $("#coeff_val" + i).attr("step", step);
        if (!curCurve.parameterLimits[i]) {
          curCurve.parameterLimits.push({ minimum: 1, maximum: 2 });
        }
        $("#coeff_val" + i + "_min").val(curCurve.parameterLimits[i].minimum);
        $("#coeff_val" + i + "_min").attr(
          "title",
          `Minimum value: ${curCurve.parameterLimits[i].minimum}`
        );
        $("#coeff_val" + i + "_max").val(curCurve.parameterLimits[i].maximum);
        $("#coeff_val" + i + "_max").attr(
          "title",
          `Maximum value: ${curCurve.parameterLimits[i].maximum}`
        );
      }

      /* $("#damp").on("input", function () {
        var val = parseInt($("#damp").val());
        if (!_.isFinite(val) || val < 1) {
          $("#damp").val(damp);
        } else {
          damp = val;
        }
        step = widthX / (damp / 10000);
        for (var i = 0; i < numOfCoeffs; ++i) {
          $("#coeff_val" + i).attr("step", step);
        }
      }); */

      if (numOfCoeffs > 5) {
        numOfCoeffs = 5;
      }

      for (var i = 0; i < numOfCoeffs; ++i) {
        $("#coeff" + i).html(coeffs[i]);
        $("#coeff_val" + i).attr("step", step);
        $("#coeff_val" + i).val(curCurve.coeffsVal[i]);
        // $("#coeff_val" + i + "_min").val(1);
        // $("#coeff_val" + i + "_min").attr("title", `Minimum value: ${1}`);
        // $("#coeff_val" + i + "_max").val(2);
        // $("#coeff_val" + i + "_max").attr("title", `Maximum value: ${2}`);

        $("#coeff_val" + i).stop(true);
        $("#coeff_val" + i + "_playButton")[0].children[0].src =
          "images/play.png";
        $("#coeff_cont" + i).show();
      }
    }

    function initSidebar() {
      initSidebarSelect();
      initSidebarInput();
      Static.trigger(
        "currentCurveChanged",
        plot.findPlotCurve($("#currentCurve").val())
      );
    }

    this.sidebarReDisplay = function () {
      return m_sidebarReDisplay;
    };

    this.setSidebarReDisplay = function (on) {
      m_sidebarReDisplay = on;
    };

    this.setTop = function (topPosition) {
      sideBarDlg.css("top", topPosition);
    };

    function initializeEventHandlers() {
      $("#currentCurve").change(function () {
        //Invalidate cache and, thus, force integrate() to re-compute
        Static.total_volume = undefined;
        Static.total_area = undefined;
        Static.prevStart = undefined;
        Static.prevEnd = undefined;
        initSidebarInput();
        Static.trigger("invalidateWatch");
        Static.trigger(
          "currentCurveChanged",
          plot.findPlotCurve($("#currentCurve").val())
        );
      });

      ///////////////////////////////////////////////////////

      /* $("#onchange").change(function () {
        for (let i = 0; i < 5; i++) {
          $("#coeff_val" + i).stop(true);
          $("#coeff_val" + i + "_playButton")[0].children[0].src =
            "images/play.png";
        }
      }); */

      $(
        "#coeff_val0_max, #coeff_val1_max, #coeff_val2_max, #coeff_val3_max, #coeff_val4_max, #coeff_val0_min, #coeff_val1_min, #coeff_val2_min, #coeff_val3_min, #coeff_val4_min"
      ).on("input", function () {
        const c = $(this)[0].id.charAt(9);
        $("#coeff_val" + c).stop(true);
        $("#coeff_val" + c + "_playButton")[0].children[0].src =
          "images/play.png";
        let curCurve = plot.findPlotCurve($("#currentCurve").val());
        if ($(this)[0].id.indexOf("_min") !== -1) {
          $(this).attr("title", `Minimum value: ${$(this).val()}`);
          curCurve.parameterLimits[parseInt(c)].minimum = parseFloat(
            $(this).val()
          );
        } else {
          $(this).attr("title", `Maximum value: ${$(this).val()}`);
          curCurve.parameterLimits[parseInt(c)].maximum = parseFloat(
            $(this).val()
          );
        }
      });

      $(
        "#coeff_val0_playButton, #coeff_val1_playButton, #coeff_val2_playButton, #coeff_val3_playButton, #coeff_val4_playButton"
      ).click(function () {
        const c = $(this)[0].id.charAt(9);
        const imgSrc = $(this)[0].children[0].src;
        if (imgSrc.indexOf("pause.png") !== -1) {
          //pause button pressed
          $("#coeff_val" + c).stop(true);
          $(this)[0].children[0].src = "images/play.png";
        } else {
          //play button pressed
          const minValue = parseFloat($("#coeff_val" + c + "_min").val());
          const maxValue = parseFloat($("#coeff_val" + c + "_max").val());
          if (minValue >= maxValue) {
            alert("Maximum value must be greater than minimum value.");
            $("#coeff_val" + c + "_max").select();
            return;
          }
          /* $("#onchange")[0].checked = false;
            $("#onchange").trigger("change"); */
          startAnimation();
          function startAnimation() {
            //$("#onchange")[0].checked = false;
            //if ($("#onchange")[0].checked) $("#onchange").click();

            const option = {
              duration: Static.animationDuration,
              step: function () {
                $("#coeff_val" + c).trigger("input");
              },
            };
            const option2 = {
              duration: Static.animationDuration,
              complete: startAnimation,
              step: function () {
                $("#coeff_val" + c).trigger("input");
              },
            };
            $("#coeff_val" + c)
              .val(parseFloat($("#coeff_val" + c + "_min").val()))
              .animate({ value: maxValue }, option);
            $("#coeff_val" + c)
              .val(parseFloat($("#coeff_val" + c + "_min").val()))
              .animate({ value: minValue }, option2);
          }
          $(this)[0].children[0].src = "images/pause.png";
        }
      });

      //////////////////////////////////////////////////////////////////////////

      //immediate update
      $("#coeff_val0, #coeff_val1, #coeff_val2, #coeff_val3, #coeff_val4").on(
        "input",
        function () {
          //if (!$("#onchange")[0].checked) {
          const value = parseFloat($(this).val());
          const minValue = parseFloat($("#" + $(this)[0].id + "_min").val());
          const maxValue = parseFloat($("#" + $(this)[0].id + "_max").val());
          if (value > maxValue) {
            $(this).val(maxValue);
          }
          if (value < minValue) {
            $(this).val(minValue);
          }
          //console.log(minValue, maxValue);
          if (validateInput($(this))) adjustCurve($(this));
        }
        //}
      );
      //update on enter
      /* $("#coeff_val0, #coeff_val1, #coeff_val2, #coeff_val3, #coeff_val4").on(
        "change",
        function () {
          if (!validateInput($(this))) {
            $(this).val(getLastValidValue($(this)));
            return;
          }
          if ($("#onchange")[0].checked) {
            const value = parseFloat($(this).val());
            const minValue = parseFloat($("#" + $(this)[0].id + "_min").val());
            const maxValue = parseFloat($("#" + $(this)[0].id + "_max").val());
            if (value > maxValue) {
              $(this).val(maxValue);
            }
            if (value < minValue) {
              $(this).val(minValue);
            }
            adjustCurve($(this));
          } 
        }
      ); */
    }

    var initializeEventHandlersOnce = _.once(initializeEventHandlers);
    this.initSidebar = function () {
      initSidebar();
      initializeEventHandlersOnce();
    };

    this.currentCurveName = function () {
      return $("#currentCurve").val();
    };

    Static.bind("titleChange", function () {
      initSidebar();
    });

    Static.bind("pointAdded pointRemoved", function (e, curve) {
      $("#currentCurve").val(curve.title);
    });

    const inputIds = [
      "coeff_val0",
      "coeff_val1",
      "coeff_val2",
      "coeff_val3",
      "coeff_val4",
    ];

    function adjustDomain(curCurve, selector) {
      const selectorIndex = inputIds.indexOf(selector[0].id);
      var coeffs = curCurve.coeffs;
      if (curCurve.domainRangeRestriction.length) {
        let s = curCurve.domainRangeRestriction[0];
        s = curCurve.plot().defines.expandDefines(s);
        s = Utility.purgeAndMarkKeywords(s);
        // s = s.replaceAll(
        //   coeffs[selectorIndex],
        //   `(${curCurve.coeffsVal[selectorIndex]})`
        // );
        for (let index = 0; index < coeffs.length; index++) {
          if (s.indexOf(coeffs[index]) != -1) {
            s = s.replaceAll(coeffs[index], `(${curCurve.coeffsVal[index]})`);
          }
        }
        curCurve.lowerX = math.evaluate(Utility.replaceKeywordMarkers(s));

        s = curCurve.domainRangeRestriction[1];
        s = curCurve.plot().defines.expandDefines(s); //plot.defines.expandDefines
        s = Utility.purgeAndMarkKeywords(s);
        for (let index = 0; index < coeffs.length; index++) {
          if (s.indexOf(coeffs[index]) != -1) {
            s = s.replaceAll(coeffs[index], `(${curCurve.coeffsVal[index]})`);
          }
        }
        curCurve.upperX = math.evaluate(Utility.replaceKeywordMarkers(s));

        //console.log(domainRangeRestriction[0], domainRangeRestriction[1]);
      }
    }

    function adjustCurveUnique(selector) {
      var curCurve = plot.findPlotCurve($("#currentCurve").val());
      var coeffs = curCurve.coeffs;
      var fn = curCurve.fn;
      if (curCurve.fn) {
        fn = Utility.purgeAndMarkKeywords(fn);
        for (var i = 0; i < coeffs.length; ++i) {
          while (fn.indexOf(coeffs[i]) != -1) {
            fn = fn.replace(coeffs[i], `(${$("#coeff_val" + i).val()})`);
          }
          curCurve.coeffsVal[i] = parseFloat($("#coeff_val" + i).val());
        }
        fn = Utility.replaceKeywordMarkers(fn);
        curCurve.expandedFn = fn; //Added 6/17/2020

        adjustDomain(curCurve, selector);

        var data = curCurve.data();
        if (curCurve.unboundedRange) {
          data.setFn(fn);
        } else {
          var s = Utility.makeSamples({
            fx: fn,
            lowerX: curCurve.lowerX,
            upperX: curCurve.upperX,
            numOfSamples: curCurve.numOfSamples,
          });
          if (!s) return;
          data.setSamples(s);
        }
      } else if (curCurve.parametricFnX && curCurve.parametricFnY) {
        let parametricFnX = curCurve.parametricFnX,
          parametricFnY = curCurve.parametricFnY;
        fn = Utility.purgeAndMarkKeywords(parametricFnX);
        for (var i = 0; i < coeffs.length; ++i) {
          while (fn.indexOf(coeffs[i]) != -1) {
            fn = fn.replace(coeffs[i], $("#coeff_val" + i).val());
          }
          curCurve.coeffsVal[i] = $("#coeff_val" + i).val();
        }
        parametricFnX = Utility.replaceKeywordMarkers(fn);

        fn = Utility.purgeAndMarkKeywords(parametricFnY);
        for (var i = 0; i < coeffs.length; ++i) {
          while (fn.indexOf(coeffs[i]) != -1) {
            fn = fn.replace(coeffs[i], $("#coeff_val" + i).val());
          }
          curCurve.coeffsVal[i] = $("#coeff_val" + i).val();
        }
        parametricFnY = Utility.replaceKeywordMarkers(fn);

        adjustDomain(curCurve, selector);

        var data = curCurve.data();
        if (curCurve.unboundedRange) {
          data.setFn(curCurve.expandedFn);
        } else {
          var s = Utility.makeSamples({
            fx: null,
            lowerX: curCurve.lowerX,
            upperX: curCurve.upperX,
            numOfSamples: curCurve.numOfSamples,
            parametricFnX,
            parametricFnY,
            parametric_variable: curCurve.parametric_variable,
          });
          if (!s) return;
          data.setSamples(s);
        }
      }
      Static.trigger("curveAdjusted");
      plot.autoRefresh();
    }

    function adjustCurveNonUnique(selector) {
      const currentCurveCoeffs = plot.findPlotCurve(
        self.currentCurveName()
      ).coeffs;

      const selectorIndex = inputIds.indexOf(selector[0].id);

      var array = plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
      for (let index = 0; index < array.length; index++) {
        const curCurve = array[index];

        var coeffs = curCurve.coeffs;

        for (var i = 0; i < coeffs.length; ++i) {
          if (curCurve.fn) {
            var fn = Utility.purgeAndMarkKeywords(curCurve.fn);
            if (coeffs.indexOf(currentCurveCoeffs[selectorIndex]) != -1) {
              while (
                coeffs.indexOf(currentCurveCoeffs[selectorIndex]) != -1 &&
                fn.indexOf(currentCurveCoeffs[selectorIndex]) != -1
              ) {
                fn = fn.replace(
                  currentCurveCoeffs[selectorIndex],
                  `(${selector.val()})`
                );
              }
              for (let index = 0; index < coeffs.length; index++) {
                const element = coeffs[index];
                fn = fn.replaceAll(element, curCurve.coeffsVal[index]);
              }
              curCurve.coeffsVal[selectorIndex] = parseFloat(selector.val());

              curCurve.expandedFn = Utility.replaceKeywordMarkers(fn); //Added 6/17/2020

              adjustDomain(curCurve, selector);

              var data = curCurve.data();
              if (curCurve.unboundedRange) {
                data.setFn(curCurve.expandedFn);
              } else {
                var s = Utility.makeSamples({
                  fx: curCurve.expandedFn,
                  lowerX: curCurve.lowerX,
                  upperX: curCurve.upperX,
                  numOfSamples: curCurve.numOfSamples,
                });
                if (!s) return;
                data.setSamples(s);
              }
            } //
          } else if (curCurve.parametricFnX && curCurve.parametricFnY) {
            let parametricFnX = curCurve.parametricFnX,
              parametricFnY = curCurve.parametricFnY;
            var fn = Utility.purgeAndMarkKeywords(parametricFnX);
            if (coeffs.indexOf(currentCurveCoeffs[selectorIndex]) != -1) {
              while (
                coeffs.indexOf(currentCurveCoeffs[selectorIndex]) != -1 &&
                fn.indexOf(currentCurveCoeffs[selectorIndex]) != -1
              ) {
                fn = fn.replace(
                  currentCurveCoeffs[selectorIndex],
                  selector.val()
                );
              }
              for (let index = 0; index < coeffs.length; index++) {
                const element = coeffs[index];
                fn = fn.replaceAll(element, curCurve.coeffsVal[index]);
              }
              curCurve.coeffsVal[selectorIndex] = selector.val();

              parametricFnX = Utility.replaceKeywordMarkers(fn); //Added 6/17/2020

              // adjustDomain(curCurve, selector);

              /* var data = curCurve.data();
              if (curCurve.unboundedRange) {
                data.setFn(curCurve.expandedFn);
              } else {
                var s = Utility.makeSamples({
                  fx: null,
                  lowerX: curCurve.lowerX,
                  upperX: curCurve.upperX,
                  numOfSamples: curCurve.numOfSamples,
                  parametricFnX,
                  parametricFnY,
                  parametric_variable: parametric_variable
                });
                if (!s) return;
                data.setSamples(s);
              } */
            }
            fn = Utility.purgeAndMarkKeywords(parametricFnY);
            if (coeffs.indexOf(currentCurveCoeffs[selectorIndex]) != -1) {
              while (
                coeffs.indexOf(currentCurveCoeffs[selectorIndex]) != -1 &&
                fn.indexOf(currentCurveCoeffs[selectorIndex]) != -1
              ) {
                fn = fn.replace(
                  currentCurveCoeffs[selectorIndex],
                  selector.val()
                );
              }
              for (let index = 0; index < coeffs.length; index++) {
                const element = coeffs[index];
                fn = fn.replaceAll(element, curCurve.coeffsVal[index]);
              }
              curCurve.coeffsVal[selectorIndex] = selector.val();

              parametricFnY = Utility.replaceKeywordMarkers(fn); //Added 6/17/2020

              //adjustDomain(curCurve, selector);

              /* var data = curCurve.data();
              if (curCurve.unboundedRange) {
                data.setFn(curCurve.expandedFn);
              } else {
                var s = Utility.makeSamples({
                  fx: null,
                  lowerX: curCurve.lowerX,
                  upperX: curCurve.upperX,
                  numOfSamples: curCurve.numOfSamples,
                  parametricFnY,
                  parametricFnY,
                  parametric_variable: parametric_variable
                });
                if (!s) return;
                data.setSamples(s);
              } */
            }
            adjustDomain(curCurve, selector);
            var data = curCurve.data();
            if (curCurve.unboundedRange) {
              data.setFn(curCurve.expandedFn);
            } else {
              var s = Utility.makeSamples({
                fx: null,
                lowerX: curCurve.lowerX,
                upperX: curCurve.upperX,
                numOfSamples: curCurve.numOfSamples,
                parametricFnX,
                parametricFnY,
                parametric_variable: curCurve.parametric_variable,
              });
              if (!s) return;
              data.setSamples(s);
            }
          }
        }
      }
      Static.trigger("curveAdjusted");
      plot.autoRefresh();
    }

    function adjustCurve(selector) {
      if (Static.uniqueParameter) {
        adjustCurveUnique(selector);
      } else {
        adjustCurveNonUnique(selector);
      }
    }

    Static.bind("visibilityChange", function (e, plotItem, on) {
      if (!on) {
        for (var i = 0; i < 5; ++i) {
          $("#coeff_val" + i).stop(true);
          $("#coeff_val" + i + "_playButton")[0].children[0].src =
            "images/play.png";
        }
      }
    });

    Static.bind("itemAttached", function (e, plotItem, on) {
      for (var i = 0; i < 5; ++i) {
        $("#coeff_val" + i).stop(true);
        $("#coeff_val" + i + "_playButton")[0].children[0].src =
          "images/play.png";
      }
      if (
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram
      ) {
        if (on) {
          //attached
        } else {
          //detached
          if (
            !plot
              .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
              .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
              .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
              .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotZone))
              .length ||
            !plot.hasVisiblePlotCurve()
          ) {
            //self.showSidebar(false);
          }
        }
        Static.trigger("visibilityChange", [plotItem, on]);
      }
    });

    function getLastValidValue(input) {
      /* var inputIds = [
        "coeff_val0",
        "coeff_val1",
        "coeff_val2",
        "coeff_val3",
        "coeff_val4",
      ]; */
      var curCurve = plot.findPlotCurve($("#currentCurve").val());

      return curCurve.coeffsVal[inputIds.indexOf(input[0].id)];
    }

    function isValidNumber(val) {
      return _.isFinite(parseFloat(val));
    }

    function validateInput(input) {
      var inputIds = [
        "coeff_val0",
        "coeff_val1",
        "coeff_val2",
        "coeff_val3",
        "coeff_val4",
      ];
      var curCurve = plot.findPlotCurve($("#currentCurve").val());
      var coeffsVal = curCurve.coeffsVal;

      var inputIdIndex = inputIds.indexOf(input[0].id);
      if (!isValidNumber(input.val())) {
        return false;
      }

      return true;
    }

    self.initSidebar();
  }
}
;
define("infoPropertiesPane", ["pane"], function(){});

"include ['sideBar']"


class PlotSideBar extends SideBar{
    constructor(plot, plotDiv) {//
		super(plotDiv.parent(), plotDiv, 2, "left");
		var self = this;
        var m_plot = plot;
		this.plot = function(){
			return m_plot;
		}
		
		Static.bind("paneClose", function(e, headerElement){
		   self.hideGridItemWithHeaderElement(headerElement);
		}); 
		
	}
	
	showSidebar(on) {
		if(this.isSideBarVisible() == on)
			return;			
		super.showSidebar(on);		
		this.plot().autoRefresh();           
	}

showGridItem (gridIndex, on) {
      this.doShowGridItem (gridIndex, on);
   }

	
}
;
define("plotSideBar", ["sideBar"], function(){});

"include ['pane']";


/*
pp.addProperty({
name: "My Name only Prop",
id: "nameOnly"
})
pp.addProperty({
name: "My First Prop",
id: "firstProp",
type: "span"
})
pp.addProperty({
name: "My First Prop",
id: "firstProp",
type: "text"
})
pp.addProperty({
name: "My First Prop",
id: "firstProp",
type:"number",
value: 20.0,
min: 10.0,
max: 30.0,
step: 0.5
})

pp.addProperty({
name: "My Color",
id: "colorProp",
type:"color",
value: "red"

})

pp.addProperty({
name: "My Checkbox",
id: "checkboxProp",
type:"checkbox",
checked: true

})
pp.addProperty({
name: "My select",
id: "selectProp",
type:"select",
selectorOptions: ["one", "Two", "Three", 1, 2, 3]

})

pp.addProperty({
name: "My Radio1",
id: "radioProp1",
type:"radio",
group: "myRadioGroup",
checked: true

})

pp.addProperty({
name: "My Radio2",
id: "radioProp2",
type:"radio",
group: "myRadioGroup"

})
 */
/////

class PropertiesPane extends Pane {
  static fontsDisplay() {
    return [
      "Arial",
      "Arial Black",
      "Comic Sans MS",
      "Courier New",
      "Georgia",
      "Impact",
      "Lucida Console",
      "Lucida Sans Unicode",
      "PalatinoLinotype",
      "Tahoma",
      "Times New Roman",
      "Trebuchet MS",
      "Verdana",
      "Gill Sans",
    ];
  }

  static fontGroup(displayIndex) {
    var fontsGroup = [
      "Arial,Arial,Helvetica,sans-serif",
      "Arial Black,Arial Black,Gadget,sans-serif",
      "Comic Sans MS,Comic Sans MS,cursive",
      "Courier New,Courier New,Courier,monospace",
      "Georgia,Georgia,serif",
      "Impact,Charcoal,sans-serif",
      "Lucida Console,Monaco,monospace",
      "Lucida Sans Unicode,Lucida Grande,sans-serif",
      "Palatino Linotype,Book Antiqua,Palatino,serif",
      "Tahoma,Geneva,sans-serif",
      "Times New Roman,Times,serif",
      "Trebuchet MS,Helvetica,sans-serif",
      "Verdana,Geneva,sans-serif",
      "Gill Sans,Geneva,sans-serif",
    ];
    return fontsGroup[displayIndex];
  }

  constructor(_parent) {
    super(_parent);
    var self = this;

    let pos = 0;

    var propertiesTable = $("<table/>");
    self.paneParent.append(propertiesTable);

    this.table = function () {
      return propertiesTable;
    };

    this.init = function (options) {
      var _options = options || {
        expandable: true,
        clickableNodeNames: true,
      };
      propertiesTable.treetable(_options);
    };

    /* $("#foldersTable").treetable(
                  "loadBranch",
                  parentNode,
                  makeRow(data.tree[i])
                ); */

    let removedNodeMap = new Map(); //unloadBranch(node)

    /* this.hide = function (id) {
      var node = propertiesTable.treetable("node", id);
      //console.log(node.row);
      if (node) {
        removedNodeMap.set(id, node);
        node.row.hide();
        // propertiesTable.treetable("removeNode", id);
      }
    };

    this.show = function (id) {
      var node = removedNodeMap.get(id);
      if (node) {
        let row = node.row;
        row.show();
        //row.find("SPAN")[0].remove();
        //propertiesTable.treetable("loadBranch", node.parentNode(), row);
      }
    }; */

    this.hide = function (id) {
      propertiesTable.treetable("collapseNode", id);
      var node = propertiesTable.treetable("node", id);
      if (node) {
        const row = node.row;
        let parentRow = node.row.parent();
        if (!parentRow[0]) {
          parentRow = propertiesTable.find("TBODY");
        }
        removedNodeMap.set(id, { row, parentRow });
        row.detach();
      }
    };

    this.show = function (id) {
      const obj = removedNodeMap.get(id);
      if (!obj) return;
      const { row, parentRow } = obj;
      if (row) {
        const pos = parseInt(row.attr("data-tt-pos"));
        const rows = parentRow[0].children;
        const posLastRow = parseInt(
          $(rows[rows.length - 1]).attr("data-tt-pos")
        );
        if (pos < posLastRow) {
          for (let index = 0; index < rows.length; index++) {
            const element = rows[index];
            if (parseInt($(element).attr("data-tt-pos")) > pos) {
              parentRow[0].insertBefore(row[0], element);
              break;
            }
          }
        } else {
          parentRow.append(row);
        }
      }
    };

    this.getElementValueDataAttribute = function (id) {
      //"data-tt-id" val
      var row = null;
      var trElements = propertiesTable[0].getElementsByTagName("TR");
      for (var i = 0; i < trElements.length; ++i) {
        if (trElements[i].getAttribute("data-tt-id") == id) {
          row = trElements[i];
          break;
        }
      }
      if (row) {
        var children = row.children;
        if (children.length !== 2) return null;
        return $(children[1].children[0]);
      }
      return null;
    };

    //This is not safe. It requires unique names
    this.getTableRowByPropertyName = function (name) {
      var trElements = propertiesTable[0].getElementsByTagName("TR");
      for (var i = 0; i < trElements.length; ++i) {
        if (trElements[i].cells[0].innerText == name) {
          return $(trElements[i]);
        }
      }
      return null;
    };

    this.getTableRowByPropertyId = function (id) {
      //"data-tt-id" val
      var trElements = propertiesTable[0].getElementsByTagName("TR");
      for (var i = 0; i < trElements.length; ++i) {
        if (trElements[i].getAttribute("data-tt-id") == id) {
          return $(trElements[i]);
        }
      }
      return null;
    };

    this.getElementValueDataByPropertyName = function (name) {
      //"data-tt-id" val
      var row = null;
      var trElements = propertiesTable[0].getElementsByTagName("TR");
      for (var i = 0; i < trElements.length; ++i) {
        if (trElements[i].cells[0].innerText == name) {
          row = trElements[i];
          break;
        }
      }
      if (row) {
        var children = row.children;
        if (children.length !== 2) return null;
        return $(children[1].children[0]);
      }
      return null;
    };

    this.setFontSize = function (sz) {
      //param e.g "10px"
      propertiesTable.css("font-size", sz);
    };

    function makeRow(options) {
      if (options.type == undefined) {
        options.type = "span";
      }

      var disabled = "";
      if (options.disabled) disabled = "disabled";
      var checked = "";
      if (options.checked) checked = "checked";
      var _value = "";
      if (options.value !== undefined) _value = "value=" + options.value;

      var row = null;

      if (options.type == "text") {
        return $(
          '<tr><td style="border: 0.5px solid grey;">' +
            options.name +
            '</td><td style="border: 0.5px solid grey;"><input type="text" ' +
            disabled +
            " " +
            _value +
            ' style="width:100%"/></td></tr>'
        );
      }
      if (options.type == "button") {
        return $(
          '<tr><td style="border: 0.5px solid grey;">' +
            options.name +
            '</td><td style="border: 0.5px solid grey;"><input type="button" ' +
            disabled +
            ' value="..." /></td></tr>'
        );
      }
      if (options.type == "number") {
        return $(
          '<tr><td style="border: 0.5px solid grey;">' +
            options.name +
            '</td><td style="border: 0.5px solid grey;"><input type="number" ' +
            disabled +
            " step =" +
            options.step +
            " min =" +
            options.min +
            " max=" +
            options.max +
            " " +
            _value +
            ' style="width:100%"/></td></tr>'
        );
      }
      if (options.type == "checkbox") {
        return $(
          '<tr><td style="border: 0.5px solid grey;">' +
            options.name +
            '</td><td style="border: 0.5px solid grey;"><input ' +
            disabled +
            ' type="checkbox" style="width:100%" ' +
            checked +
            "/></td></tr>"
        );
      }
      if (options.type == "radio") {
        return $(
          '<tr><td style="border: 0.5px solid grey;">' +
            options.name +
            '</td><td style="border: 0.5px solid grey;"><input ' +
            disabled +
            ' type="radio" name=' +
            options.group +
            ' style="width:100%" ' +
            checked +
            "/></td></tr>"
        );
      }
      if (options.type == "color") {
        var color = "#000000";
        if (options.value) color = Utility.colorNameToHex(options.value);
        return $(
          '<tr><td style="border: 0.5px solid grey;">' +
            options.name +
            '</td><td style="border: 0.5px solid grey;"><input ' +
            disabled +
            ' type="color" value=' +
            color +
            " /></td></tr>"
        );
      }

      /////////////////////
      if (options.type == "span") {
        return $(
          '<tr><td style="border: 0.5px solid grey;">' +
            options.name +
            '</td><td style="border: 0.5px solid grey;"><span style="width:100%"/></td></tr>'
        );
      }

      if (options.type == "select") {
        var row = $(
          '<tr><td style="border: 0.5px solid grey;">' +
            options.name +
            "</td></tr>"
        );
        var select = $("<select " + disabled + " />");
        if (options.selectorOptions) {
          for (var i = 0; i < options.selectorOptions.length; ++i) {
            select.append(
              $("<option>" + options.selectorOptions[i] + "</option>")
            );
          }
        }
        return row.append(
          $('<td style="border: 0.5px solid grey;">').append(select)
        );
      }

      return row;
    }

    this.addProperty = function (options) {
      var row = makeRow(options);
      if (!row) return null;
      var selector = null;
      row.attr("data-tt-pos", pos);
      pos++;
      row.attr("data-tt-id", options.id);
      if (options.parentId !== undefined)
        row.attr("data-tt-parent-id", options.parentId);
      if (options.branchId !== undefined)
        row.attr("data-tt-branch", options.branchId);
      if (
        options.type == "text" ||
        options.type == "number" ||
        options.type == "color" ||
        options.type == "checkbox" ||
        options.type == "radio"
      ) {
        selector = $(row[0].getElementsByTagName("INPUT"));
        selector.on("change", function () {
          if (options.fun) {
            if (options.type == "checkbox") {
              options.fun($(this)[0].checked);
            } else {
              options.fun($(this).val());
            }
          }
        });
      }
      if (options.type == "select") {
        selector = $(row[0].getElementsByTagName("SELECT"));
        selector.on("change", function () {
          if (options.fun) {
            options.fun($(this)[0].selectedIndex);
          }
        });
      }
      if (options.type == "button") {
        selector = $(row[0].getElementsByTagName("INPUT"));
        selector.on("click", function () {
          if (options.fun) {
            options.fun();
          }
        });
      }
      if (options.type == "span") {
        //default
        selector = $(row[0].getElementsByTagName("SPAN"));
      }
      propertiesTable.append(row);
      if (options.title) row.attr("title", options.title);
      return selector;
    };
  }
  header(caption) {
    var hdr = $("<table />");
    hdr.append(
      '<caption style="text-align:center; border-width:4px; color:black"><b>' +
        caption +
        "</b></caption>"
    );
    this.headerTableHead = $(
      '<thead style="background-color:lightgray">\
              <tr style="border-style:solid; border-width:0.5px">\
              <th style="border-style:none;"><label>Property</label></th>\
              <th style="border-style:none; text-align:right"><label style="margin-right:4px">Value</label></th>\
              </tr>\
              </thead>'
    );
    hdr.append(this.headerTableHead);

    return hdr;
  }
}
;
define("propertiesPane", ["pane"], function(){});

"include ['propertiesPane']";


class CurvePropertiesPane extends PropertiesPane {
  constructor(_parent, plot) {
    super(_parent);
    var self = this;

    self.setHeader(
      plot.leftSidebar.gridItem(0).headerElement,
      "Curve Properties",
      true
    );

    var curveSelectProp = this.addProperty({
      name: "Curve",
      id: "currentCurve",
      type: "select",
      title: "Curve being modified",
      fun: currentCurve,
    });
    this.addProperty({
      name: "Rename",
      id: "renameCurve",
      type: "button",
      title: "Give the curve a different unique name",
      fun: renameCurve,
    });
    this.addProperty({
      name: "Remove",
      id: "removeCurve",
      type: "button",
      title: "Permanently remove the currently selected curve",
      fun: removeCurve,
    });
    this.addProperty({
      name: "Fit",
      id: "fitCurve",
      type: "button",
      title: "Assign a curve fitter to the currently selected curve",
      fun: fitCurve,
    });
    this.addProperty({
      name: "Zone",
      id: "zone",
      type: "button",
      title: "Assign a zone to the currently selected curve",
      fun: zone,
    });
    this.addProperty({
      name: "Legend Attributes",
      id: "legendAttributes",
      type: "button",
      title: "Configure how the curve is represented on the legend",
      fun: legendAttributes,
    });
    this.addProperty({
      name: "Orientation",
      id: "orientation",
      type: "select",
      selectorOptions: ["Vertical", "Horizontal"],
      title:
        "Set the orientation of the curve. This affect how the step and stick styles are displayed",
      fun: orientation,
    });
    var curveStyleOptions = [
      "Lines (Default)",
      "Sticks",
      "Steps",
      "Dots",
      "NoCurve",
    ];
    var curveSTyleSelector = this.addProperty({
      name: "Style",
      id: "curveStyle",
      type: "select",
      selectorOptions: curveStyleOptions,
      title: "Set the curve's drawing style",
      fun: curveStyle,
    });

    var axisSpanElement = this.addProperty({
      name: "Axes",
      id: "curveAxes",
      title:
        "Set X and Y axis. The curve is drawn according to the coordinates of its Axes.",
    });
    var axisHorizontalSelectElement = this.addProperty({
      name: "Horizontal",
      id: "horizontal",
      parentId: "curveAxes",
      type: "select",
      selectorOptions: ["Bottom", "Top"],
      title: "Set X axis.",
      fun: horizontal,
    });
    var axisVerticalSelectElement = this.addProperty({
      name: "Vertical",
      id: "vertical",
      parentId: "curveAxes",
      type: "select",
      selectorOptions: ["Left", "Right"],
      title: "Set Y axis.",
      fun: vertical,
    });
    var swapAxes = this.addProperty({
      name: "Swap axes",
      id: "swapAxes",
      parentId: "curveAes",
      type: "checkbox",
      title:
        "If checked, the axes are swapped. That is, f(x) is horizontal and x is vertical.",
      fun: swapAxesFn,
    });
    this.addProperty({
      name: "Pen",
      title: "Build and assign a pen.",
      id: "curvePen",
    });
    this.addProperty({
      name: "Color",
      id: "curvePenColor",
      parentId: "curvePen",
      type: "color",
      title: "Set the pen color",
      fun: curvePenColor,
    });
    this.addProperty({
      name: "Style",
      id: "curvePenStyle",
      parentId: "curvePen",
      type: "select",
      selectorOptions: ["solid", "dot", "dash", "dash-dot", "dash-dot-dot"],
      title: "Set the pen style",
      fun: curvePenStyle,
    });
    this.addProperty({
      name: "Width",
      id: "curvePenWidth",
      parentId: "curvePen",
      type: "select",
      selectorOptions: [1, 2, 3, 4, 5],
      title: "Set the pen width",
      fun: curvePenWidth,
    });
    this.addProperty({
      name: "Curve Symbol",
      title:
        "Assign a symbol. Any previously set symbol is removed by setting a new one.",
      id: "curveSymbol",
    });
    this.addProperty({
      name: "Pen",
      title: "Build and assign a pen.",
      id: "curveSymPen",
      parentId: "curveSymbol",
    });
    this.addProperty({
      name: "Color",
      id: "curveSymbolPenColor",
      parentId: "curveSymPen",
      type: "color",
      title: "Set the pen color",
      fun: curveSymbolPenColor,
    });
    this.addProperty({
      name: "Width",
      id: "curveSymbolPenWidth",
      parentId: "curveSymPen",
      type: "select",
      selectorOptions: [1, 2, 3, 4, 5],
      title: "Set the pen width",
      fun: curveSymbolPenWidth,
    });
    this.addProperty({
      name: "Fill Brush",
      id: "curveSymbolBrushColor",
      parentId: "curveSymbol",
      type: "color",
      title:
        "Assign a brush. The brush is used to draw the interior of the symbol.",
      fun: curveSymbolBrushColor,
    });
    this.addProperty({
      name: "Style",
      id: "curveSymbolStyle",
      parentId: "curveSymbol",
      type: "select",
      selectorOptions: [
        "None",
        "Rectangle",
        "Cross",
        "Diamond",
        "Ellipse",
        "Diagonal cross",
      ],
      title: "Specify the symbol style",
      fun: curveSymbolStyle,
    });
    this.addProperty({
      name: "Size",
      id: "curveSymbolSize",
      parentId: "curveSymbol",
      type: "select",
      selectorOptions: ["5x5", "6x6", "8x8", "10x10", "12x12", "15x15"],
      title: "Specify the symbol's size.",
      fun: curveSymbolSize,
    });
    this.addProperty({
      name: "Fill",
      title:
        "If the curve style is not equal to Sticks, the area between the curve and the baseline can be filled.",
      id: "curveFill",
    });
    this.addProperty({
      name: "Brush",
      id: "curveFillBrushColor",
      parentId: "curveFill",
      type: "color",
      title: "Assign the brush used to fill the curve.",
      fun: curveFillBrushColor,
    });
    var fillCurveCheckBox = this.addProperty({
      name: "Fill Curve",
      id: "fillCurve",
      parentId: "curveFill",
      type: "checkbox",
      title: "If checked, curve filling is enabled.",
      fun: fillCurve,
    });
    this.addProperty({
      name: "Baseline",
      id: "baseline",
      type: "number",
      value: 0.0,
      step: 0.5,
      title:
        "Set the value of the baseline. The baseline is required for filling the curve with a brush or the Sticks curve style.",
      fun: baseline,
    });

    this.addProperty({
      name: "Pen Width",
      id: "penWidth",
      type: "select",
      selectorOptions: [1, 2, 3, 4, 5],
      title: "Assign a pen width.",
      fun: curvePenWidth2,
    });

    this.addProperty({
      name: "Colormap",
      id: "colormap",
      type: "select",
      selectorOptions: ["RGB-map", "Indexed-map"],
      title:
        "Change the color map. Color Maps are used for mapping the intensity values to colors",
      fun: colormap,
    });

    this.addProperty({
      name: "Interpolation",
      id: "interpolation",
      type: "select",
      selectorOptions: ["Bi-Linear", "Bi-Cubic"],
      title: "Select the interpolation type.",
      fun: interpolation,
    });

    var spectrogramElement = this.addProperty({
      name: "Spectrogram",
      title: "Configure how the spectrogram is drawn.",
      id: "spectrogram",
    });
    this.addProperty({
      name: "show",
      id: "showSpectrogram",
      parentId: "spectrogram",
      type: "checkbox",
      checked: true,
      title: "If checked, the spectrogram is drawn.",
      fun: showSpectrogram,
    });
    this.addProperty({
      name: "alpha",
      id: "alpha",
      parentId: "spectrogram",
      type: "number",
      min: 0.0,
      max: 255,
      value: 255,
      step: 1,
      title: "Set an alpha value for the raster data.",
      fun: alpha,
    });

    var contoursElement = this.addProperty({
      name: "Contours",
      title: "Configure contours.",
      id: "contours",
    });
    this.addProperty({
      name: "show",
      id: "showContours",
      parentId: "contours",
      type: "checkbox",
      title: "If checked, contours are drawn.",
      fun: showContours,
    });
    this.addProperty({
      name: "Number of planes",
      id: "numberOfPlanes",
      parentId: "contours",
      type: "number",
      min: 0.0,
      max: 20,
      value: 10,
      step: 1,
      title: "Set the number of contour planes.",
      fun: numberOfPlanes,
    });

    this.addProperty({
      name: "Color interval",
      title: "Set the color range.",
      id: "colorInterval",
    });
    this.addProperty({
      name: "color1",
      id: "color1",
      parentId: "colorInterval",
      type: "color",
      title: "Color used for the minimum value of the value interval.",
      fun: color1,
    });
    this.addProperty({
      name: "color2",
      id: "color2",
      parentId: "colorInterval",
      type: "color",
      title: "Color used for the maximum value of the value interval.",
      fun: color2,
    });

    this.addProperty({
      name: "Color range",
      title: "Set the value interval, that corresponds to the color map.",
      id: "colorRange",
    });
    this.addProperty({
      name: "minimum Z",
      id: "minimumZ",
      parentId: "colorRange",
      type: "number",
      title: "Lower limit of the interval.",
      fun: minimumZ,
    });
    this.addProperty({
      name: "maximum Z",
      id: "maximumZ",
      parentId: "colorRange",
      type: "number",
      title: "Upper limit of the interval.",
      fun: maximumZ,
    });

    this.init(); //call this method after adding all properties

    //var curveSelectProp = this.getElementValueDataByPropertyName("Current Curve")
    //var curveSelectProp = this.getElementValueDataAttribute("currentCurve");
    //console.log(axisSpanElement)
    this.setFontSize("12px");

    /* function initCurveSelect() {
            let opts = curveSelectProp.children();
            for (let i = 0; i < opts.length; ++i) {
                curveSelectProp[0].removeChild(opts[i]);
            }
            let curves = plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
            for (let i = 0; i < curves.length; ++i) {
				let opt = $('<option>' + curves[i].title() + '</option>');
				opt.attr("value", curves[i].title());
				curveSelectProp.append(opt);                
            }
            Static.trigger("currentCurveChangedViaPropertiesPane", curves[0]);
            return null;
        } */

    function initCurveSelect() {
      let opts = curveSelectProp.children();
      for (let i = 0; i < opts.length; ++i) {
        curveSelectProp[0].removeChild(opts[i]);
      }
      var itemList = plot.itemList();
      var curves = [];
      for (var i = 0; i < itemList.length; ++i) {
        if (
          itemList[i].rtti === PlotItem.RttiValues.Rtti_PlotCurve ||
          itemList[i].rtti === PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
          itemList[i].rtti === PlotItem.RttiValues.Rtti_PlotSpectrogram
        ) {
          curves.push(itemList[i]);
        }
      }
      for (let i = 0; i < curves.length; ++i) {
        let opt = $("<option>" + curves[i].title() + "</option>");
        opt.attr("value", curves[i].title());
        curveSelectProp.append(opt);
      }
      Static.trigger("currentCurveChangedViaPropertiesPane", curves[0]);
      return null;
    }

    function currentCurve(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      initDlg(curve);
      Static.trigger("currentCurveChangedViaPropertiesPane", curve);
    }

    /* function disableCurveDependentCntrls(on){
			axisHorizontalSelectElement.attr("disabled", on);
			axisVerticalSelectElement.attr("disabled", on);
		} */

    Static.bind("showGridItem", function (e, m_anchorPosition, gridIndex, on) {
      if (m_anchorPosition == "left" && gridIndex == 0 && on) {
        let curve = plot.findPlotCurve(curveSelectProp.val());
        initDlg(curve);
      }
    });

    Static.bind("itemAttached", function (e, plotItem, on) {
      if (
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram
      ) {
        if (on) {
          //attached
          //plot.leftSidebar.showGridItem(0, true);
        } else {
          //detached
          if (
            !plot.hasVisiblePlotCurve() &&
            !plot.hasVisiblePlotSpectroCurve() &&
            !plot.hasVisiblePlotSpectrogram()
          ) {
            /* $("#curvePropertyDiv2").hide();
						$("#curvePropertyDiv").hide();
						$("#curvePropertyHead").hide();
						$("#plotPropertyDiv").css("height", "92%"); */
            //self.showPropertiesPane(false);
            plot.leftSidebar.showGridItem(0, false);
          }
          if (!plot.hasPlotCurve()) {
            //disableCurveDependentCntrls(true)
          }
        }
        initCurveSelect();

        initDlg(plot.findPlotCurve(curveSelectProp.val()));
        //}
      }
    });

    plot.leftSidebar.showGridItem(0, false);

    var selectIndex = -1;
    function renameCurve() {
      selectIndex = curveSelectProp[0].selectedIndex;
      Utility.curveRenameDlg(curveSelectProp.val(), plot);
    }

    Static.bind("curveRenamed", function () {
      if (selectIndex == -1) selectIndex = curveSelectProp[0].selectedIndex;
      initCurveSelect();
      curveSelectProp[0].selectedIndex = selectIndex;
      var curve = plot.findPlotCurve(curveSelectProp.val());
      //initDlg(curve);
      selectIndex = -1;
    });

    function removeCurve() {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      plot.trashDlg.trash(curve);
      // curve.detach();
      // curve.delete();
    }

    function fitCurve() {
      plot.curveFitDlg.curveFitCb(plot.findPlotCurve(curveSelectProp.val()));
    }

    function zone() {
      plot.zoneDlg.zoneCb(plot.findPlotCurve(curveSelectProp.val()));
    }

    function legendAttributes() {
      plot.curveAttributeDlg.curveAttributeCb(
        plot.findPlotCurve(curveSelectProp.val())
      );
    }

    function orientation(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      if (selectIndex == 1) curve.setOrientation(Static.Horizontal);
      else curve.setOrientation(Static.Vertical);
    }

    var styleMap = [
      Curve.CurveStyle.Lines,
      Curve.CurveStyle.Sticks,
      Curve.CurveStyle.Steps,
      Curve.CurveStyle.Dots,
      Curve.CurveStyle.NoCurve,
    ];
    function curveStyle(selectIndex) {
      //curveStyleOptions
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.setStyle(styleMap[selectIndex]);
    }
    Static.bind("curveStyleChanged", function (e, curve) {
      initDlg(curve);
    });

    function setContoursTd(curve) {
      var visible = "Visible";
      if (!curve.testDisplayMode(PlotSpectrogram.DisplayMode.ContourMode))
        visible = "Hidden";
      contoursElement.html(
        visible + ", planes:" + curve.contourLevels().length
      );
    }

    function setSpectrogramTd(curve) {
      var visible = "Visible";
      if (!curve.testDisplayMode(PlotSpectrogram.DisplayMode.ImageMode))
        visible = "Hidden";
      spectrogramElement.html(visible + ", alpha:" + curve.alpha());
    }

    //var axisSpanElement = this.getElementValueDataAttribute("curveAxes");
    function setCurveAxesTd(curve) {
      var vertical = "Left";
      if (curve.yAxis() == Axis.AxisId.yRight) vertical = "Right";
      var horizontal = "Bottom";
      if (curve.xAxis() == Axis.AxisId.xTop) horizontal = "Top";
      axisSpanElement.html(horizontal + ", " + vertical);
    }
    Static.bind("axisChanged", function (e, axis, curve) {
      initDlg(curve);
    });
    //var axisHorizontalSelectElement = this.getElementValueDataAttribute("horizontal");
    function horizontal(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      var axis = selectIndex == 0 ? Axis.AxisId.xBottom : Axis.AxisId.xTop;
      curve.setXAxis(axis);
      setCurveAxesTd(curve);
      Static.trigger("curveAxisChangedViaPropertiesPane", [axis, curve]);
    }
    //var axisVerticalSelectElement = this.getElementValueDataAttribute("vertical");
    function vertical(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      var axis = selectIndex == 0 ? Axis.AxisId.yLeft : Axis.AxisId.yRight;
      curve.setYAxis(axis);
      setCurveAxesTd(curve);
      Static.trigger("curveAxisChangedViaPropertiesPane", [axis, curve]);
    }

    function swapAxesFn(checked) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      if (checked) curve.swapAxes();
      else curve.unSwapAxes();
    }

    this.penIcon = function (curve /* index, size */) {
      if (!curve) return null;
      var height = 16;
      var width = 50;
      var graphic = new Graphic(null, width, height);
      var painter = new PaintUtil.Painter(graphic);
      if (curve.pen().color != Static.NoPen) {
        var pn = curve.pen();
        painter.setPen(pn);
        var y = height * 0.5; //0.5 * parseFloat($("#curvePenIcon_td").css('height'));
        painter.drawLine(0.0, y, width, y);
      }
      painter = null;
      return graphic;
    };
    this.spanElem = null;
    var curvePenSpanElementParent =
      this.getElementValueDataAttribute("curvePen").parent();
    this.setPenIcon = function () {
      //curvePenIcon_td
      var plotItem = plot.findPlotCurve(curveSelectProp.val());
      var tdElem = curvePenSpanElementParent;
      var icon = this.penIcon(plotItem);
      if (this.spanElem) this.spanElem.remove();
      this.spanElem = $('<span id="spanElem" />');
      if (icon) icon.setParent(this.spanElem);
      this.spanElem.appendTo(tdElem);
    };
    var curvePenColorElement =
      this.getElementValueDataAttribute("curvePenColor");
    function curvePenColor(color) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      let pen = curve.pen();
      pen.color = color;
      curve.setPen(pen);
      initDlg(curve);
    }
    Static.bind("penAttributeChanged", function (e, curve) {
      initDlg(curve);
    });
    var curvePenStyles = ["solid", "dot", "dash", "dashDot", "dashDotDot"];
    var curvePenStyleElement =
      this.getElementValueDataAttribute("curvePenStyle");
    function curvePenStyle(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      let pen = curve.pen();
      pen.style = curvePenStyles[selectIndex];
      curve.setPen(pen);
      initDlg(curve);
    }
    var curvePenWidthElement =
      this.getElementValueDataAttribute("curvePenWidth");
    function curvePenWidth(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      let pen = curve.pen();
      pen.width = selectIndex + 1;
      curve.setPen(pen);
      initDlg(curve);
    }

    function minimumZ(val) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.colorRange().setMinValue(val);
      plot.autoRefresh();
    }

    function maximumZ(val) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.colorRange().setMaxValue(val);
      plot.autoRefresh();
    }

    function color1(color) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.setColorInterval(color, Utility.RGB2HTML(curve.color2()));
    }

    function color2(color) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.setColorInterval(Utility.RGB2HTML(curve.color1()), color);
    }

    function numberOfPlanes(val) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      //curve.setContourLevels( curve.calculateContourLevels(val) );
      curve.setNumberOfContourPlanes(parseInt(val));
      setContoursTd(curve);
    }

    function showContours(on) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.showContour(on);
      setContoursTd(curve);
    }

    function showSpectrogram(on) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.showSpectrogram(on);
      setSpectrogramTd(curve);
    }

    function alpha(val) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.setAlpha(parseInt(val));
      setSpectrogramTd(curve);
    }

    function colormap(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      if (selectIndex == 0) {
        curve.setSpectrogramColorMap(Spectrogram.ColorMap.RGBMap);
      } else {
        curve.setSpectrogramColorMap(Spectrogram.ColorMap.IndexMap);
      }
    }

    function interpolation(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      var data = curve.data();
      if (!data.hasOwnProperty("_interpolationType")) return;
      if (selectIndex == 0) {
        data.setInterpolaionType(RasterFileData.InterpolationType.linear);
      } else {
        data.setInterpolaionType(RasterFileData.InterpolationType.cubic);
      }
      curve.invalidateCache();
      curve.itemChanged();
    }

    function curvePenWidth2(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      /* let pen = curve.pen();
            pen.width = selectIndex + 1; */
      curve.setPenWidth(selectIndex + 1);
      //initDlg(curve);
    }

    var curveSymbolSizeElement =
      this.getElementValueDataAttribute("curveSymbolSize");
    this.symbolIcon = function (curve /* index, size */) {
      if (!curve) return null;
      var val = 10; //parseFloat($("#sizeSymbol").val());
      var size = new Misc.Size(val, val);
      var height = val;
      var width = val;
      var graphic = new Graphic(null, width, height);
      var painter = new PaintUtil.Painter(graphic);
      if (curve.symbol()) {
        var sh = height / 2; // + 1;
        if (curve.symbol().style() == Symbol2.Style.Ellipse) {
          //sh -= 1;
        }
        painter.setPen(curve.symbol().pen());
        curve
          .symbol()
          .drawGraphicSymbol(painter, new Misc.Point(width / 2, sh), size);
      }
      painter = null;
      return graphic;
    };
    this.spanElem2 = null;
    var curveSymbolSpanElementParent =
      this.getElementValueDataAttribute("curveSymbol").parent();
    this.setSymbolIcon = function () {
      //curvePenIcon_td
      var plotItem = plot.findPlotCurve(curveSelectProp.val());
      var tdElem = curveSymbolSpanElementParent;
      var icon = this.symbolIcon(plotItem);
      if (this.spanElem2) this.spanElem2.remove();
      this.spanElem2 = $('<span id="spanElem2" />');
      if (icon) icon.setParent(this.spanElem2);
      this.spanElem2.appendTo(tdElem);
    };
    Static.bind("symbolAdded symbolAttributeChanged", function (e, curve) {
      initDlg(curve);
    });
    var curveSymbolPenColorElement = this.getElementValueDataAttribute(
      "curveSymbolPenColor"
    );
    function curveSymbolPenColor(color) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      let sym = curve.symbol();
      if (!sym) {
        return;
      }
      let pen = sym.pen();
      pen.color = color;
      sym.setPen(pen);
      initDlg(curve);
      curve.plot().autoRefresh();
      curve.plot().updateLegend(curve);
    }
    var curveSymbolPenWidthElement = this.getElementValueDataAttribute(
      "curveSymbolPenWidth"
    );
    function curveSymbolPenWidth(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      Utility.setSymbolPenWidth(curve, selectIndex + 1);
      self.setSymbolIcon();
    }
    var curveSymbolBrushColorElement = this.getElementValueDataAttribute(
      "curveSymbolBrushColor"
    );
    function curveSymbolBrushColor(color) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      let sym = curve.symbol();
      if (!sym) {
        return;
      }
      let brush = sym.brush();
      brush.color = color;
      sym.setBrush(brush);
      curve.plot().autoRefresh();
      curve.plot().updateLegend(curve);
      self.setSymbolIcon();
    }
    function addSymbol(curve, style) {
      let _style = Symbol2.Style.NoSymbol; //style == 'None'
      if (style == "MRect") {
        _style = Symbol2.Style.MRect;
      }
      if (style == "Cross") {
        _style = Symbol2.Style.Cross;
      }
      if (style == "Diamond") {
        _style = Symbol2.Style.Diamond;
      }
      if (style == "Ellipse") {
        _style = Symbol2.Style.Ellipse;
      }
      if (style == "XCross") {
        _style = Symbol2.Style.XCross;
      }
      Utility.addSymbol(curve, _style);
    }
    var curveSymbolSizeElement =
      this.getElementValueDataAttribute("curveSymbolSize");
    var curveSymbolStyleElement =
      this.getElementValueDataAttribute("curveSymbolStyle");
    var symbolStyles = [
      "None",
      "MRect",
      "Cross",
      "Diamond",
      "Ellipse",
      "XCross",
    ];
    var symbolStylesInt = [
      Symbol2.Style.MRect,
      Symbol2.Style.Cross,
      Symbol2.Style.Diamond,
      Symbol2.Style.Ellipse,
      Symbol2.Style.XCross,
    ];
    function curveSymbolStyle(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());

      if (symbolStyles[selectIndex] == "None") {
        curveSymbolPenWidthElement.val(1);
        curveSymbolPenColorElement.val(Utility.colorNameToHex("black"));
        curveSymbolBrushColorElement.val(Utility.colorNameToHex("transparent"));
        curveSymbolSizeElement.val(10);
      } else {
      }
      addSymbol(curve, symbolStyles[selectIndex]);
    }
    //var curveSymbolSizeElement = this.getElementValueDataAttribute("curveSymbolSize");
    var symbolSizes = [5, 6, 8, 10, 12, 15];
    //var symbolStylesInt = [MRect, Cross, Diamond, Symbol2.Style.Ellipse, XCross];
    function curveSymbolSize(selectIndex) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      Utility.setSymbolSize(curve, symbolSizes[selectIndex]);
      self.setSymbolIcon();
    }

    var curveFillElement = this.getElementValueDataAttribute("curveFill");
    var curveFillElementParent = curveFillElement.parent();
    this.brushIcon = function (curve, color) {
      if (!curve) return null;
      var val = 12; //parseFloat($("#sizeSymbol").val());
      var size = new Misc.Size(val, val);
      var height = val;
      var width = val;
      var graphic = new Graphic(null, width, height);
      var painter = new PaintUtil.Painter(graphic);
      if (curve.brush().color == "noBrush") return null;
      painter.setBrush(curve.brush());
      //painter.setBrush( new Misc.Brush(curveFillElement.val()) );
      var rc = new Misc.Rect(new Misc.Point(), new Misc.Size(val, val));
      rc.moveCenter(new Misc.Point(val / 2, val / 2));
      painter.drawRect(rc.left(), rc.top(), rc.width(), rc.height());
      painter = null;
      return graphic;
    };
    this.spanElem3 = null;
    var curveFillBrushColorElement = this.getElementValueDataAttribute(
      "curveFillBrushColor"
    );
    var curveFillBrushColorElementParent = curveFillBrushColorElement.parent();
    this.setBrushIcon = function () {
      //curvePenIcon_td
      var plotItem = plot.findPlotCurve(curveSelectProp.val());
      var tdElem = curveFillElementParent;
      var icon = self.brushIcon(plotItem);
      if (this.spanElem3) this.spanElem3.remove();
      this.spanElem3 = $('<span id="spanElem" />');
      if (icon) icon.setParent(this.spanElem3);
      this.spanElem3.appendTo(tdElem);
    };
    function curveFillBrushColor(color) {
      var curve = plot.findPlotCurve(curveSelectProp.val());
      if (curve.fill) {
        let brush = curve.brush();
        brush.color = color;
        curve.setBrush(brush);
      }
      self.setBrushIcon();
    }
    var fillCurveElement = this.getElementValueDataAttribute("fillCurve");
    function fillCurve(checked) {
      var curve = plot.findPlotCurve(curveSelectProp.val());
      curve.fill = checked;
      if (checked) {
        let brush = curve.brush();
        brush.color = curveFillBrushColorElement.val();
        curve.setBrush(brush);
      } else {
        Utility.removeCurveBrush(curve);
      }
      self.setBrushIcon();
      //console.log(curve.brush());
    }
    Static.bind("curveBrushChanged", function (e, curve) {
      initDlg(curve);
      fillCurveCheckBox[0].checked = true;
    });
    var baselineElement = this.getElementValueDataAttribute("baseline");
    function baseline(val) {
      let curve = plot.findPlotCurve(curveSelectProp.val());
      curve.setBaseline(val);
    }

    var showContoursElement = self.getElementValueDataAttribute("showContours");
    var numberOfPlanesElement =
      self.getElementValueDataAttribute("numberOfPlanes");
    var showSpectrogramElement =
      self.getElementValueDataAttribute("showSpectrogram");
    var alphaElement = self.getElementValueDataAttribute("alpha");

    var penWidthElement = self.getElementValueDataAttribute("penWidth");
    var color1Element = self.getElementValueDataAttribute("color1");
    var color2Element = self.getElementValueDataAttribute("color2");
    var minimumZElement = self.getElementValueDataAttribute("minimumZ");
    var maximumZElement = self.getElementValueDataAttribute("maximumZ");

    function aspectRatioOneToOneFn() {
      axisHorizontalSelectElement.attr("disabled", Static.aspectRatioOneToOne);
      axisVerticalSelectElement.attr("disabled", Static.aspectRatioOneToOne);
    }

    Static.bind("aspectRatioChanged", function () {
      aspectRatioOneToOneFn();
    });

    function initDlg(curve) {
      if (!curve || curve.title() !== curveSelectProp.val()) {
        return;
      }

      aspectRatioOneToOneFn();
      if (curve.axesSwapped) {
        swapAxes[0].checked = true;
      } else {
        swapAxes[0].checked = false;
      }

      if (curve.rtti === PlotItem.RttiValues.Rtti_PlotSpectroCurve) {
        self.show("penWidth");
        self.show("colorInterval");
        self.show("colorRange");
        penWidthElement[0].selectedIndex = curve.penWidth() - 1;
        color1Element.val(Utility.RGB2HTML(curve.color1()));
        color2Element.val(Utility.RGB2HTML(curve.color2()));
        var intv = curve.colorRange();
        minimumZElement.val(intv.minValue());
        maximumZElement.val(intv.maxValue());
      } else {
        self.hide("penWidth");
        self.hide("colorInterval");
        self.hide("colorRange");
      }

      if (curve.rtti === PlotItem.RttiValues.Rtti_PlotSpectrogram) {
        if (curve.isVisible()) {
          self.show("spectrogram");
          self.show("contours");
        } else {
          self.hide("spectrogram");
          self.hide("contours");
        }

        self.show("colormap");

        if (curve.data().hasOwnProperty("_interpolationType"))
          //plotting from file
          self.show("interpolation");
        else self.hide("interpolation");

        var on = curve.testDisplayMode(PlotSpectrogram.DisplayMode.ImageMode);
        showSpectrogramElement[0].checked = curve.testDisplayMode(
          PlotSpectrogram.DisplayMode.ImageMode
        );
        alphaElement.val(curve.alpha());
        showContoursElement[0].checked = curve.testDisplayMode(
          PlotSpectrogram.DisplayMode.ContourMode
        );
        numberOfPlanesElement.val(curve.contourLevels().length);
        setSpectrogramTd(curve);
        setContoursTd(curve);
      } else {
        self.hide("spectrogram");
        self.hide("contours");
        self.hide("interpolation");
        self.hide("colormap");
      }

      if (
        curve.rtti === PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
        curve.rtti === PlotItem.RttiValues.Rtti_PlotSpectrogram
      ) {
        self.hide("fitCurve");
        self.hide("curveSymbol");
        self.hide("legendAttributes");
        self.hide("orientation");
        self.hide("curveStyle");
        self.hide("curveFill");
        self.hide("baseline");
        self.hide("curvePen");
      } else {
        self.show("fitCurve");
        self.show("curveSymbol");
        self.show("legendAttributes");
        self.show("orientation");
        self.show("curveStyle");
        self.show("curveFill");
        self.show("baseline");
        self.show("curvePen");
      }
      /* let penStyles = ["solid", "dot", "dash", "dashDot", "dashDotDot"];
            $("#penColor").val(Utility.colorNameToHex(curve.pen().color));
            $("#penWidth")[0].selectedIndex = curve.pen().width - 1;
            $("#penStyle")[0].selectedIndex = penStyles.indexOf(curve.pen().style); */
      if (curve.rtti === PlotItem.RttiValues.Rtti_PlotCurve) {
        curvePenColorElement.val(Utility.colorNameToHex(curve.pen().color));
        curvePenStyleElement[0].selectedIndex = curvePenStyles.indexOf(
          curve.pen().style
        );
        curvePenWidthElement[0].selectedIndex = curve.pen().width - 1;
        if (curve.symbol()) {
          curveSymbolPenColorElement.val(
            Utility.colorNameToHex(curve.symbol().pen().color)
          );
          curveSymbolPenWidthElement[0].selectedIndex =
            curve.symbol().pen().width - 1;
          curveSymbolBrushColorElement.val(
            Utility.colorNameToHex(curve.symbol().brush().color)
          );
          var index = -1;
          var style = curve.symbol().style();
          if (style == "None") index = 0;
          else index = symbolStylesInt.indexOf(curve.symbol().style()) + 1;
          curveSymbolStyleElement[0].selectedIndex = index;
          //console.log(curve.symbol().size())
          curveSymbolSizeElement[0].selectedIndex = symbolSizes.indexOf(
            curve.symbol().size().height
          );
        } else {
          curveSymbolPenColorElement.val(Utility.colorNameToHex("black"));
          curveSymbolPenWidthElement[0].selectedIndex = 0;
          curveSymbolBrushColorElement.val(Utility.colorNameToHex("black"));
          curveSymbolStyleElement[0].selectedIndex = 0;
          //console.log(curve.symbol().size())
          curveSymbolSizeElement[0].selectedIndex = 3;
        }
      }

      if (curve.rtti === PlotItem.RttiValues.Rtti_PlotCurve) {
        curveSTyleSelector[0].selectedIndex =
          _.keys(styleMap)[_.values(styleMap).indexOf(curve.style())];
      }

      axisHorizontalSelectElement[0].selectedIndex =
        curve.xAxis() == Axis.AxisId.xBottom ? 0 : 1;
      axisVerticalSelectElement[0].selectedIndex =
        curve.yAxis() == Axis.AxisId.yLeft ? 0 : 1;

      setCurveAxesTd(curve);

      if (curve.rtti === PlotItem.RttiValues.Rtti_PlotCurve) {
        self.setPenIcon();
        self.setSymbolIcon();

        fillCurveElement[0].checked = curve.fill;
        curveFillBrushColorElement.val(curve.brush().color);
        self.setBrushIcon();

        baselineElement.val(curve.baseline());

        var orientationElement =
          self.getElementValueDataAttribute("orientation");
        if (curve.orientation() == Static.Vertical)
          orientationElement[0].selectedIndex = 0;
        else orientationElement[0].selectedIndex = 1;
      }
    }

    ////////////////////
    //console.log(spectrogramNode)
    Static.bind("visibilityChange", function (e, curve, on) {
      if (
        curve.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram &&
        curve.title() == curveSelectProp.val()
      ) {
        if (curve.rtti === PlotItem.RttiValues.Rtti_PlotSpectrogram) {
          /* if (on) {
            self.show("spectrogram");
            self.show("contours");
            //curve.setDisplayMode(PlotSpectrogram.DisplayMode.ImageMode, true);
          } else {
            self.hide("spectrogram");
            self.hide("contours");
          } */
          //curve.setDisplayMode(PlotSpectrogram.DisplayMode.ImageMode, on);
        }
      }
    });

    ///////////////////////
  }
}
;
define("curvePropertiesPane", ["propertiesPane"], function(){});

"include ['propertiesPane']";


class PlotPropertiesPane extends PropertiesPane {
  constructor(_parent, plot) {
    super(_parent);
    var self = this;
    self.setHeader(
      plot.leftSidebar.gridItem(1).headerElement,
      "Easy Grapher",
      true
    );
    const headerElement = plot.leftSidebar.gridItem(1).headerElement;
    headerElement.css({ height: 40, fontSize: 18 });
    headerElement.parent().css("font-family", "Times New Roman, Times, serif");
    headerElement.parent().css({ fontSize: 16 });
    this.headerTableHead.hide();

    this.shadeWatchArea = true;
    /*********************************************************************************************
     *Plot Specific Properties
     **********************************************************************************************/
    /*********************************************************************************************
     *Function Editor
     ********************************************************************************************/
    let tableSamples = [];
    let newTableCurve = null;
    function makePointTableRow() {
      let row = $(
        '<tr>\
        <td style="border: 1px solid"><math-field style="display: flex; justify-content: center; margin: 1px; font-size: 16px;" value=""></math-field></td>\
        <td style="border: 1px solid"><math-field style="display: flex; justify-content: center; margin: 1px; font-size: 16px;" value=""></math-field></td>\
      </tr>'
      );

      const row_inputs = $(row).find("math-field");
      Utility.extendGetValue(row_inputs[0]);
      Utility.extendGetValue(row_inputs[1]);

      row.on("change", function () {
        //const row = $(this).parent().parent();
        const inputs = $(this).find("math-field");

        tableSamples = getPointsFromTable();
        newTableCurve.setSamples(tableSamples);
        plot.autoRefresh();
        //console.log(tableSamples);
        if (validInput(inputs[0].value) && validInput(inputs[1].value)) {
          const rows = $("#pointTableTable")[0].rows;
          const _inputs = $(rows[rows.length - 1]).find("math-field");
          if (
            _inputs[0].value.replace(/\s/g, "").length &&
            _inputs[1].value.replace(/\s/g, "").length
          ) {
            $("#pointTableTable").append(makePointTableRow());
            const lastRow = $("#pointTableTable").find("TR").last();
            const inp = lastRow.find("math-field").first()[0];
            //console.log(inp);
            inp.focus();
          }
        }
      });
      row.on("input", function () {
        //console.log($("#pointTableTable")[0].rows);
        const rows = $("#pointTableTable")[0].rows;
        const inputs = $(this).find("math-field");
        if (
          //rows.length > 2 &&
          $(this).index() !== rows.length - 1 &&
          inputs[0].value.length == 0 &&
          inputs[1].value.length == 0
        ) {
          //console.log(478, $(this).index());
          //tableSamples = getPointsFromTable();
          //console.log(tableSamples);
          $(this).off("change");
          $(this).off("input");
          $("#pointTableTable")[0].deleteRow($(this).index());
        }
      });

      return row;
    }

    /* table-layout: fixed;
  width: 100%;   */

    const pointTable = $(
      '<div style="border: 4px ridge white;">\
        <div style="background-color:lightgray; height:25px;"><b>Table (</b><span id="tableCurveName"></span>)<button id="pointTableClose" class="closeButton" style="float:right;" title="Close">X</button></div>\
        <table id="pointTableTable" style="table-layout: fixed;">\
          <tr style="font-size: 18px;">\
              <th style="text-align: center;">x<sub>1</sub></th>\
              <th style="text-align: center;">y<sub>1</sub></th>\
          </tr>\
        </table>\
      </div>'
    );

    const t = this.table();
    const e = $(
      '<tr>\
      <td colspan="2" style="margin:0px; padding:0px;">\
        <div style="font-size: 14px;">\
        <math-field id="fnDlg_function" data-toggle="tooltip" data-trigger="hover" data-placement="bottom" data-original-title="Enter a function" virtual-keyboard-mode="manual" title="" style="padding-left: 2px; padding-right: 2px; font-size: 20px; border-style: solid; border-width: 1px">x^2</math-field>\
        &nbspTitle: <input id="fnDlg_title" style="margin:1px; width:30%; height:26px;" type="text" value="curve_1"/><button id="executeButton" style="float: right" title="Add the defined curve to the plot"><img src="images/execute.png" width="20" height="20"></button><button id="settingsButton" style="float: right" title="Curve definition settings"><img src="images/wrench.png" width="20" height="20"></button><button id="tableButton" style="float: right" title="Point table"><img src="images/table.png" width="20" height="20"></button>\
        </div>\
      </td>\
    </tr>'
    );
    t.prepend(e);

    t.parent().append(pointTable);

    $("#pointTableTable").append(makePointTableRow());

    // $(".pointTableRow").on("input", function () {
    //   //console.log(parseFloat($(this).val()));
    // });

    function validInput(str) {
      let result = false;
      if (str.length) {
        result = true;
      }
      return result;
    }

    function getPointsFromTable() {
      let samples = [];
      const rows = $("#pointTableTable")[0].rows;
      let precisionX = plot.axisPrecision(newTableCurve.xAxis());
      let decimalPlacesX = plot.axisDecimalPlaces(newTableCurve.xAxis());
      let precisionY = plot.axisPrecision(newTableCurve.yAxis());
      let decimalPlacesY = plot.axisDecimalPlaces(newTableCurve.yAxis());
      for (let i = 1; i < rows.length; i++) {
        const inputs = $(rows[i]).find("math-field");
        let x = inputs[0].value.replace(/\s/g, "");
        let y = inputs[1].value.replace(/\s/g, "");
        if (x.length) {
          x = Utility.logBaseAdjust(
            //plot.defines.expandDefines(Utility.latexToAscii(inputs[0]))
            plot.defines.expandDefines(inputs[0].getValue("ascii-math"))
          );
          try {
            x = math.evaluate(x).toString();
          } catch (error) {
            alert(error.message);
            inputs[0].value = "";
            return;
          }
          inputs[0].value = Utility.toPrecision(
            Utility.adjustForDecimalPlaces(x, decimalPlacesX),
            precisionX
          );
        }
        if (y.length) {
          //Utility.logBaseAdjust(fnDlgFunctionVal)
          y = Utility.logBaseAdjust(
            //plot.defines.expandDefines(Utility.latexToAscii(inputs[1]))
            plot.defines.expandDefines(inputs[1].getValue("ascii-math"))
          );
          try {
            y = math.evaluate(y).toString();
          } catch (error) {
            alert(error.message);
            inputs[1].value = "";
            return;
          }
          inputs[1].value = Utility.toPrecision(
            Utility.adjustForDecimalPlaces(y, decimalPlacesY),
            precisionY
          );
        }

        // const
        // const y = parseFloat(inputs[1].value);
        if (x.length && y.length) {
          x = parseFloat(x);
          y = parseFloat(y);
          samples.push(new Misc.Point(x, y));
        }
      }

      samples.sort(function (a, b) {
        return a.x - b.x;
      });

      return samples;
    }

    function updatePointTable(curve) {
      if (!pointTable.is(":visible")) {
        return;
      }
      const samples = curve.data().samples();
      const rows = $("#pointTableTable")[0].rows;
      let precisionX = plot.axisPrecision(curve.xAxis());
      let decimalPlacesX = plot.axisDecimalPlaces(curve.xAxis());
      let precisionY = plot.axisPrecision(curve.yAxis());
      let decimalPlacesY = plot.axisDecimalPlaces(curve.yAxis());
      let indexInSamples = 0;
      for (let i = 1; i < rows.length; i++) {
        const inputs = $(rows[i]).find("math-field");
        if (inputs[0].value.length && inputs[1].value.length) {
          inputs[0].value = Utility.toPrecision(
            Utility.adjustForDecimalPlaces(
              samples[indexInSamples].x,
              decimalPlacesX
            ),
            precisionX
          );
          inputs[1].value = Utility.toPrecision(
            Utility.adjustForDecimalPlaces(
              samples[indexInSamples].y,
              decimalPlacesY
            ),
            precisionY
          );
          indexInSamples++;
        }
      }
      Static.trigger("pointsTableUpdated", curve);
    }

    pointTable.hide();
    headerElement.show();

    $("#settingsButton").click(function () {
      plot._functionDlg.functionDlg(Utility.generateCurveName(plot));
    });

    const mf = $("#fnDlg_function")[0];
    Utility.extendGetValue(mf);
    //mf.setOptions({ smartSuperscript: false });
    $(mf).tooltip();
    // mf.setOptions({
    //   inlineShortcuts: {
    //     "*": "*",
    //   },
    // });

    // mf.setOptions({
    //   inlineShortcuts: {
    //     ...mf.getOptions("inlineShortcuts"), // Preserve default shortcuts
    //     "*": "\\ast",
    //   },
    // });

    $("#executeButton").click(function () {
      const m_value = $("#fnDlg_function")[0].value;
      if ($("#fnDlg_function").val().length) {
        //console.log($("#fnDlg_function")[0].value);
        plot._functionDlg.doEnter(true);
      }
      //$("#fnDlg_function")[0].value = m_value;
      $("#fnDlg_function")[0].executeCommand("selectAll");
      $("#fnDlg_function").focus();
      //console.log($("#fnDlg_function")[0].value);
    });

    $("#fnDlg_function").on("input", function (e) {
      // $(mf).tooltip("hide");
      // $(mf).attr("data-original-title", `Enter a function`);
      // $(mf).removeClass("red-tooltip");
      Utility.displayErrorMessage(mf, null); //clear error message
    });

    $("#fnDlg_function").on("keyup", function (e) {
      mf.applyStyle({ backgroundColor: "none" }, { range: [0, -1] });
    });

    $("#fnDlg_function").on("keyup", function (e) {
      const w = parseFloat(t.parent().parent().css("width"));
      //console.log($("#fnDlg_function")[0].caretPoint);
      if ($("#fnDlg_function")[0].caretPoint) {
        const c = $("#fnDlg_function")[0].caretPoint.x;

        if (c > w) {
          t.parent().parent()[0].scrollLeft = c - w + 80;
        }
        if (e.key === "Enter" || e.keyCode === 13) {
          $("#executeButton").click();
          //$("#executeButton")[0].focus();
        }
      }
    });

    Static.bind("itemAttached", function (e, curve, on) {
      if (curve === newTableCurve && !on) {
        //console.log(456);
        t.show();
        pointTable.hide();
        headerElement.show();
        clearPointTable();
      }
      $("#fnDlg_title").val(Utility.generateCurveName(plot));
    });

    Static.bind("currentCurveChangedEnds", function (e, curve) {
      if (!curve) return;
      //console.log(curve.data().samples());
      //const samples = curve.samples();
      if (curve == newTableCurve) {
        updatePointTable(curve);
      }
    });

    $("#tableButton").click(function () {
      t.hide();
      //t.parent().append(pointTable);
      pointTable.show();
      headerElement.hide();

      newTableCurve = new MyCurve($("#fnDlg_title").val());
      $("#tableCurveName").html($("#fnDlg_title").val());
      let color = Utility.randomColor();
      newTableCurve.setPen(new Misc.Pen(color, 4));
      newTableCurve.setStyle(Curve.CurveStyle.Dots);
      /*let sym = new Symbol2(
        Symbol2.Style.MRect,
        new Misc.Brush(Utility.invert(color)),
        new Misc.Pen(color),
        new Misc.Size(8, 8)
      );
      newTableCurve.setSymbol(sym);
      let attribute = "";
      if (Static.showline && Static.showsymbol) {
        attribute = "lineAndSymbol";
      } else if (Static.showline) {
        attribute = "line";
      } else if (Static.showsymbol) {
        attribute = "symbol";
      }
      Utility.setLegendAttribute(
        newTableCurve,
        attribute,
        newTableCurve.getLegendIconSize()
      );*/ //attribute = "line" or "symbol" or "lineAndSymbol"

      //newTableCurve.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
      newTableCurve.attach(plot);
    });

    function clearPointTable() {
      let rows = $("#pointTableTable")[0].rows;
      while (rows.length > 2) {
        $("#pointTableTable")[0].deleteRow(1);
      }
      // rows = $("#pointTableTable")[0].rows;
      const inputs = $("#pointTableTable").find("math-field");
      inputs[0].value = "";
      inputs[1].value = "";
    }

    $("#pointTableClose").click(function () {
      $("#fnDlg_title").val(Utility.generateCurveName(plot));

      if (getPointsFromTable().length == 0) {
        newTableCurve.detach();
        newTableCurve = null;
      }
      t.show();
      pointTable.hide();
      headerElement.show();
      clearPointTable();
    });

    function xEnteredFunction() {
      console.log("x entered");
    }

    function yEnteredFunction() {
      console.log("y entered");
    }

    Static.bind("undoRedoOperation", function (e, curve) {
      if (newTableCurve === curve) {
        updatePointTable(curve);
      }
    });

    Static.bind("curveRenamed", function (e, curve, existingName, newName) {
      if (curve === newTableCurve) {
        $("#tableCurveName").html(newName);
      }
    });

    this.generateTable = function (curve) {
      //Show the points table
      t.hide();
      //t.parent().append(pointTable);
      pointTable.show();
      headerElement.hide();

      $("#tableCurveName").html(curve.title());

      newTableCurve = curve;

      //Ensure we have a clear table
      clearPointTable();
      let precisionX = plot.axisPrecision(curve.xAxis());
      let decimalPlacesX = plot.axisDecimalPlaces(curve.xAxis());
      let precisionY = plot.axisPrecision(curve.yAxis());
      let decimalPlacesY = plot.axisDecimalPlaces(curve.yAxis());
      const samples = curve.data().samples();
      for (let i = 0; i < samples.length; i++) {
        const element = samples[i];
        const lastRow = $("#pointTableTable").find("TR").last();
        lastRow.find("math-field").first()[0].value = Utility.toPrecision(
          Utility.adjustForDecimalPlaces(element.x, decimalPlacesX),
          precisionX
        );
        lastRow.find("math-field").last()[0].value = Utility.toPrecision(
          Utility.adjustForDecimalPlaces(element.y, decimalPlacesY),
          precisionY
        );
        $("#pointTableTable").append(makePointTableRow());
      }
    };

    /******************************************************************************************
     * Graph settings
     * *****************************************************************************************/

    this.addProperty({
      name: "Graph Settings",
      title: "Graph properties",
      id: "graphSettings",
    });

    /*********************************************************************************************
     *General Settings Properties
     ********************************************************************************************/
    this.addProperty({
      name: "General Settings",
      title: "General properties",
      id: "generalSettings",
      parentId: "graphSettings",
    });
    /*  var axesOrientation = this.addProperty({
      name: "Axes orientation",
      id: "axesOrientation",
      parentId: "generalSettings",
      type: "select",
      selectorOptions: ["Implicit", "Do not swap axes", "Swap axes"],
    });
    this.addProperty({
      name: "1:1 aspect ratio",
      id: "aspectRatio",
      parentId: "generalSettings",
      type: "checkbox",
      //checked: true,
      title: "Set plot asspectRatio",
      fun: aspectRatio,
    });
    this.addProperty({
      name: "+/- root",
      id: "plusMinusRoot",
      parentId: "generalSettings",
      type: "checkbox",
      //checked: true,
      title: "Add a curve for any negative root",
      fun: negativeRoot,
    }); */
    this.addProperty({
      name: "Plot Title",
      title: "Configure plot title",
      id: "plotTitle",
      parentId: "generalSettings",
    });
    var plotTitleTitleSelector = this.addProperty({
      name: "Title",
      id: "plotTitleTitle",
      parentId: "plotTitle",
      type: "text",
      title: "Set a plot title",
      fun: plotTitleTitle,
    });
    this.addProperty({
      name: "Font",
      id: "plotTitleFont",
      parentId: "plotTitle",
      type: "select",
      selectorOptions: PropertiesPane.fontsDisplay(),
      title: "Set plot title font type",
      fun: plotTitleFont,
    });
    this.addProperty({
      name: "Point",
      id: "plotTitlePoint",
      parentId: "plotTitle",
      type: "number",
      value: "20",
      min: "6",
      max: "32",
      title: "Set plot title font size",
      fun: plotTitlePoint,
    });
    this.addProperty({
      name: "Color",
      id: "plotTitleColor",
      parentId: "plotTitle",
      type: "color",
      title: "Set plot title font color",
      title: "Set plot title font color",
      fun: plotTitleColor,
    });
    this.addProperty({
      name: "Bold",
      id: "plotTitleBold",
      parentId: "plotTitle",
      type: "checkbox",
      checked: true,
      title: "Set plot title font weight",
      fun: plotTitleBold,
    });
    this.addProperty({
      name: "Plot Footer",
      title: "Configure plot footer",
      id: "plotFooter",
      parentId: "generalSettings",
    });
    this.addProperty({
      name: "Footer",
      id: "plotFooterFooter",
      parentId: "plotFooter",
      type: "text",
      value: "Footer",
      title: "Set a plot footer",
      fun: plotFooterFooter,
    });
    this.addProperty({
      name: "Font",
      id: "plotFooterFont",
      parentId: "plotFooter",
      type: "select",
      selectorOptions: PropertiesPane.fontsDisplay(),
      title: "Set plot footer font type",
      fun: plotFooterFont,
    });
    this.addProperty({
      name: "Point",
      id: "plotFooterPoint",
      parentId: "plotFooter",
      type: "number",
      value: "20",
      min: "6",
      max: "32",
      title: "Set plot footer font size",
      fun: plotFooterPoint,
    });
    this.addProperty({
      name: "Color",
      id: "plotFooterColor",
      parentId: "plotFooter",
      type: "color",
      title: "Set plot footer font color",
      fun: plotFooterColor,
    });
    this.addProperty({
      name: "Bold",
      id: "plotFooterBold",
      parentId: "plotFooter",
      type: "checkbox",
      checked: true,
      title: "Set plot footer font weight",
      fun: plotFooterBold,
    });
    this.addProperty({
      name: "Background",
      id: "plotBackground",
      parentId: "generalSettings",
      type: "color",
      value: "#ffffc8",
      title: "Set plot background color",
      fun: plotBackground,
    });
    this.addProperty({
      name: "Legend",
      title: "Configure legend",
      id: "plotLegend",
      parentId: "generalSettings",
    });
    this.addProperty({
      name: "Background",
      id: "plotLegendBackground",
      parentId: "plotLegend",
      type: "color",
      value: "#ffffff",
      title: "Set legend background color",
      fun: plotLegendBackground,
    });
    this.addProperty({
      name: "Show Line",
      id: "plotLegendShowLine",
      parentId: "plotLegend",
      type: "checkbox",
      title: "If checked, curve is represented by a line on the legend",
      fun: plotLegendShowLine,
    });
    this.addProperty({
      name: "Show Symbol",
      id: "plotLegendShowSymbol",
      parentId: "plotLegend",
      type: "checkbox",
      title: "If checked, attached symbols are represented on the legend",
      fun: plotLegendShowSymbol,
    });

    //////
    this.addProperty({
      name: "Font",
      id: "plotLegendFont",
      parentId: "plotLegend",
      type: "select",
      selectorOptions: PropertiesPane.fontsDisplay(),
      title: "Set plot legend font type",
      fun: plotLegendFont,
    });
    this.addProperty({
      name: "Point",
      id: "plotLegendPoint",
      parentId: "plotLegend",
      type: "number",
      value: "12",
      min: "6",
      max: "32",
      title: "Set plot legend font size",
      fun: plotLegendPoint,
    });
    this.addProperty({
      name: "Color",
      id: "plotLegendColor",
      parentId: "plotLegend",
      type: "color",
      title: "Set plot legend font color",
      fun: plotLegendColor,
    });
    this.addProperty({
      name: "Bold",
      id: "plotLegendBold",
      parentId: "plotLegend",
      type: "checkbox",
      checked: false,
      title: "Set plot legend font weight",
      fun: plotLegendBold,
    });

    this.addProperty({
      name: "Tooltip",
      id: "tooltipLegend",
      parentId: "plotLegend",
      // type: "checkbox",
      // checked: false,
      title: "Set tooltip properties",
      //fun: plotLegendBold,
    });

    this.addProperty({
      name: "showTooltip",
      id: "showTooltipLegend",
      parentId: "tooltipLegend",
      type: "checkbox",
      checked: true,
      title: "Show tooltip on hover",
      fun: showTooltipLegend,
    });

    this.addProperty({
      name: "Background",
      id: "tooltipLegendBackground",
      parentId: "tooltipLegend",
      type: "color",
      value: "#7e5730",
      title: "Set legend tooltip background color",
      fun: tooltipLegendBackground,
    });

    /* this.addProperty({
      name: "Font",
      id: "tooltipLegendFont",
      parentId: "tooltipLegend",
      type: "select",
      selectorOptions: PropertiesPane.fontsDisplay(),
      title: "Set tooltip legend font type",
      fun: tooltipLegendFont,
    }); */

    this.addProperty({
      name: "Point",
      id: "tooltipLegendPoint",
      parentId: "tooltipLegend",
      type: "number",
      value: "12",
      min: "6",
      max: "32",
      title: "Set tooltip legend font size",
      fun: tooltipLegendPoint,
    });
    this.addProperty({
      name: "Color",
      id: "tooltipLegendColor",
      parentId: "tooltipLegend",
      type: "color",
      value: "#ffffff",
      title: "Set tooltip legend font color",
      fun: tooltipLegendColor,
    });

    /* this.addProperty({
      name: "Bold",
      id: "tooltipLegendBold",
      parentId: "tooltipLegend",
      type: "checkbox",
      checked: false,
      title: "Set tooltip legend font weight",
      fun: tooltipLegendBold,
    }); */

    /***************************************Drawing Settings Properties************************************/
    this.addProperty({
      name: "Drawing Settings",
      title: "Drawing properties",
      id: "drawingSettings",
      parentId: "graphSettings",
    });
    var axesOrientation = this.addProperty({
      name: "Axes orientation",
      id: "axesOrientation",
      parentId: "drawingSettings",
      type: "select",
      selectorOptions: ["Implicit", "Do not swap axes", "Swap axes"],
    });
    this.addProperty({
      name: "1:1 aspect ratio",
      id: "aspectRatio",
      parentId: "drawingSettings",
      type: "checkbox",
      //checked: true,
      title: "Set plot asspectRatio",
      fun: aspectRatio,
    });

    this.addProperty({
      name: "+/- root",
      id: "plusMinusRoot",
      parentId: "drawingSettings",
      type: "checkbox",
      //checked: true,
      title: "Add a curve for any negative root",
      fun: negativeRoot,
    });

    var animationRate = this.addProperty({
      name: "Animation rate",
      id: "animationRate",
      parentId: "drawingSettings",
      type: "select",
      selectorOptions: ["Moderate", "Slow", "Fast"],
      title: "Set the animation speed for parameters",
      //disabled: true,
    });

    animationRate.change(function () {
      const animationRates = [
        Static.animationDuration_Moderate,
        Static.animationDuration_Slow,
        Static.animationDuration_Fast,
      ];
      Static.animationDuration = animationRates[$(this)[0].selectedIndex];
    });

    /***************************************Scale Settings Properties************************************/
    this.addProperty({
      name: "Scale Settings",
      title: "Configure scales",
      id: "scaleSettings",
      parentId: "graphSettings",
    });
    this.addProperty({
      name: "Title",
      title: "Configure scale title",
      id: "scaleTitle",
      parentId: "scaleSettings",
    });
    var bottomScaleTitle = this.addProperty({
      name: "Bottom",
      id: "bottomScaleTitle",
      parentId: "scaleTitle",
      type: "text",
      value: "Bottom-Scale",
      title: "Set bottom scale title",
      fun: bottomScaleTitle,
    });
    var topScaleTitle = this.addProperty({
      name: "Top",
      id: "topScaleTitle",
      parentId: "scaleTitle",
      type: "text",
      value: "Top-Scale",
      title: "Set top scale title",
      fun: topScaleTitle,
    });
    var leftScaleTitle = this.addProperty({
      name: "Left",
      id: "leftScaleTitle",
      parentId: "scaleTitle",
      type: "text",
      value: "Left-Scale",
      title: "Set left scale title",
      fun: leftScaleTitle,
    });
    var rightScaleTitle = this.addProperty({
      name: "Right",
      id: "rightScaleTitle",
      parentId: "scaleTitle",
      type: "text",
      value: "Right-Scale",
      title: "Set right scale title",
      fun: rightScaleTitle,
    });
    this.addProperty({
      name: "Font",
      id: "scaleTitleFont",
      parentId: "scaleTitle",
      type: "select",
      selectorOptions: PropertiesPane.fontsDisplay(),
      title: "Set scale title font type",
      fun: scaleTitleFont,
    });
    this.addProperty({
      name: "Point",
      id: "scaleTitlePoint",
      parentId: "scaleTitle",
      type: "number",
      value: "14",
      min: "6",
      max: "32",
      title: "Set scale title font size",
      fun: scaleTitlePoint,
    });
    this.addProperty({
      name: "Color",
      id: "scaleTitleColor",
      parentId: "scaleTitle",
      type: "color",
      title: "Set scale title font color",
      fun: scaleTitleColor,
    });
    this.addProperty({
      name: "Bold",
      id: "scaleTitleBold",
      parentId: "scaleTitle",
      type: "checkbox",
      title: "Set scale title font weight",
      fun: scaleTitleBold,
    });
    this.addProperty({
      name: "Type & precision",
      title: "Configure scale type and precision",
      id: "scalePosition",
      parentId: "scaleSettings",
    });
    this.addProperty({
      name: "Bottom",
      title: "Configure bottom scale type",
      id: "scalePositionBottom",
      parentId: "scalePosition",
    });
    var bottom_attribute = this.addProperty({
      name: "Attribute",
      title: "Scale attributes used during autoscaling",
      id: "scalePositionBottomAttribute",
      parentId: "scalePositionBottom",
    });
    var bottom_Reference = this.addProperty({
      name: "Reference",
      title: "Reference used for IncludeReference and Symmetric",
      id: "scalePositionBottomAttributeReference",
      parentId: "scalePositionBottomAttribute",
      type: "number",
      value: "0",
      disabled: true,
      fun: function (value) {
        plot
          .axisScaleEngine(Axis.AxisId.xBottom)
          .setReference(parseFloat(value));
        plot.autoRefresh();
      },
    });
    var bottom_IncludeReference = this.addProperty({
      name: "IncludeReference",
      title: "Include the value at Reference during autoscaling",
      id: "scalePositionBottomAttributeIncludeReference",
      parentId: "scalePositionBottomAttribute",
      type: "checkbox",
      fun: function (checked) {
        const se = plot.axisScaleEngine(Axis.AxisId.xBottom);
        se.setAttribute(ScaleEngine.Attributes.IncludeReference, checked);
        bottom_Reference.attr(
          "disabled",
          !se.testAttribute(
            ScaleEngine.Attributes.IncludeReference |
              ScaleEngine.Attributes.Symmetric
          )
        );

        plot.autoRefresh();
      },
    });
    var bottom_Symmetric = this.addProperty({
      name: "Symmetric",
      title: "Include the value at Reference during autoscaling",
      id: "scalePositionBottomAttributeSymmetric",
      parentId: "scalePositionBottomAttribute",
      type: "checkbox",
      fun: function (checked) {
        const se = plot.axisScaleEngine(Axis.AxisId.xBottom);
        se.setAttribute(ScaleEngine.Attributes.Symmetric, checked);
        bottom_Reference.attr(
          "disabled",
          !se.testAttribute(
            ScaleEngine.Attributes.IncludeReference |
              ScaleEngine.Attributes.Symmetric
          )
        );
        plot.autoRefresh();
      },
    });
    var bottom_Floating = this.addProperty({
      name: "Floating",
      title:
        "Do not round scales to the closest major division during autoscaling",
      id: "scalePositionBottomAttributeFloating",
      parentId: "scalePositionBottomAttribute",
      type: "checkbox",
      fun: function (checked) {
        plot
          .axisScaleEngine(Axis.AxisId.xBottom)
          .setAttribute(ScaleEngine.Attributes.Floating, checked);
        plot.autoRefresh();
      },
    });
    var bottom_Inverted = this.addProperty({
      name: "Inverted",
      title: "Invert the scale during autoscaling",
      id: "scalePositionBottomAttributeInverted",
      parentId: "scalePositionBottomAttribute",
      type: "checkbox",
      fun: function (checked) {
        plot
          .axisScaleEngine(Axis.AxisId.xBottom)
          .setAttribute(ScaleEngine.Attributes.Inverted, checked);
        plot.autoRefresh();
      },
    });
    var bottom_linear = this.addProperty({
      name: "Linear",
      title: "Linear scale",
      id: "scalePositionBottomLinear",
      parentId: "scalePositionBottom",
      type: "radio",
      checked: true,
      group: "scalePositionBottomGroup",
    });
    var bottom_log = this.addProperty({
      name: "Log",
      title: "Log scale",
      id: "scalePositionBottomLog",
      parentId: "scalePositionBottom",
      type: "radio",
      group: "scalePositionBottomGroup",
    });
    var bottom_logBase = this.addProperty({
      name: "Base",
      title: "Set the base of Log scale",
      id: "scalePositionBottomBase",
      parentId: "scalePositionBottom",
      disabled: true,
      type: "number",
      value: "10",
      min: "2",
      max: "10",
    });
    var bottom_precision = this.addProperty({
      name: "Precision",
      title:
        "Display scale labels either as exponential or fixed-point notation with the specified number of digits.",
      id: "scalePositionBottomBottom",
      parentId: "scalePositionBottom",
      type: "number",
      value: "4",
      min: "2",
      max: "10",
    });
    this.addProperty({
      name: "Top",
      title: "Configure top scale type",
      id: "scalePositionTop",
      parentId: "scalePosition",
    });
    var top_attribute = this.addProperty({
      name: "Attribute",
      title: "Scale attributes used during autoscaling",
      id: "scalePositionTopAttribute",
      parentId: "scalePositionTop",
    });
    var top_Reference = this.addProperty({
      name: "Reference",
      title: "Reference used for IncludeReference and Symmetric",
      id: "scalePositionTopAttributeIncludeReference",
      parentId: "scalePositionTopAttribute",
      type: "number",
      value: "0",
      disabled: true,
      fun: function (value) {
        plot.axisScaleEngine(Axis.AxisId.xTop).setReference(parseFloat(value));
        plot.autoRefresh();
      },
    });
    var top_IncludeReference = this.addProperty({
      name: "IncludeReference",
      title: "Include the value at Reference during autoscaling",
      id: "scalePositionTopAttributeIncludeReference",
      parentId: "scalePositionTopAttribute",
      type: "checkbox",
      fun: function (checked) {
        const se = plot.axisScaleEngine(Axis.AxisId.xTop);
        se.setAttribute(ScaleEngine.Attributes.IncludeReference, checked);
        top_Reference.attr(
          "disabled",
          !se.testAttribute(
            ScaleEngine.Attributes.IncludeReference |
              ScaleEngine.Attributes.Symmetric
          )
        );
        plot.autoRefresh();
      },
    });
    var top_Symmetric = this.addProperty({
      name: "Symmetric",
      title: "Include the value at Reference during autoscaling",
      id: "scalePositionTopAttributeSymmetric",
      parentId: "scalePositionTopAttribute",
      type: "checkbox",
      fun: function (checked) {
        const se = plot.axisScaleEngine(Axis.AxisId.xTop);
        se.setAttribute(ScaleEngine.Attributes.Symmetric, checked);
        top_Reference.attr(
          "disabled",
          !se.testAttribute(
            ScaleEngine.Attributes.IncludeReference |
              ScaleEngine.Attributes.Symmetric
          )
        );
        plot.autoRefresh();
      },
    });
    var top_Floating = this.addProperty({
      name: "Floating",
      title:
        "Do not round scales to the closest major division during autoscaling",
      id: "scalePositionTopAttributeFloating",
      parentId: "scalePositionTopAttribute",
      type: "checkbox",
      fun: function (checked) {
        plot
          .axisScaleEngine(Axis.AxisId.xTop)
          .setAttribute(ScaleEngine.Attributes.Floating, checked);
        plot.autoRefresh();
      },
    });
    var top_Inverted = this.addProperty({
      name: "Inverted",
      title: "Invert the scale during autoscaling",
      id: "scalePositionTopAttributeInverted",
      parentId: "scalePositionTopAttribute",
      type: "checkbox",
      fun: function (checked) {
        plot
          .axisScaleEngine(Axis.AxisId.xTop)
          .setAttribute(ScaleEngine.Attributes.Inverted, checked);
        plot.autoRefresh();
      },
    });
    var top_linear = this.addProperty({
      name: "Linear",
      title: "Linear scale",
      id: "scalePositionTopLinear",
      parentId: "scalePositionTop",
      type: "radio",
      checked: true,
      group: "scalePositionTopGroup",
    });
    var top_log = this.addProperty({
      name: "Log",
      title: "Log scale",
      id: "scalePositionTopLog",
      parentId: "scalePositionTop",
      type: "radio",
      group: "scalePositionTopGroup",
    });
    var top_logBase = this.addProperty({
      name: "Base",
      title: "Set the base of Log scale",
      id: "scalePositionTopBase",
      parentId: "scalePositionTop",
      disabled: true,
      type: "number",
      value: "10",
      min: "2",
      max: "10",
    });
    var top_precision = this.addProperty({
      name: "Precision",
      title:
        "Display scale labels either as exponential or fixed-point notation with the specified number of digits.",
      id: "scalePositionTopTop",
      parentId: "scalePositionTop",
      type: "number",
      value: "4",
      min: "2",
      max: "10",
    });
    this.addProperty({
      name: "Left",
      title: "Configure left scale type",
      id: "scalePositionLeft",
      parentId: "scalePosition",
    });
    var left_attribute = this.addProperty({
      name: "Attribute",
      title: "Scale attributes used during autoscaling",
      id: "scalePositionLeftAttribute",
      parentId: "scalePositionLeft",
    });
    var left_Reference = this.addProperty({
      name: "Reference",
      title: "Reference used for IncludeReference and Symmetric",
      id: "scalePositionLeftAttributeIncludeReference",
      parentId: "scalePositionLeftAttribute",
      type: "number",
      value: "0",
      disabled: true,
      fun: function (value) {
        plot.axisScaleEngine(Axis.AxisId.yLeft).setReference(parseFloat(value));
        plot.autoRefresh();
      },
    });
    var left_IncludeReference = this.addProperty({
      name: "IncludeReference",
      title: "Include the value at Reference during autoscaling",
      id: "scalePositionLeftAttributeIncludeReference",
      parentId: "scalePositionLeftAttribute",
      type: "checkbox",
      fun: function (checked) {
        const se = plot.axisScaleEngine(Axis.AxisId.yLeft);
        se.setAttribute(ScaleEngine.Attributes.IncludeReference, checked);
        left_Reference.attr(
          "disabled",
          !se.testAttribute(
            ScaleEngine.Attributes.IncludeReference |
              ScaleEngine.Attributes.Symmetric
          )
        );
        plot.autoRefresh();
      },
    });
    var left_Symmetric = this.addProperty({
      name: "Symmetric",
      title: "Include the value at Reference during autoscaling",
      id: "scalePositionLeftAttributeSymmetric",
      parentId: "scalePositionLeftAttribute",
      type: "checkbox",
      fun: function (checked) {
        const se = plot.axisScaleEngine(Axis.AxisId.yLeft);
        se.setAttribute(ScaleEngine.Attributes.Symmetric, checked);
        left_Reference.attr(
          "disabled",
          !se.testAttribute(
            ScaleEngine.Attributes.IncludeReference |
              ScaleEngine.Attributes.Symmetric
          )
        );
        plot.autoRefresh();
      },
    });
    var left_Floating = this.addProperty({
      name: "Floating",
      title:
        "Do not round scales to the closest major division during autoscaling",
      id: "scalePositionLeftAttributeFloating",
      parentId: "scalePositionLeftAttribute",
      type: "checkbox",
      fun: function (checked) {
        plot
          .axisScaleEngine(Axis.AxisId.yLeft)
          .setAttribute(ScaleEngine.Attributes.Floating, checked);
        plot.autoRefresh();
      },
    });
    var left_Inverted = this.addProperty({
      name: "Inverted",
      title: "Invert the scale during autoscaling",
      id: "scalePositionLeftAttributeInverted",
      parentId: "scalePositionLeftAttribute",
      type: "checkbox",
      fun: function (checked) {
        plot
          .axisScaleEngine(Axis.AxisId.yLeft)
          .setAttribute(ScaleEngine.Attributes.Inverted, checked);
        plot.autoRefresh();
      },
    });
    var left_linear = this.addProperty({
      name: "Linear",
      title: "Linear scale",
      id: "scalePositionLeftLinear",
      parentId: "scalePositionLeft",
      type: "radio",
      checked: true,
      group: "scalePositionLeftGroup",
    });
    var left_log = this.addProperty({
      name: "Log",
      title: "Log scale",
      id: "scalePositionLeftLog",
      parentId: "scalePositionLeft",
      type: "radio",
      group: "scalePositionLeftGroup",
    });
    var left_logBase = this.addProperty({
      name: "Base",
      title: "Set the base of Log scale",
      id: "scalePositionLeftBase",
      parentId: "scalePositionLeft",
      disabled: true,
      type: "number",
      value: "10",
      min: "2",
      max: "10",
    });
    var left_precision = this.addProperty({
      name: "Precision",
      title:
        "Display scale labels either as exponential or fixed-point notation with the specified number of digits.",
      id: "scalePositionLeftLeft",
      parentId: "scalePositionLeft",
      type: "number",
      value: "4",
      min: "2",
      max: "10",
    });
    this.addProperty({
      name: "Right",
      title: "Configure right scale type",
      id: "scalePositionRight",
      parentId: "scalePosition",
    });
    var right_attribute = this.addProperty({
      name: "Attribute",
      title: "Scale attributes used during autoscaling",
      id: "scalePositionRightAttribute",
      parentId: "scalePositionRight",
    });
    var right_Reference = this.addProperty({
      name: "Reference",
      title: "Reference used for IncludeReference and Symmetric",
      id: "scalePositionRightAttributeIncludeReference",
      parentId: "scalePositionRightAttribute",
      type: "number",
      value: "0",
      disabled: true,
      fun: function (value) {
        plot
          .axisScaleEngine(Axis.AxisId.yRight)
          .setReference(parseFloat(value));
        plot.autoRefresh();
      },
    });
    var right_IncludeReference = this.addProperty({
      name: "IncludeReference",
      title: "Include the value at Reference during autoscaling",
      id: "scalePositionRightAttributeIncludeReference",
      parentId: "scalePositionRightAttribute",
      type: "checkbox",
      fun: function (checked) {
        const se = plot.axisScaleEngine(Axis.AxisId.yRight);
        se.setAttribute(ScaleEngine.Attributes.IncludeReference, checked);
        right_Reference.attr(
          "disabled",
          !se.testAttribute(
            ScaleEngine.Attributes.IncludeReference |
              ScaleEngine.Attributes.Symmetric
          )
        );
        plot.autoRefresh();
      },
    });
    var right_Symmetric = this.addProperty({
      name: "Symmetric",
      title: "Include the value at Reference during autoscaling",
      id: "scalePositionRightAttributeSymmetric",
      parentId: "scalePositionRightAttribute",
      type: "checkbox",
      fun: function (checked) {
        const se = plot.axisScaleEngine(Axis.AxisId.yRight);
        se.setAttribute(ScaleEngine.Attributes.Symmetric, checked);
        right_Reference.attr(
          "disabled",
          !se.testAttribute(
            ScaleEngine.Attributes.IncludeReference |
              ScaleEngine.Attributes.Symmetric
          )
        );
        plot.autoRefresh();
      },
    });
    var right_Floating = this.addProperty({
      name: "Floating",
      title:
        "Do not round scales to the closest major division during autoscaling",
      id: "scalePositionRightAttributeFloating",
      parentId: "scalePositionRightAttribute",
      type: "checkbox",
      fun: function (checked) {
        plot
          .axisScaleEngine(Axis.AxisId.yRight)
          .setAttribute(ScaleEngine.Attributes.Floating, checked);
        plot.autoRefresh();
      },
    });
    var right_Inverted = this.addProperty({
      name: "Inverted",
      title: "Invert the scale during autoscaling",
      id: "scalePositionRightAttributeInverted",
      parentId: "scalePositionRightAttribute",
      type: "checkbox",
      fun: function (checked) {
        plot
          .axisScaleEngine(Axis.AxisId.yRight)
          .setAttribute(ScaleEngine.Attributes.Inverted, checked);
        plot.autoRefresh();
      },
    });
    var right_linear = this.addProperty({
      name: "Linear",
      title: "Linear scale",
      id: "scalePositionRightLinear",
      parentId: "scalePositionRight",
      type: "radio",
      checked: true,
      group: "scalePositionRightGroup",
    });
    var right_log = this.addProperty({
      name: "Log",
      title: "Log scale",
      id: "scalePositionRightLog",
      parentId: "scalePositionRight",
      type: "radio",
      group: "scalePositionRightGroup",
    });
    var right_logBase = this.addProperty({
      name: "Base",
      title: "Set the base of Log scale",
      id: "scalePositionRightBase",
      parentId: "scalePositionRight",
      disabled: true,
      type: "number",
      value: "10",
      min: "2",
      max: "10",
    });
    var right_precision = this.addProperty({
      name: "Precision",
      title:
        "Display scale labels either as exponential or fixed-point notation with the specified number of digits.",
      id: "scalePositionRightRight",
      parentId: "scalePositionRight",
      type: "number",
      value: "4",
      min: "2",
      max: "10",
    });
    ///////////
    this.addProperty({
      name: "Font",
      id: "scaleTitleFont",
      parentId: "scalePosition",
      type: "select",
      selectorOptions: PropertiesPane.fontsDisplay(),
      title: "Set scale label font type",
      fun: scaleLabelFont,
    });

    this.addProperty({
      name: "Point",
      id: "scaleLabelPoint",
      parentId: "scalePosition",
      type: "number",
      value: "12",
      min: "6",
      max: "32",
      title: "Set scale label font size",
      fun: scaleLabelPoint,
    });
    this.addProperty({
      name: "Color",
      id: "scaleTitleColor",
      parentId: "scalePosition",
      type: "color",
      title: "Set scale label font color",
      fun: scaleLabelColor,
    });
    this.addProperty({
      name: "Bold",
      id: "scaleTitleBold",
      parentId: "scalePosition",
      type: "checkbox",
      title: "Set scale label font weight",
      fun: scaleLabelBold,
    });
    ////////////////

    this.addProperty({
      name: "Limits",
      title: "Configure scale limits",
      id: "scaleLimits",
      parentId: "scaleSettings",
    });

    var enableUserScale = this.addProperty({
      name: "Enable user scale",
      id: "limitsEnableUserScale",
      parentId: "scaleLimits",
      type: "checkbox",
    });

    this.addProperty({
      name: "Bottom",
      id: "limitsBottom",
      parentId: "scaleLimits",
    });
    var bottom_min = this.addProperty({
      name: "minimum",
      id: "limitsBottomMinimum",
      parentId: "limitsBottom",
      type: "number",
      value: "0",
      disabled: true,
    });
    var bottom_max = this.addProperty({
      name: "maximum",
      id: "limitsBottomMaximum",
      parentId: "limitsBottom",
      type: "number",
      value: "0",
      disabled: true,
    });
    this.addProperty({
      name: "Left",
      id: "limitsLeft",
      parentId: "scaleLimits",
    });
    var left_min = this.addProperty({
      name: "minimum",
      id: "limitsLeftMinimum",
      parentId: "limitsLeft",
      type: "number",
      value: "0",
      disabled: true,
    });
    var left_max = this.addProperty({
      name: "maximum",
      id: "limitsLeftMaximum",
      parentId: "limitsLeft",
      type: "number",
      value: "0",
      disabled: true,
    });
    this.addProperty({ name: "Top", id: "limitsTop", parentId: "scaleLimits" });
    var top_min = this.addProperty({
      name: "minimum",
      id: "limitsTopMinimum",
      parentId: "limitsTop",
      type: "number",
      value: "0",
      disabled: true,
    });
    var top_max = this.addProperty({
      name: "maximum",
      id: "limitsTopMaximum",
      parentId: "limitsTop",
      type: "number",
      value: "0",
      disabled: true,
    });
    this.addProperty({
      name: "Right",
      id: "limitsRight",
      parentId: "scaleLimits",
    });
    var right_min = this.addProperty({
      name: "minimum",
      id: "limitsRightMinimum",
      parentId: "limitsRight",
      type: "number",
      value: "0",
      disabled: true,
    });
    var right_max = this.addProperty({
      name: "maximum",
      id: "limitsRightMaximum",
      parentId: "limitsRight",
      type: "number",
      value: "0",
      disabled: true,
    });
    /*this.addProperty({
			name: "Exp. Notation",
			title: "Set Exp. Notation limits",
			id: "scaleExpNotation",
			parentId: "scaleSettings",
		});
		 var exponent_lower = this.addProperty({
			name: "Values less than",
			id: "expNotationValuesLessThan",
			parentId: "scaleExpNotation",
			type: "number",
			value: "-1e+4",
		});
		var exponent_upper = this.addProperty({
			name: "Values greater than",
			id: "expNotationValuesGreaterThan",
			parentId: "scaleExpNotation",
			type: "number",
			value: "1e+4",
		}); */
    this.addProperty({
      name: "Margins",
      title: "Set scale margins",
      id: "scaleMargins",
      parentId: "scaleSettings",
    });
    var margin_left = this.addProperty({
      name: "Left axis",
      id: "scaleMarginsLeftAxis",
      parentId: "scaleMargins",
      type: "number",
      min: "0",
      value: "0.0",
    });
    var margin_right = this.addProperty({
      name: "Right axis",
      id: "scaleMarginsRightAxis",
      parentId: "scaleMargins",
      type: "number",
      min: "0",
      value: "0.0",
    });
    var margin_bottom = this.addProperty({
      name: "Bottom axis",
      id: "scaleMarginsBottomAxis",
      parentId: "scaleMargins",
      type: "number",
      min: "0",
      value: "0.0",
    });
    var margin_top = this.addProperty({
      name: "Top axis",
      id: "scaleMarginsTopAxis",
      parentId: "scaleMargins",
      type: "number",
      min: "0",
      value: "0.0",
    });
    this.addProperty({
      name: "Components",
      title: "Configure plot components",
      id: "scaleComponents",
      parentId: "scaleSettings",
    });
    var show_backbone = this.addProperty({
      name: "Show backbone",
      id: "scaleComponentsShowBackbone",
      parentId: "scaleComponents",
      type: "checkbox",
      checked: true,
    });
    var show_labels = this.addProperty({
      name: "Show labels",
      id: "scaleComponentsShowLabels",
      parentId: "scaleComponents",
      type: "checkbox",
      checked: true,
    });
    var show_ticks = this.addProperty({
      name: "Show ticks",
      id: "scaleComponentsShowTicks",
      parentId: "scaleComponents",
      type: "checkbox",
      checked: true,
    });
    var tick_length = this.addProperty({
      name: "Tick length",
      id: "scaleComponentsTickLength",
      parentId: "scaleComponents",
      type: "select",
      selectorOptions: ["Small", "Medium", "Large"],
    });

    /********************Point Operation Settings Properties****************************************/
    /* this.addProperty({name: "Point Operation Settings", id: "pointOperationSettings"});
				var point_selection = this.addProperty({name: "When a point is selected", id: "pointSelected", parentId: "pointOperationSettings", type:"select", selectorOptions: ["Display data", "remove it", "Modify it"]});
				var addRemovePoint = this.addProperty({name: "Add/Remove Point", id: "addRemovePoint", parentId: "pointOperationSettings", type:"checkbox"}); */

    /***************Error Settings Properties**************************************************/
    this.addProperty({
      name: "Error Settings",
      title: "Configure error handling",
      id: "errorSettings",
      parentId: "graphSettings",
    });
    var errorResponse = this.addProperty({
      name: "When an error occurs",
      id: "errorResponse",
      parentId: "errorSettings",
      type: "select",
      selectorOptions: [
        "Adjust the domain",
        "Stop and warn",
        "Silently ignore",
        "Allow for ignore",
      ],
    });

    /*****************Zoomer Settings Properties**************************************************/
    var zoomerSettings = this.addProperty({
      name: "Zoomer Settings",
      title: "Configure zoomer",
      id: "zoomerSettings",
      parentId: "graphSettings",
    });

    var zoomerAxes = this.addProperty({
      name: "Zoom according to the current curve axes",
      id: "zoomerAxes",
      parentId: "zoomerSettings",
      type: "checkbox",
      checked: true,
    });
    var zoomAxisHorizontal = this.addProperty({
      name: "Horizontal",
      id: "zoomerHorizontalAxes",
      parentId: "zoomerSettings",
      type: "select",
      selectorOptions: ["Bottom", "Top"],
      disabled: true,
    });
    var zoomAxisVertical = this.addProperty({
      name: "Vertical",
      id: "zoomerVerticalAxes",
      parentId: "zoomerSettings",
      type: "select",
      selectorOptions: ["Left", "Right"],
      disabled: true,
    });
    var trackerMode = this.addProperty({
      name: "Tracker mode",
      id: "zoomerTrackerMode",
      parentId: "zoomerSettings",
      type: "select",
      selectorOptions: ["Always off", "Always on", "Active only"],
      //disabled: true,
    });

    /********************Magnifier Settings Properties***********************************************/
    var magnifierSettings = this.addProperty({
      name: "Magnifier Settings",
      title: "Configure magnifier",
      id: "magnifierSettings",
      parentId: "graphSettings",
    });
    var magnifierLeftAxis = this.addProperty({
      name: "Left axis enabled",
      id: "magnifierLeftAxis",
      parentId: "magnifierSettings",
      type: "checkbox",
      checked: true,
    });
    var magnifierRightAxis = this.addProperty({
      name: "Right axis enabled",
      id: "magnifierRightAxis",
      parentId: "magnifierSettings",
      type: "checkbox",
    });
    var magnifierBottomAxis = this.addProperty({
      name: "Bottom axis enabled",
      id: "magnifierBottomAxis",
      parentId: "magnifierSettings",
      type: "checkbox",
      checked: true,
    });
    var magnifierTopAxis = this.addProperty({
      name: "Top axis enabled",
      id: "magnifierTopAxis",
      parentId: "magnifierSettings",
      type: "checkbox",
    });

    /******************Watch Settings Properties***************************************************/
    var watchSettings = this.addProperty({
      name: "Watch Settings",
      title: "Configure watch",
      id: "watchSettings",
      parentId: "graphSettings",
    });

    var watchShading = this.addProperty({
      name: "Shading",
      id: "watchShading",
      parentId: "watchSettings",
    });
    var watchShadeWatchArea = this.addProperty({
      name: "Shade watch area",
      id: "watchShadeWatchArea",
      parentId: "watchShading",
      type: "checkbox",
      checked: true,
    });
    var watchShadeAutoScale = this.addProperty({
      name: "Shade to axis",
      title: "If autoscaling is enabled, shade up to the axis.",
      id: "watchShadeAutoScale",
      parentId: "watchShading",
      type: "checkbox",
      checked: true,
    });
    var watchShadeColor = this.addProperty({
      name: "Shade color",
      title: "Set the shading color",
      id: "watchShadeColor",
      parentId: "watchShading",
      value: "#006464",
      type: "color",
    });
    var watchCentroidWithArea = this.addProperty({
      name: "Watch centroid with area",
      title: "Place a marker at the centroid",
      id: "watchCentroidWithArea",
      parentId: "watchSettings",
      type: "checkbox",
      checked: true,
    });

    /******************Watch Calculation Properties***************************************************/
    var watchCalculationAccuracy = this.addProperty({
      name: "Calculation Settings",
      id: "watchCalculationAccuracy",
      title: "Configure calculation accuracy",
      parentId: "graphSettings",
    });
    this.addProperty({
      name: "Accuracy level",
      id: "watchCalculationAccuracyLevel",
      title: "Set the accuracy level",
      parentId: "watchCalculationAccuracy",
    });
    var watchCalculationAccuracyLow = this.addProperty({
      name: "Low",
      id: "watchCalculationAccuracyLow",
      parentId: "watchCalculationAccuracyLevel",
      type: "radio",
      group: "watchCalculationAccuracyGroup",
    });
    var watchCalculationAccuracyModerate = this.addProperty({
      name: "Moderate",
      id: "watchCalculationAccuracyModerate",
      parentId: "watchCalculationAccuracyLevel",
      type: "radio",
      group: "watchCalculationAccuracyGroup",
      checked: true,
    });
    var watchCalculationAccuracyHigh = this.addProperty({
      name: "High",
      id: "watchCalculationAccuracyHigh",
      parentId: "watchCalculationAccuracyLevel",
      type: "radio",
      group: "watchCalculationAccuracyGroup",
    });

    var decimalPlacesForCalculation = this.addProperty({
      name: "Decimal places in calculation",
      title: "Set the maximum decimal places used in calculations for an axis",
      id: "decimalPlacesForCalculationy",
      parentId: "watchCalculationAccuracy",
    });
    var userDecimalPlacesForCalculation = this.addProperty({
      name: "Enable user selection",
      title: "Let the user set the maximum decimal places used in calculations",
      id: "userDecimalPlacesForCalculation",
      parentId: "decimalPlacesForCalculationy",
      type: "checkbox",
    });
    var bottom_decimalPlaces = this.addProperty({
      name: "Bottom axis",
      title: "Set the maximum decimal places used in calculations",
      id: "scalePositionBottomBottom",
      parentId: "decimalPlacesForCalculationy",
      disabled: true,
      type: "number",
      value: "2",
      min: "0",
    });
    var left_decimalPlaces = this.addProperty({
      name: "Left axis",
      title: "Set the maximum decimal places used in calculations",
      id: "scalePositionBottomBottom",
      parentId: "decimalPlacesForCalculationy",
      type: "number",
      disabled: true,
      value: "2",
      min: "0",
    });
    var top_decimalPlaces = this.addProperty({
      name: "Top axis",
      title: "Set the maximum decimal places used in calculations",
      id: "scalePositionBottomBottom",
      parentId: "decimalPlacesForCalculationy",
      type: "number",
      disabled: true,
      value: "2",
      min: "0",
    });
    var right_decimalPlaces = this.addProperty({
      name: "Right axis",
      title: "Set the maximum decimal places used in calculations",
      id: "scalePositionBottomBottom",
      parentId: "decimalPlacesForCalculationy",
      type: "number",
      disabled: true,
      value: "2",
      min: "0",
    });

    var dicontinuity = this.addProperty({
      name: "Nearnest to discontinuity",
      title: "Set how discontinuity calculations are made.",
      id: "dicontinuity",
      parentId: "watchCalculationAccuracy",
    });

    var dicontinuityUserSetting = this.addProperty({
      name: "Allow user setting",
      title: "Allow the user to set the nearnest to discontinuity",
      id: "dicontinuityUserSetting",
      parentId: "dicontinuity",
      type: "checkbox",
    });

    var dicontinuityOffsetFactor = this.addProperty({
      name: "Nearnest (1 millionth)",
      title:
        "Set how close a point is to any discontinuity as a millionth of a step.",
      id: "dicontinuityOffsetFactor",
      parentId: "dicontinuity",
      type: "number",
      value: "2",
      min: "2",
      max: "100",
      disabled: true,
    });

    dicontinuityUserSetting.change(function () {
      if ($(this)[0].checked) {
        dicontinuityOffsetFactor.attr("disabled", false);
      } else {
        dicontinuityOffsetFactor.attr("disabled", true);
      }
      Static.dicontinuityUserSetting = $(this)[0].checked;
    });

    dicontinuityOffsetFactor.change(function () {
      //console.log($(this).val());
      let val = parseInt($(this).val());
      if (val < 2) {
        val = 2;
        $(this).val(2);
      }
      Static.dicontinuityOffsetFactor = val / Static.dicontinuityFactor;
    });

    Static.bind("numberOfPoints", function (e, sz) {
      if (!Static.dicontinuityUserSetting) {
        let val = (1 / 100) * sz;
        //if(plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve).length){
        if (val > dicontinuityOffsetFactor.val()) {
          dicontinuityOffsetFactor.val(val);
          Static.dicontinuityOffsetFactor = val / Static.dicontinuityFactor;
        }
      }
    });

    var uniqueParameter = this.addProperty({
      name: "Unique parameters",
      title:
        "If checked, parameters are unique to the curve in which they exist.",
      id: "uniqueParameter",
      parentId: "watchCalculationAccuracy",
      type: "checkbox",
      checked: false,
      fun: function (checked) {
        Static.uniqueParameter = checked;
      },
    });

    //////////////////////////////////

    function updateCalculationDecimalPlaces(_curve = null) {
      //if (userDecimalPlacesForCalculation[0].checked) return;
      var curve = _curve || plot.rv._curve;
      //console.log(curve)
      if (curve) {
        const autoReplot = plot.autoReplot();
        plot.setAutoReplot(false);
        var xAxis = curve.xAxis();
        var yAxis = curve.yAxis();
        let xDecimalPlaces = 4;
        let yDecimalPlaces = 4;
        if (userDecimalPlacesForCalculation[0].checked) {
          if (xAxis == Axis.AxisId.xBottom) {
            xDecimalPlaces = parseInt(bottom_decimalPlaces.val());
          }
          if (xAxis == Axis.AxisId.xTop) {
            xDecimalPlaces = parseInt(top_decimalPlaces.val());
          }
          if (yAxis == Axis.AxisId.yLeft) {
            yDecimalPlaces = parseInt(left_decimalPlaces.val());
          }
          if (yAxis == Axis.AxisId.yRight) {
            yDecimalPlaces = parseInt(right_decimalPlaces.val());
          }
        } else {
          const obj = Utility.grapherDeterminedDecimalPlaces(curve);
          yDecimalPlaces = obj.decimalPlacesY;
          xDecimalPlaces = obj.decimalPlacesX;
        }
        if (
          xAxis == Axis.AxisId.xBottom &&
          xDecimalPlaces != parseInt(bottom_decimalPlaces.val())
        ) {
          bottom_decimalPlaces.val(xDecimalPlaces);
          bottom_decimalPlaces.trigger("change");
        }
        if (
          xAxis == Axis.AxisId.xTop &&
          xDecimalPlaces != parseInt(top_decimalPlaces.val())
        ) {
          top_decimalPlaces.val(xDecimalPlaces);
          top_decimalPlaces.trigger("change");
        }
        if (
          yAxis == Axis.AxisId.yLeft &&
          yDecimalPlaces != parseInt(left_decimalPlaces.val())
        ) {
          left_decimalPlaces.val(yDecimalPlaces);
          left_decimalPlaces.trigger("change");
        }
        if (
          yAxis == Axis.AxisId.yRight &&
          yDecimalPlaces != parseInt(right_decimalPlaces.val())
        ) {
          right_decimalPlaces.val(yDecimalPlaces);
          right_decimalPlaces.trigger("change");
        }
        plot.setAutoReplot(autoReplot);
        plot.autoRefresh();
      }
    }

    this.updateCalculationDecimalPlaces = function (curve) {
      updateCalculationDecimalPlaces(curve);
    };

    Static.bind("replot", function () {
      updateCalculationDecimalPlaces();
    });

    function setReadonlyUserDecimalPlacesForCalculation(on) {
      bottom_decimalPlaces.attr("disabled", on);
      left_decimalPlaces.attr("disabled", on);
      top_decimalPlaces.attr("disabled", on);
      right_decimalPlaces.attr("disabled", on);
    }
    userDecimalPlacesForCalculation.change(function () {
      setReadonlyUserDecimalPlacesForCalculation(!this.checked);
      updateCalculationDecimalPlaces();
      Static.userDecimalPlacesForCalculation = this.checked;
    });
    /////////////////////////////////////////////

    /* var watchShading = this.addProperty({
      name: "Shading",
      id: "watchShading",
      parentId: "watchSettings",
    });
    var watchShadeWatchArea = this.addProperty({
      name: "Shade watch area",
      id: "watchShadeWatchArea",
      parentId: "watchShading",
      type: "checkbox",
      checked: true,
    });
    var watchShadeAutoScale = this.addProperty({
      name: "Shade to axis",
      title: "If autoscaling is enabled, shade up to the axis.",
      id: "watchShadeAutoScale",
      parentId: "watchShading",
      type: "checkbox",
      checked: true,
    });
    var watchShadeColor = this.addProperty({
      name: "Shade color",
      title: "Set the shading color",
      id: "watchShadeColor",
      parentId: "watchShading",
      value: "#006464",
      type: "color",
    });
    var watchCentroidWithArea = this.addProperty({
      name: "Watch centroid with area",
      title: "Place a marker at the centroid",
      id: "watchCentroidWithArea",
      parentId: "watchSettings",
      type: "checkbox",
      checked: true,
    }); */

    /*****************************Grid Settings Properties****************************************************/
    this.addProperty({
      name: "Grid Settings",
      title: "Configure grid",
      id: "gridSettings",
      parentId: "graphSettings",
    });
    this.addProperty({
      name: "Minor Lines",
      id: "gridMinorLines",
      parentId: "gridSettings",
    });
    var minor_gridLines = this.addProperty({
      name: "Show",
      id: "gridMinorLinesShow",
      parentId: "gridMinorLines",
      type: "checkbox",
      checked: true,
    });
    var minor_divisions = this.addProperty({
      name: "Minors per major",
      id: "gridMinorsPerMajor",
      parentId: "gridMinorLines",
      type: "number",
      value: "5",
      min: "2",
      max: "20",
    });
    var minor_line_color = this.addProperty({
      name: "Color",
      id: "gridMinorLinesColor",
      parentId: "gridMinorLines",
      type: "color",
    });
    this.addProperty({
      name: "Major Lines",
      id: "gridMajorLines",
      parentId: "gridSettings",
    });
    var major_gridLines = this.addProperty({
      name: "Show",
      id: "gridMajorLinesShow",
      parentId: "gridMajorLines",
      type: "checkbox",
      checked: true,
    });
    var major_divisions = this.addProperty({
      name: "Majors",
      id: "gridMajorMajors",
      parentId: "gridMajorLines",
      type: "number",
      value: "8",
      min: "1",
      max: "40",
    });
    var major_line_color = this.addProperty({
      name: "Color",
      id: "gridMajorLinesColor",
      parentId: "gridMajorLines",
      type: "color",
    });
    var gridSettings = this.addProperty({
      name: "Grid Axes",
      id: "gridAxes",
      parentId: "gridSettings",
    });
    var gridAxes = this.addProperty({
      name: "According to current curve",
      id: "gridAxesAccordingToCurve",
      parentId: "gridAxes",
      type: "checkbox",
      checked: true,
    });
    var gridAxisHorizontal = this.addProperty({
      name: "Horizontal",
      id: "gridHorizontalAxes",
      parentId: "gridAxes",
      type: "select",
      selectorOptions: ["Bottom", "Top"],
      disabled: true,
    });
    var gridAxisVertical = this.addProperty({
      name: "Vertical",
      id: "gridVerticalAxes",
      parentId: "gridAxes",
      type: "select",
      selectorOptions: ["Left", "Right"],
      disabled: true,
    });

    /********************Point Operation Settings Properties****************************************/
    var point_selection = this.addProperty({
      name: "When a point is selected",
      title: "Set what happens to selected point",
      id: "pointSelected",
      parentId: "graphSettings",
      type: "select",
      selectorOptions: ["Display data", "remove it", "Modify it"],
    });
    var addRemovePoint = this.addProperty({
      name: "Add/Remove Point",
      title:
        "If checked, point addition (with double click) and point removal (with left click) is enabled. Point selection (P-Sel), is disabled.",
      id: "addRemovePoint",
      type: "checkbox",
      parentId: "graphSettings",
    });

    this.init(); //call this method after adding all properties

    /**************************************General Settings Properties Callbacks*****************************/
    axesOrientation.change(function () {
      //"Implicit", "Do not swap axes", "Swap axes"
      var index = $(this)[0].selectedIndex;
      if (index == 0) {
        //Implicit
        Static.swapAxes = 0;
        console.log("Implicit", Static.swapAxes);
      } else if (index == 1) {
        //Do not swap axes
        Static.swapAxes = 1;
        console.log("Do not swap axes", Static.swapAxes);
      } else if (index == 2) {
        //Swap axes
        Static.swapAxes = 2;
        console.log("Swap axes", Static.swapAxes);
      }
    });

    ///////////////////////////////////////////////

    const plotDiv = $("#plotDiv");
    let doAdjust = false;
    let centralDivW = 0,
      centralDivH = 0;
    function doAdjustPlotDiv() {
      //const legendW = plot.legend().legendDivWidth();
      //const legendW = plot.legend().maxWidth();
      //console.log(legendW);
      if (Math.abs(centralDivW - centralDivH) < 4) return;
      if (centralDivW > centralDivH) {
        let diff =
          parseFloat(plot.getLayout().getCentralDiv().css("width")) -
          parseFloat(plot.getLayout().getCentralDiv().css("height"));
        let plotDivW = parseFloat(plotDiv.css("width")) - diff;
        plotDiv.css("width", plotDivW + "px");
      } else {
        let diff =
          parseFloat(plot.getLayout().getCentralDiv().css("height")) -
          parseFloat(plot.getLayout().getCentralDiv().css("width"));
        let plotDivH = parseFloat(plotDiv.css("height")) - diff;
        plotDiv.css("height", plotDivH + "px");
      }
      plot.autoRefresh();
    }

    Static.onHtmlElementResize(plot.legend().legendDiv()[0], function () {
      // const legendW = plot.legend().legendDivWidth();
      // console.log(legendW);
      doAdjustPlotDiv();
    });

    let rightSideBarVisible = false;
    let leftSideBarVisible = false;
    let index_0 = false,
      index_1 = false;
    Static.bind("showGridItem", function (e, m_anchorPosition, gridIndex, on) {
      if (m_anchorPosition == "right") {
        rightSideBarVisible = on;
      }
      if (m_anchorPosition == "left") {
        leftSideBarVisible = on;
        if (gridIndex == 0) index_0 = on;
        if (gridIndex == 1) index_1 = on;
      }
      if (Static.aspectRatioOneToOne) {
        if (doAdjust) doAdjustPlotDiv();
      }
      if (on) {
        Static.trigger("invalidateWatch");
        Static.trigger("positionChanged");
      } /* else{
        plot.tbar.setButtonCheck(plot.tbar.sBar, false);
      } */
    });

    function negativeRoot(checked) {
      Static.negativeRoot = checked;
    }

    //let aspectRatioAutoScale = false;

    function adjustScales() {
      const yAxisInterval = plot.axisInterval(0);
      const xAxisInterval = plot.axisInterval(2);
      const yAxisInverted =
        yAxisInterval.minValue() > yAxisInterval.maxValue() ? true : false;
      const xAxisInverted =
        xAxisInterval.minValue() > xAxisInterval.maxValue() ? true : false;

      let maxWidth = Math.max(
        Math.abs(yAxisInterval.maxValue() - yAxisInterval.minValue()),
        Math.abs(xAxisInterval.maxValue() - xAxisInterval.minValue())
      );
      //console.log("maxWidth", yAxisInterval.width());
      let minY = yAxisInterval.minValue();
      if (yAxisInverted) {
        minY = yAxisInterval.maxValue();
      }

      let minX = xAxisInterval.minValue();

      if (xAxisInverted) {
        minX = xAxisInterval.maxValue();
      }

      if (yAxisInverted) {
        plot.setAxisScale(0, minY + maxWidth, minY);
      } else {
        plot.setAxisScale(0, minY, minY + maxWidth);
      }

      if (xAxisInverted) {
        plot.setAxisScale(2, minX + maxWidth, minX);
      } else {
        plot.setAxisScale(2, minX, minX + maxWidth);
      }

      plot.tbar.setButtonCheck(plot.tbar.auto, true);
    }

    let plotItemMap = new Map();

    function adjustPlotItemAxis(plotItem) {
      plotItemMap.set(plotItem, {
        xAxis: plotItem.xAxis(),
        yAxis: plotItem.yAxis(),
      });
      plotItem.setAxes(Axis.AxisId.xBottom, Axis.AxisId.yLeft);
      plot.legend().updateLegendToolTip(plotItem);
    }

    function restorePlotItemAxis() {
      plotItemMap.forEach(function (value, plotItem) {
        plotItem.setAxes(value.xAxis, value.yAxis);
        plot.legend().updateLegendToolTip(plotItem);
      });
      plotItemMap.clear();
    }

    function aspectRatio(checked) {
      //padding-top: 100%;
      Static.aspectRatioOneToOne = checked;
      centralDivW = parseFloat(plot.getLayout().getCentralDiv().css("width"));
      centralDivH = parseFloat(plot.getLayout().getCentralDiv().css("height"));

      if (checked) {
        const plotItems = plot.itemList();
        for (let index = 0; index < plotItems.length; index++) {
          const plotItem = plotItems[index];
          adjustPlotItemAxis(plotItem);
        }
        doAdjust = true;
        doAdjustPlotDiv();
        if (plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve).length > 0)
          adjustScales();

        self.rightAxisEnabled = plot.axisEnabled(1);
        self.topAxisEnabled = plot.axisEnabled(3);

        plot.enableAxis(1, false);
        plot.enableAxis(3, false);
      } else {
        restorePlotItemAxis();
        plot.enableAxis(1, self.rightAxisEnabled);
        plot.enableAxis(3, self.topAxisEnabled);
        doAdjust = false;
        //plot.rightSidebar.showSidebar(false);
        plotDiv.css("width", "77.9653%");
        plotDiv.css("height", "98%");

        plotDiv.css(
          "height",
          parseFloat(plotDiv.css("height")) - plot.tbar.tbarHeight + "px"
        );
        plot.autoRefresh();
        let L = plot
          .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
          .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
          .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram));
        if (L.length); //plot.rightSidebar.showSidebar(true);
      }
      Static.trigger("aspectRatioChanged", checked);
    }

    $(window).resize(function () {
      if (Static.aspectRatioOneToOne) {
        const visible = plot.rightSidebar.isSideBarVisible();
        if (visible) {
          plot.rightSidebar.showSidebar(false);
        }
        aspectRatio(false);
        let L = plot
          .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
          .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
          .concat(plot.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram));
        if (L.length) plot.rightSidebar.showSidebar(visible);

        aspectRatio(true);
      }
    });

    Static.bind("aspectRatioChanged", function () {
      if (!Static.aspectRatioOneToOne) {
        if (plot.tbar.isButtonChecked(plot.tbar.auto))
          Utility.setAutoScale(plot, true);
        plot.tbar.showDropdownItem("View", 2);
        plot.tbar.showDropdownItem("View", 3);
      } else {
        plot.tbar.hideDropdownItem("View", 2);
        plot.tbar.hideDropdownItem("View", 3);
        Utility.setAutoScale(plot, true);
        adjustScales();
      }
    });

    Static.bind("autoScalingEnabled", function (e, auto) {
      if (Static.aspectRatioOneToOne && auto) {
        adjustScales();
      }
    });

    Static.bind("itemAttached", function (e, plotItem, on) {
      if (!Static.dicontinuityUserSetting) {
        const plotCurves = plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
        let _val = Number.MIN_VALUE;
        if (plotCurves.length == 0) {
          _val = 2;
        } else {
          for (let i = 0; i < plotCurves.length; i++) {
            const v = plotCurves[i].dataSize() * (1 / 100);
            _val = v > _val ? v : _val;
          }
        }
        dicontinuityOffsetFactor.val(_val);
        Static.dicontinuityOffsetFactor = _val / Static.dicontinuityFactor;
      }
      if (!on) {
        plotItemMap.delete(plotItem);
      }
      if (!Static.aspectRatioOneToOne) return;
      const doAutoReplot = plot.autoReplot();
      plot.setAutoReplot(false);
      doAdjustPlotDiv();
      if (
        on &&
        plot.itemList(/* PlotItem.RttiValues.Rtti_PlotCurve */).length > 0
      ) {
        adjustPlotItemAxis(plotItem);

        if (
          plot.itemList(/* PlotItem.RttiValues.Rtti_PlotCurve */).length == 1
        ) {
          aspectRatio(false);
          aspectRatio(true);
        }

        //if (plotItem instanceof MyCurve) {
        Utility.setAutoScale(plot, true);
        adjustScales();
        //}
      }
      if (!on) {
        if (
          plot.itemList(/* PlotItem.RttiValues.Rtti_PlotCurve */).length == 0
        ) {
          aspectRatio(true);
        } else {
          if (plot.tbar.isButtonChecked(plot.tbar.auto)) {
            Utility.setAutoScale(plot, true);
            adjustScales();
          }
        }
      }
      plot.setAutoReplot(doAutoReplot);
      plot.autoRefresh();

      if (
        !Static.dicontinuityUserSetting &&
        plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve).length == 0
      ) {
        dicontinuityOffsetFactor.val(2);
        Static.dicontinuityOffsetFactor = 2 / Static.dicontinuityFactor;
      }
    });

    Static.bind("visibilityChange", function (e, plotItem, visible) {
      if (Static.aspectRatioOneToOne) {
        if (plot.tbar.isButtonChecked(plot.tbar.auto)) {
          if (
            plotItem instanceof MyCurve ||
            plotItem instanceof Spectrogram ||
            plotItem instanceof SpectroCurve
          ) {
            Utility.setAutoScale(plot, true);
            adjustScales();
          }
        }
      }
    });

    function plotTitleTitle(title) {
      plot.setTitle(title);
    }
    function plotTitleFont(index) {
      var font = plot.titleFont();
      font.name = PropertiesPane.fontGroup(index);
      plot.setTitleFont(font);
    }
    function plotTitlePoint(val) {
      var font = plot.titleFont();
      font.th = val;
      plot.setTitleFont(font);
    }
    function plotTitleColor(color) {
      var font = plot.titleFont();
      font.fontColor = color;
      plot.setTitleFont(font);
    }
    function plotTitleBold(checked) {
      var font = plot.titleFont();
      if (checked) {
        font.weight = "bold";
      } else {
        font.weight = "normal";
      }
      plot.setTitleFont(font);
    }
    function plotFooterFooter(footer) {
      plot.setFooter(footer);
    }
    function plotFooterFont(index) {
      var font = plot.footerFont();
      font.name = PropertiesPane.fontGroup(index);
      plot.setFooterFont(font);
    }
    function plotFooterPoint(val) {
      var font = plot.footerFont();
      font.th = val;
      plot.setFooterFont(font);
    }
    function plotFooterColor(color) {
      var font = plot.footerFont();
      font.fontColor = color;
      plot.setFooterFont(font);
    }
    function plotFooterBold(checked) {
      var font = plot.footerFont();
      if (checked) {
        font.weight = "bold";
      } else {
        font.weight = "normal";
      }
      plot.setFooterFont(font);
    }
    function plotBackground(color) {
      plot.setPlotBackground(color);
    }
    function plotLegendBackground(color) {
      var table = plot.getLayout().getLegendDiv().children()[0];
      $(table).css("background-color", color);
    }
    function plotLegendShowLine(checked) {
      Static.showline = checked;
    }
    function plotLegendShowSymbol(checked) {
      Static.showsymbol = checked;
    }

    //////
    function plotLegendFont(index) {
      var font = plot.legendFont();
      font.name = PropertiesPane.fontGroup(index);
      plot.setLegendFont(font);
    }
    function plotLegendPoint(val) {
      var font = plot.legendFont();
      font.th = parseInt(val);
      plot.setLegendFont(font);
    }
    function plotLegendColor(color) {
      var font = plot.legendFont();
      font.fontColor = color;
      plot.setLegendFont(font);
    }
    function plotLegendBold(checked) {
      var font = plot.legendFont();
      if (checked) {
        font.weight = "bold";
      } else {
        font.weight = "normal";
      }
      plot.setLegendFont(font);
    }

    function showTooltipLegend(checked) {
      Static.showTooltipLegend = checked;

      if (checked) {
        self.show("tooltipLegendBackground");
        self.show("tooltipLegendPoint");
        self.show("tooltipLegendColor");
      } else {
        self.hide("tooltipLegendBackground");
        self.hide("tooltipLegendPoint");
        self.hide("tooltipLegendColor");
      }
    }

    function tooltipLegendBackground(color) {
      $("#legendDiv")[0].style.setProperty("--tooltip-bg-color", color);
    }

    function tooltipLegendPoint(val) {
      const th = parseInt(val);
      $("#legendDiv")[0].style.setProperty("--tooltip-font-size", th + "px");
    }
    function tooltipLegendColor(color) {
      $("#legendDiv")[0].style.setProperty("--tooltip-color", color);
    }

    /**************************************Scale Settings Properties Callbacks*****************************/
    //helpers
    function setAxisTitleFont() {
      //helper
      var axisLabelFont = plot.axisLabelFont(Axis.AxisId.xBottom);
      var axisTitleFont = plot.axisTitleFont(Axis.AxisId.xBottom);
      axisLabelFont.th = axisTitleFont.th * 0.86;
      setAxisLabelFont();
      plot.setAxisTitleFont(Axis.AxisId.xBottom, axisTitleFont);
      plot.setAxisTitleFont(Axis.AxisId.xTop, axisTitleFont);
      plot.setAxisTitleFont(Axis.AxisId.yLeft, axisTitleFont);
      plot.setAxisTitleFont(Axis.AxisId.yRight, axisTitleFont);
    }
    function setAxisLabelFont() {
      plot.setAxisLabelFont(Axis.AxisId.xBottom, axisLabelFont);
      plot.setAxisLabelFont(Axis.AxisId.xTop, axisLabelFont);
      plot.setAxisLabelFont(Axis.AxisId.yLeft, axisLabelFont);
      plot.setAxisLabelFont(Axis.AxisId.yRight, axisLabelFont);
    }

    function bottomScaleTitle(title) {
      plot.setAxisTitle(Axis.AxisId.xBottom, title);
    }
    function topScaleTitle(title) {
      plot.setAxisTitle(Axis.AxisId.xTop, title);
    }
    function leftScaleTitle(title) {
      plot.setAxisTitle(Axis.AxisId.yLeft, title);
    }
    function rightScaleTitle(title) {
      plot.setAxisTitle(Axis.AxisId.yRight, title);
    }

    function scaleTitleFont(index) {
      var font = plot.axisTitleFont(Axis.AxisId.xBottom);
      font.name = PropertiesPane.fontGroup(index);
      plot.setAxisTitleFont(Axis.AxisId.xBottom, font);
      plot.setAxisTitleFont(Axis.AxisId.xTop, font);
      plot.setAxisTitleFont(Axis.AxisId.yLeft, font);
      plot.setAxisTitleFont(Axis.AxisId.yRight, font);
    }
    function scaleTitlePoint(val) {
      var font = plot.axisTitleFont(Axis.AxisId.xBottom);
      font.th = parseInt(val); // * 0.86;
      plot.setAxisTitleFont(Axis.AxisId.xBottom, font);
      plot.setAxisTitleFont(Axis.AxisId.xTop, font);
      plot.setAxisTitleFont(Axis.AxisId.yLeft, font);
      plot.setAxisTitleFont(Axis.AxisId.yRight, font);
    }
    function scaleTitleColor(color) {
      var font = plot.axisTitleFont(Axis.AxisId.xBottom);
      font.fontColor = color;
      plot.setAxisTitleFont(Axis.AxisId.xBottom, font);
      plot.setAxisTitleFont(Axis.AxisId.xTop, font);
      plot.setAxisTitleFont(Axis.AxisId.yLeft, font);
      plot.setAxisTitleFont(Axis.AxisId.yRight, font);
    }
    function scaleTitleBold(checked) {
      var font = plot.axisTitleFont(Axis.AxisId.xBottom);
      if (checked) {
        font.weight = "bold";
      } else {
        font.weight = "normal";
      }
      plot.setAxisTitleFont(Axis.AxisId.xBottom, font);
      plot.setAxisTitleFont(Axis.AxisId.xTop, font);
      plot.setAxisTitleFont(Axis.AxisId.yLeft, font);
      plot.setAxisTitleFont(Axis.AxisId.yRight, font);
    }

    /////////////
    function scaleLabelFont(index) {
      var font = plot.axisLabelFont(Axis.AxisId.xBottom);
      font.name = PropertiesPane.fontGroup(index);
      plot.setAxisLabelFont(Axis.AxisId.xBottom, font);
      plot.setAxisLabelFont(Axis.AxisId.xTop, font);
      plot.setAxisLabelFont(Axis.AxisId.yLeft, font);
      plot.setAxisLabelFont(Axis.AxisId.yRight, font);
    }
    function scaleLabelPoint(val) {
      var font = plot.axisLabelFont(Axis.AxisId.xBottom);
      font.th = parseInt(val); // * 0.86;
      plot.setAxisLabelFont(Axis.AxisId.xBottom, font);
      plot.setAxisLabelFont(Axis.AxisId.xTop, font);
      plot.setAxisLabelFont(Axis.AxisId.yLeft, font);
      plot.setAxisLabelFont(Axis.AxisId.yRight, font);
    }
    function scaleLabelColor(color) {
      var font = plot.axisLabelFont(Axis.AxisId.xBottom);
      font.fontColor = color;
      plot.setAxisLabelFont(Axis.AxisId.xBottom, font);
      plot.setAxisLabelFont(Axis.AxisId.xTop, font);
      plot.setAxisLabelFont(Axis.AxisId.yLeft, font);
      plot.setAxisLabelFont(Axis.AxisId.yRight, font);
    }
    function scaleLabelBold(checked) {
      var font = plot.axisLabelFont(Axis.AxisId.xBottom);
      if (checked) {
        font.weight = "bold";
      } else {
        font.weight = "normal";
      }
      plot.setAxisLabelFont(Axis.AxisId.xBottom, font);
      plot.setAxisLabelFont(Axis.AxisId.xTop, font);
      plot.setAxisLabelFont(Axis.AxisId.yLeft, font);
      plot.setAxisLabelFont(Axis.AxisId.yRight, font);
    }
    ///

    //["NoAttribute", "IncludeReference", "Symmetric", "Floating",  "Inverted"]
    // function scaleAttribute(index) {
    // 	const se = plot.axisScaleEngine(Axis.AxisId.xBottom);
    // 	if(index == 0){
    // 		se.setAttributes(0);
    // 		//se.setAttribute(ScaleEngine.Attributes.NoAttribute, true);
    // 	}
    // 	if(index == 3){
    // 		se.setAttribute(ScaleEngine.Attributes.Floating, true);
    // 	}
    // 	if(index == 4){
    // 		se.setAttribute(ScaleEngine.Attributes.Inverted, true);
    // 	}
    // 	plot.autoRefresh();
    // }

    bottom_log.change(function () {
      bottom_logBase.attr("disabled", false);
      Static.trigger("invalidateWatch");
      plot.setAxisScaleEngine(Axis.AxisId.xBottom, new LogScaleEngine());
      //$("#margin_bottom").val(0);
    });
    bottom_logBase.change(function () {
      Static.trigger("invalidateWatch");
      plot.axisScaleEngine(Axis.AxisId.yLeft).setBase($(this).val());
      plot.autoRefresh();
    });
    bottom_linear.change(function () {
      bottom_logBase.attr("disabled", true);
      Static.trigger("invalidateWatch");
      plot.setAxisScaleEngine(Axis.AxisId.xBottom, new LinearScaleEngine());
      //Static.trigger("invalidateWatch");
      //Static.trigger("curveAdjusted");
      //$("#margin_bottom").val(0)
    });

    left_log.change(function () {
      left_logBase.attr("disabled", false);
      // $("#margin_left").val(0)
      Static.trigger("invalidateWatch");
      plot.setAxisScaleEngine(Axis.AxisId.yLeft, new LogScaleEngine());
    });
    $("#left_logBase").change(function () {
      Static.trigger("invalidateWatch");
      m_plot.axisScaleEngine(Axis.AxisId.yLeft).setBase($(this).val());
      m_plot.autoRefresh();
    });
    left_linear.change(function () {
      left_logBase.attr("disabled", true);
      Static.trigger("invalidateWatch");
      plot.setAxisScaleEngine(Axis.AxisId.yLeft, new LinearScaleEngine());
      //Static.trigger("invalidateWatch");
      //Static.trigger("curveAdjusted");
      //$("#margin_left").val(0);
    });

    top_log.change(function () {
      top_logBase.attr("disabled", false);
      Static.trigger("invalidateWatch");
      plot.setAxisScaleEngine(Axis.AxisId.xTop, new LogScaleEngine());
      //$("#margin_top").val(0)
    });

    top_logBase.change(function () {
      Static.trigger("invalidateWatch");
      plot.axisScaleEngine(Axis.AxisId.yLeft).setBase($(this).val());
      plot.autoRefresh();
    });

    top_linear.change(function () {
      $("#top_logBase").attr("disabled", true);
      Static.trigger("invalidateWatch");
      plot.setAxisScaleEngine(Axis.AxisId.xTop, new LinearScaleEngine());
      // $("#margin_top").val(0);
    });

    right_log.change(function () {
      //console.log(44)
      right_logBase.attr("disabled", false);
      Static.trigger("invalidateWatch");
      plot.setAxisScaleEngine(Axis.AxisId.yRight, new LogScaleEngine());
      //$("#margin_right").val(0);
    });

    right_logBase.change(function () {
      Static.trigger("invalidateWatch");
      plot.axisScaleEngine(Axis.AxisId.yLeft).setBase($(this).val());
      plot.autoRefresh();
    });

    right_linear.change(function () {
      $("#right_logBase").attr("disabled", true);
      Static.trigger("invalidateWatch");
      plot.setAxisScaleEngine(Axis.AxisId.yRight, new LinearScaleEngine());
      // $("#margin_right").val(0);
    });

    bottom_precision.change(function () {
      plot.setAxisPrecision(Axis.AxisId.xBottom, parseInt($(this).val()));
      Static.trigger("invalidateWatch");
      Static.trigger("decimalPlacesChanged");
      bottom_min.val(
        parseFloat(bottom_min.val()).toPrecision(
          parseInt(bottom_precision.val())
        )
      );
      bottom_max.val(
        parseFloat(bottom_max.val()).toPrecision(
          parseInt(bottom_precision.val())
        )
      );
    });

    top_precision.change(function () {
      plot.setAxisPrecision(Axis.AxisId.xTop, parseInt($(this).val()));
      Static.trigger("invalidateWatch");
      Static.trigger("decimalPlacesChanged");
      top_min.val(
        parseFloat(top_min.val()).toPrecision(parseInt(top_precision.val()))
      );
      top_max.val(
        parseFloat(top_max.val()).toPrecision(parseInt(top_precision.val()))
      );
    });
    left_precision.change(function () {
      plot.setAxisPrecision(Axis.AxisId.yLeft, parseInt($(this).val()));
      Static.trigger("invalidateWatch");
      Static.trigger("decimalPlacesChanged");
      left_min.val(
        parseFloat(left_min.val()).toPrecision(parseInt(left_precision.val()))
      );
      left_max.val(
        parseFloat(left_max.val()).toPrecision(parseInt(left_precision.val()))
      );
    });
    right_precision.change(function () {
      plot.setAxisPrecision(Axis.AxisId.yRight, parseInt($(this).val()));
      Static.trigger("invalidateWatch");
      Static.trigger("decimalPlacesChanged");
      right_min.val(
        parseFloat(right_min.val()).toPrecision(parseInt(right_precision.val()))
      );
      right_max.val(
        parseFloat(right_max.val()).toPrecision(parseInt(right_precision.val()))
      );
    });

    bottom_decimalPlaces.val(plot.axisDecimalPlaces(Axis.AxisId.xBottom));
    bottom_decimalPlaces.change(function () {
      plot.setAxisDecimalPlaces(Axis.AxisId.xBottom, parseInt($(this).val()));
      Static.trigger("invalidateWatch");
      Static.trigger("decimalPlacesChanged");
    });

    top_decimalPlaces.val(plot.axisDecimalPlaces(Axis.AxisId.xTop));
    top_decimalPlaces.change(function () {
      plot.setAxisDecimalPlaces(Axis.AxisId.xTop, parseInt($(this).val()));
      Static.trigger("invalidateWatch");
      Static.trigger("decimalPlacesChanged");
    });

    left_decimalPlaces.val(plot.axisDecimalPlaces(Axis.AxisId.yLeft));
    left_decimalPlaces.change(function () {
      plot.setAxisDecimalPlaces(Axis.AxisId.yLeft, parseInt($(this).val()));
      Static.trigger("invalidateWatch");
      Static.trigger("decimalPlacesChanged");
    });

    right_decimalPlaces.val(plot.axisDecimalPlaces(Axis.AxisId.yRight));
    right_decimalPlaces.change(function () {
      plot.setAxisDecimalPlaces(Axis.AxisId.yRight, parseInt($(this).val()));
      Static.trigger("invalidateWatch");
      Static.trigger("decimalPlacesChanged");
    });

    function setReadonly(on) {
      bottom_min.attr("disabled", on);
      bottom_max.attr("disabled", on);
      left_min.attr("disabled", on);
      left_max.attr("disabled", on);
      top_min.attr("disabled", on);
      top_max.attr("disabled", on);
      right_min.attr("disabled", on);
      right_max.attr("disabled", on);
    }
    enableUserScale.change(function () {
      setReadonly(!this.checked);
      //Utility.setAutoScale(plot, !this.checked)
      //initLimitsInput();
      if (left_min.val() !== left_max.val())
        plot.setAxisScale(
          Axis.AxisId.yLeft,
          parseFloat(left_min.val()),
          parseFloat(left_max.val())
        );
      if (bottom_min.val() !== bottom_max.val())
        plot.setAxisScale(
          Axis.AxisId.xBottom,
          parseFloat(bottom_min.val()),
          parseFloat(bottom_max.val())
        );
      if (right_min.val() !== right_max.val())
        plot.setAxisScale(
          Axis.AxisId.yRight,
          parseFloat(right_min.val()),
          parseFloat(right_max.val())
        );
      if (top_min.val() !== top_max.val())
        plot.setAxisScale(
          Axis.AxisId.xTop,
          parseFloat(top_min.val()),
          parseFloat(top_max.val())
        );
    });

    Static.bind("autoScaleChanged", function (e, on) {
      setReadonly(on);
      enableUserScale.prop("checked", !on);
    });

    var curve = null;
    Static.bind("itemAttached", function (e, plotItem, on) {
      if (plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        initLimitsInput();
      }
    });

    Static.bind("scaleDivChanged", function (e) {
      initLimitsInput();
    });

    function initLimitsInput() {
      var intv = plot.axisInterval(Axis.AxisId.xBottom);
      bottom_min.val(
        intv.minValue().toPrecision(parseInt(bottom_precision.val()))
      );
      bottom_max.val(
        intv.maxValue().toPrecision(parseInt(bottom_precision.val()))
      );
      intv = plot.axisInterval(Axis.AxisId.yLeft);
      left_min.val(intv.minValue().toPrecision(parseInt(left_precision.val())));
      left_max.val(intv.maxValue().toPrecision(parseInt(left_precision.val())));
      intv = plot.axisInterval(Axis.AxisId.xTop);
      top_min.val(intv.minValue().toPrecision(parseInt(top_precision.val())));
      top_max.val(intv.maxValue().toPrecision(parseInt(top_precision.val())));
      intv = plot.axisInterval(Axis.AxisId.yRight);
      right_min.val(
        intv.minValue().toPrecision(parseInt(right_precision.val()))
      );
      right_max.val(
        intv.maxValue().toPrecision(parseInt(right_precision.val()))
      );
    }
    bottom_min.change(function () {
      if (bottom_min.val() !== bottom_max.val())
        plot.setAxisScale(
          Axis.AxisId.xBottom,
          parseFloat(bottom_min.val()),
          parseFloat(bottom_max.val())
        );
      const currentCurve = plot.rv.currentCurve();
      if (Static.aspectRatioOneToOne && currentCurve) {
        if (
          currentCurve.yAxis() == Axis.AxisId.yLeft &&
          currentCurve.xAxis() == Axis.AxisId.xBottom &&
          left_min.val() != bottom_min.val()
        ) {
          left_min.val(parseFloat(bottom_min.val()));
          left_min.change();
        }
        if (
          currentCurve.yAxis() == Axis.AxisId.yRight &&
          currentCurve.xAxis() == Axis.AxisId.xBottom &&
          right_min.val() != bottom_min.val()
        ) {
          right_min.val(parseFloat(bottom_min.val()));
          right_min.change();
        }
      }
    });
    bottom_max.change(function () {
      if (bottom_min.val() !== bottom_max.val())
        plot.setAxisScale(
          Axis.AxisId.xBottom,
          parseFloat(bottom_min.val()),
          parseFloat(bottom_max.val())
        );
      const currentCurve = plot.rv.currentCurve();
      if (Static.aspectRatioOneToOne && currentCurve) {
        if (
          currentCurve.yAxis() == Axis.AxisId.yLeft &&
          currentCurve.xAxis() == Axis.AxisId.xBottom &&
          left_max.val() != bottom_max.val()
        ) {
          left_max.val(parseFloat(bottom_max.val()));
          left_max.change();
        }
        if (
          currentCurve.yAxis() == Axis.AxisId.yRight &&
          currentCurve.xAxis() == Axis.AxisId.xBottom &&
          right_max.val() != bottom_max.val()
        ) {
          right_max.val(parseFloat(bottom_max.val()));
          right_max.change();
        }
      }
    });
    top_min.change(function () {
      if (top_min.val() !== top_max.val())
        plot.setAxisScale(
          Axis.AxisId.xTop,
          parseFloat(top_min.val()),
          parseFloat(top_max.val())
        );
      const currentCurve = plot.rv.currentCurve();
      if (Static.aspectRatioOneToOne && currentCurve) {
        if (
          currentCurve.yAxis() == Axis.AxisId.yLeft &&
          currentCurve.xAxis() == Axis.AxisId.xTop &&
          left_min.val() != top_min.val()
        ) {
          left_min.val(parseFloat(top_min.val()));
          left_min.change();
        }
        if (
          currentCurve.yAxis() == Axis.AxisId.yRight &&
          currentCurve.xAxis() == Axis.AxisId.xTop &&
          right_min.val() != top_min.val()
        ) {
          right_min.val(parseFloat(top_min.val()));
          right_min.change();
        }
      }
    });
    top_max.change(function () {
      if (top_min.val() !== top_max.val())
        plot.setAxisScale(
          Axis.AxisId.xTop,
          parseFloat(top_min.val()),
          parseFloat(top_max.val())
        );
      const currentCurve = plot.rv.currentCurve();
      if (Static.aspectRatioOneToOne && currentCurve) {
        if (
          currentCurve.yAxis() == Axis.AxisId.yLeft &&
          currentCurve.xAxis() == Axis.AxisId.xTop &&
          left_max.val() != top_max.val()
        ) {
          left_max.val(parseFloat(top_max.val()));
          left_max.change();
        }
        if (
          currentCurve.yAxis() == Axis.AxisId.yRight &&
          currentCurve.xAxis() == Axis.AxisId.xTop &&
          right_max.val() != top_max.val()
        ) {
          right_max.val(parseFloat(top_max.val()));
          right_max.change();
        }
      }
    });
    left_min.change(function () {
      if (left_min.val() !== left_max.val())
        plot.setAxisScale(
          Axis.AxisId.yLeft,
          parseFloat(left_min.val()),
          parseFloat(left_max.val())
        );
      const currentCurve = plot.rv.currentCurve();
      if (Static.aspectRatioOneToOne && currentCurve) {
        if (
          currentCurve.yAxis() == Axis.AxisId.yLeft &&
          currentCurve.xAxis() == Axis.AxisId.xBottom &&
          bottom_min.val() != left_min.val()
        ) {
          bottom_min.val(parseFloat(left_min.val()));
          bottom_min.change();
        }
        if (
          currentCurve.yAxis() == Axis.AxisId.yLeft &&
          currentCurve.xAxis() == Axis.AxisId.xTop &&
          top_min.val() != left_min.val()
        ) {
          top_min.val(parseFloat(left_min.val()));
          top_min.change();
        }
      }
    });
    left_max.change(function () {
      if (left_min.val() !== left_max.val())
        plot.setAxisScale(
          Axis.AxisId.yLeft,
          parseFloat(left_min.val()),
          parseFloat(left_max.val())
        );
      const currentCurve = plot.rv.currentCurve();
      if (Static.aspectRatioOneToOne && currentCurve) {
        if (
          currentCurve.yAxis() == Axis.AxisId.yLeft &&
          currentCurve.xAxis() == Axis.AxisId.xBottom &&
          bottom_max.val() != left_max.val()
        ) {
          bottom_max.val(parseFloat(left_max.val()));
          bottom_max.change();
        }
        if (
          currentCurve.yAxis() == Axis.AxisId.yLeft &&
          currentCurve.xAxis() == Axis.AxisId.xTop &&
          top_max.val() != left_max.val()
        ) {
          top_max.val(parseFloat(left_max.val()));
          top_max.change();
        }
      }
    });
    right_min.change(function () {
      if (right_min.val() !== right_max.val())
        plot.setAxisScale(
          Axis.AxisId.yRight,
          parseFloat(right_min.val()),
          parseFloat(right_max.val())
        );
      const currentCurve = plot.rv.currentCurve();
      if (Static.aspectRatioOneToOne && currentCurve) {
        if (
          currentCurve.yAxis() == Axis.AxisId.yRight &&
          currentCurve.xAxis() == Axis.AxisId.xBottom &&
          bottom_min.val() != right_min.val()
        ) {
          bottom_min.val(parseFloat(right_min.val()));
          bottom_min.change();
        }
        if (
          currentCurve.yAxis() == Axis.AxisId.yRight &&
          currentCurve.xAxis() == Axis.AxisId.xTop &&
          top_min.val() != right_min.val()
        ) {
          top_min.val(parseFloat(right_min.val()));
          top_min.change();
        }
      }
    });
    right_max.change(function () {
      if (right_min.val() !== right_max.val())
        plot.setAxisScale(
          Axis.AxisId.yRight,
          parseFloat(right_min.val()),
          parseFloat(right_max.val())
        );
      const currentCurve = plot.rv.currentCurve();
      if (Static.aspectRatioOneToOne && currentCurve) {
        if (
          currentCurve.yAxis() == Axis.AxisId.yRight &&
          currentCurve.xAxis() == Axis.AxisId.xBottom &&
          bottom_max.val() != right_max.val()
        ) {
          bottom_max.val(parseFloat(right_max.val()));
          bottom_max.change();
        }
        if (
          currentCurve.yAxis() == Axis.AxisId.yRight &&
          currentCurve.xAxis() == Axis.AxisId.xTop &&
          top_max.val() != right_max.val()
        ) {
          top_max.val(parseFloat(right_max.val()));
          top_max.change();
        }
      }
    });
    /* exponent_lower.change(function () {
			plot.setNonExponentNotationLimits(parseFloat($(this).val()), parseFloat(exponent_upper.val()));
		});

		exponent_upper.change(function () {
			plot.setNonExponentNotationLimits(parseFloat(exponent_lower.val()), parseFloat($(this).val()));
		}); */

    margin_left.change(function () {
      var margin = 0;
      var scaleEngine = plot.axisScaleEngine(Axis.AxisId.yLeft);
      if (scaleEngine instanceof LogScaleEngine) {
        var scaleDiv = plot.axisScaleDiv(Axis.AxisId.yLeft);
        //margin = (Static.mLog(scaleEngine.base(), scaleDiv.upperBound()) - Static.mLog(scaleEngine.base(), scaleDiv.lowerBound()))*$(this).val()/100;
        margin = Static.mLog(scaleEngine.base(), $(this).val());
      } else {
        var intvY = plot.axisInterval(Axis.AxisId.yLeft);
        //margin = intvY.width()*$(this).val()/100;
        margin = $(this).val();
      }
      plot.axisScaleEngine(Axis.AxisId.yLeft).setMargins(margin, margin);
      plot.autoRefresh();
    });

    margin_right.change(function () {
      var margin = 0;
      var scaleEngine = plot.axisScaleEngine(Axis.AxisId.yRight);
      if (scaleEngine instanceof LogScaleEngine) {
        var scaleDiv = plot.axisScaleDiv(Axis.AxisId.yRight);
        //margin = (Static.mLog(scaleEngine.base(), scaleDiv.upperBound()) - Static.mLog(scaleEngine.base(), scaleDiv.lowerBound()))*$(this).val()/100;
        margin = Static.mLog(scaleEngine.base(), $(this).val());
      } else {
        var intvY = plot.axisInterval(Axis.AxisId.yRight);
        //margin = intvY.width()*$(this).val()/100;
        margin = $(this).val();
      }
      plot.axisScaleEngine(Axis.AxisId.yRight).setMargins(margin, margin);
      plot.autoRefresh();
    });

    margin_bottom.change(function () {
      var margin = 0;
      var scaleEngine = plot.axisScaleEngine(Axis.AxisId.xBottom);
      if (scaleEngine instanceof LogScaleEngine) {
        var scaleDiv = plot.axisScaleDiv(Axis.AxisId.xBottom);

        margin = Static.mLog(scaleEngine.base(), $(this).val());
      } else {
        var intvY = plot.axisInterval(Axis.AxisId.xBottom);
        //margin = intvY.width()*$(this).val()/100;
        margin = $(this).val();
      }
      plot.axisScaleEngine(Axis.AxisId.xBottom).setMargins(margin, margin);
      plot.autoRefresh();
    });

    margin_top.change(function () {
      var margin = 0;
      var scaleEngine = plot.axisScaleEngine(Axis.AxisId.xTop);
      if (scaleEngine instanceof LogScaleEngine) {
        var scaleDiv = plot.axisScaleDiv(Axis.AxisId.xTop);

        margin = Static.mLog(scaleEngine.base(), $(this).val());
      } else {
        var intvY = plot.axisInterval(Axis.AxisId.xTop);
        //margin = intvY.width()*$(this).val()/100;
        margin = $(this).val();
      }
      plot.axisScaleEngine(Axis.AxisId.xTop).setMargins(margin, margin);
      plot.autoRefresh();
    });

    show_backbone.change(function () {
      Utility.enableComponent(
        plot,
        AbstractScaleDraw.ScaleComponent.Backbone,
        this.checked
      );
    });
    show_ticks.change(function () {
      Utility.enableComponent(
        plot,
        AbstractScaleDraw.ScaleComponent.Ticks,
        this.checked
      );
      tickLengthRow.toggle(this.checked);
    });

    tick_length.change(function () {
      var map = ["small", "medium", "large"];
      Utility.setTickLength(plot, map[$(this)[0].selectedIndex]);
    });
    show_labels.change(function () {
      Utility.enableComponent(
        plot,
        AbstractScaleDraw.ScaleComponent.Labels,
        this.checked
      );
    });
    point_selection.change(function () {
      var index = $(this)[0].selectedIndex;
      if (index == 1) {
        //console.log("remove");
        plot.curveClosestPoint.setCb(function (curve, point) {
          curve.removePoint(point);
        });
      } else if (index == 2) {
        //console.log("modify");
        plot.curveClosestPoint.setCb(function (curve, point) {
          plot.pointEntryDlg.pointEntryCb(
            "Modify/Remove Point",
            plot,
            curve.title(),
            point
          );
        });
      } else {
        //console.log("display");
        plot.curveClosestPoint.setCb(null);
      }
    });
    addRemovePoint.change(function () {
      plot.addRemovePoint.activate(this.checked);
      if (this.checked) {
        //console.log("addRemovePoint on");
        plot.zm.setTrackerMode(Picker.DisplayMode.AlwaysOff);
        plot.curveSelector.abortSelection();
      } else {
        //console.log("addRemovePoint off");
        plot.zm.setTrackerMode(Picker.DisplayMode.ActiveOnly);
      }
      Static.trigger("addRemovePoint", this.checked);
    });
    errorResponse.change(function () {
      var index = $(this)[0].selectedIndex;
      if (index == 1) {
        //console.log("Utility.warn");
        Utility.errorResponse = Utility.warn;
      } else if (index == 2) {
        //console.log("Utility.silentIgnore");
        Utility.errorResponse = Utility.silentIgnore;
      } else if (index == 3) {
        //console.log("Utility.warnIgnore");
        Utility.errorResponse = Utility.warnIgnore;
      } else {
        //index == 0 stopWarn
        //console.log("Utility.adjustDomain");
        Utility.errorResponse = Utility.adjustDomain;
      }
    });

    Static.bind("currentCurveChanged", function (e, _curve) {
      curve = _curve;
      if (curve) {
        var zoomer = plot.zm;
        if (zoomerAxes[0].checked) {
          zoomer.setAxis(curve.xAxis(), curve.yAxis());
        } else {
          var h = Axis.AxisId.xBottom;
          if (zoomAxisHorizontal[0].selectedIndex == 1) {
            h = Axis.AxisId.xTop;
          }
          var v = Axis.AxisId.yLeft;
          if (zoomAxisVertical[0].selectedIndex == 1) {
            v = Axis.AxisId.yRight;
          }
          zoomer.setAxis(h, v);
        }
      }
      setZoomerAxesInfo();
    });
    /* change via PropertiesPane and via axisDlg respectively */
    Static.bind(
      "curveAxisChangedViaPropertiesPane axisChanged",
      function (e, axis, curve) {
        var zoomer = plot.zm;
        if (zoomerAxes[0].checked) {
          zoomer.setAxis(curve.xAxis(), curve.yAxis());
        } else {
          if (zoomAxisHorizontal[0].selectedIndex == 0) {
            zoomer.setAxis(Axis.AxisId.xBottom, zoomer.yAxis());
          } else {
            zoomer.setAxis(Axis.AxisId.xTop, zoomer.yAxis());
          }
          if (zoomAxisVertical[0].selectedIndex == 0) {
            zoomer.setAxis(zoomer.xAxis(), Axis.AxisId.yLeft);
          } else {
            zoomer.setAxis(zoomer.xAxis(), Axis.AxisId.yRight);
          }
        }
        setZoomerAxesInfo();
      }
    );

    function zoomerAxisControlsDisabled(on) {
      zoomAxisHorizontal.attr("disabled", on);
      zoomAxisVertical.attr("disabled", on);
    }

    zoomAxisVertical.change(function () {
      var zoomer = plot.zm;
      if ($(this)[0].selectedIndex == 0) {
        zoomer.setAxis(zoomer.xAxis(), Axis.AxisId.yLeft);
      } else {
        zoomer.setAxis(zoomer.xAxis(), Axis.AxisId.yRight);
      }
      setZoomerAxesInfo();
    });

    zoomAxisHorizontal.change(function () {
      var zoomer = plot.zm;
      if ($(this)[0].selectedIndex == 0) {
        zoomer.setAxis(Axis.AxisId.xBottom, zoomer.yAxis());
      } else {
        zoomer.setAxis(Axis.AxisId.xTop, zoomer.yAxis());
      }
      setZoomerAxesInfo();
    });

    trackerMode.change(function () {
      plot.zm.setTrackerMode($(this)[0].selectedIndex);
      // var zoomer = plot.zm;
      // if ($(this)[0].selectedIndex == 0) {
      //   zoomer.setAxis(Axis.AxisId.xBottom, zoomer.yAxis());
      // } else {
      //   zoomer.setAxis(Axis.AxisId.xTop, zoomer.yAxis());
      // }
      // setZoomerAxesInfo();
    });

    zoomerAxes.click(function () {
      if ($(this)[0].checked) {
        zoomerAxisControlsDisabled(true);
      } else {
        zoomerAxisControlsDisabled(false);
        var zoomer = plot.zm;
        if (zoomAxisHorizontal[0].selectedIndex == 0) {
          zoomer.setAxis(Axis.AxisId.xBottom, zoomer.yAxis());
        } else {
          zoomer.setAxis(Axis.AxisId.xTop, zoomer.yAxis());
        }
        if (zoomAxisVertical[0].selectedIndex == 0) {
          zoomer.setAxis(zoomer.xAxis(), Axis.AxisId.yLeft);
        } else {
          zoomer.setAxis(zoomer.xAxis(), Axis.AxisId.yRight);
        }
      }
      setZoomerAxesInfo();
      Static.trigger("zoomAccordingToCurve", $(this)[0].checked);
    });

    function setZoomerAxesInfo() {
      var horizontal = "";
      //zoomAxisHorizontal[0].selectedIndex = 0;
      var vertical = "";
      //zoomAxisVertical[0].selectedIndex = 0;
      var zoomer = plot.zm;
      if (zoomerAxes[0].checked && curve) {
        if (curve.yAxis() == Axis.AxisId.yRight) {
          vertical = "Right";
          zoomAxisVertical[0].selectedIndex = 1;
        } else {
          vertical = "Left";
          zoomAxisVertical[0].selectedIndex = 0;
        }
        if (curve.xAxis() == Axis.AxisId.xTop) {
          horizontal = "Top";
          zoomAxisHorizontal[0].selectedIndex = 1;
        } else {
          horizontal = "Bottom";
          zoomAxisHorizontal[0].selectedIndex = 0;
        }
      } else {
        if (zoomAxisHorizontal[0].selectedIndex == 1) {
          horizontal = "Top";
        } else {
          horizontal = "Bottom";
        }
        if (zoomAxisVertical[0].selectedIndex == 1) {
          vertical = "Right";
        } else {
          vertical = "Left";
        }
      }
      zoomerSettings.html(horizontal + ", " + vertical);
    }
    function setMagnifierAxesInfo() {
      var info = "";
      var left = "";
      var right = "";
      var bottom = "";
      var top = "";
      var magnifier = plot.magnifier;
      if (magnifier.isAxisEnabled(Axis.AxisId.yLeft)) {
        left = "Left";
      }
      if (magnifier.isAxisEnabled(Axis.AxisId.yRight)) {
        right = "Right";
      }
      if (magnifier.isAxisEnabled(Axis.AxisId.xBottom)) {
        bottom = "Bottom";
      }
      if (magnifier.isAxisEnabled(Axis.AxisId.xTop)) {
        top = "Top";
      }

      var previousInfoLength = 0;
      info = info + left;
      if (
        info.length > previousInfoLength &&
        (right.length || bottom.length || top.length)
      )
        info = info + ", ";
      previousInfoLength = info.length;
      info = info + right;
      if (info.length > previousInfoLength && (bottom.length || top.length))
        info = info + ", ";
      previousInfoLength = info.length;
      info = info + bottom;
      if (info.length > previousInfoLength && top.length) info = info + ", ";
      info = info + top;
      if (info == "") info = "No axis enabled";
      magnifierSettings.html(info);
    }
    magnifierLeftAxis.change(function () {
      plot.magnifier.setAxisEnabled(Axis.AxisId.yLeft, this.checked);
      setMagnifierAxesInfo();
    });
    magnifierRightAxis.change(function () {
      plot.magnifier.setAxisEnabled(Axis.AxisId.yRight, this.checked);
      setMagnifierAxesInfo();
    });
    magnifierBottomAxis.change(function () {
      plot.magnifier.setAxisEnabled(Axis.AxisId.xBottom, this.checked);
      setMagnifierAxesInfo();
    });
    magnifierTopAxis.change(function () {
      plot.magnifier.setAxisEnabled(Axis.AxisId.xTop, this.checked);
      setMagnifierAxesInfo();
    });

    function watchShadeIcon(color) {
      var val = 12; //parseFloat($("#sizeSymbol").val());
      var size = new Misc.Size(val, val);
      var height = val;
      var width = val;
      // var graphic = new GraphicUtil.Graphic(null, width, height);
      var graphic = new Graphic(null, width, height);
      var painter = new PaintUtil.Painter(graphic);
      painter.setBrush(new Misc.Brush(color));
      var rc = new Misc.Rect(new Misc.Point(), new Misc.Size(val, val));
      rc.moveCenter(new Misc.Point(val / 2, val / 2));
      painter.drawRect(rc.left(), rc.top(), rc.width(), rc.height());
      painter = null;
      return graphic;
    }

    function setBrushIcon(color) {
      //curvePenIcon_td
      var icon = watchShadeIcon(color);
      if (watchShading[0].children) $(watchShading[0].children[0]).remove();
      if (icon && watchShadeWatchArea[0].checked) icon.setParent(watchShading);
    }

    function setWatchInfo() {
      var info = "";
      var accuracy = "";
      var shade = "No shade";
      if (Static.accuracyFactor == Static.accuracyFactorModerate * 2) {
        accuracy = "Low";
      }
      if (Static.accuracyFactor == Static.accuracyFactorModerate) {
        accuracy = "Moderate";
      }
      if (Static.accuracyFactor == Static.accuracyFactorModerate * 0.01) {
        accuracy = "High";
      }
      if (watchShadeWatchArea[0].checked) {
        shade = "Shade ";
      }
      watchCalculationAccuracy.html(accuracy);
      watchSettings.html(accuracy + "; " + shade);
      if (watchShadeWatchArea[0].checked)
        watchShadeIcon(watchShadeColor.val()).setParent(watchSettings);
    }
    watchCalculationAccuracyLow.change(function () {
      //console.log("Low");
      Static.accuracyFactor = Static.accuracyFactorModerate * 2; //Step is equivalent to 2 px
      setWatchInfo();
      Static.trigger("invalidateWatch");
      Static.trigger("calculationAccuracy");
    });
    watchCalculationAccuracyModerate.change(function () {
      //console.log("Moderate");
      Static.accuracyFactor = Static.accuracyFactorModerate; //Step is equivalent to 1 px
      setWatchInfo();
      Static.trigger("invalidateWatch");
      Static.trigger("calculationAccuracy");
    });
    watchCalculationAccuracyHigh.change(function () {
      //console.log("High");
      Static.accuracyFactor = Static.accuracyFactorModerate * 0.01; //Step is equivalent to 0.01 px
      setWatchInfo();
      Static.trigger("invalidateWatch");
      Static.trigger("calculationAccuracy");
    });
    watchShadeWatchArea.change(function () {
      self.shadeWatchArea = watchShadeWatchArea[0].checked;
      if (self.shadeWatchArea) watchShadeColor.attr("disabled", false);
      else watchShadeColor.attr("disabled", true);
      setWatchInfo();

      setBrushIcon(watchShadeColor.val());
      Static.trigger("shadeWatchArea", self.shadeWatchArea);
    });

    watchShadeColor.change(function () {
      setBrushIcon($(this).val());
      setWatchInfo();
      Static.trigger("curveShapeColorChanged", $(this).val());
    });

    watchShadeAutoScale.change(function () {
      //Static.watchCentroidWithArea = $(this)[0].checked;
      Static.trigger("autoScaleCurveShapeItem", $(this)[0].checked);
    });

    //Static.watchCentroidWithArea = true;
    watchCentroidWithArea.change(function () {
      //Static.watchCentroidWithArea = $(this)[0].checked;
      Static.trigger("watchCentroidWithArea", $(this)[0].checked);
    });

    minor_divisions.change(function () {
      //Static.showsymbol = this.checked
      var value = Math.min(Math.max(2, $(this).val()), 20);
      minor_divisions.val(value);
      //console.log(value)
      plot.setAxisMaxMinor(Axis.AxisId.yLeft, value);
      plot.setAxisMaxMinor(Axis.AxisId.yRight, value);
      plot.setAxisMaxMinor(Axis.AxisId.xTop, value);
      plot.setAxisMaxMinor(Axis.AxisId.xBottom, value);
    });
    major_divisions.change(function () {
      //Static.showsymbol = this.checked
      var value = Math.min(Math.max(1, $(this).val()), 40);
      major_divisions.val(value);
      plot.setAxisMaxMajor(Axis.AxisId.yLeft, $(this).val());
      plot.setAxisMaxMajor(Axis.AxisId.yRight, $(this).val());
      plot.setAxisMaxMajor(Axis.AxisId.xTop, $(this).val());
      plot.setAxisMaxMajor(Axis.AxisId.xBottom, $(this).val());
    });
    minor_line_color.change(function () {
      var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
      grid.setMinorPen(minor_line_color[0].value);
    });
    major_line_color.change(function () {
      var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
      grid.setMajorPen(major_line_color[0].value);
    });
    major_gridLines.change(function () {
      var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
      Utility.majorGridLines(grid, $(this)[0].checked);
      minor_gridLines.attr("disabled", !$(this)[0].checked);
    });
    Static.bind("majorGridLines", function (e, grid, on) {
      major_gridLines[0].checked = on;
      minor_gridLines.attr("disabled", !on);
    });
    minor_gridLines.change(function () {
      var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
      Utility.minorGridLines(grid, $(this)[0].checked);
    }); //gridAxisHorizontal
    Static.bind("minorGridLines", function (e, grid, on) {
      minor_gridLines[0].checked = on;
    });

    /////////////////////////////////////////////////
    Static.bind("currentCurveChanged", function (e, _curve) {
      curve = _curve;
      if (curve) {
        var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
        if (gridAxes[0].checked) {
          grid.setAxes(curve.xAxis(), curve.yAxis());
        } else {
          var h = Axis.AxisId.xBottom;
          if (gridAxisHorizontal[0].selectedIndex == 1) {
            h = Axis.AxisId.xTop;
          }
          var v = Axis.AxisId.yLeft;
          if (gridAxisVertical[0].selectedIndex == 1) {
            v = Axis.AxisId.yRight;
          }
          grid.setAxes(h, v);
        }
      }
      setGridAxesInfo();
    });
    /* change via PropertiesPane and via axisDlg respectively */
    Static.bind(
      "curveAxisChangedViaPropertiesPane axisChanged",
      function (e, axis, curve) {
        var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
        if (gridAxes[0].checked) {
          grid.setAxes(curve.xAxis(), curve.yAxis());
        } else {
          if (gridAxisHorizontal[0].selectedIndex == 0) {
            grid.setAxes(Axis.AxisId.xBottom, grid.yAxis());
          } else {
            grid.setAxes(Axis.AxisId.xTop, grid.yAxis());
          }
          if (zoomAxisVertical[0].selectedIndex == 0) {
            grid.setAxes(grid.xAxis(), Axis.AxisId.yLeft);
          } else {
            grid.setAxes(grid.xAxis(), Axis.AxisId.yRight);
          }
        }
        setGridAxesInfo();
      }
    );

    Static.bind("pSel", function (e, on) {
      if (on) {
        self.show("pointSelected");
        addRemovePoint[0].checked = false;
        addRemovePoint.trigger("change");
        plot.curveSelector.setEnabled(false);
      } else {
        self.hide("pointSelected");
      }
    });

    Static.bind("curveSel", function (e, on) {
      if (on) {
        self.show("pointSelected");
        addRemovePoint[0].checked = false;
        addRemovePoint.trigger("change");
        //plot.curveSelector.setEnabled(false);
      } else {
        self.hide("pointSelected");
      }
    });

    function gridAxisControlsDisabled(on) {
      gridAxisHorizontal.attr("disabled", on);
      gridAxisVertical.attr("disabled", on);
    }

    gridAxisVertical.change(function () {
      var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
      if ($(this)[0].selectedIndex == 0) {
        grid.setAxes(grid.xAxis(), Axis.AxisId.yLeft);
      } else {
        grid.setAxes(grid.xAxis(), Axis.AxisId.yRight);
      }
      setGridAxesInfo();
    });

    gridAxisHorizontal.change(function () {
      var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
      if ($(this)[0].selectedIndex == 0) {
        grid.setAxes(Axis.AxisId.xBottom, grid.yAxis());
      } else {
        grid.setAxes(Axis.AxisId.xTop, grid.yAxis());
      }
      setGridAxesInfo();
    });

    gridAxes.click(function () {
      if ($(this)[0].checked) {
        gridAxisControlsDisabled(true);
      } else {
        gridAxisControlsDisabled(false);
        var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
        if (gridAxisHorizontal[0].selectedIndex == 0) {
          grid.setAxes(Axis.AxisId.xBottom, grid.yAxis());
        } else {
          grid.setAxes(Axis.AxisId.xTop, grid.yAxis());
        }
        if (gridAxisVertical[0].selectedIndex == 0) {
          grid.setAxes(grid.xAxis(), Axis.AxisId.yLeft);
        } else {
          grid.setAxes(grid.xAxis(), Axis.AxisId.yRight);
        }
      }
      setGridAxesInfo();
      Static.trigger("gridlinesAccordingToCurve", $(this)[0].checked);
    });

    function setGridAxesInfo() {
      var horizontal = "";
      //gridAxisHorizontal[0].selectedIndex = 0;
      var vertical = "";
      //gridAxisVertical[0].selectedIndex = 0;
      var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
      if (gridAxes[0].checked && curve) {
        if (curve.yAxis() == Axis.AxisId.yRight) {
          vertical = "Right";
          gridAxisVertical[0].selectedIndex = 1;
        } else {
          vertical = "Left";
          gridAxisVertical[0].selectedIndex = 0;
        }
        if (curve.xAxis() == Axis.AxisId.xTop) {
          horizontal = "Top";
          gridAxisHorizontal[0].selectedIndex = 1;
        } else {
          horizontal = "Bottom";
          gridAxisHorizontal[0].selectedIndex = 0;
        }
      } else {
        if (gridAxisHorizontal[0].selectedIndex == 1) {
          horizontal = "Top";
        } else {
          horizontal = "Bottom";
        }
        if (gridAxisVertical[0].selectedIndex == 1) {
          vertical = "Right";
        } else {
          vertical = "Left";
        }
      }
      gridSettings.html(horizontal + ", " + vertical);
    }
    /////////////////////////////////////////////////////

    function aspectRatioOneToOneFn() {
      /* if (Static.aspectRatioOneToOne) {
        self.hide("scalePositionBottomAttribute");
        self.hide("scalePositionTopAttribute");
        self.hide("scalePositionLeftAttribute");
        self.hide("scalePositionRightAttribute");
      } else {
        self.show("scalePositionBottomAttribute");
        self.show("scalePositionTopAttribute");
        self.show("scalePositionLeftAttribute");
        self.show("scalePositionRightAttribute");
      } */

      //bottom_Reference.attr("disabled", Static.aspectRatioOneToOne);
      bottom_IncludeReference.attr("disabled", Static.aspectRatioOneToOne);
      bottom_Symmetric.attr("disabled", Static.aspectRatioOneToOne);
      bottom_Floating.attr("disabled", Static.aspectRatioOneToOne);
      bottom_Inverted.attr("disabled", Static.aspectRatioOneToOne);

      //top_Reference.attr("disabled", Static.aspectRatioOneToOne);
      top_IncludeReference.attr("disabled", Static.aspectRatioOneToOne);
      top_Symmetric.attr("disabled", Static.aspectRatioOneToOne);
      top_Floating.attr("disabled", Static.aspectRatioOneToOne);
      top_Inverted.attr("disabled", Static.aspectRatioOneToOne);

      //left_Reference.attr("disabled", Static.aspectRatioOneToOne);
      left_IncludeReference.attr("disabled", Static.aspectRatioOneToOne);
      left_Symmetric.attr("disabled", Static.aspectRatioOneToOne);
      left_Floating.attr("disabled", Static.aspectRatioOneToOne);
      left_Inverted.attr("disabled", Static.aspectRatioOneToOne);

      //right_Reference.attr("disabled", Static.aspectRatioOneToOne);
      right_IncludeReference.attr("disabled", Static.aspectRatioOneToOne);
      right_Symmetric.attr("disabled", Static.aspectRatioOneToOne);
      right_Floating.attr("disabled", Static.aspectRatioOneToOne);
      right_Inverted.attr("disabled", Static.aspectRatioOneToOne);

      if (!Static.aspectRatioOneToOne) {
        if (bottom_IncludeReference[0].checked) {
          bottom_Reference.attr("disabled", false);
        } else {
          bottom_Reference.attr("disabled", true);
        }
      } else {
        bottom_Reference.attr("disabled", true);
      }

      if (!Static.aspectRatioOneToOne) {
        if (right_IncludeReference[0].checked) {
          right_Reference.attr("disabled", false);
        } else {
          right_Reference.attr("disabled", true);
        }
      } else {
        right_Reference.attr("disabled", true);
      }

      if (!Static.aspectRatioOneToOne) {
        if (top_IncludeReference[0].checked) {
          top_Reference.attr("disabled", false);
        } else {
          top_Reference.attr("disabled", true);
        }
      } else {
        top_Reference.attr("disabled", true);
      }

      if (!Static.aspectRatioOneToOne) {
        if (left_IncludeReference[0].checked) {
          left_Reference.attr("disabled", false);
        } else {
          left_Reference.attr("disabled", true);
        }
      } else {
        left_Reference.attr("disabled", true);
      }
    }

    Static.bind("aspectRatioChanged", function () {
      aspectRatioOneToOneFn();
    });

    function initControls() {
      aspectRatioOneToOneFn();
      zoomerAxisControlsDisabled(true);
      setZoomerAxesInfo();
      setGridAxesInfo();
      setMagnifierAxesInfo();
      setWatchInfo();
      setBrushIcon(watchShadeColor.val());
      plotTitleTitleSelector.val(plot.title());
      initLimitsInput();
      var grid = plot.itemList(PlotItem.RttiValues.Rtti_PlotGrid)[0];
      //console.log(grid.xMinEnabled())
      minor_gridLines[0].checked = grid.xMinEnabled();
      major_gridLines[0].checked = grid.xEnabled();
      bottomScaleTitle.val(plot.axisTitle(Axis.AxisId.xBottom));
      topScaleTitle.val(plot.axisTitle(Axis.AxisId.xTop));
      leftScaleTitle.val(plot.axisTitle(Axis.AxisId.yLeft));
      rightScaleTitle.val(plot.axisTitle(Axis.AxisId.yRight));

      minor_line_color.val(Utility.colorNameToHex(grid.minorPen()));
      major_line_color.val(Utility.colorNameToHex(grid.majorPen()));
      //console.log(minor_line_color)

      self.hide("pointSelected");
      /* self.hide("lowerLimitY");
      self.hide("upperLimitY");
      self.hide("lowerLimitXY");
      self.hide("upperLimitXY");
      self.hide("color1Min");
      self.hide("color2Max");
      self.hide("threeDType"); */
    }

    initControls();

    // self.hide("pointSelected");
    //self.hide("upperLimit");
  }
}
;
define("plotPropertiesPane", ["propertiesPane"], function(){});



/**
 * Attributes of an entry on a legend.
 *
 * LegendData is a container to exchange attributes, that are only known to the plot-item and legend. By overloading
 * PlotItem.legendData() different attributes and a modified ( or completely different ) implementation of a legend could be used.
 *
 */
class LegendData extends EnumBase {
  constructor() {
    super();
    var m_map = {};
    var m_empty = true;

    /**
     * Returns the value of the TitleRole attribute
     * @returns {LegendData.Role}
     */
    this.title = function () {
      return this.value(LegendData.Role.TitleRole);
    };

    /**
     * Returns value of the IconRole attribute
     * @returns {LegendData.Role}
     */
    this.icon = function () {
      return this.value(LegendData.Role.IconRole);
    };

    /**
     * Returns value of the ModeRole attribute
     * @returns {(LegendData.Role | LegendData.Mode)}
     */
    this.mode = function () {
      if (this.hasRole(LegendData.Role.ModeRole))
        return this.value(LegendData.Role.ModeRole);
      return LegendData.Mode.ReadOnly;
    };

    /**
     * Set an attribute value
     * @param {Number} role Attribute role
     * @param {var} Attribute value Attribute value
     */
    this.setValue = function (role, val) {
      //m_data.push({role:role, value:val});
      m_map[role] = val;
      m_empty = false;
    };

    /**
     * Returns true when the internal map is empty
     * @returns {Boolean} true/false
     */
    this.isValid = function () {
      return !m_empty;
    };

    /**
     * Returns true when the internal map has an entry for role
     * @param {Number} role Attribute role
     * @returns {Boolean} role true / false
     */
    this.hasRole = function (role) {
      return contains(role);
    };

    /**
     * @param {Number} role Attribute role
     * @returns {Number} Attribute value for a specific role
     */
    this.value = function (role) {
      if (!contains(role)) return null;
      return m_map[role];
    };

    function contains(role) {
      if (typeof m_map[role] === "undefined") return false;
      return true;
    }

    /**
     *
     * @returns {String} A string representing the object.
     */
    this.toString = function () {
      return "[LegendData]";
    };
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link LegendData.Mode}</div>
 *
 * Mode defining how a legend entry interacts.
 * @name LegendData.Mode
 * @readonly
 * @property {Number} ReadOnly          The legend item is not interactive, like a label.
 * @property {Number} Clickable         The legend item is clickable, like a push button.
 * @property {Number} Checkable         The legend item is checkable, like a checkable button.
 *
 */
Enumerator.enum("Mode { ReadOnly , Clickable , Checkable }", LegendData);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link LegendData.Role}</div>
 *
 * Identifier instructing how to interpret data. The UserRole has a value of 32
 * @name LegendData.Role
 * @readonly
 * @property {Number} ModeRole          The value is a mode.
 * @property {Number} TitleRole         The value is a title.
 * @property {Number} IconRole          The value is an icon.
 * @property {Number} UserRole          Values < UserRole are reserved for internal use.
 */
Enumerator.enum(
  "Role { ModeRole , TitleRole , IconRole , UserRole = 32 }",
  LegendData
);

/**
 * Abstract base class for legend widgets.
 *
 * Legends under control of the Plot layout system need to be derived from AbstractLegend.
 * @abstract
 */
class AbstractLegend {
  constructor() {
    Utility.makeAbstract(this, AbstractLegend);
    var m_plot = null;
    //var m_checked = false;
    var m_legendDiv = null;
    var m_maxChar = ""; //Number of characters in longest label
    //var m_iconWidth = 0;
    var m_maxWidth = 100;
    var margin = 8;
    var m_checkChangeFn = function (plotItem, check) {
      plotItem.setVisible(!check);
      //if (!m_plot.autoReplot()) m_plot.replot();
      m_plot.autoRefresh();
    };

    if (typeof checkChangeFn !== "undefined") m_checkChangeFn = checkChangeFn;

    var m_itemList = [];

    this.indexInLegend = function (plotItem) {
      return m_itemList.indexOf(plotItem);
    };

    var tbl = $("<table/>");

    this.legendTableElement = function () {
      return tbl;
    };

    /**
     * Set the DIV element that houses the legend.
     * @param {HTMLElement} div DIV element housing the legend
     */
    this.setLegendDiv = function (div) {
      if (m_legendDiv) {
        return;
      }
      m_legendDiv = div;
      m_legendDiv.append(tbl);
      m_legendDiv.css("overflow", "auto");
    };

    /**
     * Get the DIV element that houses the legend.
     * @returns {HTMLElement} DIV element
     */
    this.legendDiv = function () {
      return m_legendDiv;
    };

    /**
     * Associate the lengend with a plot. The plot becomes the owner (parent) of the legend and the layout system
     * is able to magnage changes in size and position.
     * @param {Plot} plot the plot that owns the legend.
     */
    this.setPlot = function (plot) {
      m_plot = plot;
      if (m_legendDiv !== $("#legendDiv")) {
        plot.getLayout().getPlotDiv().append(m_legendDiv);
      }
    };

    /**
     * Returns true if the legend contains no items.
     * @returns {Boolean} true / false
     */
    this.isEmpty = function () {
      return tbl[0].rows.length >= 1 ? false : true;
    };

    /**
     * Sets the width that would not be exceeded by the legend. The legend width expands or shrinks based on the width
     * of legend items. Horizontal scroll bars are introduce at max width.
     * @param {Number} width max width.
     */
    this.setMaxWidth = function (width) {
      m_maxWidth = width;
    };

    /**
     * Returns the width that the legend will not exceed.
     * @returns {Number} maximum width
     */
    this.maxWidth = function () {
      return m_maxWidth;
    };

    this.maxIconWidth = function () {
      let w = 0;
      const items = m_plot.itemList();
      for (let i = 0; i < items.length; i++) {
        var itemData = items[i].legendData()[0];
        if (!itemData.isValid()) continue;
        var icon = itemData.icon();
        if (icon && icon.width() > w) w = icon.width();
      }
      return w;
    };

    /**
     * Calculates and returns the width of the legend DIV element. The calculation considers each lengend item's text, font, icon size and margin.
     * The value returned is never greater than maximum width.
     * @returns {Number} lengend width
     */
    this.legendDivWidth = function () {
      var w =
        //m_plot.legendFont().textSize(m_maxChar).width + m_iconWidth + margin;
        m_plot.legendFont().textSize(m_maxChar).width +
        this.maxIconWidth() +
        margin;
      return w < this.maxWidth() ? w : this.maxWidth();
    };

    //Helper
    function reIndexRowElement(rowElement, newIndex) {
      var Children = $(rowElement).parent().children();
      var target = Children[newIndex];

      if ($(rowElement).index() > newIndex) {
        if (target == null) {
          target = Children[0];
        }
        if (target != rowElement && target != null) {
          $(target).before(rowElement);
        }
      } else {
        if (target == null) {
          target = Children[Children.length - 1];
        }
        if (target != rowElement && target != null) {
          $(target).after(rowElement);
        }
      }
    }

    const mj = function (tex) {
      return MathJax.tex2svg(tex, { em: 16, ex: 6, display: false });
    };

    this.setTooltip = function (rowIndex, tooltip) {
      const toolTipSpanElem = $($(tbl.find("TR")[rowIndex]).find("SPAN")[1]);
      const tooltipParts = tooltip.split("\n");

      try {
        // display and re-render the expression
        MathJax.typesetClear();
        toolTipSpanElem[0].innerHTML = "";

        if (tooltipParts[1]) {
          let child0 = mj(tooltipParts[0]);
          let tooltipParts1 = tooltipParts[1]
            .replace("Inflection point", "Infltn.~point")
            .replace("Turning point", "Turning~point")
            .replace("Intersection point", "Intersn.~point");

          let child = Utility.tex2svgMultiline(tooltipParts1, 60, {
            em: 16,
            ex: 6,
            display: false,
          });

          child.innerHTML = child0.innerHTML + `<br>` + child.innerHTML;
          toolTipSpanElem[0].appendChild(child);
        } else {
          let child = mj(tooltipParts[0]);
          toolTipSpanElem[0].appendChild(child);
        }
      } catch (err) {}
    };

    let rightClickActive = false;
    let dontScroll = false;

    this.doAddItem = function (plotItem, rowNumber) {
      function accumRowHeight(rowIndex) {
        const rows = tbl.find("TR");
        let result = 0;
        for (let i = 0; i <= rowIndex; i++) {
          result += parseInt($(rows[i]).css("height"));
        }
        return result;
      }

      let delayExpired = false;

      let hover = false;
      let tm = null;
      let mouseDown = false;
      function showTooltip(rowIndex, show = true) {
        if (!Static.showTooltipLegend) {
          return;
        }
        const toolTipSpanElem = $($(tbl.find("TR")[rowIndex]).find("SPAN")[1]);

        if (show) {
          clearTimeout(tm);
          tm = setTimeout(function () {
            if (!hover || mouseDown) return;
            if (rightClickActive) return;

            const rows = tbl.find("TR");
            for (let i = 0; i < rows.length; i++) {
              $($(rows[i]).find("SPAN")[1]).css("visibility", "hidden");
            }
            toolTipSpanElem.css("visibility", "visible");
          }, 500);
        } else {
          toolTipSpanElem.css("visibility", "hidden");
        }
      }

      var font = plotItem.plot().legendFont();

      var itemData = plotItem.legendData()[0];

      if (!itemData.isValid()) return;

      var title = itemData.title();
      var icon = itemData.icon();

      //if (icon && icon.width() > m_iconWidth) m_iconWidth = icon.width();
      var row = $("<tr></tr>");

      var tdElem = $('<td class="unchecked"></td>');
      var textLabel = $("<label/>");
      textLabel.css("color", font.fontColor);
      textLabel.css("font-size", font.th);
      textLabel.css("font-weight", font.weight);
      textLabel.css("font-family", font.name);
      textLabel.text(" " + title);

      var spanElem = $("<span></span>");
      var toolTipSpanElem = $("<span class='legendTooltip'></span>");
      //We store the unmodified title in the curveName attribute. The title in the label may be modified by adding space
      //or by locale translation.
      spanElem.attr("curveName", title);
      if (icon) icon.setParent(spanElem);
      textLabel.appendTo(spanElem);
      spanElem.appendTo(tdElem);
      toolTipSpanElem.appendTo(tdElem);

      //toolTipSpanElem.appendTo(m_plot.getLayout().getCentralDiv());

      row.append(tdElem);

      tbl.append(row);

      if (rowNumber !== undefined && rowNumber > -1) {
        m_itemList.splice(rowNumber, 0, plotItem);
        reIndexRowElement(row, rowNumber);
      } else {
        m_itemList.push(plotItem);
      }

      let scrollTop = 0;

      row.on("mouseenter", function (e) {
        if (mouseDown) return;
        hover = true;
        const hasScroll =
          m_legendDiv[0].scrollHeight > m_legendDiv[0].offsetHeight;
        //console.log(hasScroll);
        const toolTipSpanElem = $($(this).find("SPAN")[1]);
        if (toolTipSpanElem.html() == "") {
          return;
        }
        const tBarHeight = parseInt(m_plot.tbar.html().css("height"));
        let legendTop = parseInt(m_legendDiv.css("top")) + tBarHeight;
        let topOfTooltip = 0;

        //console.log($(":root")[0].style.getPropertyValue("--main-bg-color"));
        //toolTipSpanElem.css("background-color", Static.tooltipLegendBackground);
        //font-family:Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
        //toolTipSpanElem.css("font-family", "Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif");
        //use top arrow
        toolTipSpanElem.removeClass("legendTooltip1");
        toolTipSpanElem.addClass("legendTooltip");
        topOfTooltip = legendTop + accumRowHeight(row.index());

        if (
          topOfTooltip - parseInt(toolTipSpanElem.css("height")) >
          legendTop +
            m_legendDiv.scrollTop() +
            0.5 * parseInt(row.css("height"))
        ) {
          //use bottom arrow
          toolTipSpanElem.removeClass("legendTooltip");
          toolTipSpanElem.addClass("legendTooltip1");
          //$(".legendTooltip1:after").css("border-color", "#7e5730 transparent transparent transparent");

          topOfTooltip =
            legendTop +
            accumRowHeight(row.index()) -
            parseInt(toolTipSpanElem.css("height")) -
            parseInt(row.css("height"));
        }

        if (hasScroll) {
          topOfTooltip = Math.min(
            topOfTooltip,
            topOfTooltip - m_legendDiv[0].scrollTop
          );
        }

        toolTipSpanElem.css("top", topOfTooltip + 16);
        toolTipSpanElem.css(
          "left",
          parseInt(m_plot.plotDiv.css("left")) +
            parseInt(m_plot.plotDiv.css("width")) -
            parseInt(toolTipSpanElem.css("width")) -
            0.6 * parseInt(row.css("width"))
        );
        showTooltip($(this).index());
      });

      row.on("mouseleave", function (e) {
        if (mouseDown) return;
        hover = false;
        showTooltip($(this).index(), false);
      });

      m_legendDiv.on("scroll", function () {
        //console.log(486);
        if (dontScroll || rightClickActive) {
          $(this).scrollTop(scrollTop);
        } else {
          scrollTop = m_legendDiv[0].scrollTop;
        }
      });

      $(window).on("mousemove", function (e) {
        dontScroll = false;
      });

      row.on("mousedown", function (e) {
        dontScroll = true;
        rightClickActive = false;
        if (e.which == 3) {
          rightClickActive = true;
          showTooltip($(this).index(), false);
        }
      });

      $(window).on("mousedown", function (e) {
        mouseDown = true;
        if (e.which !== 3) {
          rightClickActive = false;
        }
      });

      $(window).on("mouseup", function (e) {
        mouseDown = false;
        //rightClickActive = false;
      });

      tdElem.on("click", plotItem, function (event) {
        showTooltip($(this).parent().index(), false);
        hover = false;
        //dontScroll = true;
        let m_checked = false;
        if ($(this).attr("class") === "unchecked") {
          $(this).removeClass("unchecked");
          $(this).addClass("checked");
          m_checked = true;
        } else {
          $(this).removeClass("checked");
          $(this).addClass("unchecked");
          //m_checked = false;
        }
        if (m_checkChangeFn) m_checkChangeFn(event.data, m_checked);
      });

      if (!plotItem.isVisible()) {
        tdElem.click();
      }

      if (plotItem.title().length > m_maxChar.length)
        m_maxChar = plotItem.title();

      //Static.trigger("legendToolTipChanged", plotItem);
    };

    Static.bind("hideAllItems", function () {
      const elements = tbl.find("TD");
      for (let i = 0; i < elements.length; i++) {
        $(elements[i]).removeClass("unchecked");
        $(elements[i]).addClass("checked");
      }
    });

    Static.bind("showAllItems", function () {
      const elements = tbl.find("TD");
      for (let i = 0; i < elements.length; i++) {
        $(elements[i]).removeClass("checked");
        $(elements[i]).addClass("unchecked");
      }
    });

    // Static.bind("legendToolTipChanged", function (e, _curve) {
    //   var rowNumber = m_itemList.indexOf(_curve);
    //   const horizontal =
    //     _curve.xAxis() == Axis.AxisId.xBottom ? "Bottom" : "Top";
    //   const vertical = _curve.yAxis() == Axis.AxisId.yLeft ? "Left" : "Right";
    //   let fn = "f(x): N/A";
    //   //if (_curve.fn) fn = `f(${_curve.variable}): ${_curve.fn}`;
    //   //_curve = 0;
    //   let title = "Axes: " + horizontal + ", " + vertical;
    //   if (_curve.fn) title += "\n" + `f(${_curve.variable}): ${_curve.fn}`;
    //   $(tbl[0].rows[rowNumber]).attr("title", title);
    //   _curve = 0;
    // });

    // Static.bind("axisChanged", function (e, axis, _curve) {
    //   Static.trigger("legendToolTipChanged", _curve);
    // });

    function removeElementAt(index) {
      if (index > -1) {
        m_itemList.splice(index, 1);
      }
    }

    //Helper
    function removeClickFromTDElement(rowIndex) {
      $(tbl[0].rows[rowIndex].children[0]).off("click");
    }

    /**
     * Find the legend item representing plotItem and remove it from the lengend.
     * @param {PlotItem} plotItem plot item represented by the legend item to remove
     */
    this.removeItem = function (plotItem) {
      var rowNumber = m_itemList.indexOf(plotItem);
      if (rowNumber < 0) return;
      removeElementAt(rowNumber);
      removeClickFromTDElement(rowNumber);
      //$(tbl[0].rows[rowNumber]).off("titleChanged");
      tbl[0].deleteRow(rowNumber);
      if (parseInt(tbl.css("height")) < parseInt(m_legendDiv.css("height"))) {
        m_legendDiv.css("overflow-y", "auto");
      }
      if (parseInt(tbl.css("width")) < parseInt(m_legendDiv.css("width"))) {
        m_legendDiv.css("overflow-x", "auto");
      }

      return rowNumber;
    };

    /**
     * Remove all legend items from the legend.
     */
    this.clearLegend = function () {
      var numRows = tbl[0].rows.length;
      for (var i = 0; i < numRows; ++i) {
        tbl[0].deleteRow(0);
      }
    };

    /**
     * Get the position (zero index) of the legend item in the legend.
     * @param {String} name the title of the legend item
     * @returns {Number} zero index row number on success or -1 on failure
     */
    this.rowNumberFromName = function (name) {
      var Rows = tbl[0].rows;
      for (var i = 0; i < Rows.length; ++i) {
        if (Rows[i].cells[0].innerText === name) return i;
      }
      return -1; //not found
    };
  }

  /**
   *
   * @returns {String} A string representing the object.
   */
  toString() {
    return "[AbstractLegend]";
  }

  //Subclass overwrite this method.>>>>>>>>>>>>>
  //! \return True, when no plot item is inserted
  /* isEmpty() {
        return true;
    }; */
  //Subclass overwrite this method.
  /*!
    Render the legend into a given rectangle.

    \param painter Painter
    \param rect Bounding rectangle
    \param fillBackground When true, fill rect with the widget background

    \sa renderLegend() is used by QwtPlotRenderer
     */
  renderLegend(painter, rect, fillBackground) {
    return true;
  }
  //Subclass overwrite this method.
  /*!
    \brief Update the entries for a plot item

    \param itemInfo Info about an item
    \param data List of legend entry attributes for the  item
     */
  updateLegend(itemInfo, data) {}

  /**
   * Build a legend item that represents the plot item and add it to the legend.
   *
   * If a row number argument > -1 is provided, the legend item is inserted at that row number. Otherwise, the lengend item is
   * appended to the bottom of the legend.
   * @param {PlotItem} plotItem
   * @param {Number} [rowNumber] Zero index position of the legend item
   */
  addItem(plotItem, rowNumber) {
    this.doAddItem(plotItem, rowNumber);
  }
}

/**
 * The legend widget.
 *
 * The Legend widget is a tabular arrangement of legend items. Legend items might be any type of widget, but in general
 * they will be a Label.
 * @extends AbstractLegend
 */
class Legend extends AbstractLegend {
  constructor() {
    super();
  }
  /**
   *
   * @returns {String} A string representing the object.
   */
  toString() {
    return "[Legend]";
  }
}
;
define("legend", ["static"], function(){});

"include ['legend']";

class MyLegend extends Legend {
  constructor() {
    super();
    const self = this;

    this.updateLegendToolTip = function (_curve) {
      let indepVarX = null;
      let indepVarY = null;
      let precisionY = _curve.plot().axisPrecision(_curve.yAxis());
      let precisionX = _curve.plot().axisPrecision(_curve.xAxis());
      let decimalPlacesY = _curve.plot().axisDecimalPlaces(_curve.yAxis());
      let decimalPlacesX = _curve.plot().axisDecimalPlaces(_curve.xAxis());

      let fnStr = null;
      let fnStrLatex = _curve.latex;
      if (
        (_curve.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
          _curve.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram) &&
        _curve.functionDlgData
      ) {
        fnStr = `f(${_curve.functionDlgData.variable}, ${_curve.functionDlgData.variableY}): ${_curve.fn}`;
      }
      if (_curve.rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        if (_curve.parametricFnX && _curve.parametricFnY) {
          let parametricFnX = _curve.parametricFnX;
          if (!isNaN(parametricFnX)) {
            parametricFnX = Utility.toPrecision(
              Utility.adjustForDecimalPlaces(parametricFnX, decimalPlacesX),
              precisionX
            );
          }
          let parametricFnY = _curve.parametricFnY;
          if (!isNaN(parametricFnY)) {
            parametricFnY = Utility.toPrecision(
              Utility.adjustForDecimalPlaces(parametricFnY, decimalPlacesY),
              precisionY
            );
          }
          fnStr = `Parametric(${_curve.parametric_variable}): (${parametricFnX}, ${parametricFnY})`;
        } else if (_curve.fn) {
          precisionY;
          let fn_y = _curve.fn;
          if (!isNaN(fn_y)) {
            fn_y = Utility.toPrecision(
              Utility.adjustForDecimalPlaces(_curve.fn, decimalPlacesY),
              precisionY
            );
          }
          fnStr = `f(${_curve.variable}): ${fn_y}`;
        }
      }
      if (_curve.rtti == PlotItem.RttiValues.Rtti_PlotMarker) {
        const val = _curve.value();
        fnStr = `${_curve.toolTipValueName} (${Utility.toPrecision(
          Utility.adjustForDecimalPlaces(val.x, decimalPlacesX),
          precisionX
        )}, ${Utility.toPrecision(
          Utility.adjustForDecimalPlaces(val.y, decimalPlacesY),
          precisionY
        )})`;
      }
      var rowNumber = self.indexInLegend(_curve);
      const horizontal =
        _curve.xAxis() == Axis.AxisId.xBottom ? "Bottom" : "Top";
      const vertical = _curve.yAxis() == Axis.AxisId.yLeft ? "Left" : "Right";
      //let fn = "f(x): N/A";
      let title = "Axes: " + horizontal + ", " + vertical;

      if (fnStr) {
        const arr = fnStr.split(":");
        fnStr = arr[1];

        if (arr.length < 2) {
          return;
        }
        fnStr = fnStr.replaceAll(" ", "");

        let parametricArr = [];
        let parametricObj = Utility.splitParametricFunction(fnStr);
        if (!parametricObj) {
          parametricArr.push(fnStr);
        } else {
          parametricArr.push(parametricObj.operand);
          parametricArr.push(parametricObj.base);
        }

        let m_fnConcat = "";

        for (let i = 0; i < parametricArr.length; i++) {
          let fnStr = parametricArr[i];

          // let ind = fnStr.indexOf("^");
          // while (ind !== -1 /* && index - 3 >= 0 */) {
          //   const prefix = Utility.getExponentTokenPrefix(fnStr, ind);
          //   let obj = Utility.getOperandOfExponentToken(fnStr, ind);
          //   if (obj.operand.length > 1 && obj.operand[0] !== "(") {
          //     fnStr = fnStr.replace(
          //       `${prefix}^${obj.operand[0]}`,
          //       `(${prefix}^${obj.operand[0]})`
          //     );
          //   }
          //   ind = fnStr.indexOf("^", ind + 2);
          // }

          //Replace the whitespace delimiters stripped out by simplify()
          fnStr = fnStr.replaceAll("mod", " mod ");

          let m_fn = "";
          if (_curve.rtti == PlotItem.RttiValues.Rtti_PlotMarker) {
            m_fn = fnStr;
          } else {
            Utility.adjustLatexLogBaseDecimalPlaces(decimalPlacesX);
            fnStr = fnStr.replaceAll("+-", "-").replaceAll("-+", "-");
            //nerdamer.flush();
            // m_fn = math
            //   .parse(fnStr)
            //   .toTex({ parenthesis: "auto", implicit: "hide" });
            m_fn = math
              .simplify(fnStr, {}, { exactFractions: false })
              .toTex({ parenthesis: "auto", implicit: "hide" });

            //.simplify(fnStr, {}, { exactFractions: false })
            Utility.restoreLatexLogBaseDecimalPlaces();
          }

          let ind = m_fn.indexOf("log(");
          while (ind !== -1) {
            let operand = Utility.getOperand(m_fn, "log", ind).operand;
            const obj = Utility.splitParametricFunction(operand);
            m_fn = m_fn.replace(
              `log${operand}`,
              `\\mathrm{log_{${obj.base}}}\\left(${obj.operand}\\right)`
            );
            ind = m_fn.indexOf("log(");
          }

          if (parametricArr.length > 1) {
            if (i == 0) {
              m_fnConcat += "(";
              m_fnConcat += m_fn;
              m_fnConcat += ",";
            } else {
              m_fnConcat += m_fn;
              m_fnConcat += ")";
            }
          } else {
            m_fnConcat += m_fn;
          }
        }
        title += "\n" + `${arr[0]}:` + m_fnConcat;
      }
      self.setTooltip(rowNumber, title);
      _curve = 0;
    };

    Static.bind("legendUpdated", function (e, _curve) {
      self.updateLegendToolTip(_curve);
    });

    Static.bind("axisChanged", function (e, axis, _curve) {
      self.updateLegendToolTip(_curve);
    });

    Static.bind("itemAttached", function (e, plotItem, on) {
      if (
        on &&
        (plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
          plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve ||
          plotItem.rtti == PlotItem.RttiValues.Rtti_PlotZone ||
          plotItem.rtti == PlotItem.RttiValues.Rtti_PlotMarker ||
          plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram)
      ) {
        //console.log(plotItem);
        self.updateLegendToolTip(plotItem);
      }
    });
  }
}
;
define("myLegend", ["legend"], function(){});

"include ['static','widgetOverlay', 'plotMarker']";

class MyOverlay extends WidgetOverlay {
  //function MyOverlay(widget){
  constructor(widget, eventObject) {
    super(widget);
    //WidgetOverlay.call(this, widget);////////////////
    var self = this;

    this.eventObject = eventObject;

    this.toString = function () {
      return "[MyOverlay]";
    };
  }
  drawOverlay(painter) {
    let xMap = this.curve.plot().canvasMap(this.curve.xAxis());
    let yMap = this.curve.plot().canvasMap(this.curve.yAxis());

    let cx = xMap.transform(this.eventObject.p.x);
    let cy = yMap.transform(this.eventObject.p.y);
    //console.log("point: ("+ cx + ", "+cy+")");
    painter.setBrush(new Misc.Brush("lightGrey"));
    painter.drawCircle(cx, cy, 8);
  }
}

class CurveSegmentWidgetOverlay extends WidgetOverlay {
  constructor(widget, eventObject) {
    super(widget);
    var self = this;

    this.eventObject = eventObject;

    this.toString = function () {
      return "[MyOverlay]";
    };
  }
  drawOverlay(painter) {
    const curve = this.curve;
    const plot = curve.plot();
    let xMap = plot.canvasMap(curve.xAxis());
    let yMap = plot.canvasMap(curve.yAxis());

    //console.log(plot);
    let p = {};
    painter.setBrush(new Misc.Brush("lightGrey"));
    painter.drawCircle(
      this.eventObject.clientPt.x,
      this.eventObject.clientPt.y,
      8
    );

    let samples = curve.data().samples();
    //console.log(this.eventObject.indexOfSelectedPoint)

    let otherPoint = null;

    painter.setPen(new Misc.Pen(curve.pen().color, 1, "dash"));

    if (samples.length == 1) {
      p = ScaleMap.transform(xMap, yMap, this.eventObject.p);
    } else if (samples.length == 2) {
      if (this.eventObject.indexOfSelectedPoint == 0) {
        otherPoint = samples[1];
      } else {
        otherPoint = samples[0];
      }
      p.x = xMap.transform(otherPoint.x);
      p.y = yMap.transform(otherPoint.y);
    } else if (samples.length > 2) {
      if (this.eventObject.indexOfSelectedPoint == 0) {
        otherPoint = samples[1];
        p = ScaleMap.transform(xMap, yMap, otherPoint);
      } else if (this.eventObject.indexOfSelectedPoint == samples.length - 1) {
        otherPoint = samples[samples.length - 2];
        p = ScaleMap.transform(xMap, yMap, otherPoint);
      } else {
        otherPoint = samples[this.eventObject.indexOfSelectedPoint - 1];
        p = ScaleMap.transform(xMap, yMap, otherPoint);
        let otherPoint2 = samples[this.eventObject.indexOfSelectedPoint + 1];
        let p2 = ScaleMap.transform(xMap, yMap, otherPoint2);
        painter.drawLine(p2, this.eventObject.clientPt);
      }
    }
    //console.log(this.curve.title(), this.eventObject.indexOfSelectedPoint);
    this.eventObject.moved = true;
    this.eventObject.samples = samples;

    painter.drawLine(p, this.eventObject.clientPt);
  }
}

class MyObject extends HObject {
  constructor(plot, cb) {
    super();
    var self = this;
    this._plot = plot;
    this._dmin = 10;
    this._cb == null;
    this.selected = false;
    //this.selectedCurve = false;
    this.button = Static.LeftButton;
    this.modifiers = Static.NoModifier;

    this.drawSegment = false;
    this.moved = false;

    this.panEnabled = false;
    this.zmEnabled = false;

    if (cb !== undefined) this._cb = cb;

    this.selectorWidgetOverlay = new MyOverlay(plot.getCentralWidget(), this);
    this.curveSegmentWidgetOverlay = new CurveSegmentWidgetOverlay(
      plot.getCentralWidget(),
      this
    );

    Static.bind("visibilityChange", function (e, curve, on) {
      if (self.selectorWidgetOverlay.curve !== curve) return;
      if (!on) {
        self.selectorWidgetOverlay.clearCanvas();
        this.selected = false;
      }
    });

    this.toString = function () {
      return "[MyObject]";
    };

    // this.undoStack = [];
    // this.redoStack = [];

    this.mouseUp = function (event) {
      this.drawSegment = false;
      this.curveSegmentWidgetOverlay.clearCanvas();

      if (this.moved) {
        const curve = this.curveSegmentWidgetOverlay.curve;

        const plot = this.curveSegmentWidgetOverlay.curve.plot();

        //const curve = this.curveSegmentWidgetOverlay.curve;
        let newPos = ScaleMap.invTransform(
          plot.axisScaleDraw(curve.xAxis()).scaleMap(),
          plot.axisScaleDraw(curve.yAxis()).scaleMap(),
          this.clientPt
        );
        //store the udo data before sample modification
        //const samples = this.samples.map((a) => Object.assign({}, a)); //store a copy of the samples
        const samples = this.samples.map(function(e){
          return new Misc.Point(e);
        });
        MyObject.undoStack.push({ curve, samples });
        this.samples[this.indexOfSelectedPoint] = newPos;

        this.samples.sort(function (a, b) {
          return a.x - b.x;
        });
        curve.setSamples(this.samples);

        Static.trigger(
          "currentCurveChangedEnds",
          this.selectorWidgetOverlay.curve
        );
        plot.rv.setCurrentCurve(this.previousCurrentCurve);
        Static.trigger("currentCurveChanged", this.previousCurrentCurve);

        this.previousCurrentCurve = null;

        plot.autoRefresh();
      }
      this.moved = false;

      if (this.zmEnabled) {
        plot.zm.setEnabled(true);
        //plot.pan.setEnabled(false);
        this.zmEnabled = false;
      }

      if (this.panEnabled) {
        plot.pan.setEnabled(true);
        //plot.zm.setEnabled(false);
        this.panEnabled = false;
      }
    };

    this.mouseClick = function (event) {
      if (
        event.button == this.button &&
        Utility.modifiers(event) == this.modifiers
      ) {
        if (this.selected) {
          //console.log("point: ("+ p.x + ", "+p.y+")")
          if (this._cb == null)
            alert(
              "Curve: " +
                this.selectorWidgetOverlay.curve.title() +
                "; point: (" +
                this.p.x +
                ", " +
                this.p.y +
                ")"
            );
          else {
            this._cb(this.selectorWidgetOverlay.curve, this.p);
          }
          //this.selected = false;
        }
        //this.selected = false;
        //return false;
      }
      return true;
    };

    function setAlignment(pt) {
      var curve = self.selectorWidgetOverlay.curve;
      var xs = plot.axisScaleDiv(curve.xAxis());
      var ys = plot.axisScaleDiv(curve.yAxis());
      var rect = new Misc.Rect(
        xs.lowerBound(),
        ys.lowerBound(),
        xs.range(),
        ys.range()
      );
      rect = rect.normalized();
      var alignment = 0;
      alignment |=
        pt.x < rect.left() + 0.3 * rect.width()
          ? Static.AlignRight
          : Static.AlignLeft;
      alignment |=
        pt.y - 0.3 * rect.height() > rect.top()
          ? Static.AlignBottom
          : Static.AlignTop;
      self.mPos.setLabelAlignment(alignment);
    }

    this.showMarker = function (point) {
      this.dragStartPoint = point;
      var doReplot = plot.autoReplot();
      plot.setAutoReplot(false);
      var curve = this.selectorWidgetOverlay.curve;
      self.mPos.setAxes(curve.xAxis(), curve.yAxis());

      setAlignment(point);
      self.mPos.setVisible(true);
      self.mPos.setValue(point);

      var xVal = Utility.toPrecision(
        point.x,
        plot.axisPrecision(curve.xAxis())
      );
      var yVal = Utility.toPrecision(
        point.y,
        plot.axisPrecision(curve.yAxis())
      );

      self.mPos.setLabel("(" + xVal.toString() + ", " + yVal.toString() + ")");
      plot.setAutoReplot(doReplot);
      plot.autoRefresh();
    };

    this.hideMarker = function () {
      self.mPos.setVisible(false);
    };

    Static.bind("itemAttached", function (e, plotItem, on) {
      if (plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        if(!on){
          MyObject.undoStack = MyObject.undoStack.filter(function(e){
            return e.curve != plotItem;
          });
          MyObject.redoStack = MyObject.undoStack.filter(function(e){
            return e.curve != plotItem;
          });
        }
      }
    });
  }

  eventFilter(watched, event) {
    if (event.type === "keydown") {
      if (event.ctrlKey) {
        //if (this.dragIndex < 0) return;
        if (event.keyCode === 90) {
          event.preventDefault();
          //console.log("undo");
          //const curve = this.curveSegmentWidgetOverlay.curve;
          const dragData = MyObject.undoStack.pop();
          if (!dragData) return;
          //store the redo data
          const curve = dragData.curve;
          // const samples = curve
          //   .data()
          //   .samples()
          //   .map((a) => Object.assign({}, a)); //store a copy of the samples

            const samples = curve
            .data()
            .samples().map(function(e){
              return new Misc.Point(e);
            });

            

          MyObject.redoStack.push({ curve, samples });

          dragData.curve.setSamples(dragData.samples);
          dragData.curve.plot().autoRefresh();
          Static.trigger("undoRedoOperation", curve);
          return;
        }
        if (event.keyCode === 89) {
          event.preventDefault();
          //console.log("redo");
          //const curve = this.curveSegmentWidgetOverlay.curve;
          const dragData = MyObject.redoStack.pop();
          if (!dragData) return;
          //const curve =
          //store the undo data
          const curve = dragData.curve;
          // const samples = curve
          //   .data()
          //   .samples()
          //   .map((a) => Object.assign({}, a)); //store a copy of the samples

            const samples = curve
            .data()
            .samples().map(function(e){
              return new Misc.Point(e);
            });
          MyObject.undoStack.push({ curve, samples });

          dragData.curve.setSamples(dragData.samples);
          dragData.curve.plot().autoRefresh();
          Static.trigger("undoRedoOperation", curve);
          return;
        }
      }
    }

    if (Static.isMobile()) {
      if (event.type == "touchstart") {
        //console.log(watched)
        let curves = this._plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
        if (!curves.length) return;

        var pt = watched.mapToElement({
          x: event.originalEvent.touches[0].clientX,
          y: event.originalEvent.touches[0].clientY,
        });

        let dist = {
          distance: -1,
        };
        let curvePointIndex = -1;
        let curvePointIndexAtDmin = -1;

        let dmin = 1.0e10;
        let indexInCurvesListAtDmin = -1;

        for (var i = 0; i < curves.length; ++i) {
          if (
            !curves[i].isVisible() ||
            curves[i].data().toString() == "[SyntheticPointData]"
          )
            continue;
          curvePointIndex = curves[i].closestPoint(pt, dist);
          if (dist.distance < dmin) {
            dmin = dist.distance;
            indexInCurvesListAtDmin = i;
            curvePointIndexAtDmin = curvePointIndex;
          }
        }
        if (curvePointIndexAtDmin == -1) return;

        this.p = curves[indexInCurvesListAtDmin].data().samples()[
          curvePointIndexAtDmin
        ];

        if (dmin < this._dmin) {
          if (this._cb == null)
            alert(
              "Curve: " +
                curves[indexInCurvesListAtDmin].title() +
                "; point: (" +
                this.p.x +
                ", " +
                this.p.y +
                ")"
            );
          else {
            this._cb(curves[indexInCurvesListAtDmin], this.p);
          }
        }
      }
      return;
    } else if (event.type == "click" /* || event.type == 'touchstart' */) {
      /* if ( !isMobile){
        if( event.button != m_mouseButton || Utility.modifiers(event) !== buttonModifiers)
        return true;
        } */
      this.mouseClick(event);
    } else if (event.type == "mousedown" /* || event.type == 'touchstart' */) {
      if (this.selected) {
        this.drawSegment = true;
        const plot = this.curveSegmentWidgetOverlay.curve.plot();
        this.zmEnabled = plot.zm.isEnabled();
        if (this.zmEnabled) {
          plot.zm.setEnabled(false);
        }
        this.panEnabled = plot.pan.isEnabled();
        if (this.panEnabled) {
          plot.pan.setEnabled(false);
        }
      }
    } else if (event.type == "mouseup" /* || event.type == 'touchstart' */) {
      this.mouseUp(event);
    } else if (event.type == "mouseleave" /* || event.type == 'touchstart' */) {
      this.moved = 0;
      this.previousCurrentCurve = null;
      this.mouseUp(event);

      if (this.selected) {
        this.selectorWidgetOverlay.clearCanvas();
        this.selected = false;
      }
    } else if (event.type == "mousemove" /*  || event.type == 'touchmove' */) {
      event.preventDefault();
      //console.log(watched)
      let curves = this._plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
      if (!curves.length) return;
      var pt = watched.mapToElement({
        x: event.clientX,
        y: event.clientY,
      });
      this.clientPt = pt;

      /* if (event.originalEvent.changedTouches)//event.type == "touchmove")
            pt = watched.mapToElement({
            x: event.originalEvent.changedTouches[0].clientX,
            y: event.originalEvent.changedTouches[0].clientY
            }); */

      let dist = {
        distance: -1,
      };
      let curvePointIndex = -1;
      let curvePointIndexAtDmin = -1;

      let dmin = 1.0e10;
      let indexInCurvesListAtDmin = -1;

      for (var i = 0; i < curves.length; ++i) {
        if (
          !curves[i].isVisible() ||
          curves[i].data().toString() == "[SyntheticPointData]"
        )
          continue;
        curvePointIndex = curves[i].closestPoint(pt, dist);
        if (dist.distance < dmin) {
          dmin = dist.distance;
          indexInCurvesListAtDmin = i;
          curvePointIndexAtDmin = curvePointIndex;
          if (!this.drawSegment) {
            this.indexOfSelectedPoint = curvePointIndexAtDmin;

            // this.mPos.setAxes(
            //   curves[indexInCurvesListAtDmin].xAxis(),
            //   curves[indexInCurvesListAtDmin].yAxis()
            // );
          }
        }
      }
      if (curvePointIndexAtDmin == -1) return;
      if (
        curves[indexInCurvesListAtDmin].data().toString() ==
        "[SyntheticPointData]"
      )
        return;
      this.p = curves[indexInCurvesListAtDmin].data().samples()[
        curvePointIndexAtDmin
      ];

      ////////////////
      if (this.drawSegment) {
        const plot = this.curveSegmentWidgetOverlay.curve.plot();

        if (!this.previousCurrentCurve) {
          this.previousCurrentCurve = plot.rv.currentCurve();
          plot.rv.setCurrentCurve(this.selectorWidgetOverlay.curve);
          Static.trigger(
            "currentCurveChanged",
            this.selectorWidgetOverlay.curve
          );
          //console.log(plot.rv.currentCurve().title());
        }

        this.curveSegmentWidgetOverlay.draw();
        // }
      }
      //////////////////
      if (!this.selected) {
        this.selectorWidgetOverlay.clearCanvas();
      }
      if (!this.previousCurrentCurve && dmin < this._dmin) {
        this.curveSegmentWidgetOverlay.curve =
          this.selectorWidgetOverlay.curve = curves[indexInCurvesListAtDmin];
        if (!this.selected) {
          this.selectorWidgetOverlay.draw();
          this.selected = true;
          this.showMarker(this.p);
          //if (!this.drawSegment) this.indexOfSelectedPoint = curvePointIndex;
          Static.trigger("pointSelected");
        }
      } else {
        this.selected = false;
        this.hideMarker();
        Static.trigger("pointNotSelected");
      }
    }
    return true;
  }
}

MyObject.undoStack = [];
MyObject.redoStack = [];

class CurveClosestPoint {
  constructor(plot, cb) {
    const self = this;
    this.eventHandlingObject = new MyObject(plot, cb);
    if (cb !== undefined) this.eventHandlingObject.cb = cb;
    this.cw = plot.getCentralWidget();
    this.cw.setEnabled_1(true);
    //this.cw.installEventFilter(this.eventHandlingObject);
    //this.eventHandlingObject.wo = new MyOverlay(plot.getCentralWidget(), this.eventHandlingObject);
    this.eventHandlingObject.mPos = new PlotMarker("ClosestPointMarker123@###");
    var labelFont = this.eventHandlingObject.mPos.labelFont();
    labelFont.th = 14;
    labelFont.fontColor = "red";
    //labelFont.weight = "bold";
    //console.log(labelFont)
    this.eventHandlingObject.mPos.setLabelFont(labelFont);
    //this.mPos.setItemAttribute( PlotItem.ItemAttribute.Legend, true );
    //mPos.setSymbol(new ArrowSymbol() );
    //this.eventHandlingObject.mPos.setValue(new Misc.Point( 500, 500 ) );
    //this.eventHandlingObject.mPos.setZ(50000);
    //this.eventHandlingObject.mPos.setLabel("AAAAAb");
    //this.eventHandlingObject.mPos.setLabelAlignment( Static.AlignRight | Static.AlignBottom );

    this.eventHandlingObject.mPos.attach(plot);
    this.eventHandlingObject.mPos.setVisible(false);

    //DOCS Undo Redo operation not allowed for a curve in an open table.
    Static.bind("pointsTableUpdated", function (e, curve) {});
  }

  setDistance(dist) {
    this.eventHandlingObject._dmin = dist;
  }

  setEnabled(on) {
    //this.cw.setEnabled_1(on);
    if (on) {
      this.cw.installEventFilter(this.eventHandlingObject);
    } else {
      this.cw.removeEventFilter(this.eventHandlingObject);
      this.eventHandlingObject.selectorWidgetOverlay.clearCanvas();
    }
  }

  setCb(cb) {
    this.eventHandlingObject._cb = cb;
  }

  setMousePattern(button, modifiers) {
    this.eventHandlingObject.button = button;
    this.eventHandlingObject.modifiers = modifiers;
  }
}
;
define("curveClosestPoint", ["static","widgetOverlay","plotMarker"], function(){});



/**
 * A Widget which contains a scale.
 *
 * This Widget can be used to decorate composite widgets with a scale.
 * @extends Widget
 */
class ScaleWidget extends Widget {
  constructor(plot, domDivElem, align) {
    super(domDivElem);
    var m_domDiv = this.getElement(); //domDivElem;
    var m_scaleDraw = null;
    var m_title = "";
    var m_plot = plot;

    var minBorderDist = [];
    var borderDist = [];

    var m_titleFont = new Misc.Font(14);
    var m_scaleFont = new Misc.Font(12);

    /**
     * Specify distances of the scale's endpoints from the
     * widget's borders. The actual borders will never be less
     * than minimum border distance.
     * @param {Number} dist1 Left or top Distance
     * @param {Number} dist2 Right or bottom distance
     */
    this.setBorderDist = function (dist1, dist2) {
      if (dist1 != borderDist[0] || dist2 != borderDist[1]) {
        borderDist[0] = dist1;
        borderDist[1] = dist2;
        //layoutScale();
      }
    };

    /**
     * Calculate a hint for the border distances.
     *
     * This member function calculates the distance of the scale's
     * endpoints from the widget borders which is required for the
     * mark labels to fit into the widget. The maximum of this distance
     * and the minimum border distance is returned.
     * @param {object} startAndEndObj Object with two properties: start (for the border width at the beginning of the scale) and end (for the border width at the end of the scale)
     */
    this.getBorderDistHint = function (startAndEndObj) {
      m_scaleDraw.getBorderDistHint(m_scaleFont, startAndEndObj);

      if (startAndEndObj.start < minBorderDist[0])
        startAndEndObj.start = minBorderDist[0];

      if (startAndEndObj.end < minBorderDist[1])
        startAndEndObj.end = minBorderDist[1];
    };

    /**
     * Change the label's font
     * @param {Misc.Font} font New font
     */
    this.setLabelFont = function (fontObj) {
      if (fontObj.th < 0 || fontObj.name === "" || fontObj.style === "") return;
      m_scaleFont = fontObj;
      m_plot.getLayout().adjustLayout(domDivElem, fontObj.th);
    };

    /**
     *
     * @returns {Misc.Font} font use in label
     */
    this.labelFont = function () {
      return m_scaleFont;
    };

    /**
     * Change the title's font
     * @param {Misc.Font} font New font
     */
    this.setTitleFont = function (fontObj) {
      if (fontObj.th < 0 || fontObj.name === "" || fontObj.style === "") return;
      m_titleFont = fontObj;
      m_plot.getLayout().adjustLayout(domDivElem, fontObj.th);
    };

    /**
     *
     * @returns {Misc.Font} font use in title
     */
    this.titleFont = function () {
      return m_titleFont;
    };

    /**
     * Set a scale draw
     *
     * scaleDraw has to be created with new and will be initialized with
     * the attributes of the previous scaleDraw object.
     * @param {ScaleDraw} scaleDraw ScaleDraw object
     */
    this.setScaleDraw = function (scaleDraw) {
      if (typeof scaleDraw == "undefined" || scaleDraw == m_scaleDraw) return;

      var sd = m_scaleDraw;
      if (sd) {
        //scaleDraw.setAlignment( m_scaleDraw.alignment() );
        scaleDraw.setScaleDiv(m_scaleDraw.scaleDiv());

        var transform = null;
        if (m_scaleDraw.scaleMap().transformation())
          transform = m_scaleDraw.scaleMap().transformation().copy();

        scaleDraw.setTransformation(transform);
      }

      //delete d_data->scaleDraw;
      m_scaleDraw = scaleDraw;

      //layoutScale();
    };

    /**
     *
     * @returns {ScaleDraw} scaleDraw of this scale
     */
    this.scaleDraw = function () {
      return m_scaleDraw;
    };

    //! Initialize the scale
    this.initScale = function (align) {
      m_scaleDraw = new ScaleDraw();
      m_scaleDraw.setAlignment(align);
      //m_scaleDraw.setLength( 10 );

      var linearScaleEngine = new LinearScaleEngine();
      m_scaleDraw.setScaleDiv(linearScaleEngine.divideScale(0.0, 100.0, 10, 5));
    };

    if (typeof align === "undefined")
      this.initScale(ScaleDraw.Alignment.LeftScale);
    else this.initScale(align);

    /**
     * Give title new text contents
     * @param {String} title New title
     */
    this.setTitle = function (title) {
      //alert(m_titleFont.th)
      if (m_title === title) return;
      if (title !== "") {
        if (m_title === "") {
          //We are adding a title for the first time. adjust the layout to accomodate it
          //alert(title)
          if (
            this.alignment() === ScaleDraw.Alignment.LeftScale ||
            this.alignment() === ScaleDraw.Alignment.RightScale
          ) {
            m_plot
              .getLayout()
              .adjustLayout(
                m_domDiv,
                parseFloat(m_domDiv.css("width")) + m_titleFont.th
              );
          } else {
            m_plot
              .getLayout()
              .adjustLayout(
                m_domDiv,
                parseFloat(m_domDiv.css("height")) + m_titleFont.th
              );
          }
          Static.trigger("axisTitleAdded", true);
        }
        m_title = title;
      } else {
        //We are clearing the title. reclaim the space
        if (
          this.alignment() === ScaleDraw.Alignment.LeftScale ||
          this.alignment() === ScaleDraw.Alignment.RightScale
        ) {
          m_plot
            .getLayout()
            .adjustLayout(
              m_domDiv,
              parseFloat(m_domDiv.css("width")) - m_titleFont.th
            );
        } else {
          m_plot
            .getLayout()
            .adjustLayout(
              m_domDiv,
              parseFloat(m_domDiv.css("height")) - m_titleFont.th
            );
        }
        m_title = "";
        Static.trigger("axisTitleAdded", false);
      }
      m_plot.getLayout().updateLayout();
    };

    /**
     *
     * @returns {String} title of the scale
     */
    this.title = function () {
      return m_title;
    };

    /**
     * Change the alignment
     * @param {ScaleDraw.Alignment} alignment New alignment
     */
    this.setAlignment = function (alignment) {
      if (m_scaleDraw) m_scaleDraw.setAlignment(alignment);
    };

    /**
     *
     * @returns {ScaleDraw.Alignment} the alignment
     */
    this.alignment = function () {
      if (m_scaleDraw == null) return ScaleDraw.Alignment.LeftScale;

      return m_scaleDraw.alignment();
    };

    /**
     * Calculate the label width
     * @param {String} str label
     * @returns {Number} width of the label
     */
    this.labelWidth = function (str) {
      return m_scaleFont.textSize(str).width;
    };

    /**
     * Draw the scale
     */
    this.draw = function () {
      //alert(painter)
      //var context = this.getContext();
      var longestTick = m_scaleDraw.maxTickLength();
      var spacingBetweenLabelAndTick = m_scaleDraw.spacing();
      var spacingBetweenTitleAndLabel = 10;
      var margin = 10;
      if (m_scaleDraw.orientation() === Static.Vertical) {
        //Compute the required width of widget

        var longestLbl = this.labelWidth(m_scaleDraw.longestLabel());
        var titleWidth = m_title !== "" ? m_titleFont.th : 0; //Title is vertical
        var widgetWidth =
          longestTick +
          spacingBetweenLabelAndTick +
          longestLbl +
          spacingBetweenTitleAndLabel +
          titleWidth +
          margin;

        m_plot.getLayout().adjustLayout(m_domDiv, widgetWidth);
      }
      if (m_scaleDraw.orientation() === Static.Horizontal) {
        var titleHeight = m_title !== "" ? m_titleFont.th : 0;

        var widgetHeight =
          longestTick +
          spacingBetweenLabelAndTick +
          m_scaleFont.th +
          spacingBetweenTitleAndLabel +
          titleHeight +
          margin;

        m_plot.getLayout().adjustLayout(m_domDiv, widgetHeight);
      }
      m_plot.getLayout().updateLayout();

      //We may very likely be painting widgets that are not visible
      var painter = new PaintUtil.Painter(this);
      painter.setFont(m_scaleFont);

      m_scaleDraw.draw(painter);
      if (m_title !== "") {
        painter.setFont(m_titleFont);
        this.drawTitle(painter);
      }
      painter = null;
    };

    /**
     * Rotate and paint a title according to its position.
     * @param {PaintUtil.Painter} painter Painter
     */
    this.drawTitle = function (painter) {
      var canvasWidth = painter.canvasWidth();
      var canvasHeight = painter.canvasHeight();

      painter.save();
      painter.setFont(m_titleFont);

      if (m_scaleDraw.alignment() === ScaleDraw.Alignment.LeftScale) {
        if (m_title !== "") {
          //var tl = painter.context().measureText(m_title).width;
          painter.drawVerticalText(m_title, m_titleFont.th, canvasHeight / 2);
        }
      } else if (m_scaleDraw.alignment() === ScaleDraw.Alignment.RightScale) {
        if (m_title !== "") {
          painter.drawVerticalText(
            m_title,
            canvasWidth - m_titleFont.th,
            canvasHeight / 2,
            true
          );
        }
      } else if (m_scaleDraw.alignment() === ScaleDraw.Alignment.BottomScale) {
        if (m_title !== "") {
          painter.drawText(
            m_title,
            canvasWidth / 2,
            canvasHeight - m_titleFont.th / 2,
            "center"
          );
        }
      } else if (m_scaleDraw.alignment() === ScaleDraw.Alignment.TopScale) {
        if (m_title !== "") {
          painter.drawText(m_title, canvasWidth / 2, m_titleFont.th, "center");
        }
      }
      painter.restore();
    };

    /**
     * Assign a scale division
     *
     * The scale division determines where to set the tick marks.
     * @param {ScaleDiv} scaleDiv Scale Division
     */
    this.setScaleDiv = function (scaleDiv) {
      if (m_scaleDraw.scaleDiv() !== scaleDiv) {
        m_scaleDraw.setScaleDiv(scaleDiv);
        //layoutScale();
        //alert("here")

        Static.trigger("scaleDivChanged");
      }
    };

    Static.bind("scaleDivChanged", this.scaleChange);

    /**
     * Set the transformation
     * @param {Transform} trans Transformation
     */
    this.setTransformation = function (trans) {
      m_scaleDraw.setTransformation(trans);
      //layoutScale();
    };

    this.toString = function () {
      return "[ScaleWidget]";
    };
  }
  /**
   * This function can be overloaded by derived classes.
   *
   * The default implementation does nothing
   */
  scaleChange() {
    //console.log('scaleChanged')
  }
}
;
define("scaleWidget", ["static","widget"], function(){});

/**
 * A class for evaluating an expression. See example
 *
 * This class uses Math.js
 * @example
 * const evalExp = new EvaluateExp("x^2");
 * console.log(evalExp.eval({x: 2})); // output: 4
 *
 * const cb = function(exp){
 *    return exp.replace("ahh", "10")
 * }
 *
 * const evalExp2 = new EvaluateExp("x^2 + ahh", cb);//The callback modifies the expression string to "x^2 + 10".
 * console.log(evalExp2.eval({x: 2})); //output: 14
 */
class EvaluateExp {
  /**
   * Creates an EvaluateExp instance.
   * @param {String} expStr expression
   * @param {Function} [modifyCb] optional callback that may modify the expression in some way
   */
  constructor(expStr, modifyCb) {
    var self = this;
    var m_expStr = expStr;
    var f;
    var simplified;
    this.error = false;
    var self = this;

    var expandDefines = function (m_expStr) {
      return m_expStr;
    };

    if (modifyCb) expandDefines = modifyCb;

    function init() {
      var expanded = expandDefines(m_expStr).replaceAll("mod", " mod ");
      try {
        simplified = math.parse(expanded);
        if (!m_expStr.includes("log"))
          simplified = math.simplify(simplified, {}, { exactFractions: false });
      } catch (err) {
        // var charPos = parseInt(err.message.match(/(\d+)/)[0]);
        // alert("Invalid character in function: " + expanded[charPos - 1]);
        // self.error = true;
        // return;
      }
      // if (!m_expStr.includes("log") && simplified) {
      //   //Replace the whitespace delimiters stripped out by simplify()
      //   simplified = math.parse(simplified.replaceAll("mod", " mod "));
      //   simplified = simplified.compile();
      // }
    }

    if (m_expStr && m_expStr.length > 0) {
      //if (m_expStr !== undefined && m_expStr.length > 0) {
      m_expStr = Utility.logBaseAdjust(m_expStr);
      init();
    } else throw "Initialization of EvaluateExp failed.";

    /**
     * Change the expression being evaluated
     * @param {String} s expression
     */
    this.setExpString = function (s) {
      m_expStr = s;
      init();
    };

    /**
     *
     * @returns {String} The expression being evaluated
     */
    this.getExpString = function () {
      return m_expStr;
    };

    /**
     * Evaluates the expression against the scope
     * @param {object} obj scope (e.g. {x: 10})
     * @returns {Number} value
     */
    this.eval = function (obj) {
      this.error = false;
      try {
        let val = simplified.evaluate(obj);
        //if (val.im) val = val.im;
        return val;
      } catch (err) {
        this.errorMessage = err.message;
        this.error = true;
        return 0;
      }
    };
  }
}
;
define("evaluateExp", function(){});



var Cancel = 0;
var No = 1;
var Yes = 2;

class AlertDlg {
  constructor() {
    var dlg = $(
      '<div class="modal fade" id="alert_Modal" role="dialog">\
		<div id="dlg" class="modal-dialog">\
		<!-- Modal content-->\
		<div class="modal-content">\
		<div class="modal-header">\
		<!--button type="button" class="close" data-dismiss="modal">&times;</button-->\
		<h4 class="modal-title"><b>Alert</b></h4>\
		</div>\
		<div class="modal-body">\
		<p id="msg"></p>\
		</div>\
		<div id="alertDlgFooter1" class="modal-footer">\
    <label id="doNotShowContainer" style="float: left;"><input id="doNotShow" type="checkbox"/> Don\'t show again</label>\
		<button type="button" class="btn btn-default" data-dismiss="modal">Ok</button>\
		</div>\
		<div id="alertDlgFooter2" class="modal-footer">\
		<button id="yes" type="button" class="btn btn-default">Yes</button>\
		<button id="no" type="button" class="btn btn-default">No</button>\
		<button id="cancel" type="button" class="btn btn-default">Cancel</button>\
		</div>\
		</div>\
		</div>\
		</div>'
    );

    //console.log(dlg)
    $("body").append(dlg);

    $("#doNotShowContainer").hide();

    dlg.css("z-index", 1000000000); //ensure dialog is not covered

    let doNotShowList = [];

    this.alert = function (msg, type, doNotShowOptionId) {
      if (doNotShowList.indexOf(doNotShowOptionId) != -1) return;
      $("body").append(dlg);
      $("#doNotShow")[0].checked = false;
      $("#alertDlgFooter2").hide();
      $("#alertDlgFooter1").show();
      $("#msg").text(msg);
      if (type == "small") {
        $("#dlg").addClass("modal-sm");
      } else {
        $("#dlg").removeClass("modal-sm");
      }
      if (doNotShowOptionId) {
        $("#doNotShowContainer").show();
      } else {
        $("#doNotShowContainer").hide();
      }

      $("#doNotShow").on("change", function () {
        if ($(this)[0].checked) {
          doNotShowList.push(doNotShowOptionId);
        } else {
          const n = doNotShowList.indexOf(doNotShowOptionId);
          if (n != -1) {
            doNotShowList.splice(n, 1);
          }
        }
      });
      dlg.modal({
        backdrop: "static",
      });
      //dlg.modal();
    };

    var self = this;

    this.alertYesNo = function (msg, cb, type) {
      $("body").append(dlg);
      //$(".close").hide()
      $("#alert_Modal").modal("hide");
      this.alertYesCb = cb;
      $("#alertDlgFooter1").hide();
      $("#alertDlgFooter2").show();
      $("#msg").text(msg);
      if (type == "small") {
        $("#dlg").addClass("modal-sm");
      } else {
        $("#dlg").removeClass("modal-sm");
      }
      /* dlg.modal({
					backdrop: "static"
				}); */
      //dlg.modal();
      $("#alert_Modal").modal("show");
    };

    $("#yes").click(function () {
      //$(".close").click();
      $("#alert_Modal").modal("hide");
      self.alertYesCb(Yes);
    });

    $("#no").click(function () {
      //$(".close").click();
      $("#alert_Modal").modal("hide");
      self.alertYesCb(No);
    });

    $("#cancel").click(function () {
      // $(".close").click();
      $("#alert_Modal").modal("hide");
      self.alertYesCb(Cancel);
    });

    dlg.on("hidden.bs.modal", function () {
      dlg.detach();
    });

    dlg.detach();
  }
}

class PromptDlg {
  constructor() {
    var prompt_dlg = $(
      '<div class="modal fade" id="promptModal" role="dialog">\
		<div id="prompt_dlg" class="modal-dialog">\
		<!-- Modal content-->\
		<div class="modal-content">\
		<div class="modal-header">\
    \
		<button type="button" class="close" data-dismiss="modal"></button>\
		<img id="progressSpinner" class="progress" style="position:relative; width:4%; height:4%; top:8px;" src="images/imageLoader.png"></img>\
    <img id="error" class="errorBlink" style="position:relative; width:4%; height:4%; top:-2px;" src="images/error.png"></img>\
    <span class="modal-title" id="prompt_title" style="font-size: 125%;">Alert</span>\
		</div>\
		<div class="modal-body">\
    \
		<input id="prompt_msg" style="width:100%" autofocus />\
		</div>\
		<div class="modal-footer">\
		<button type="button" class="btn btn-default" data-dismiss="modal">Cancel</button>\
		<button id="prompt_ok" type="button" class="btn btn-default">Ok</button>\
		</div>\
		</div>\
		</div>\
		</div>'
    );

    //console.log(dlg)
    //prompt_dlg.append('<img id="progressSpinner" class="progress" style= "position: absolute;" src="images/imageLoader.png"></img>');
    $("body").append(prompt_dlg);

    var self = this;

    // this.showProgress = function(){
    //   $("#progressSpinner").css("animation", "spin 2s linear infinite");
    // }

    this.hideProgress = function () {
      $("#progressSpinner").hide();
    };

    //this.hideProgress();
    $("#error").hide();

    this.prompt = function (title, defaultMsg, cb, type) {
      $("body").append(prompt_dlg);
      if (type == "small") {
        $("#prompt_dlg").addClass("modal-sm");
      }
      $("#prompt_title").text(title);
      $("#prompt_msg").val(defaultMsg);
      $("#prompt_msg").select();
      this.cb = cb;
      prompt_dlg.modal({
        backdrop: "static",
      });
    };

    prompt_dlg.on("hidden.bs.modal", function () {
      $("#progressSpinner").show();
      $("#error").hide();
      prompt_dlg.detach();
    });

    $("#prompt_ok").on("mouseenter", function () {
      $("#progressSpinner").css("animation", "spin 2s linear infinite");
    });

    $("#prompt_ok").on("mouseleave", function () {
      if (!Utility.promptProgress)
        $("#progressSpinner").css("animation", "none");
    });

    $("#prompt_ok").on("click", function () {
      Utility.promptProgress = true;
      if (self.cb($("#prompt_msg").val())) {
        $(".close").click();
        //prompt_dlg.detach();
      } else {
        $("#prompt_msg").select();
        $("#progressSpinner").hide();
        $("#error").attr("title", Utility.promptErrorMsg);
        $("#error").show();
      }
      //$("#progressSpinner").show();
      Utility.promptProgress = false;
    });

    $("#prompt_msg").on("input", function () {
      $("#progressSpinner").show();
      $("#error").hide();
    });

    prompt_dlg.detach();
  }
}

/**
 * @classdesc A class of static utility methods. You can derive from this class and add your own utility methods. See the eample below.
 * @example
 * class MyUtility extends Utility{
 * 	static myUtilityMethod(...){
 * 		...
 * 	}
 * }
 */
class Utility {
  /**
   * Get the number of decimal places in the number.
   * @param {number} value The number whose decimal places is to be determined.
   * @returns {number} A positive integer representing the number of decimal places.
   */
  static countDecimalPlaces(value) {
    if (value.im) {
      return 0;
    }
    let text = value.toString();
    // verify if number 0.000005 is represented as "5e-6"
    if (text.indexOf("e-") > -1) {
      let [base, trail] = text.split("e-");
      let deg = parseInt(trail, 10);
      return deg;
    }
    // count decimals for number in representation like "0.123456"
    if (Math.floor(value) !== value) {
      return value.toString().split(".")[1].length || 0;
    }
    return 0;
  }

  //Helper
  static BicubicInterpolation(values, x, y) {
    function TERP(t, a, b, c, d) {
      return (
        0.5 *
          (c -
            a +
            (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * t) *
              t) *
          t +
        b
      );
    }
    var i0, i1, i2, i3;

    i0 = TERP(x, values[0][0], values[1][0], values[2][0], values[3][0]);
    i1 = TERP(x, values[0][1], values[1][1], values[2][1], values[3][1]);
    i2 = TERP(x, values[0][2], values[1][2], values[2][2], values[3][2]);
    i3 = TERP(x, values[0][3], values[1][3], values[2][3], values[3][3]);
    return TERP(y, i0, i1, i2, i3);
  }

  /**
   * Compute the z - coordinate
   * @param {Array<object>} data Array of object (e.g. {x:2, y:-10, z:144}) representing a 3D point.
   * @param {Number} x x - coordinate
   * @param {Number} y y - coordinate
   * @returns {Number} z- coordinate (Bi-cubic interpolation)
   */
  static bicubicInterpolate(data, x, y) {
    var numberOfColumns = data.length;
    var numberOfRows = data[0].length;
    var rightColumn;
    var bottomRow;

    var colSpacing =
      (data[data.length - 1][0].x - data[0][0].x) / (data.length - 1);

    var colIndex = Math.floor((x - data[0][0].x) / colSpacing);

    for (var i = colIndex; i < numberOfColumns; i++) {
      if (data[i][0].x > x) {
        rightColumn = i; //data[i][0].x;

        break;
      }
    }
    if (rightColumn == undefined) rightColumn = numberOfColumns - 1; //data[numberOfColumns-1][0].x;

    var col0 = data[0];

    var rowSpacing = (col0[col0.length - 1].y - col0[0].y) / (col0.length - 1);

    var rowIndex = Math.floor((y - col0[0].y) / rowSpacing);
    for (var i = rowIndex; i < numberOfRows; i++) {
      if (col0[i].y > y) {
        bottomRow = i; //col0[i].y;

        break;
      }
    }
    if (bottomRow == undefined) bottomRow = numberOfRows - 1; //col0[numberOfRows-1].y;

    if (x > data[rightColumn][0].x || x < data[0][0].x) {
      throw "x out of range";
    }

    if (y > data[0][bottomRow].y || y < data[0][0].y) {
      throw "y out of range";
    }

    var leftBoundary = rightColumn - 2;
    var topBoundary = bottomRow - 2;

    if (
      leftBoundary >= 0 &&
      topBoundary >= 0 &&
      rightColumn + 1 < numberOfColumns &&
      bottomRow + 1 < numberOfRows
    ) {
      //inner case
      var p0 = [
        data[rightColumn - 2][bottomRow - 2].z,
        data[rightColumn - 2][bottomRow - 1].z,
        data[rightColumn - 2][bottomRow].z,
        data[rightColumn - 2][bottomRow + 1].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 2].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow + 1].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 2].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow + 1].z,
      ];

      var p3 = [
        data[rightColumn + 1][bottomRow - 2].z,
        data[rightColumn + 1][bottomRow - 1].z,
        data[rightColumn + 1][bottomRow].z,
        data[rightColumn + 1][bottomRow + 1].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    } else if (
      leftBoundary < 0 &&
      topBoundary >= 0 &&
      rightColumn + 1 < numberOfColumns &&
      bottomRow + 1 < numberOfRows
    ) {
      //left boundary case
      var p0 = [
        data[rightColumn - 1][bottomRow - 2].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow + 1].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 2].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow + 1].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 2].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow + 1].z,
      ];

      var p3 = [
        data[rightColumn + 1][bottomRow - 2].z,
        data[rightColumn + 1][bottomRow - 1].z,
        data[rightColumn + 1][bottomRow].z,
        data[rightColumn + 1][bottomRow + 1].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    } else if (
      leftBoundary >= 0 &&
      topBoundary < 0 &&
      rightColumn + 1 < numberOfColumns &&
      bottomRow < numberOfRows
    ) {
      //top boundary case
      var p0 = [
        data[rightColumn - 2][bottomRow - 1].z,
        data[rightColumn - 2][bottomRow - 1].z,
        data[rightColumn - 2][bottomRow].z,
        data[rightColumn - 2][bottomRow + 1].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow + 1].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow + 1].z,
      ];

      var p3 = [
        data[rightColumn + 1][bottomRow - 1].z,
        data[rightColumn + 1][bottomRow - 1].z,
        data[rightColumn + 1][bottomRow].z,
        data[rightColumn + 1][bottomRow + 1].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    } else if (
      leftBoundary >= 0 &&
      topBoundary >= 0 &&
      rightColumn + 1 >= numberOfColumns &&
      bottomRow + 1 < numberOfRows
    ) {
      //right boundary case
      var p0 = [
        data[rightColumn - 2][bottomRow - 2].z,
        data[rightColumn - 2][bottomRow - 1].z,
        data[rightColumn - 2][bottomRow].z,
        data[rightColumn - 2][bottomRow + 1].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 2].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow + 1].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 2].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow + 1].z,
      ];

      var p3 = [
        data[rightColumn][bottomRow - 2].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow + 1].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    } else if (
      leftBoundary >= 0 &&
      topBoundary >= 0 &&
      rightColumn + 1 < numberOfColumns &&
      bottomRow + 1 >= numberOfRows
    ) {
      //bottom boundary case
      var p0 = [
        data[rightColumn - 2][bottomRow - 2].z,
        data[rightColumn - 2][bottomRow - 1].z,
        data[rightColumn - 2][bottomRow].z,
        data[rightColumn - 2][bottomRow].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 2].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 2].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow].z,
      ];

      var p3 = [
        data[rightColumn + 1][bottomRow - 2].z,
        data[rightColumn + 1][bottomRow - 1].z,
        data[rightColumn + 1][bottomRow].z,
        data[rightColumn + 1][bottomRow].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    } else if (
      leftBoundary < 0 &&
      topBoundary < 0 &&
      rightColumn + 1 < numberOfColumns &&
      bottomRow < numberOfRows
    ) {
      //left + top boundary case
      var p0 = [
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow + 1].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow + 1].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow + 1].z,
      ];

      var p3 = [
        data[rightColumn + 1][bottomRow - 1].z,
        data[rightColumn + 1][bottomRow - 1].z,
        data[rightColumn + 1][bottomRow].z,
        data[rightColumn + 1][bottomRow + 1].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    } else if (
      leftBoundary >= 0 &&
      topBoundary < 0 &&
      rightColumn + 1 >= numberOfColumns &&
      bottomRow < numberOfRows
    ) {
      //right + top boundary case
      var p0 = [
        data[rightColumn - 2][bottomRow - 1].z,
        data[rightColumn - 2][bottomRow - 1].z,
        data[rightColumn - 2][bottomRow].z,
        data[rightColumn - 2][bottomRow + 1].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow + 1].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow + 1].z,
      ];

      var p3 = [
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow + 1].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    } else if (
      leftBoundary < 0 &&
      topBoundary >= 0 &&
      rightColumn + 1 < numberOfColumns &&
      bottomRow + 1 >= numberOfRows
    ) {
      //left + bottom boundary case
      var p0 = [
        data[rightColumn - 1][bottomRow - 2].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 2].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 2].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow].z,
      ];

      var p3 = [
        data[rightColumn + 1][bottomRow - 2].z,
        data[rightColumn + 1][bottomRow - 1].z,
        data[rightColumn + 1][bottomRow].z,
        data[rightColumn + 1][bottomRow].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    } else if (
      leftBoundary >= 0 &&
      topBoundary >= 0 &&
      rightColumn + 1 >= numberOfColumns &&
      bottomRow + 1 >= numberOfRows
    ) {
      //right + bottom boundary case
      var p0 = [
        data[rightColumn - 2][bottomRow - 2].z,
        data[rightColumn - 2][bottomRow - 1].z,
        data[rightColumn - 2][bottomRow].z,
        data[rightColumn - 2][bottomRow].z,
      ];

      var p1 = [
        data[rightColumn - 1][bottomRow - 2].z,
        data[rightColumn - 1][bottomRow - 1].z,
        data[rightColumn - 1][bottomRow].z,
        data[rightColumn - 1][bottomRow].z,
      ];

      var p2 = [
        data[rightColumn][bottomRow - 2].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow].z,
      ];

      var p3 = [
        data[rightColumn][bottomRow - 2].z,
        data[rightColumn][bottomRow - 1].z,
        data[rightColumn][bottomRow].z,
        data[rightColumn][bottomRow].z,
      ];

      return Utility.BicubicInterpolation(
        [p0, p1, p2, p3],
        (x - data[rightColumn - 1][0].x) /
          (data[rightColumn][0].x - data[rightColumn - 1][0].x),
        (y - col0[bottomRow - 1].y) /
          (col0[bottomRow].y - col0[bottomRow - 1].y)
      );
    }
    return undefined;
  }

  //Helper
  static BilinearInterpolation(q11, q12, q21, q22, x1, x2, y1, y2, x, y) {
    /*  var x2x1, y2y1, x2x, y2y, yy1, xx1;
		x2x1 = x2 - x1;
		y2y1 = y2 - y1;
		x2x = x2 - x;
		y2y = y2 - y;
		yy1 = y - y1;
		xx1 = x - x1; 
		  return 1.0 / (x2x1 * y2y1) * (
			q11 * x2x * y2y +
			q21 * xx1 * y2y +
			q12 * x2x * yy1 +
			q22 * xx1 * yy1
		);  */

    return (
      (1.0 / ((x2 - x1) * (y2 - y1))) *
      (q11 * (x2 - x) * (y2 - y) +
        q21 * (x - x1) * (y2 - y) +
        q12 * (x2 - x) * (y - y1) +
        q22 * (x - x1) * (y - y1))
    );
  }

  /**
   * Compute the z - coordinate
   * @param {Array<Array<Number>>} data Array of object (e.g. {x:2, y:-10, z:144}) representing a 3D point.
   * @param {Number} x x - coordinate
   * @param {Number} y y - coordinate
   * @returns {Number} z- coordinate (Bi-linear interpolation)
   */
  static bilinearInterpolate(data, x, y) {
    var numberOfColumns = data.length;
    var numberOfRows = data[0].length;
    var rightColumn;
    var bottomRow;

    var colSpacing =
      (data[data.length - 1][0].x - data[0][0].x) / (data.length - 1);

    var colIndex = Math.floor((x - data[0][0].x) / colSpacing);
    //console.log(colIndex);

    for (var i = colIndex; i < numberOfColumns; i++) {
      if (data[i][0].x > x) {
        rightColumn = i; //data[i][0].x;

        break;
      }
    }
    if (rightColumn == undefined) rightColumn = numberOfColumns - 1;

    var col0 = data[0];

    var rowSpacing = (col0[col0.length - 1].y - col0[0].y) / (col0.length - 1);

    var rowIndex = Math.floor((y - col0[0].y) / rowSpacing);

    for (var i = rowIndex; i < numberOfRows; i++) {
      if (col0[i].y > y) {
        bottomRow = i; //col0[i].y;

        break;
      }
    }
    if (bottomRow == undefined) bottomRow = numberOfRows - 1;

    if (x > data[rightColumn][0].x || x < data[0][0].x) {
      throw "x out of range";
    }

    if (y > data[0][bottomRow].y || y < data[0][0].y) {
      throw "y out of range";
    }

    var leftBoundary = rightColumn - 1;
    var topBoundary = bottomRow - 1;

    var x1, y1, x2, y2, q11, q12, q21, q22;

    x1 = data[leftBoundary][0].x;
    x2 = data[rightColumn][0].x;
    y1 = data[0][bottomRow].y;
    y2 = data[0][topBoundary].y;

    q11 = data[leftBoundary][bottomRow].z;
    q12 = data[leftBoundary][topBoundary].z;
    q21 = data[rightColumn][bottomRow].z;
    q22 = data[rightColumn][topBoundary].z;

    return Utility.BilinearInterpolation(
      q11,
      q12,
      q21,
      q22,
      x1,
      x2,
      y1,
      y2,
      x,
      y
    );
  }

  /**
   * Generate a unique curve name
   * @param {Plot} plot Plot to which a curve with the generated name will be attached
   * @param {String} [prefix] Prefix of name. The default is "curve_".
   * @returns {string} unique curve name
   */
  static generateCurveName(plot, prefix) {
    let suffix = 1;
    let preFix = prefix || "curve_";
    let curveName = preFix.concat(suffix);
    while (plot.findPlotCurve(curveName)) curveName = preFix.concat(++suffix);
    return curveName;
  }

  /**
   * Generate a unique curve copy name
   * @param {Plot} plot Plot to which a curve with the generated name will be attached
   * @param {String} [name] The name of the curve being copied.
   * @returns {string} unique curve name
   */
  static generateCurveCopyName(plot, name) {
    let suffix = 1;
    let preFix = name + "_copy";
    let curveName = preFix.concat(suffix);
    while (plot.findPlotCurve(curveName)) curveName = preFix.concat(++suffix);
    return curveName;
  }

  static dragAndDropFiles(dropElement, handler) {
    let borderColor = dropElement.css("border-color");
    let borderWidth = dropElement.css("border-width");
    ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
      dropElement[0].addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    ["dragenter", "dragover"].forEach((eventName) => {
      dropElement[0].addEventListener(eventName, highlight, false);
    });
    ["dragleave", "drop"].forEach((eventName) => {
      dropElement[0].addEventListener(eventName, unhighlight, false);
    });

    function highlight(e) {
      dropElement.css("border-color", "purple");
      dropElement.css("border-width", "4px");
      //dropElement.addClass("highlight");
    }

    function unhighlight(e) {
      dropElement.css("border-color", borderColor);
      dropElement.css("border-width", borderWidth);
      //dropElement.removeClass("highlight");
    }

    dropElement[0].addEventListener("drop", handleDrop, false);

    function handleDrop(e) {
      handler(e.dataTransfer.files); ///
    }
  }

  static pltPlotCurveData(plot, curveData) {
    let curve = null;
    if (curveData.fn) {
      curve = plot.functionDlgCb(curveData.functionDlgData);
      curve.setTitle(curveData.title);
      //return;
    } else {
      //curve = new curveConstructor(curveData.title);
      curve = plot.createCurve(curveData.rtti, curveData.title);
      curve.setSamples(Utility.pointsFromXYObjectArray(curveData.samples));
    }

    if (curveData.symbolType !== Symbol2.Style.NoSymbol) {
      let sym = new Symbol2();
      sym.setStyle(curveData.symbolType);
      sym.setSize(new Misc.Size(curveData.symbolWidth, curveData.symbolWidth));
      sym.setPen(
        new Misc.Pen(curveData.symbolPenColor, curveData.symbolPenWidth)
      );
      sym.setBrush(new Misc.Brush(curveData.symbolBrushColor));
      curve.setSymbol(sym);
    }

    curve.setStyle(curveData.style);
    if (curveData.fitType) {
      curve.fitType = curveData.fitType;
      curve.equation = curveData.equation;
    }

    //curve.setSamples(Utility.pointsFromXYObjectArray(curveData.samples));
    if (curveData.fitType == "natural" || curveData.fitType == "periodic") {
      //curve.setData(CurveFitDlg.curve.data())
      let f = new SplineCurveFitter();
      let s = f.spline();
      if (curveData.fitType == "periodic") {
        s.setSplineType(Static.SplineType.Periodic);
      } else {
        s.setSplineType(Static.SplineType.Natural);
      }
      curve.setCurveFitter(f);
    }

    curve.setPen(
      new Misc.Pen(
        curveData.pen.color,
        curveData.pen.width,
        curveData.pen.style
      )
    );

    curve.setAxes(curveData.xAxis, curveData.yAxis);

    return curve;
  }

  static getPlotCurveData(curve) {
    let d = {};
    d.rtti = PlotItem.RttiValues.Rtti_PlotCurve;
    d.title = curve.title();

    const fn = curve.fn;
    if (fn) {
      d.functionDlgData = curve.functionDlgData;
    } else {
      d.samples = curve.data().samples();
    }

    d.fn = curve.fn;

    d.pen = curve.pen();
    d.fitType = curve.fitType;
    d.equation = curve.equation;

    let sym = curve.symbol();
    d.symbolType = Symbol2.Style.NoSymbol;
    if (sym) {
      d.symbolType = sym.style();
      d.symbolWidth = sym.size().width;
      d.symbolPenColor = sym.pen().color;
      d.symbolPenWidth = sym.pen().width;
      d.symbolBrushColor = sym.brush().color;
    }
    d.style = curve.style();

    d.xAxis = curve.xAxis();
    d.yAxis = curve.yAxis();

    return d;
  }

  static copyCurve(curve) {
    const plot = curve.plot();
    let newTitle = Utility.generateCurveCopyName(plot, curve.title());
    const curveData = Utility.getPlotCurveData(curve);
    curveData.title = newTitle;
    if (curveData.functionDlgData) {
      curveData.functionDlgData.title = newTitle;
    }
    Utility.pltPlotCurveData(plot, curveData).attach(plot);
  }

  static copyCurves(curves) {
    const plot = curves[0].plot();
    const autoReplot = plot.autoReplot();
    plot.setAutoReplot(false);
    for (let i = 0; i < curves.length; i++) {
      Utility.copyCurve(curves[i]);
    }
    plot.setAutoReplot(autoReplot);
    plot.autoRefresh();
  }

  /**
   * Check a key press event for modifier (ALT, SHIFT, CTRL) key press.
   *
   * Modifiers are represented by the constants:
   * - {@link Static.NoModifier}
   * - {@link Static.AltModifier}
   * - {@link Static.ControlModifier}
   * - {@link Static.ShiftModifier}
   *
   * To check if an event is associated with ALT modifier, for example, use: `modifiers(event) & Static.AltModifier`
   * @param {Event} event Key Event
   * @returns {number} Number identifying any modifier combinations.
   */
  static modifiers(event) {
    var _modifiers = Static.NoModifier;
    if (event.altKey && event.ctrlKey && event.shiftKey)
      return (
        _modifiers |
        Static.AltModifier |
        Static.ControlModifier |
        Static.ShiftModifier
      );
    if (event.altKey && event.ctrlKey)
      return _modifiers | Static.AltModifier | Static.ControlModifier;
    if (event.altKey && event.shiftKey)
      return _modifiers | Static.AltModifier | Static.ShiftModifier;
    if (event.ctrlKey && event.shiftKey)
      return _modifiers | Static.ControlModifier | Static.ShiftModifier;
    if (event.altKey) return _modifiers | Static.AltModifier;
    if (event.ctrlKey) return _modifiers | Static.ControlModifier;
    if (event.shiftKey) return _modifiers | Static.ShiftModifier;
    return _modifiers;
  }

  /**
   * Check a mouse event for button press
   * @param {Event} event
   * @returns {number} Constant identifying mouse button pressed. (NoButton=-1: No mouse button pressed, LeftButton=0: Left mouse button pressed, MidButton=1: Middle mouse button pressed, RightButton=2: Right mouse button pressed)
   */
  static button(event) {
    if (event == null) return false;
    return event.button;
  }

  /**
   * Get a list of predefined colors
   * @returns {Array<String>}
   */
  static colorList() {
    return ["black", "red", "green", "blue", "yellow", "brown"];
  }

  /**
   * Convert an array of array of numbers ([[-10, 50], [41, 89], ...]) to an array
   * of Misc.Point ([new Mic.Point(-10, 50), new Mic.Point(41, 89), ...])
   *
   * @param {Array<Array<Number>>} arrayOfTwoMemberArrays
   * @returns {Array<Misc.Point>}
   */
  static makePoints(arrayOfTwoMemberArrays) {
    return arrayOfTwoMemberArrays.map(function (arrayOfTwoMembers) {
      return new Misc.Point(
        parseFloat(arrayOfTwoMembers[0]),
        parseFloat(arrayOfTwoMembers[1])
      );
    });
  }

  // /**
  //  * Build an object containing data that can be use for a spectrocure.
  //  *
  //  *
  //  *
  //  * The points property holds a array of object (e.g.: {x:2, y:-10, z:12}) that represent a 3D point.
  //  *
  //  * zMin and zMax properties hold the minimum and maximum z value respectively.
  //  * @param {Array<Array<Number>>} arrayOfThreeMemberArrays Array of array of numbers ([[-10, 50, 87], [41, 89, -150], ...])
  //  * @returns {object} spectrocure data object. See example below.
  //  * @example
  //  * {
  //  *    points: [{x:2, y:-10, z:12}, {x:2, y:-10, z:12}, ...],
  //  *    zMin: 2,
  //  *    zMax: 30
  //  * }
  //  */
  // static makeSpectrocurvePoints1(arrayOfThreeMemberArrays) {
  //   //console.log(arr)
  //   var res = [];
  //   var minZ = Number.MAX_VALUE;
  //   var maxZ = Number.MIN_VALUE;
  //   arrayOfThreeMemberArrays.forEach(function (arrayOfThreeMembers) {
  //     var zVal = parseFloat(arrayOfThreeMembers[2]);
  //     if (zVal < minZ) minZ = arrayOfThreeMembers[2];
  //     if (zVal > maxZ) maxZ = arrayOfThreeMembers[2];
  //     res.push({
  //       x: parseFloat(arrayOfThreeMembers[0]),
  //       y: parseFloat(arrayOfThreeMembers[1]),
  //       z: zVal,
  //     });
  //   });
  //   return { points: res, zMin: minZ, zMax: maxZ };
  // }

  /**
   * Construct an array of xy object (e.g.: [{x:2, y:15}, {x:-22, y:125}, ...]) from an array of Misc.Point
   * @param {Array<Misc.Point>} points List of points
   * @returns {Array<object>} Array of 2D objects
   */
  static pointsToXYObjectArray(points) {
    return points.map(function (pt) {
      return {
        x: pt.x,
        y: pt.y,
      };
    });
  }

  /**
   * Construct an array of Misc.Point (e.g.: [ new Misc.Point(2, 15), new Misc.Point(-22, 125), ...]) from an array of 2D xy object
   * @param {Array<object>} XYpoints List of xy objects
   * @returns {Array<Misc.Point>} Array of 2D points
   */
  static pointsFromXYObjectArray(XYpoints) {
    return XYpoints.map(function (pt) {
      return new Misc.Point(pt.x, pt.y);
    });
  }

  /**
   * Construct a linear equation of the form `mx + c` from 2 known points in a xy coordinate system.
   * @param {Misc.Point} p1 First point
   * @param {Misc.Point} p2 Second point
   * @returns {String} equation (e.g. "-15 x + 34")
   */
  static linearEquationFromPoints(p1, p2, decimalPlaces) {
    var m = (p2.y - p1.y) / (p2.x - p1.x);
    var c = -m * p1.x + p1.y;
    if (decimalPlaces) {
      m = Utility.adjustForDecimalPlaces(m, decimalPlaces);
      c = Utility.adjustForDecimalPlaces(c, decimalPlaces);
    }
    var fn = m.toString();
    fn += "x+";
    fn += c.toString();
    return fn;
  }

  /**
   * Build an object containing data that can be use for a curve, spectrocure or spectrogram.
   *
   * The points property holds a array of object that describes a 2D ({x:2, y:-10}) or 3D ({x:2, y:-10, z:12}) point.
   *
   * dataType property holds a string that gives a hint. Possible types are "curve" (for 2D), "spectrocurve" or "spectrogram" (for 3D). The hint is provided by making it the first line in the file. If no hint is provided, dataType property is set to null and toArrays() will try to determine if the csv content is for 2D or 3D spectrocurve or 3D spectrogram.
   *
   * zMin and zMax properties hold the minimum and maximum z value respectively.
   * @param {String} csvContent A string containing the csv content read from a file. (e.g.: "2, 4\n3, 9\n, ..." representing csv that describes 2D or "2, 4, -10\n3, 9, 12\n, ..." representing csv that describes 3D)
   * @returns {object} data object. See example below.
   * @example
   * For 2D data
   * {
   *    points: [{x:2, y:-10}, {x:2, y:-10}, ...],
   *    dataType: "curve", // or null
   *    zMin: 2,
   *    zMax: 30
   * }
   *
   * For 3D data
   * {
   *    points: [{x:2, y:-10, z:12}, {x:2, y:-10, z:12}, ...],
   *    dataType: "spectrocurve", //or "spectrogram" or null
   *    zMin: 2,
   *    zMax: 30
   * }
   */
  static toArrays(csvContent) {
    var _minZ = Number.MAX_VALUE;
    var _maxZ = Number.MIN_VALUE;
    var type = null;
    var arr = csvContent.split("\n");
    var keyword = arr[0].toLowerCase();
    if (keyword.includes("curve")) {
      type = "curve";
    } else if (keyword.includes("spectrocurve")) {
      type = "spectrocurve";
    } else if (keyword.includes("spectrogram")) {
      type = "spectrogram";
    }
    var result = [];
    for (var i = 0; i < arr.length; ++i) {
      var pt = arr[i].split(",");
      if (isNaN(parseFloat(pt))) {
        continue;
      }
      pt = pt.map(function (item) {
        return parseFloat(item);
      });
      if (pt.length == 3) {
        //3d data
        result.push({ x: pt[0], y: pt[1], z: pt[2] });
        if (result[result.length - 1].z < _minZ)
          _minZ = result[result.length - 1].z;
        if (result[result.length - 1].z > _maxZ)
          _maxZ = result[result.length - 1].z;
      } else {
        result.push(pt);
      }
    }
    return { array: result, dataType: type, minZ: _minZ, maxZ: _maxZ };
  }

  /**
   * Toggles auto scale for all axes on and off
   *
   * Triggers the "rescaled" event. (Static.trigger("rescaled", auto);)
   * @param {Plot} plot The plot
   * @param {Boolean} auto On / Off
   */
  static setAutoScale(plot, auto) {
    const autoReplot = plot.autoReplot();
    plot.setAutoReplot(false);

    plot.setAxesAutoScale(auto);
    plot.setAutoReplot(autoReplot);
    plot.autoRefresh();
    Static.trigger("rescaled", auto);
  }

  /**
   * Toggles auto scale for all axes on and off
   *
   * @param {Plot} plot The plot
   * @returns {Boolean} True, if autoscale is set
   */
  static isAutoScale(plot) {
    if (
      !plot.axisAutoScale(0) ||
      !plot.axisAutoScale(1) ||
      !plot.axisAutoScale(2) ||
      !plot.axisAutoScale(3)
    ) {
      return false;
    }
    return true;
  }

  /**
   * Toggles the major gridlines for both x and Y on and off
   *
   * Triggers the "majorGridLines" event. (Static.trigger("majorGridLines", [grid, on]);)
   * @param {PlotGrid} grid
   * @param {Boolean} on On / Off
   *
   */
  static majorGridLines(grid, on) {
    grid.enableX(on);
    grid.enableY(on);
    Static.trigger("majorGridLines", [grid, on]);
  }

  /**
   * Toggles the minor gridlines for both x and Y on and off
   *
   * Triggers the "majorGridLines" event. (Static.trigger("minorGridLines", [grid, on]);)
   * @param {PlotGrid} grid
   * @param {Boolean} on On / Off
   *
   */
  static minorGridLines(grid, on) {
    grid.enableXMin(on);
    grid.enableYMin(on);
    Static.trigger("minorGridLines", [grid, on]);
  }

  /**
   * Generates a random color
   *
   * @param {Number} brightness The desired brightness. Six levels of brightness from 0 to 5, 0 being the darkest
   * @returns {String} rgb color (e.g.: "rgb(255, 0, 0)")
   */
  static randomColor(brightness = 0) {
    // Six levels of brightness from 0 to 5, 0 being the darkest
    if (brightness > 5) brightness = 5;
    if (brightness < 0) brightness = 0;
    var rgb = [Math.random() * 256, Math.random() * 256, Math.random() * 256];
    var mix = [brightness * 51, brightness * 51, brightness * 51]; //51 => 255/5
    var mixedrgb = [rgb[0] + mix[0], rgb[1] + mix[1], rgb[2] + mix[2]].map(
      function (x) {
        return Math.round(x / 2.0);
      }
    );
    return "rgb(" + mixedrgb.join(",") + ")";
  }

  /**
   * Display a color picker that allows the user to select a brush color. The color chosen is use to build a bush that is assigned to the curve.
   * @param {Curve} curve The curve
   * @param {Function} successCb A callback that is executed when a color change is selected.
   */
  static setCurveBrush(curve, successCb) {
    var colorSelector = $('<input type="color" style="opacity:0;">');
    if (!curve || curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve) return;
    if (curve.brush().color == Static.NoBrush)
      colorSelector.val(Utility.colorNameToHex("rgb(255, 255, 254)"));
    else colorSelector.val(Utility.colorNameToHex(curve.brush().color));
    colorSelector.change(function () {
      var brush = curve.brush();
      brush.color = $(this).val();
      curve.setBrush(brush);
      if (successCb !== undefined) {
        successCb(curve);
      }
      $(this).remove();
    });
    colorSelector.trigger("click");
  }

  /**
   * Sets a brush color to Static.NoBrush
   * @param {Curve} curve The curve
   */
  static removeCurveBrush(curve) {
    var brush = curve.brush();
    brush.color = Static.NoBrush;
    curve.setBrush(brush);
  }

  /**
   * Set the pen width of a curve symbol.
   *
   * This method triggers the "symbolAttributeChanged" event (Static.trigger("symbolAttributeChanged", curve))
   * @param {Curve} curve The curve
   * @param {Number} width Pen width
   */
  static setSymbolPenWidth(curve, width) {
    var sym = curve.symbol();
    if (!sym) {
      return;
    }
    var pen = sym.pen();
    pen.width = width;
    //sym.setPen(pen)
    //curve.setSymbol(sym) //reset the symbol so that the legend size is recalculated
    curve.plot().autoRefresh();

    Utility.updateLegendIconSize(curve); //recalculate legend icon size
    curve.plot().updateLegend(curve);
    //curve.itemChanged();
    //curve.legendChanged();
    Static.trigger("symbolAttributeChanged", curve);
  }

  /**
   * Recalculates legend icon size
   * @param {Curve} curve The curve
   */
  static updateLegendIconSize(curve) {
    var sz = curve.getLegendIconSize();
    if (curve.symbol()) {
      sz = curve.symbol().boundingRect().size();
      //sz.width += 2; // margin
      //sz.height += 3; // margin
    }

    if (
      curve.symbol() &&
      curve.testLegendAttribute(Curve.LegendAttribute.LegendShowSymbol)
    ) {
      if (curve.testLegendAttribute(Curve.LegendAttribute.LegendShowLine)) {
        // Avoid, that the line is completely covered by the symbol

        var w = Math.ceil(1.5 * sz.width);

        if (w % 2) w++;

        sz.width = Math.max(40, w);
      }
      curve.setLegendIconSize(sz);
    } else if (
      curve.testLegendAttribute(Curve.LegendAttribute.LegendShowLine)
    ) {
      sz.width = 40;
      curve.setLegendIconSize(sz);
    }
  }

  /**
   * Sets the curve symbol size
   *
   * This method triggers the "symbolAttributeChanged" event (Static.trigger("symbolAttributeChanged", curve))
   * @param {Curve} curve The curve
   * @param {Misc.Size} value New size
   *
   */
  static setSymbolSize(curve, value) {
    //console.log(value)
    var sym = curve.symbol();
    if (!sym) return;
    var sz = sym.size();
    sz.width = value;
    sz.height = value;
    sym.setSize(sz);
    curve.plot().autoRefresh();
    Utility.updateLegendIconSize(curve); //recalculate legend icon size
    //curve.itemChanged();
    //curve.legendChanged();
    curve.plot().updateLegend(curve);
    Static.trigger("symbolAttributeChanged", curve);
  }

  /**
   * Add a new symbol of a given style to the curve
   *
   * This method triggers the "symbolAdded" event (Static.trigger("symbolAdded", curve))
   * @param {Curve} curve The curve
   * @param {Symbol2.Style} style New symbol style
   *
   */
  static addSymbol(curve, style) {
    if (!curve || curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve) return;
    if (style == Symbol2.Style.NoSymbol) {
      curve.setSymbol(null);
      //return;
    }
    var sym = curve.symbol();
    if (sym == null) {
      sym = new Symbol2();
      sym.setBrush(new Misc.Brush(Static.NoBrush));
      sym.setSize(new Misc.Size(10, 10));
      curve.setSymbol(sym);
    }
    //console.log(sym.size())
    if (sym.size().width <= 0) sym.setSize(new Misc.Size(10, 10));
    sym.setStyle(style);
    curve.itemChanged();
    curve.legendChanged();
    Static.trigger("symbolAdded", curve);
  }

  /**
   * Displays a dialog that allows editing of a new title for the curve.
   *
   * Triggers the "curveRenamed" event. (Static.trigger("curveRenamed", auto);)
   * @param {String} existingName Current curve title
   *
   * This method triggers the "curveRenamed" event (Static.trigger("curveRenamed", curve))
   * @param {Plot} plot The plot
   * @param {Function} successCb A callback that is executed when a new title is selected.
   *
   */
  static curveRenameDlg(existingName, plot, successCb) {
    Utility.prompt(
      'Enter a new name for "' + existingName + '"',
      existingName,
      function (newName) {
        if (existingName == newName) {
          //User decided not change the name
          Utility.alert("You did not change the name!");
          return false;
        }
        var curve = plot.findPlotCurve(existingName);
        if (!plot.findPlotCurve(newName)) {
          //A curve with title "name" (i.e the new name chosen by user is not known to the app)
          curve.setTitle(newName);
          if (successCb !== undefined) successCb(newName, curve);
          Static.trigger("curveRenamed", [curve, existingName, newName]);
          return true;
        } else {
          Utility.alert(newName + " already exist");
          return false;
        }
      },
      "small"
    );
  }

  /**
   * Sets how the curve (or any plot item) is represented on the legend.
   * @param {Curve} curve The curve
   * @param {String} attribute Attribute. Possible attributes are: "line", "symbol" or "lineAndSymbol".
   * @param {Mis.Size} defaultIconSize Icon size
   */
  static setLegendAttribute(curve, attribute, defaultIconSize) {
    //attribute = "line" or "symbol" or "lineAndSymbol"
    if (attribute == "line") {
      //LegendShowLine is dependent on defaultIconSize. Be sure icon size is set to defaultIconSize
      //before setting LegendShowLine.
      curve.setLegendIconSize(new Misc.Size(defaultIconSize));
      curve.setLegendAttribute(Curve.LegendAttribute.LegendShowSymbol, false);
      curve.setLegendAttribute(Curve.LegendAttribute.LegendShowLine, true);
      return;
    }
    if (attribute == "symbol") {
      //LegendShowSymbol is dependent on defaultIconSize. Be sure icon size is set to defaultIconSize
      //before setting LegendShowSymbol.
      curve.setLegendIconSize(new Misc.Size(defaultIconSize));
      curve.setLegendAttribute(Curve.LegendAttribute.LegendShowLine, false);
      curve.setLegendAttribute(Curve.LegendAttribute.LegendShowSymbol, true);
      return;
    }
    if (attribute == "lineAndSymbol") {
      //LegendShowSymbol is dependent on defaultIconSize. Be sure icon size is set to defaultIconSize
      //before setting LegendShowSymbol.
      curve.setLegendIconSize(new Misc.Size(defaultIconSize));
      curve.setLegendAttribute(Curve.LegendAttribute.LegendShowLine, true);
      curve.setLegendAttribute(Curve.LegendAttribute.LegendShowSymbol, true);
      return;
    }
    //defaultIconSize.width = defaultIconSize.height;//ensure the icon is square
    //curve.setLegendIconSize(new Misc.Size(defaultIconSize))
    curve.setLegendAttribute(Curve.LegendAttribute.LegendShowLine, false);
    curve.setLegendAttribute(Curve.LegendAttribute.LegendShowSymbol, false);
    //iconSize is dependent on attributes. be sure to clear any attributes
    //before setting iconSize.
  }

  /*var Backbone = 0x01;
	//! Ticks
	var Ticks = 0x02;
	//! Labels
	var Labels = 0x04;*/

  /**
   * En/disable component(s)
   *
   * @param {Plot} plot The plot
   * @param {AbstractScaleDraw.ScaleComponent} component The component to en/disable. Use | operator to en/disable more thn one component at a time. (e.g.: AbstractScaleDraw.ScaleComponent.Ticks | AbstractScaleDraw.ScaleComponent.Backbone)
   * @param {Boolean} on true / false
   */
  static enableComponent(plot, component, on) {
    var scaleDraw = null;
    for (var axisId = 0; axisId < Axis.AxisId.axisCnt; ++axisId) {
      scaleDraw = plot.axisScaleDraw(axisId);
      scaleDraw.enableComponent(component, on);
    }
    plot.autoRefresh();
  }

  /**
   * Sets the tick lenght of scale ticks
   * @param {Plot} plot The plot
   * @param {String} length The new length ("small", "medium" or "large")
   */
  static setTickLength(plot, length) {
    //length = "small", "medium" or "large"
    var scaleDraw = null;
    for (var axisId = 0; axisId < Axis.AxisId.axisCnt; ++axisId) {
      scaleDraw = plot.axisScaleDraw(axisId);
      if (length == "small") {
        scaleDraw.setTickLength(ScaleDiv.TickType.MajorTick, 6);
        scaleDraw.setTickLength(ScaleDiv.TickType.MinorTick, 3);
      } else if (length == "medium") {
        scaleDraw.setTickLength(ScaleDiv.TickType.MajorTick, 8);
        scaleDraw.setTickLength(ScaleDiv.TickType.MinorTick, 4);
      } else if (length == "large") {
        scaleDraw.setTickLength(ScaleDiv.TickType.MajorTick, 12);
        scaleDraw.setTickLength(ScaleDiv.TickType.MinorTick, 6);
      }
    }
    plot.autoRefresh();
  }

  static makeParametricSamples(obj) {
    var parametricFnX = obj.parametricFnX;
    var parametricFnY = obj.parametricFnY;
    var lowerX = obj.lowerX;
    var upperX = obj.upperX;
    var numOfSamples = obj.numOfSamples;
    var indepVarIsDegree = obj.indepVarIsDegree;
    var parametric_variable = obj.parametric_variable;
    var indepVar = obj.variable; // || Utility.findIndepVar(fx);

    if (typeof numOfSamples === "undefined") numOfSamples = 100;

    if (parametric_variable !== "t") {
      parametricFnX = Utility.purgeAndMarkKeywords(parametricFnX);
      while (parametricFnX.indexOf(parametric_variable) != -1)
        parametricFnX = parametricFnX.replace(parametric_variable, "t");
      parametricFnX = Utility.replaceKeywordMarkers(parametricFnX);

      parametricFnY = Utility.purgeAndMarkKeywords(parametricFnY);
      while (parametricFnY.indexOf(parametric_variable) != -1)
        parametricFnY = parametricFnY.replace(parametric_variable, "t");
      parametricFnY = Utility.replaceKeywordMarkers(parametricFnY);
    }

    let parserFnX = new EvaluateExp(parametricFnX);
    if (parserFnX.error) {
      Utility.alert(parserFnX.errorMessage);
      return null;
    }
    let parserFnY = new EvaluateExp(parametricFnY);
    if (parserFnY.error) {
      Utility.alert(parserFnY.errorMessage);
      return null;
    }
    var samples = [];
    var step = (upperX - lowerX) / (numOfSamples - 1);

    for (var i = 0; i <= numOfSamples - 1; ++i) {
      var tVal = lowerX + i * step;

      let xVal = parserFnX.eval({ t: tVal });
      if (!isFinite(xVal)) {
        if (Utility.errorResponse == Utility.warn) {
          Utility.alert(
            `"${xVal}" is an invalid "x" parametric input or  causes a "divide by zero" error.`
          );
          return null;
        } else if (Utility.errorResponse == Utility.warnIgnore) {
          Utility.alertYesNo(
            "Error found!!! Do you want to silently ignore errors?",
            function (answer) {
              if (answer == Cancel) {
                //console.log("C");
                return null;
              }
              if (answer == Yes) {
                //console.log("Y");
                Utility.errorResponse = Utility.silentIgnore;
                Utility.errorResponseChanged = true;
                obj.warnIgnoreCb && obj.warnIgnoreCb();
                return null;
              }
              if (answer == No) {
                console.log("N");
                return null;
              }
              //return 1
            }
          );
          samples = [];
          break;
        } else {
          continue;
        }
      }

      let yVal = parserFnY.eval({ t: tVal });
      if (!isFinite(yVal)) {
        if (Utility.errorResponse == Utility.warn) {
          Utility.alert(
            `"${yVal}" is an invalid "y" parametric input or  causes a "divide by zero" error.`
          );
          return null;
        } else if (Utility.errorResponse == Utility.warnIgnore) {
          Utility.alertYesNo(
            "Error found!!! Do you want to silently ignore errors?",
            function (answer) {
              if (answer == Cancel) {
                //console.log("C");
                return null;
              }
              if (answer == Yes) {
                //console.log("Y");
                Utility.errorResponse = Utility.silentIgnore;
                Utility.errorResponseChanged = true;
                obj.warnIgnoreCb && obj.warnIgnoreCb();
                return null;
              }
              if (answer == No) {
                console.log("N");
                return null;
              }
              //return 1
            }
          );
          samples = [];
          break;
        } else {
          continue;
        }
      }

      if (samples.length == 0) {
        samples.push(new Misc.Point(xVal, yVal));
      } else {
        if (
          samples[samples.length - 1].x !== xVal &&
          samples[samples.length - 1].y !== yVal
        )
          samples.push(new Misc.Point(xVal, yVal));
      }
    }
    // samples = _.uniq(samples, function (e) {
    //   return e.x && e.y;
    // });
    return samples;
  }

  /**
   * Make data for a Curve or Spectrocurve
   * @param {object} obj data required by  makeSamples()
   *
   * obj has the following properties:
   * - fx - The function e.g. "x^2 + 2x + 1"
   * - lowerX - lower x limit e.g.: -10
   * - upperX - upper x limit e.g.: 10
   * - lowerY - lower y limit e.g.: -10 (only valid for Spectrocurve)
   * - upperY - upper y limit e.g.: -10 (only valid for Spectrocurve)
   * - numOfSamples - Number of points
   * - indepVar - The character representing the x independent variable. If this property is not provided, makeSamples() try to determine the independent variable.
   * - indepVarY - The character representing the y independent variable.
   * @returns {object | Array<Misc.Point>} An oject containing data for a Spectrocurve (e.g.: {data: [new Mis.Point(0, 1), new Mis.Point(10, -21), ...], zLimits: { min: 0, max: 20 }}) or an array of points for a Curve (e.g.: [new Mis.Point(0, 1), new Mis.Point(10, -21), ...])
   */
  static makeSamples(obj) {
    if (obj.parametricFnX && obj.parametricFnY) {
      return Utility.makeParametricSamples(obj);
    }
    var fx = obj.fx;
    var parametricFnX = obj.parametricFnX;
    var parametricFnY = obj.parametricFnY;
    var lowerX = obj.lowerX;
    var upperX = obj.upperX;
    var lowerY;
    var upperY;
    var numOfSamples = obj.numOfSamples;
    var indepVarIsDegree = obj.indepVarIsDegree;
    var parametric_variable = obj.parametric_variable;
    var indepVar = obj.variable || Utility.findIndepVar(fx);
    var indepVarY = obj.variableY; // || findIndepVarY(fx); TODO

    obj.discontinuity = obj.discontinuity || [];

    //let parser = new EvaluateExp(fx);

    if (typeof numOfSamples === "undefined") numOfSamples = 100;
    if (indepVar !== "x") {
      fx = Utility.purgeAndMarkKeywords(fx);
      while (fx.indexOf(indepVar) != -1) fx = fx.replace(indepVar, "x");
      fx = Utility.replaceKeywordMarkers(fx);
    }

    if (obj.threeD && indepVarY !== "y") {
      while (fx.indexOf(indepVarY) != -1) fx = fx.replace(indepVarY, "y");

      lowerY = obj.lowerY;
      var upperY = obj.upperY;
    }

    let parser = new EvaluateExp(fx);

    if (obj.threeD) {
      lowerY = obj.lowerY;
      upperY = obj.upperY;
    }

    var samples = [];

    if (parser.error) {
      Utility.alert(parser.errorMessage);
      return null;
    }

    /* const node = math.parse(fx); // parse expression into a node tree
		const code = node.compile();  */

    var step = (upperX - lowerX) / (numOfSamples - 1);
    var stepY;
    if (obj.threeD) {
      stepY = (upperY - lowerY) / (numOfSamples - 1);
    }

    var yVal;
    var zVal;
    var zMin = Number.MAX_VALUE;
    var zMax = Number.MIN_VALUE;
    // let insertZero = false;
    // if (lowerX < 0 && upperX > 0) {
    //   insertZero = true;
    // }

    let indexInDiscontinuity = 0;
    //let firstDiscontinuity = obj.discontinuity[0];
    for (var i = 0; i <= numOfSamples - 1; ++i) {
      var xVal = lowerX + i * step;

      if (obj.threeD) {
        yVal = lowerY + i * stepY;
        zVal = parser.eval({ x: xVal, y: yVal });
        if (zVal < zMin) zMin = zVal;
        if (zVal > zMax) zMax = zVal;
      } else {
        let x = Utility.adjustForDecimalPlaces(xVal, 8);

        let d = Utility.adjustForDecimalPlaces(
          obj.discontinuity[indexInDiscontinuity],
          8
        );

        //console.log(x, d);
        if (
          obj.discontinuity.length &&
          indexInDiscontinuity < obj.discontinuity.length &&
          x >= d
        ) {
          xVal = obj.discontinuity[indexInDiscontinuity]; ////
          //console.log(xVal - step / Static.dicontinuityOffsetFactor, lowerX);
          if (xVal - step * Static.dicontinuityOffsetFactor >= lowerX) {
            yVal = parser.eval({
              x: xVal - step * Static.dicontinuityOffsetFactor,
            });
            samples.push(
              new Misc.Point(
                xVal - step * Static.dicontinuityOffsetFactor,
                yVal
              )
            ); //point before but close to discontinuity
          }
          if (xVal + step * Static.dicontinuityOffsetFactor < upperX) {
            yVal = parser.eval({
              x: xVal + step * Static.dicontinuityOffsetFactor,
            });
            samples.push(
              new Misc.Point(
                xVal + step * Static.dicontinuityOffsetFactor,
                yVal
              )
            ); //point after but close to discontinuity
          }
          yVal = NaN;
          indexInDiscontinuity++;
          //firstDiscontinuity = undefined;
          //i--;
        } else {
          yVal = parser.eval({ x: xVal });
        }
      }

      //if (!isFinite(yVal) || (Utility.errorResponse != Utility.adjustDomain && obj.discontinuity.length)) {
      if (!isFinite(yVal)) {
        if (Utility.errorResponse == Utility.warn) {
          Utility.alert(
            "f(" +
              xVal +
              "): is an error. Perhaps " +
              xVal +
              " is an invalid input or f(" +
              xVal +
              ') causes a "divide by zero" error.'
          );
          return null;
        } else if (Utility.errorResponse == Utility.warnIgnore) {
          Utility.alertYesNo(
            "Error found!!! Do you want to silently ignore errors?",
            function (answer) {
              if (answer == Cancel) {
                //console.log("C");
                return null;
              }
              if (answer == Yes) {
                //console.log("Y");
                Utility.errorResponse = Utility.silentIgnore;
                Utility.errorResponseChanged = true;
                obj.warnIgnoreCb && obj.warnIgnoreCb();
                return null;
              }
              if (answer == No) {
                console.log("N");
                return null;
              }
              //return 1
            }
          );
          samples = [];
          break;
        } else {
          continue;
        }
      }
      if (obj.threeD && !isFinite(zVal)) {
        if (Utility.errorResponse == Utility.warn) {
          Utility.alert(
            "f(" +
              xVal +
              "," +
              yVal +
              '): yields infinity. Probably a "divide by zero" error. Try changing the limits or adjusting number of points.'
          );
          return null;
        } else if (Utility.errorResponse == Utility.warnIgnore) {
          Utility.alertYesNo(
            "Error found!!! Do you want to silently ignore errors?",
            function (answer) {
              if (answer == Cancel) {
                console.log("C");
                return null;
              }
              if (answer == Yes) {
                console.log("Y");

                Utility.errorResponse = Utility.silentIgnore;
                Utility.errorResponseChanged = true;
                //obj.ok_fn(obj);

                return null;
              }
              if (answer == No) {
                console.log("N");
                return null;
              }
              //return 1
            }
          );
          samples = [];
          break;
        } else {
          continue;
        }
      }
      if (parser.error) {
        Utility.alert(parser.errorMessage);
        return null;
      }
      if (obj.threeD) {
        samples.push({ x: xVal, y: yVal, z: zVal });
      } else {
        samples.push(new Misc.Point(xVal, yVal));
      }
    }
    if (Utility.errorResponseChanged) {
      Utility.errorResponseChanged = false;
      Utility.errorResponse = Utility.warnIgnore;
    }
    //console.log(samples)
    if (obj.threeD) {
      return { data: samples, zLimits: { min: zMin, max: zMax } };
    }
    if (!obj.threeD) {
      const points = Utility.curveTurningPoint(fx, indepVar, samples);
      //console.log("Add Turning points", points);
      obj.turningPoints = points; //return turning points to makeSamples() caller
      if (points.length) {
        for (let i = 0; i < points.length; i++) {
          samples.push(points[i]);
        }
        samples = samples.sort(function (a, b) {
          return a.x - b.x;
        });
      }
    }

    //Check the samples for discontinuity

    // let m_prev, m_diff, p1, p2;

    // for (let i = 1; i < samples.length; i++) {
    //   p1 = samples[i - 1];
    //   p2 = samples[i];

    //   let m = (p2.y - p1.y) / (p2.x - p1.x);
    //   if (m_prev !== undefined) {
    //     m_diff = m - m_prev;
    //     if (Math.abs(m_diff) > 20) {
    //       console.log(p1.x, p2.x);
    //       let m_x = p1.x;
    //       let s = (p2.x - p1.x) / 40000;
    //       let n = 0;
    //       while (m_x < p2.x) {
    //         let y = Math.abs(parser.eval({ x: m_x }));
    //         console.log("y", y, n);
    //         m_x += s;
    //         n++;
    //       }
    //       break;
    //     }
    //   }
    //   m_prev = m;
    // }

    // if (
    //   obj.discontinuity &&
    //   obj.discontinuity.length &&
    //   Utility.mFuzzyCompare(
    //     obj.discontinuity[obj.discontinuity.length - 1],
    //     samples[samples.length - 1].x,
    //     1e-10
    //   )
    // )
    //   if (
    //     obj.discontinuity &&
    //     obj.discontinuity.length &&
    //     Utility.mFuzzyCompare(obj.discontinuity[0], samples[0].x, 1e-10)
    //   ) {
    //     //samples = samples.slice(0, samples.length - 1);
    //   }

    //samples.shift();

    //console.log(samples);
    //remove outliers
    //TODO replace with algorithm that filters outliers.
    // if (obj.discontinuity && obj.discontinuity.length) {
    //   samples = samples.filter(function (e) {
    //     return Math.abs(e.y) < 1e14;
    //   });
    // }
    // if (obj.discontinuity && obj.discontinuity.length) {
    //   samples = this.filterOutlier(samples);
    // }

    //console.log(samples);
    return samples;
  }

  static curveTurningPoint(
    fn,
    variable,
    samples,
    decimalPlacesX = 4,
    decimalPlacesY = 4
  ) {
    if (!variable || fn.indexOf(variable) == -1) {
      return [];
    }
    //Replace the whitespace delimiters stripped out by simplify()
    fn = fn.replaceAll("mod", " mod ");

    const infPoints = Utility.curveInflectionPoint(
      fn,
      variable,
      samples,
      decimalPlacesX,
      decimalPlacesY
    );

    let m_fn = fn;
    let result = [];
    let derivative = null;
    try {
      derivative = math.derivative(m_fn, variable);
    } catch (error) {
      return result;
    }

    derivative = derivative.toString();
    if (isFinite(derivative)) {
      return result;
    }
    // if (isNaN(derivative) || !isFinite(derivative)) {
    //   return result;
    // }
    //derivative = derivative.toString();

    var solution = [];
    if (derivative.indexOf(variable) !== -1) {
      var eq = null;
      try {
        eq = nerdamer(`${derivative}=0`);
        solution = eq.solveFor(variable);
        nerdamer.flush();
      } catch (error) {
        //console.log("App unable to find turning point");
      }
    }
    //console.log(solution[0].toString());
    /* if (solution && solution.length < 20) {
      m_fn = m_fn.replaceAll(variable, "Z");
      for (let i = 0; i < solution.length; i++) {
        result.push(
          new Misc.Point(
            Utility.adjustForDecimalPlaces(
              parseFloat(solution[i].toString()),
              decimalPlacesX
            ),
            Utility.adjustForDecimalPlaces(
              math.evaluate(m_fn, { Z: parseFloat(solution[i].toString()) }),
              decimalPlacesY
            )
          )
        );
      }
      const xLower = samples[0].x;
      const xUpper = samples[samples.length - 1].x;
      //console.log(xLower, xUpper);

      result = result.filter(function (e) {
        return e.x >= xLower && e.x <= xUpper;
      });

      if (infPoints && infPoints.length) {
        const arr = infPoints.map(function (e) {
          return e.x;
        });
        result = result.filter(function (el) {
          return arr.indexOf(el.x) === -1;
        });
      }

      return result;
    } */

    const parser = new EvaluateExp(derivative);

    let sign = math.sign(parser.eval({ x: samples[0].x }));
    for (let i = 0; i < samples.length; i++) {
      const m = parser.eval({ x: samples[i].x });
      if (math.sign(m) !== 0 && math.sign(m) == sign * -1) {
        //Search for turning point
        const numOfSteps = 1000 / Static.accuracyFactor;
        const step = (samples[i].x - samples[i - 1].x) / numOfSteps;
        let arr = [];
        for (let n = 0; n < numOfSteps; n++) {
          let xVal = samples[i - 1].x + n * step;
          arr.push(Math.abs(parser.eval({ x: xVal })));
        }
        const min = Math.min(...arr);
        sign *= -1;
        let xVal = samples[i - 1].x + arr.indexOf(min) * step;
        result.push(
          new Misc.Point(
            Utility.adjustForDecimalPlaces(xVal, decimalPlacesX),
            Utility.adjustForDecimalPlaces(
              math.evaluate(m_fn, { x: xVal }),
              decimalPlacesY
            )
          )
        );
      }
    }
    return result;
  }

  static curveInflectionPoint(
    fn,
    variable,
    samples,
    decimalPlacesX = 4,
    decimalPlacesY = 4
  ) {
    let m_fn = fn;
    let result = [];
    let derivative = null;
    try {
      derivative = math.derivative(m_fn, variable);
    } catch (error) {
      return result;
    }
    if (isFinite(derivative.toString())) {
      return result;
    }
    // if (isNaN(derivative) || !isFinite(derivative)) {
    //   return result;
    // }
    derivative = math.derivative(derivative, variable);
    const parser = new EvaluateExp(derivative.toString());
    /* 1 when x > 0
      -1 when x < 0
      0 when x == 0 */
    // console.log("m_fn", m_fn);
    // console.log("samples[1].x", samples[1].x);
    let sign = math.sign(parser.eval({ x: samples[1].x }));
    if (sign == 0) {
      sign = 1;
    }
    for (let i = 1; i < samples.length; i++) {
      const m = parser.eval({ x: samples[i].x });
      // if (math.sign(m) == 0) {
      //   result.push(
      //     new Misc.Point(samples[i].x, math.evaluate(m_fn, { x: samples[i].x }))
      //   );
      //   sign *= -1;
      //   break;
      // }
      if (math.sign(m) !== 0 && math.sign(m) == sign * -1) {
        //Search for turning point
        const numOfSteps = 1000 / Static.accuracyFactor;
        const step = (samples[i].x - samples[i - 1].x) / numOfSteps;
        let arr = [];
        for (let n = 0; n < numOfSteps; n++) {
          let xVal = samples[i - 1].x + n * step;
          arr.push(Math.abs(parser.eval({ x: xVal })));
        }
        const min = Math.min(...arr);
        // console.log("Static.accuracyFactor", numOfSteps);
        //console.log(486, min);
        sign *= -1;
        let xVal = samples[i - 1].x + arr.indexOf(min) * step;
        result.push(
          new Misc.Point(
            Utility.adjustForDecimalPlaces(xVal, decimalPlacesX),
            Utility.adjustForDecimalPlaces(
              math.evaluate(m_fn, { x: xVal }),
              decimalPlacesY
            )
          )
        );
      }
    }
    return result;
  }
  //Utility.mode

  static mathMode() {
    //rad 0.89399666360055789051826949840421 grad 0.98768834059513772619004024769344
    const test = math.evaluate("sin(90)");
    if (test == 0.89399666360055789051826949840421) {
      return "rad";
    }
    if (test == 0.98768834059513772619004024769344) {
      return "grad";
    }
    return "deg";
  }

  /* static getOperand(str, keyword, indexOfKeyword) {
    const subStr = str.substring(indexOfKeyword + keyword.length);
    let operand1 = subStr[0];
    let result = XRegExp.matchRecursive(subStr, "\\(", "\\)", "g");
    if (result) {
      if (operand1 !== "(") {
        return { operand1, operand2: result[0] };
      } else {
        return { operand1: result[0], operand2: result[1] };
      }
    }
    return null;
  } */

  /**
   *
   * @param {*} exp
   * @param {*} keyword
   * @param {*} indexOfKeyword
   * @returns
   */
  static getOperand(exp, keyword, indexOfKeyword) {
    //get operand
    let unmodifiedOperand = null;
    let operand = "";
    let lBracket = 0;
    for (let i = indexOfKeyword + keyword.length; i < exp.length; i++) {
      if (exp[i] == "(") {
        operand += "(";
        lBracket++;
        continue;
      }
      if (exp[i] == ")") {
        if (lBracket) {
          operand += ")";
          lBracket--;
          if (lBracket == 0) {
            break;
          }
        }
        continue;
      }
      operand += exp[i];
    }
    if (
      //str.substr(0, str.lastIndexOf(list[i]))
      operand.length > 3 &&
      operand[0] == "(" &&
      operand[1] == "(" &&
      operand[operand.length - 1] == ")" &&
      operand[operand.length - 2] == ")"
    ) {
      operand = operand.substring(
        operand.indexOf("(") + 1,
        operand.lastIndexOf(")")
      );
      unmodifiedOperand = `(${operand})`;
    }

    return { operand, unmodifiedOperand };
  }

  // static getOperand(exp, keyword, indexOfKeyword) {
  //   //get operand
  //   let operand = "";
  //   let lBracket = 0;
  //   for (let i = indexOfKeyword + keyword.length; i < exp.length; i++) {
  //     if (exp[i] == "(") {
  //       operand += "(";
  //       lBracket++;
  //       continue;
  //     }
  //     if (exp[i] == ")") {
  //       operand += ")";
  //       lBracket--;
  //       if (lBracket == 0) {
  //         break;
  //       }
  //       continue;
  //     }
  //     operand += exp[i];
  //   }
  //   return operand;
  // }

  static getLogOperandAndBase(str, index) {
    let bracket = 0;
    let result = "";
    for (let i = index + 3; i < str.length; i++) {
      const c = str[i];
      result += c;
      if (c == "(") {
        bracket++;
      }
      if (c == ")") {
        bracket--;
      }
      if (bracket == 0) {
        return result;
      }
    }
    return result;
  }

  static getOperandOfExponentToken(exp, indexOfExponent) {
    //get operand
    let operand = "";
    let unmodifiedOperand = null;
    if (Utility.isAlpha(exp[indexOfExponent + 1])) {
      //return exp[indexOfExponent + 1];
      return { operand: exp[indexOfExponent + 1], unmodifiedOperand };
    } else {
      const substr = exp.substring(indexOfExponent + 1);
      const num = parseFloat(substr);
      if (!isNaN(num)) {
        //return num.toString();
        // let s = num.toString();
        // if (s.length > 1) {
        //   s = s[0] + "*" + s.substring(1);
        // }
        return { operand: num.toString(), unmodifiedOperand };
      }
    }

    let lBracket = 0;
    for (let i = indexOfExponent + 1; i < exp.length; i++) {
      if (exp[i] == "(") {
        operand += "(";
        lBracket++;
        continue;
      }
      if (exp[i] == ")") {
        operand += ")";
        lBracket--;
        if (lBracket == 0) {
          break;
        }
        continue;
      }
      operand += exp[i];
    }
    // if (
    //   //str.substr(0, str.lastIndexOf(list[i]))
    //   operand.length > 3 &&
    //   operand[0] == "(" &&
    //   operand[1] == "(" &&
    //   operand[operand.length - 1] == ")" &&
    //   operand[operand.length - 2] == ")"
    // ) {
    //   operand = operand.substring(
    //     operand.indexOf("(") + 1,
    //     operand.lastIndexOf(")")
    //   );
    //   unmodifiedOperand = `(${operand})`;
    // }

    //operand = operand.replaceAll("")
    return { operand, unmodifiedOperand };
  }

  static discontinuity(exp, lower, upper, indepVar) {
    $(window).bind("equationEditorAngleModeChanged", function (e, mode) {
      console.log(mode);
      Utility.mode = mode;
    });

    if (indepVar !== "x") {
      exp = Utility.purgeAndMarkKeywords(exp);
      while (exp.indexOf(indepVar) != -1) exp = exp.replace(indepVar, "x");
      exp = Utility.replaceKeywordMarkers(exp);
    }

    let denominators = [];
    const trigs = [
      "sin",
      "cos",
      "tan",
      "sec",
      "csc",
      "cot",
      "asin",
      "acos",
      "atan",
      "asec",
      "acsc",
      "acot",
    ];

    function replaceTrigTanKeyword(exp, keyword, replacement1, replacement2) {
      if (exp.indexOf(keyword) == -1) return exp;
      while (exp.indexOf(keyword) !== -1) {
        const indexOfKeyword = exp.indexOf(keyword);

        //get operand
        /* let operand = "";
        let lBracket = 0;
        for (let i = indexOfKeyword + keyword.length; i < exp.length; i++) {
          if (exp[i] == "(") {
            operand += "(";
            lBracket++;
            continue;
          }
          if (exp[i] == ")") {
            operand += ")";
            lBracket--;
            if (lBracket == 0) {
              break;
            }
            continue;
          }
          operand += exp[i];
        } */

        let obj = Utility.getOperand(exp, keyword, indexOfKeyword);
        if (obj.unmodifiedOperand) {
          exp = exp.replace(obj.unmodifiedOperand, obj.operand);
        }
        let operand = obj.operand;
        exp = exp.replace(
          keyword + operand,
          "((" + replacement1 + operand + ")/(" + replacement2 + operand + "))"
        );
      }
      return exp;
    }

    function replaceTrigKeyword(exp, keyword, replacement) {
      if (exp.indexOf(keyword) == -1) return exp;
      while (exp.indexOf(keyword) !== -1) {
        const indexOfKeyword = exp.indexOf(keyword);

        //get operand
        /* let operand = "";
        let lBracket = 0;
        for (let i = indexOfKeyword + keyword.length; i < exp.length; i++) {
          if (exp[i] == "(") {
            operand += "(";
            lBracket++;
            continue;
          }
          if (exp[i] == ")") {
            operand += ")";
            lBracket--;
            if (lBracket == 0) {
              break;
            }
            continue;
          }
          operand += exp[i];
        } */

        let obj = Utility.getOperand(exp, keyword, indexOfKeyword);
        if (obj.unmodifiedOperand) {
          exp = exp.replace(obj.unmodifiedOperand, obj.operand);
        }
        let operand = obj.operand;

        exp = exp.replace(
          keyword + operand,
          "(1/(" + replacement + operand + "))"
        );
      }
      return exp;
    }

    function adjustConstantForMode(exp) {
      const trigsForConstantAdjustment = [
        "sin",
        "cos",
        "tan",
        "sec",
        "csc",
        "cot",
        // "asin",
        // "acos",
        // "atan",
        // "asec",
        // "acsc",
        // "acot",
      ];

      for (let i = 0; i < trigsForConstantAdjustment.length; i++) {
        let keyword = trigsForConstantAdjustment[i];
        let indexOfKeyword = exp.indexOf(keyword);
        if (indexOfKeyword == -1) continue;
        while (indexOfKeyword !== -1) {
          indexOfKeyword = exp.indexOf(keyword, indexOfKeyword);
          if (indexOfKeyword !== -1) {
            //get operand
            let operand = "";
            let lBracket = 0;
            for (let i = indexOfKeyword + keyword.length; i < exp.length; i++) {
              if (exp[i] == "(") {
                operand += "(";
                lBracket++;
                continue;
              }
              if (exp[i] == ")") {
                operand += ")";
                lBracket--;
                if (lBracket == 0) {
                  break;
                }
                continue;
              }
              operand += exp[i];
            }
            let constant = 0,
              replacement = 0;
            if (Utility.mathMode() == "deg") {
              constant = Math.abs(math.evaluate(operand, { x: 0 }));
              if (constant != 0) {
                replacement = (constant * Math.PI) / 180;
                exp = exp.replace(constant, replacement);
              }
            }

            indexOfKeyword++;
            //replacement.toString().length - constant.toString().length + 1;
          }
        }
      }
      return exp;
    }

    function adjustForMode(solution) {
      let considerMode = false;
      for (let i = 0; i < denominators.length; i++) {
        for (let n = 0; n < trigs.length; n++) {
          if (denominators[i].indexOf(trigs[n]) !== -1) {
            considerMode = true;
            break;
          }
        }
        if (considerMode) break;
      }
      if (considerMode && Utility.mathMode() == "deg") {
        return (solution * 180) / Math.PI;
      }
      return solution;
    }

    function getCoeff(exp) {
      //exp = math.simplify(exp, {}, { exactFractions: false }).toString();
      let coeff = [];
      const node = math.parse(exp);
      const filtered = node.filter(function (node) {
        return node.op === "*" && node.args[1].name === "x";
      });

      // let filtered_constant = node.filter(function (node) {
      //   return node.type === "ConstantNode";
      // });

      for (let i = 0; i < filtered.length; i++) {
        coeff.push(filtered[i].args[0].getContent().value);
      }
      //coeff = _.uniq(coeff);
      return coeff;
    }

    function isPeriodic(exp) {
      return exp.indexOf("sin") != -1 || exp.indexOf("cos") != -1;
      /* exp = math.simplify(exp, {}, { exactFractions: false }).toString();
      let keyWord = "sin";
      if (exp.indexOf("cos") != -1) {
        keyWord = "cos";
      }
      let operand = Utility.getOperand(exp, keyWord, exp.indexOf(keyWord));
      operand = operand.replace("(", "").replace(")", "");
      let periodic = true;
      let _result = [];
      if (operand.length) {
        exp = exp.replaceAll(operand, "x");
        //exp = exp.replaceAll("*", "");
        let eq = nerdamer(`${exp}=0`);
        var solution = eq.solveFor("x");

        if (solution.length !== undefined && solution.length > 20) {
          for (let i = 0; i < solution.length; i++) {
            let val = Utility.adjustForDecimalPlaces(
              adjustForMode(math.evaluate(solution.at(i).valueOf())),
              10
            );
            _result.push(val);
          }
          _result = _.uniq(_result);
          _result = _result.sort(function (a, b) {
            return a - b;
          });

          //let periodic = true;
          //if (solution.length > 20) {
          let m_d = (_result[1] % 180) - (_result[0] % 180);
          for (let i = 1; i < _result.length; i++) {
            if (((_result[i] % 180) - (_result[i - 1] % 180)) % 180 != m_d) {
              periodic = false;
              break;
            }
          }
          // }
        }
      }
      return periodic; */
    }

    function getFactors(exp) {
      let factors = [];
      const node = math.parse(exp);
      const filtered = node.filter(function (node) {
        return (
          node.op === "*" &&
          (node.args[0].name === "sin" || node.args[0].name === "cos") &&
          (node.args[1].name === "sin" || node.args[1].name === "cos")
        );
      });

      // let filtered_constant = node.filter(function (node) {
      //   return node.type === "ConstantNode";
      // });

      for (let i = 0; i < filtered.length; i++) {
        factors.push(filtered[i].args[0].getContent().toString());
        factors.push(filtered[i].args[1].getContent().toString());
      }

      factors = factors.filter(function (e) {
        return e.indexOf("x") !== -1;
      });
      factors = _.uniq(factors);
      return factors;
    }

    function getDenominators(exp) {
      let denom = [];
      const node = math.parse(exp);
      const filtered = node.filter(function (node) {
        return node.op === "/";
      });

      // let filtered_constant = node.filter(function (node) {
      //   return node.type === "ConstantNode";
      // });

      for (let i = 0; i < filtered.length; i++) {
        denom.push(filtered[i].args[1].getContent().toString());
      }

      denom = denom.filter(function (e) {
        return e.indexOf("x") !== -1;
      });
      denom = _.uniq(denom);
      return denom;
    }

    exp = replaceTrigKeyword(exp, "sec", "cos");
    exp = replaceTrigKeyword(exp, "csc", "sin");
    exp = replaceTrigKeyword(exp, "cot", "tan");

    exp = replaceTrigTanKeyword(exp, "tan", "sin", "cos");
    //exp = replaceTrigTanKeyword(exp, "cot", "cos", "sin");
    try {
      exp = math.simplify(exp, {}, { exactFractions: false }).toString();
    } catch (error) {}
    //Replace the whitespace delimiters stripped out by simplify()
    exp = exp.replaceAll("mod", " mod ");
    exp = adjustConstantForMode(exp);

    let factors = [];
    denominators = denominators.concat(getDenominators(exp));
    denominators.forEach(function (d) {
      factors = factors.concat(getFactors(d));
    });

    if (factors.length == 0) {
      factors = denominators;
    }
    //console.log(486, denominators);

    let result = [];

    let d = 0;
    factors.forEach(function (e) {
      let m_result = [];
      let eq = null;
      var solution = null;
      try {
        eq = nerdamer(`${e}=0`);
        solution = eq.solveFor("x");
        nerdamer.flush();
      } catch (error) {
        console.log("Error in discontinuity()");
      }

      let periodic = false;
      let coeff = 1;
      if (
        solution.length > 20 &&
        (e.indexOf("sin") !== -1 || e.indexOf("cos") !== -1)
      ) {
        /* let coeffs = getCoeff(e);
        if (coeffs.length) coeff = coeffs[0]; */
        periodic = isPeriodic(e);
      }

      if (solution.length !== undefined) {
        for (let i = 0; i < solution.length; i++) {
          //console.log(math.evaluate(solution.at(i).valueOf()));
          // let val = Utility.adjustForDecimalPlaces(
          //   adjustForMode(math.evaluate(solution.at(i).valueOf())),
          //   10
          // );
          let val = Utility.adjustForDecimalPlaces(
            adjustForMode(solution.at(i).valueOf()),
            10
          );
          m_result.push(val);
        }
        m_result = _.uniq(m_result);
        m_result = m_result.sort(function (a, b) {
          return a - b;
        });

        //let periodic = true;
        if (solution.length > 20) {
          /* let m_d =
            (m_result[1] % Math.floor(180 / coeff)) -
            (m_result[0] % Math.floor(180 / coeff));
          for (let i = 1; i < m_result.length; i++) {
            if (
              ((m_result[i] % Math.floor(180 / coeff)) -
                (m_result[i - 1] % Math.floor(180 / coeff))) %
                Math.floor(180 / coeff) !=
              m_d
            ) {
              periodic = false;
              break;
            }
          } */

          if (periodic) {
            //a periodic function
            //Check for periodic
            d = m_result[1] - m_result[0];
            let a1 = m_result[0];

            if (d != 0) {
              //a periodic function
              if (m_result[0] > lower) {
                a1 = m_result[0] - Math.round((m_result[0] - lower) / d) * d;
              }
              m_result = [];

              let n = 0;
              while (1) {
                m_result.push(a1 + n * d);
                if (m_result[n] > upper) {
                  break;
                }
                n++;
              }
            }
          } else {
            //non periodic function with many solutions
          }
        }

        for (let i = 0; i < m_result.length; i++) {
          if (
            (m_result[i] >= lower ||
              Utility.mFuzzyCompare(m_result[i], lower, 1e-7)) &&
            (m_result[i] <= upper ||
              Utility.mFuzzyCompare(upper, m_result[i], 1e-7))
          ) {
            result.push(Utility.adjustForDecimalPlaces(m_result[i], 20));
          }
        }
      } else {
        let val = solution.valueOf();
        if (
          (val > lower || Utility.mFuzzyCompare(val, lower, 1e-10)) &&
          (val < upper || Utility.mFuzzyCompare(val, upper, 1e-10))
        ) {
          result.push(val);
        }
      }
    });

    result = _.uniq(result);
    result = result.sort(function (a, b) {
      return a - b;
    });
    return result;
  }

  /* static filterOutlier(samples) {
    let m_samples = samples.map(function (e) {
      return e.y;
    });

    //Arrange the data in order from smallest to largest.
    m_samples = m_samples.sort(function (a, b) {
      return a - b;
    });

    const numberOfSamples = m_samples.length;

    //Find the first quartile, Q1.
    let Q1 = m_samples[Math.round(0.25 * numberOfSamples)];
    let Q3 = m_samples[Math.round(0.75 * numberOfSamples)];

    let IQR = Q3 - Q1;

    //Find the upper boundary.
    const upper = Q3 + 20 * IQR;

    //Find the lower boundary.
    const lower = Q1 - 20 * IQR;

    samples = samples.filter(function (e) {
      return e.y > lower && e.y < upper;
    });

    return samples;
  } */

  /**
   * Make a class abstract. Abstract classes cannot be instantiated. See example.
   * @param {object} obj The `this` value
   * @param {Function} constructor The constructor
   * @example
   * class MyAbstractClass {
   *    constructor() {
   *      Utility.makeAbstract(this, MyAbstractClass);
   *    }
   * }
   * new MyAbstractClass() //Throws an error
   *
   * class MyClass extends MyAbstractClass {
   * }
   * new MyClass() //Ok
   *
   */
  static makeAbstract(obj, constructor) {
    if (obj.constructor == constructor) {
      throw new Error("Abstract classes can't be instantiated.");
    }
  }

  /**
   * Returns val bounded by min and max. This is equivalent to Math.max(min, Math.min(val, max)).
   * @param {Number} min Minimum value
   * @param {Number} val Value
   * @param {Number} max Maximum value
   * @returns {Number} Value
   * @example
   * let myValue = 10;
     let minValue = 2;
     let maxValue = 6;

     let boundedValue = Utility.qBound(minValue, myValue, maxValue);
     // boundedValue == 6
   */
  static qBound(min, val, max) {
    return Math.max(min, Math.min(val, max));
  }

  /**
   * Adjust the precision of a number.
   *
   * In most cases, round-off errors dont matter: they have no significant impact on the results. However,
   * it looks ugly when displaying output to a user. A solution is to limit the precision just below
   * the actual precision of 16 digits in the displayed output:
   * @param {number} value number to be adjusted.
   * @param {number} numberOfDigits required precision.
   * @returns {String} adjusted number.
   */
  static toPrecision(value, numberOfDigits) {
    if (numberOfDigits < 1) {
      numberOfDigits = 1;
    } else if (numberOfDigits > 16) {
      numberOfDigits = 16;
    }
    //return math.format(value, {precision: numberOfDigits});
    return value.toPrecision(numberOfDigits);
  }

  /* static logStep(changeType, obj = null) {
    let displayStr = null;
    switch (changeType) {
      case Static.operation:
        Utility.stepsData = obj;
        displayStr = `Finding the point(s) of intersection of the curves "${Utility.stepsData.equations[0]}" and "${Utility.stepsData.equations[1]}".`;
        console.log(displayStr);
        break;
      case Static.constructEquation:
        if (obj == "Intersection") {
          displayStr = `At any point of intersection, equtions are equal. Thus\n\t ${Utility.stepsData.equations[0]} = ${Utility.stepsData.equations[1]}.`;
        }
        console.log(displayStr);
        break;
      case Static.rearrangeEquation:
        if (obj == "Intersection") {
          displayStr = `Re-arranging the equations. We get\n\t (${Utility.stepsData.equations[0]}) - (${Utility.stepsData.equations[1]}) = 0`;
        }
        console.log(displayStr);
        break;
      case Static.solveEquation:
        if (obj == "Intersection") {
          displayStr = `Solving the equation for "${Utility.stepsData.variable}":`;
          console.log(displayStr);
          Static.stepper.load();
        }
        //Static.stepper.unload();
        //console.log(displayStr);
        break;

      default:
        break;
    }
  } */

  static grapherDeterminedDecimalPlaces(curve) {
    function countPlaces() {
      const m_samples = curve.data().samples();
      let placesX = 0;
      let placesY = 0;
      for (let i = 0; i < m_samples.length; i++) {
        let p = Utility.countDecimalPlaces(m_samples[i].x);
        if (p > placesX) {
          placesX = p;
        }
        p = Utility.countDecimalPlaces(m_samples[i].y);
        if (p > placesY) {
          placesY = p;
        }
      }
      return { placesX, placesY };
    }

    // console.log(curve);

    if (
      Utility.errorResponse === Utility.silentIgnore &&
      curve.discontinuity &&
      curve.discontinuity.length > 0
    ) {
      return { decimalPlacesX: 200, decimalPlacesY: 200 };
    }

    let decimalPlacesX = 4;
    let decimalPlacesY = 4;

    if (!curve || curve.rtti !== PlotItem.RttiValues.Rtti_PlotItem) {
      return { decimalPlacesX, decimalPlacesY };
    }

    let xMinAbs = Math.abs(curve.minXValue());
    if (xMinAbs < 1) {
      while (
        decimalPlacesX !== 15 &&
        math.round(xMinAbs, decimalPlacesX) == 0
      ) {
        decimalPlacesX += 1;
      }
      if (decimalPlacesX == 15) {
        decimalPlacesX = countPlaces().placesX;
      }
    }
    let yMinAbs = Math.abs(curve.minYValue());
    if (yMinAbs < 1) {
      while (
        decimalPlacesY !== 15 &&
        math.round(yMinAbs, decimalPlacesY) == 0
      ) {
        decimalPlacesY += 1;
      }
      if (decimalPlacesY == 15) {
        decimalPlacesY = countPlaces().placesY;
      }
    }
    if (decimalPlacesX == 0) {
      decimalPlacesX = 4;
    }
    if (decimalPlacesY == 0) {
      decimalPlacesY = 4;
    }
    return { decimalPlacesX, decimalPlacesY };
  }

  /**
   * Adjust the decimal places of a number. See example.
   * @param {number} number number to be adjusted.
   * @param {number} places number of decimal places.
   * @returns {number} adjusted number.
   * @example
   * adjustForDecimalPlaces(4.145214, 3) -> 4.145
   */
  static adjustForDecimalPlaces(number, places) {
    if (places == undefined) places = 5;

    // if (places > 300) places = 300;
    var multiplier = Math.pow(10, places);
    return Math.round(number * multiplier) / multiplier;
  }

  /**
   * Compares the floating point value a and b and returns true if they are considered equal, otherwise false.
   * @param {Number} a
   * @param {Number} b
   * @returns {Boolean} true if they are considered equal, otherwise false.
   */
  static mFuzzyCompare(a, b, eps = Static._eps) {
    var diff = Math.abs(a - b);
    if (diff < eps) {
      return true;
    }
    return false;
    //return (Math.abs(a - b) * 1000000000000. <= Math.min(Math.abs(a), Math.abs(b)));
  }

  /**
   * Compares the floating point value value1 and value2 and returns true if they are considered equal, otherwise false.
   * @param {Number} value1 Value
   * @param {Number} value2 Value
   * @param {Number} intervalSize Interval width
   * @returns {Boolean} true if they are considered equal, otherwise false.
   * @example
   * //The following two checks will determine if the value is within the interval
   * m3FuzzyCompare(value, interval.minValue(), interval.width())
   * m3FuzzyCompare(value, interval.maxValue(), interval.width())
   */
  static m3FuzzyCompare(value1, value2, intervalSize) {
    var eps = Math.abs(Static._eps * intervalSize);

    if (value2 - value1 > eps) return -1;

    if (value1 - value2 > eps) return 1;

    return 0;
  }

  /**
   * Build a RGB color string that represents the inverted color of the RGB color string received as argument.
   * @param {String} rgb Color (e.g.: "rgb(255, 0, 0)", "#ff0000", or "red")
   * @returns {String} Inverted color
   */
  static invert(bg) {
    if (typeof bg == "string" && bg.indexOf("#") == -1)
      bg = Utility.RGB2HTML(bg);
    // rgb = Utility.colorToRGB(rgb);
    // rgb = [].slice
    //   .call(arguments)
    //   .join(",")
    //   .replace(/rgb\(|\)|rgba\(|\)|\s/gi, "")
    //   .split(",");
    // for (var i = 0; i < rgb.length; i++) rgb[i] = (i === 3 ? 1 : 255) - rgb[i];
    // return "rgb(" + rgb.join(", ") + ")";

    bg = parseInt(Number(bg.replace("#", "0x")), 10);
    bg = ~bg;
    bg = bg >>> 0;
    bg = bg & 0x00ffffff;
    bg = "#" + bg.toString(16).padStart(6, "0");

    return bg;
  }

  /**
   * Generate a RGB color string from the argument.
   */
  static colorToRGB(hex) {
    if (hex.indexOf("rgb") !== -1) return hex;
    if (hex.indexOf("#") == -1) hex = Utility.colorNameToHex(hex);
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

    const r =
      "rgb(" +
      parseInt(result[1], 16) +
      "," +
      parseInt(result[2], 16) +
      "," +
      parseInt(result[3], 16) +
      ")";

    return r;
  }

  /**
   * Generate a hex color string from the argument(s). See example for usage.
   * @param {object|String|Number} red An object or string representing a RGB color or a number ([0-255]) representing the red component of the color.
   * @param {Number} [green] A number ([0-255]) representing the green component of the color (Disregarded if red is not a number)
   * @param {Number} [blue] A number ([0-255]) representing the blue component of the color (Disregarded if red is not a number)
   * @returns {String} hex color string
   * @example
   * RGB2HTML({r:255, g:0, b:0}) -> "#ff0000"
   * RGB2HTML("rgb(255, 0, 0)") -> "#ff0000"
   * RGB2HTML(255, 0, 0) -> "#ff0000"
   */
  static RGB2HTML(red, green, blue) {
    if (typeof red == "string") {
      var str = red;
      //console.log(red)
      str = str.replace("rgb(", "");
      red = parseInt(str);
      str = str.replace(",", "");
      str = str.replace(red, "");
      green = parseInt(str);
      str = str.replace(",", "");
      str = str.replace(green, "");
      blue = parseInt(str);
    }
    if (red.r !== undefined) {
      var temp = red;
      red = red.r;
      green = temp.g;
      blue = temp.b;
    }
    var decColor = 0x1000000 + blue + 0x100 * green + 0x10000 * red;
    return "#" + decColor.toString(16).substr(1);
  }

  /**
   * Get a hex color string from a color name.
   * @param {String} colour color name
   * @returns {String} hex color string
   * @example
   * colorNameToHex("aliceblue") -> "#f0f8ff"
   */
  static colorNameToHex(colour) {
    var colours = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgrey: "#a9a9a9",
      darkgreen: "#006400",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      "indianred ": "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370d8",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#d87093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32",
    };

    if (typeof colour === "object")
      return Utility.RGB2HTML(colour.r, colour.g, colour.b);

    if (colour[0] == "r" && colour[1] == "g" && colour[2] == "b")
      return Utility.RGB2HTML(colour);

    if (colour[0] == "#") return colour;

    if (typeof colours[colour.toLowerCase()] != "undefined")
      return colours[colour.toLowerCase()];

    return "#000000";
  }

  /**
   * Displays a dialog box with a message.
   * @param {string} msg The text to display in the dialog box
   * @param {string} [type = "big"] To display a small dialog, use "small" for this argument.
   * @param {string} [doNotShowOptionId] Unique Id use to display the "Don't show again" checkbox.
   *
   * @example
   * Utility.alert("No curves found", "small") //Display a small alert box with the message "No curves found".
   */
  static alert(msg, type, doNotShowOptionId) {
    if (Utility.alertObj == undefined) {
      Utility.alertObj = new AlertDlg();
    }
    Utility.alertObj.alert(msg, type, doNotShowOptionId);
  }

  /**
	 * Displays a dialog box with a question and allow the user to cancel or answer Yes or No.
	 * @param {string} msg The text(question) to display in the dialog box.
	 * @param {Function} cb A callback, that takes one argument(an integer), that is called when the user clicks Yes, No or Cancel. See example below.
	 * @param {string} [type = "big"] To display a small dialog, use "small" for this argument.
	 * @example Utility.alertYesNo("Do you want to save the changes to the Grapher?", function(answer){
		switch(answer){
			case Cancel:
				console.log('do Cancel stuff')
				break;
			case Yes:
				console.log('do Yes stuff')
				break;
			case No:
				console.log('do No stuff')
				break;
			default:
				// code block
		}
		}); 
	 */
  static alertYesNo(msg, cb, type) {
    if (Utility.alertObj == undefined) {
      Utility.alertObj = new AlertDlg();
    }
    Utility.alertObj.alertYesNo(msg, cb, type);
  }

  /**
	 * Displays a dialog box that prompts the visitor for input.
	 * @param {string} msg The text to display in the dialog box
	 * @param {string} defaultMsg The default input text
	 * @param {Function} cb A callback, that takes one argument, that is called when the visitor clicks OK. See example below.
	 * @param {string} [type = "big"] To display a small dialog, use "small" for this argument.
	 * @example Utility.prompt("Enter a new name for", "AAAA", function(str){
			console.log(str) //If the visitor clicks OK, the input is log to the console. 
			return true
			})
	 */
  static prompt(msg, defaultMsg, cb, type) {
    if (Utility.promptObj == undefined) {
      Utility.promptObj = new PromptDlg();
    }
    Utility.promptObj.prompt(msg, defaultMsg, cb, type);
  }

  /**
   * Build a color string of the form "rgb(225, 0, 0)" from the form "#ff0000";
   * @param {String} hex Hex color string
   * @returns {String} Equivalent RGB color string
   */
  static HTMLToRGB(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
      ? Utility.mRgb(
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
        )
      : null;
  }

  /**
   * Build an object representing a RGB color
   * @param {Number} red Integer between 0 and 255 representing the red color component
   * @param {Number} green Integer between 0 and 255 representing the green color component
   * @param {Number} blue Integer between 0 and 255 representing the blue color component
   * @returns {object} An object of the form {r: 255, g:0, b:0}. The object has a toString() method that provides a string representation of the object. obj.toString() -> "rgb(255, 0, 0)"
   */
  static mRgb(red, green, blue) {
    return {
      r: red,
      g: green,
      b: blue,
      toString: function () {
        return "rgb(" + red + "," + green + "," + blue + ")";
      },
    };
  }

  /**
   * Build an object representing a RGBA color
   * @param {Number} red Integer between 0 and 255 representing the red color component
   * @param {Number} green Integer between 0 and 255 representing the green color component
   * @param {Number} blue Integer between 0 and 255 representing the blue color component
   * @param {Number} alpha Integer between 0 and 255 representing the alpha color component
   * @returns {object} An object of the form {r: 255, g:0, b:0, a:0}. The object has a toString() method that provides a string representation of the object. obj.toString() -> "rgb(255, 0, 0, 0)"
   */
  static mRgba(red, green, blue, alpha) {
    return {
      r: red,
      g: green,
      b: blue,
      a: alpha,
      toString: function () {
        return "rgb(" + red + "," + green + "," + blue + "," + alpha + ")";
      },
    };
  }

  static containAlpha(str) {
    if (!str || str.length == 0) {
      return false;
    }
    for (let i = 0; i < str.length; i++) {
      if (Utility.isAlpha(str[i])) {
        return true;
      }
    }
    return false;
  }

  /**
   * @param {String} ch Character
   * @returns {number} Returns true if the character is a letter. otherwise returns false.
   */
  static isAlpha(ch) {
    ch = ch.toLowerCase().charCodeAt(0);
    return ch > 96 && ch < 122;
  }

  static isDigit(c) {
    let pattern = /[0-9]/;
    return pattern.test(c);
  }

  static removeUnwantedParentheses(str) {
    let arr = str.match(/\([-+*/.+a-zA-Z0-9]*\)/g);
    if (!arr) return str;
    for (let i = 0; i < arr.length; i++) {
      let doReplace = false;
      let subStr = arr[i];

      let replStr = subStr.substring(1, subStr.length - 1);

      let replStr2 = replStr
        .replaceAll("*", "")
        .replaceAll("/", "")
        .replace(/[a-zA-Z]/g, "");
      if (math.hasNumericValue(replStr2)) {
        doReplace = true;
      }

      if (replStr.length === 1 || math.hasNumericValue(replStr) || doReplace) {
        str = str.replace(subStr, replStr);
      }
    }
    return str;
  }

  static removeUnwantedAsterisk(str) {
    //return str;
    if (str.length < 3) return str;
    if (str.length == 3) {
      if (str[1] == "*" && Utility.isDigit(str[0]) && Utility.isAlpha(str[2])) {
        return str.replace("*", "");
      }
      return str;
    }
    let result = str[0];

    for (let i = 1; i < str.length; i++) {
      if (str[i] !== "*") {
        result += str[i];
        continue;
      }

      if (str[i - 2] && str[i - 2] == "^") {
        result += str[i];
        continue;
      }

      if (Utility.isDigit(str[i - 1]) && Utility.isAlpha(str[i + 1])) {
        if (str[i + 2]) {
          if (!Utility.isAlpha(str[i + 2])) {
            continue;
          } else {
            result += str[i];
          }
        }
      }
      if (
        Utility.isAlpha(str[i - 1]) &&
        (str[i + 1] == "(" || Utility.isDigit(str[i + 1]))
      ) {
        result += str[i];
        continue;
      }
      if (
        Utility.isAlpha(str[i - 1]) &&
        str[i + 2] &&
        Utility.isAlpha(str[i + 1]) &&
        Utility.isAlpha(str[i + 2])
      ) {
        result += str[i];
      }
    }
    return result;
  }

  static enableIntegrate() {}

  /**
   * The expression parser of math.js has support for letting functions
   * parse and evaluate arguments themselves, instead of calling them with
   * evaluated arguments.
   *
   * By adding a property `raw` with value true to a function, the function
   * will be invoked with unevaluated arguments, allowing the function
   * to process the arguments in a customized way.
   *
   * enableIntegrate() sets up math.js to handle finite integration.
   *
   *
   * Syntax:
   *
   *     integrate(integrand, variable, start, end)
   *     integrate(integrand, variable, start, end, step)
   *
   * @example
   * math.evaluate('integrate(2*x, x, 0, 2)') //integrate 2x with respect to x between the limit [0 - 2]
   * math.evaluate('integrate(2*x, x, 0, 2, 0.01)') //integrate 2x with respect to x between the limit [0 - 2] in steps of 0.01
   *
   */
  static enableIntegrate() {
    if (math.integrate) return;
    //integraeEnabled = true;

    /**
     * Calculate the numeric integration of a function
     *
     * @param {Function} f
     * @param {number} start
     * @param {number} end
     * @param {number} [step=0.01]
     * @inner
     */
    function integrate(f, start, end, volumeX, step) {
      //Reset
      Static.total_area = 0;
      Static.total_volume = 0;
      var _x = 0;
      volumeX = volumeX || false;
      var x = start;
      var y = 0;
      if (volumeX) {
        if (step > Static._eps) {
          for (x; x < end; x += step) {
            var _x = x + step;
            if (_x > end) step = step - (_x - end);
            y = f(x + step / 2);
            Static.total_volume += y * step * y * Math.PI;
          }
        } else {
          alert(
            "The aplication is attempting to use too small a step in the trapezoidial rule."
          );
        }
        return Static.total_volume;
      }
      if (step > Static._eps) {
        for (x; x < end; x += step) {
          var _x = x + step;
          if (_x > end) step = step - (_x - end);
          y = f(x + step / 2);
          Static.total_area += y * step;
        }
      } else {
        alert(
          "The aplication is attempted to use too small a step in the trapezoidial rule."
        );
      }

      return Static.total_area;
    }

    /**
     * A transformation for the integrate function. This transformation will be
     * invoked when the function is used via the expression parser of math.js.
     *
     * Syntax:
     *
     *     integrate(integrand, variable, start, end)
     *     integrate(integrand, variable, start, end, step)
     *
     * Usage:
     *
     *     math.evaluate('integrate(2*x, x, 0, 2)')
     *     math.evaluate('integrate(2*x, x, 0, 2, 0.01)')
     *
     * @param {Array.<math.expression.node.Node>} args
     *            Expects the following arguments: [f, x, start, end, step]
     * @param {object} math
     * @param {object} [scope]
     */
    integrate.transform = function (args, math, scope) {
      // determine the variable name
      if (!args[1].isSymbolNode) {
        throw new Error("Second argument must be a symbol");
      }
      const variable = args[1].name;

      // evaluate start, end, and step
      var start = args[2].compile().evaluate(scope);
      var end = args[3].compile().evaluate(scope);
      var volumeX = args[4] && args[4].compile().evaluate(scope); // volumeX is optional
      var step = args[5] && args[5].compile().evaluate(scope); // step is optional

      // create a new scope, linked to the provided scope. We use this new scope
      // to apply the variable.
      var fnScope = scope;

      // construct a function which evaluates the first parameter f after applying
      // a value for parameter x.
      var fnCode = args[0].compile();
      var f = function (x) {
        fnScope.set(variable, x);
        return fnCode.evaluate(fnScope);
      };

      // execute the integration
      return integrate(f, start, end, volumeX, step);
    };

    // mark the transform function with a "rawArgs" property, so it will be called
    // with uncompiled, unevaluated arguments.
    integrate.transform.rawArgs = true;

    // import the function into math.js. Raw functions must be imported in the
    // math namespace, they can't be used via `eval(scope)`.
    math.import({
      integrate: integrate,
    });
  }

  /**
   * Build a string from `str` for which any keyword is replaced by `""`
   * @param {*} str
   * @returns {String} String with all keywords removed
   */
  static purgeKewords(str) {
    var result = str.replace(/\^/g, "");
    let count = 0;
    for (var i = 0; i < Static.keywords.length; ++i) {
      while (result.indexOf(Static.keywords[i]) != -1) {
        result = result.replace(Static.keywords[i], "");
        count++;
      }
    }
    return { str: result, count };
  }

  /**
   * Search a expresion string for a independent variable.
   *
   * An idependent variable is any alpha character other than e.
   * @param {String} fx Expression string
   * @returns {String} Independent variable.
   */
  static findIndepVar(fx) {
    //e = 2.718281828, thus 'e' is excluded from alphas
    var alphas = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var i = 0;

    var fnWithoutKeywords = Utility.purgeKewords(fx).str;

    while (i < fnWithoutKeywords.length) {
      var c = fnWithoutKeywords.charAt(i);
      var str = "";
      while (alphas.indexOf(c) != -1 && i < fnWithoutKeywords.length) {
        str += c;
        ++i;
        c = fnWithoutKeywords.charAt(i);
      }
      if (str.length === 1) {
        return str;
      }
      ++i;
    }
    return undefined;
  }

  // /\b(log)\b/g
  static countString(str, subStr, wholeWord = false) {
    let pattern = null;
    if (wholeWord) {
      pattern = new RegExp(`\\b${subStr}\\b`, "g");
    } else {
      pattern = new RegExp(`${subStr}`, "g");
    }
    let res = str.match(pattern);
    if (res) {
      return res.length;
    }
    return 0;
  }

  static getLogBase(str, index) {
    let result = "";
    let bracket = 0;
    let collectChar = false;
    for (let i = index; i < str.length; i++) {
      if (collectChar) {
        result += str[i];
      }
      if (str[i] == "(") {
        bracket++;
        if (!collectChar) {
          collectChar = true;
          result += str[i];
        }
      }
      if (str[i] == ")") {
        bracket--;
        //result += str[i];
      }
      if (collectChar && bracket == 0) {
        return result;
      }
    }
    return result;
  }

  static splitParametricFunction(str) {
    if (!Utility.isParametricFunction(str)) {
      return null;
    }

    let logCommaExpected = 0;
    let arr = null;
    str = str.replace("(", "");
    str = str.substring(0, str.length - 1);

    const comma = Utility.countString(str, ",");
    if (comma == 1) {
      arr = str.split(",");
      return { operand: arr[0], base: arr[1] };
    } else {
      for (let i = 0; i < str.length; i++) {
        if (
          i + 3 < str.length &&
          str[i] == "l" &&
          str[i + 1] == "o" &&
          str[i + 2] == "g"
        ) {
          logCommaExpected++;
          i += 3;
        }
        if (str[i] == ",") {
          if (logCommaExpected == 0) {
            return {
              operand: str.substring(0, i),
              base: str.substring(i + 1, str.length),
            };
          } else {
            logCommaExpected--;
          }
        }
      }
    }
    return null;
  }

  static isParametricFunction(str) {
    if (!(str[0] == "(" && str[str.length - 1] == ")")) {
      return false;
    }

    const comma = Utility.countString(str, ",");
    if (comma == 0) {
      return false;
    } else {
      const kw = Utility.countString(str, "log");
      if (comma - kw == 1) {
        return true;
      } else {
        return false;
      }
    }
    return false;
  }

  /**
   * Check the expression string for a keyword
   * @param {String} str String to search
   * @returns {String} keyword or if no keyword is found, null.
   */
  static containsKeyword(str) {
    for (var i = 0; i < Static.keywords.length; i++) {
      if (str.indexOf(Static.keywords[i]) == -1) continue;
      return Static.keywords[i];
    }
    return null;
  }

  static containsTrigKeyword(str) {
    for (var i = 0; i < Static.trigKeywords.length; i++) {
      if (str.indexOf(Static.trigKeywords[i]) == -1) continue;
      return Static.trigKeywords[i];
    }
    return null;
  }

  // static insertAbs(expStr) {
  //   var str = expStr;

  //   let bar = 0;
  //   let par = 0;
  //   for (let i = 0; i < str.length; i++) {
  //     if (str[i] == "|") {
  //       bar++;
  //       str = str.replace(str[i], "$"); //opening bar
  //     }
  //     if (par == 0) {
  //     }
  //   }

  //   str = str.replace("$", "abs(");
  //   str = str.replace("~", ")");
  //   return str;
  // }

  /**
   * Build a Math.js valid expression string from `expStr` for which any occurrences of `logb(x)` is replaced by `log(x, b)` where b, the base, is an integer between 2 and 10.
   * @example
   * logBaseAdjust("4x^2 + log4(1.5x)") -> "4x^2 + log(1.5x, 4)"
   * @param {String} expStr Expression string
   * @returns {String} Modified expression string
   */
  static logBaseAdjust(expStr) {
    /* var logBaseStr = [
      "log2",
      "log3",
      "log4",
      "log5",
      "log6",
      "log7",
      "log8",
      "log9",
      "log10",
    ];

    //helper
    function insertLogBase(expStr, logStr) {
      if (!expStr) return null;
      var str = expStr;
      //var resultStr = "";
      if (expStr.includes(logStr)) {
        var base = logStr.replace("log", "");
        //console.log(base)
        while (str.indexOf(logStr) !== -1) {
          var i = str.indexOf(logStr) + logStr.length;
          var leftPar = 0;
          var rightPar = 0;
          for (i; i < str.length; ++i) {
            if (str[i] == "(") leftPar++;
            if (str[i] == ")") rightPar++;
            if (leftPar == rightPar) {
              str = str.insertAt(i, 0, "," + base);
              str = str.replace(logStr, "log");
              //console.log(str)
              break;
            }
          }
        }
      }
      return str;
    }

    for (var i = 0; i < logBaseStr.length; i++) {
      expStr = insertLogBase(expStr, logBaseStr[i]);
    } */
    return expStr;
  }

  /**
   * Get the square of the number
   * @param {Number} value Number to square (value*value)
   * @returns {number} Square of value (value*value)
   */
  static sqr(value) {
    return Math.pow(value, 2);
  }

  static replaceKeywordMarkers(str) {
    for (var i = 0; i < Utility.keywordMarkers.length; ++i) {
      while (str.indexOf(Utility.keywordMarkers[i].marker) != -1) {
        str = str.replace(
          Utility.keywordMarkers[i].marker,
          Utility.keywordMarkers[i].keyword
        );
      }
    }
    Utility.keywordMarkers = [];
    return str;
  }

  static purgeAndMarkKeywords(str) {
    for (var i = 0; i < Static.keywords.length; ++i) {
      while (str.indexOf(Static.keywords[i]) != -1) {
        var _marker = "%" + Utility.keywordMarkers.length + "%";
        str = str.replace(Static.keywords[i], _marker);
        Utility.keywordMarkers.push({
          marker: _marker,
          keyword: Static.keywords[i],
        });
      }
    }
    return str;
  }

  static insertProductSignOnPi(str) {
    if (str.indexOf(",") != -1) return str;
    if (!str || str.length == 0) {
      return "";
    }
    let indexOfPi = str.indexOf("pi");
    while (indexOfPi !== -1) {
      if (
        indexOfPi + 1 < str.length - 1 &&
        Utility.isAlpha(str[indexOfPi + 2])
      ) {
        str = str.replace("pi", "pi*");
      }
      if (indexOfPi > 0 && Utility.isAlpha(str[indexOfPi - 1])) {
        str = str.replace("pi", "*pi");
      }
      indexOfPi = str.indexOf("pi", indexOfPi + 1);
    }
    return str;
  }

  static insertProductSign(str, defines) {
    if (str.indexOf(",") != -1) return str;
    if (!str || str.length == 0) {
      return "";
    }

    str = str.replace(/\s/g, "");

    // try {
    //   str = math
    //     .simplify(str, {}, { exactFractions: false })
    //     .toString()
    //     .replace(/\s/g, "");
    // } catch (error) {}
    // str = math
    //   .simplify(str, {}, { exactFractions: false })
    //   .toString()
    //   .replace(/\s/g, "");

    //Replace the whitespace delimiters stripped out by simplify()
    //str = str.replaceAll("mod", " mod ");

    function hasKeyword(str) {
      for (var i = 0; i < Static.keywords.length; ++i) {
        while (str.indexOf(Static.keywords[i]) != -1) return true;
      }
      return false;
    }

    //if (hasKeyword(str)) return str;

    let res = null;
    if (hasKeyword(str)) {
      str = Utility.purgeAndMarkKeywords(str);
      res = str.match(/%(.*?)%/g);
      for (let i = 0; i < res.length; i++) {
        // str = str.replace(res[i], `(${res[i]}`);
      }
    }

    var result = "";
    result += str[0];
    for (var i = 1; i < str.length; ++i) {
      if (
        (Utility.isAlpha(str[i - 1]) && Utility.isAlpha(str[i])) ||
        (Utility.isAlpha(str[i - 1]) && str[i] == "(")
      ) {
        if (
          defines &&
          !defines.isCharPartOfAdefine(str[i - 1]) &&
          str[i - 1] !== ","
        ) {
          //if (!defines?.isCharPartOfAdefine(str[i - 1]) && str[i - 1] !== ",") {
          result += "*";
        }
      }
      // if (_.isFinite(str[i - 1]) && Utility.isAlpha(str[i])) {
      //   result += "*";
      // }
      result += str[i];
    }

    if (res) {
      /* for (let i = 0; i < res.length; i++) {
        result = result.replace(`(${res[i]}`, res[i]);
      } */
      result = Utility.replaceKeywordMarkers(result);
    }

    result = Utility.insertProductSignOnPi(result);
    return result;
  }

  /* Static.keywords = [
  "unaryMinus",
  "sqrt",
  "asinh",
  "acosh",
  "atanh",
  "acoth",
  "asech",
  "acsch",
  "asin",
  "acos",
  "atan",
  "acot",
  "asec",
  "acsc",
  "sinh",
  "cosh",
  "tanh",
  "coth",
  "sech",
  "csch",
  "sin",
  "cos",
  "tan",
  "sec",
  "csc",
  "cot",
  "ln",
  "log",
  "log2",
  "log3",
  "log4",
  "log5",
  "log6",
  "log7",
  "log8",
  "log9",
  "log10",
  "deg",
  "pi",
  "PI",
  "e",
  // "E",
  "abs",
  //"mod",
]; //"deg" comes before "e", deliberately. */

  static getExponentTokenPrefix(str, indexOfToken) {
    const substr = str.substring(0, indexOfToken);
    let pattern = /log_\(([^)]+)\)/;
    let _result = substr.match(pattern);
    if (_result && _result[0]) {
      return _result[0];
    }

    pattern = /log_([^)]+)/;
    _result = substr.match(pattern);
    if (_result && _result[0]) {
      return _result[0];
    }

    let result = "";
    indexOfToken--;

    while (
      indexOfToken > -1 &&
      (Utility.isAlpha(str[indexOfToken]) || str[indexOfToken - 1] == "_") //log^ || log_^ || log_2^ || log_(22)^
    ) {
      result += str[indexOfToken];
      indexOfToken--;
    }
    return [...result].reverse().join("");
    //return "log_(10)";
  }

  static missingClosingPar(str) {
    let par = 0;
    for (let i = 0; i < str.length; i++) {
      const element = str[i];
      if (str[i] == "(") {
        par++;
      }
      if (str[i] == ")") {
        par--;
      }
    }
    if (par > 0) {
      return true;
    }
    return false;
  }

  static replaceLatex(result) {
    function getDivideOperand(exp, keyword, indexOfKeyword) {
      //get operand
      let operand = "";
      let lBracket = 0;
      for (let i = indexOfKeyword; i < exp.length; i++) {
        if (!lBracket && exp[i] == "(") {
          operand += "(";
          lBracket++;
          continue;
        }
        if (lBracket && exp[i] !== ")") {
          //operand += ")";
          operand += exp[i];
        }
        if (exp[i] == ")") {
          operand += ")";
          if (operand.indexOf("\\frac") !== -1) {
            if (exp[i + 1] && exp[i + 1] == "(") {
              continue;
            } else {
              operand = operand.replace("(", "");
              return operand;
            }
          }
          operand = operand.replace("(", "").replace(")", "");
          return operand;
        }
      }
      return null;
    }

    function purgeLatexFrac(str) {
      let index = str.indexOf("frac");
      if (index == -1) return str;

      while (index !== -1) {
        let operandsArr = str.replace(")(", ")@(").split("@");
        let operand1 = operandsArr[0].replace("frac", "");
        let operand2 = operandsArr[1];
        str = str.replace(
          `frac${operand1}${operand2}`,
          `${operand1}/${operand2}`
        );
        index = str.indexOf("frac");
      }
      return str;
    }

    //result = purgeLatexFrac(result);

    result = result
      .replaceAll("^{}", "")
      .replace(/\\operatorname{abs}/g, "abs")
      .replace(/{/g, "(")
      .replace(/}/g, ")")
      .replace(/\\operatorname{abs}/g, "abs")
      .replace(/\\left/g, "")
      .replace(/\\right/g, "")
      .replace(/\\cdot/g, "*")
      .replace(/\\lbrace/g, "{")
      .replace(/\\rbrace/g, "}")
      .replace(/\\sin/g, "sin")
      .replace(/\\cos/g, "cos")
      .replace(/\\tan/g, "tan")
      .replace(/\\cot/g, "cot")
      .replace(/\\csc/g, "csc")
      .replace(/\\sec/g, "sec")
      .replace(/\\log2/g, "log2")
      .replace(/\\ln/g, "ln")
      .replace(/\\pi/g, "pi")
      //.replace(/^(\\prime)/g, "'")
      .replaceAll("\\prime", "'")
      //.replace(/^(\\doubleprime)/g, "''")
      .replaceAll("\\doubleprime", "''")
      .replaceAll("')", "'")
      .replaceAll("('", "'")
      .replaceAll("^'", "'")
      .replace(/\\sqrt/g, "sqrt")
      .replaceAll("sin^(-1)", "asin") //\sin^{(-1)}
      .replaceAll("sin^((-1))", "asin")
      .replaceAll("cos^(-1)", "acos")
      .replaceAll("cos^((-1))", "acos")
      .replaceAll("tan^(-1)", "atan")
      .replaceAll("tan^((-1))", "atan")
      .replaceAll("cot^(-1)", "acot")
      .replaceAll("cot^((-1))", "acot")
      .replaceAll("sec^(-1)", "asec")
      .replaceAll("sec^((-1))", "asec")
      .replaceAll("csc^(-1)", "acsc")
      .replaceAll("csc^((-1))", "acsc")
      .replace(/\\sinh/g, "sinh")
      .replace(/\\cosh/g, "cosh")
      .replace(/\\tanh/g, "tanh")
      .replace(/\\coth/g, "coth")
      .replace(/\\csch/g, "csch")
      .replace(/\\sech/g, "sech")
      .replaceAll("sinh^(-1)", "asinh")
      .replaceAll("sinh^((-1))", "asinh")
      .replaceAll("cosh^(-1)", "acosh")
      .replaceAll("cosh^((-1))", "acosh")
      .replaceAll("tanh^(-1)", "atanh")
      .replaceAll("tanh^((-1))", "atanh")
      .replaceAll("coth^(-1)", "acoth")
      .replaceAll("coth^((-1))", "acoth")
      .replaceAll("csch^(-1)", "acsch")
      .replaceAll("csch^((-1))", "acsch")
      .replaceAll("sech^(-1)", "asech")
      .replaceAll("sech^((-1))", "asech")
      .replace(/\\log/g, "log")
      .replace(/\\abs/g, "abs")
      .replace(/\\times/g, "*")
      //.replaceAll("?", ")")
      .replace(/\\/g, "")
      .replace(/\s/g, "");

    result = purgeLatexFrac(result);

    return result;
  }

  static isValidNonAlphaChar(c) {
    const isValidNonAlphaChars = ["(", ")", "+", "*", "-", "/", "^"];
    return isValidNonAlphaChars.indexOf(c) != -1;
  }

  static indexOfFirstNonValidChar(str) {
    const isValidNonAlphaChar = ["(", ")", "+", "*", "-", "/"];
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      if (
        Utility.isAlpha(c) ||
        Utility.isDigit(c) ||
        Utility.isValidNonAlphaChar(c)
      ) {
        continue;
      }
      if (i < str.length - 2 && c == "." && Utility.isDigit(str[i + 1])) {
        continue;
      }
      return i;
    }
    return -1; //Invalid index
  }

  static mathjsErrorToPosition(errorStr) {
    let arr = errorStr.match(/(char \d+)/);
    if (arr) {
      return parseInt(arr[0].replace("char ", ""));
    }
    return -1;
  }

  // static errorCheck(mf) {
  //   function doCheck(json) {
  //     if (json[0] == "Error") {
  //       return json;
  //     }
  //     for (let i = 0; i < json.length; i++) {
  //       const e = json[i];
  //       if (typeof e == "object") {
  //         let res = doCheck(e);
  //         if (res) {
  //           return res;
  //         }
  //       }
  //     }
  //     return null;
  //   }

  //   let result = [];

  //   if (mf.expression.isValid) {
  //     return null;
  //   }
  //   const ce = mf.computeEngine;
  //   const json = ce.parse(mf.value).json;

  //   return doCheck(json);
  // }

  static adjustLatexLogBaseDecimalPlaces(decimalPlaces) {
    Utility.logLatex = math.log.toTex;

    math.log.toTex = function (node, options) {
      node.traverse(function (node, path, parent) {
        //console.log(node, path, parent); //args[1]
        if (node.type === "ConstantNode" && path === "args[1]") {
          node.value = math.round(node.value, decimalPlaces);
        }
        return node;
      });
      return `\\mathrm{log_{${node.args[1]}}}\\left(${node.args[0]}\\right)`;
    };
  }

  static restoreLatexLogBaseDecimalPlaces() {
    math.log.toTex = Utility.logLatex;
  }

  static extendGetValue(mf) {
    try {
      //Alow custom functions.
      const customFunctions = {
        log_: function (a, b) {
          return math.log(b, a);
        },
      };
      math.import(customFunctions);
    } catch (error) {}

    /* 
      Helper functions    */

    function exponentOnKeyword(result) {
      let index = result.indexOf("^");
      let bracketAdded = false;
      while (index !== -1) {
        const prefix = Utility.getExponentTokenPrefix(result, index);

        let obj = Utility.getOperandOfExponentToken(result, index);
        if (obj.operand.length > 1 && obj.operand[0] !== "(") {
          result = result.replace(
            `${prefix}^${obj.operand[0]}`,
            `(${prefix}^${obj.operand[0]})`
          );
          bracketAdded = true;
        }
        if (
          (obj.operand == "-1" || obj.operand == "(-1)") &&
          Static.trigKeywords.indexOf(prefix) !== -1
        ) {
          if (prefix[0] == "a") {
            result = result.replace(`${prefix}`, `${prefix.substring(1)}`);
          } else {
            result = result.replace(`${prefix}`, `a${prefix}`);
          }
          result = result.replace(`^${obj.operand}`, "");
        }
        if (obj.unmodifiedOperand) {
          result = result.replace(obj.unmodifiedOperand, obj.operand);
        }
        const operandOfExponent = obj.operand;

        if (prefix.indexOf("pi") === -1) {
          obj = Utility.getOperand(
            result,
            prefix + "^" + operandOfExponent,
            index - prefix.length
          );
        } else {
          // obj = Utility.getOperand(result, "^", index);
          // if (obj.unmodifiedOperand) {
          //   result = result.replace(obj.unmodifiedOperand, obj.operand);
          // }
          index = result.indexOf("^", index + 1);
          continue;
        }
        let operand = obj.operand;

        if (prefix.length > 1) {
          const strToReplace = `${prefix}^${operandOfExponent}${operand}`;
          const replacementStr = `${prefix}${operand}^(${operandOfExponent})`;
          result = result.replace(strToReplace, replacementStr);
          index = result.indexOf(
            "^",
            result.indexOf(operand, index) + operand.length + 2
          );
        } else {
          if (bracketAdded) {
            index = result.indexOf("^", index + 2);
          } else {
            index = result.indexOf("^", index + 1);
          }
          bracketAdded = false;
        }
      }
      return result;
    }

    //////////////////////////////////////////////////////

    mf.getValueTemp = mf.getValue;

    mf.getValue = function (format = "ascii-math") {
      const mf = this;

      const latex = mf.getValueTemp("latext");
      let result = latex
        .replace(/\\times/g, "\\cdot")
        .replaceAll("{\\prime}", "primePlaceHolder")
        .replaceAll("{\\doubleprime}", "doublePrimePlaceHolder")
        .replace(/\\cdot/g, "cdotPlaceHolder");

      mf.value = result;

      result = mf.getValueTemp(format);
      mf.value = latex;

      // const matches1 = result.match(
      //   /(\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)(?=mod)|.(?=mod))/
      // );
      // const matches2 = result.match(
      //   /((?<=mod)\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)|(?<=mod).)/
      // );

      // if (matches1) {
      //   matches1.forEach(function (oprnd1, i) {
      //     result = result.replace(
      //       `${matches1[i]}mod${matches2[i]}`,
      //       `mod(${matches1[i]},${matches2[i]})`
      //     );
      //   });
      // }

      result = result.replaceAll("primePlaceHolder", "'");
      result = result.replaceAll("doublePrimePlaceHolder", "''");
      result = result.replaceAll("^'", "'");
      result = result.replaceAll("cdotPlaceHolder", "*");

      result = result
        .replace(/\s/g, "")
        .replace(/\\operatorname{abs}/g, "abs")
        .replace(/\\lbrace/g, "{")
        .replace(/\\rbrace/g, "}");

      result = exponentOnKeyword(result);

      if (Utility.missingClosingPar(result)) {
        result = result.replace(/\?/g, ")");
      }

      let index = result.indexOf("log");
      if (index !== -1) {
        while (index !== -1 && result[index + 3] !== "_") {
          result = result.replace("log", "log_(10)");
          index = result.indexOf("log", index + 3);
        }

        index = result.indexOf("log_(");
        while (index !== -1) {
          const n = result.indexOf(")", index);
          const base = Utility.getLogBase(result, index); //log_12(8)
          const obj = Utility.getOperand(result, `log_${base}`, index);
          if (obj.unmodifiedOperand) {
            result = result.replace(obj.unmodifiedOperand, obj.operand);
          }
          let operand = obj.operand;
          result = result.replace(
            `log_${base}${operand}`,
            `log(${operand},${base})`
          );
          index = result.indexOf("log_(");
        }

        index = result.indexOf("log_");
        while (index !== -1) {
          const base = result[index + 4];
          const obj = Utility.getOperand(result, `log_${base}`, index);
          if (obj.unmodifiedOperand) {
            result = result.replace(obj.unmodifiedOperand, obj.operand);
          }
          let operand = obj.operand;

          result = result.replace(
            `log_${base}${operand}`,
            `log(${operand},${base})`
          );
          index = result.indexOf("log_");
        }
      }

      //Add whitespace delimiters to mod (i.e modulus ooperator)
      result = result.replaceAll("mod", " mod ");

      return result;
    };
  }

  // static latexToAscii(mf) {
  //   return mf.getValue("ascii-math");
  // }

  /* static latexToAscii1(mf, throwError = true) {
    let mfValue = mf.value.replaceAll("\\left", "").replaceAll("\\right", "");

    mf.value = mf.value.replaceAll("_{}", "");

    let index = mf.value.indexOf("\\ln_");
    if (index !== -1) {
      Utility.displayErrorMessage(mf, `"ln" cannot have a subscript.`);
      return null;
    }

    mf.value = mf.value.replaceAll("^{}", "");
    let result = Utility.replaceLatex(mf.value);

    index = result.indexOf("frac");
    while (index !== -1) {
      let obj = Utility.getOperand(result, "frac", index);
      if (obj.unmodifiedOperand) {
        result = result.replace(obj.unmodifiedOperand, obj.operand);
      }
      let operand1 = obj.operand;

      obj = Utility.getOperand(result, "frac" + operand1, index);
      if (obj.unmodifiedOperand) {
        result = result.replace(obj.unmodifiedOperand, obj.operand);
      }
      let operand2 = obj.operand;
      result = result.replace(
        `frac${operand1}${operand2}`,
        `${operand1}/${operand2}`
      );
      index = result.indexOf("frac");
    }

    index = result.indexOf("sqrt[");
    while (index !== -1) {
      const indexOfClosingSquareBracket = result.indexOf("]");
      const root = result.substring(index + 5, indexOfClosingSquareBracket);

      const obj = Utility.getOperand(result, "sqrt[" + root + "]", index);
      if (obj.unmodifiedOperand) {
        result = result.replace(obj.unmodifiedOperand, obj.operand);
      }
      let operand = obj.operand;

      result = result.replace(
        `sqrt[${root}]${operand}`,
        `nthRoot(${operand}, ${root})`
      );
      index = result.indexOf("sqrt[");
    }

    index = result.indexOf("^");
    let bracketAdded = false;
    while (index !== -1) {
      const prefix = Utility.getExponentTokenPrefix(result, index);
      let obj = Utility.getOperandOfExponentToken(result, index);
      if (obj.operand.length > 1 && obj.operand[0] !== "(") {
        result = result.replace(
          `${prefix}^${obj.operand[0]}`,
          `(${prefix}^${obj.operand[0]})`
        );
        bracketAdded = true;
      }
      if (obj.unmodifiedOperand) {
        result = result.replace(obj.unmodifiedOperand, obj.operand);
      }
      const operandOfExponent = obj.operand;
      if (throwError) {
        try {
          math.parse(operandOfExponent);
        } catch (error) {
          Utility.displayErrorMessage(mf, error.message);
          return null;
        }
      }
      obj = Utility.getOperand(
        result,
        prefix + "^" + operandOfExponent,
        index - prefix.length
      );
      if (obj.unmodifiedOperand) {
        result = result.replace(obj.unmodifiedOperand, obj.operand);
      }
      let operand = obj.operand;

      if (prefix.length > 1) {
        const strToReplace = `${prefix}^${operandOfExponent}${operand}`;
        const replacementStr = `${prefix}${operand}^(${operandOfExponent})`;
        result = result.replace(strToReplace, replacementStr);
        index = result.indexOf(
          "^",
          result.indexOf(operand, index) + operand.length + 2
        );
      } else {
        if (bracketAdded) {
          index = result.indexOf("^", index + 2);
        } else {
          index = result.indexOf("^", index + 1);
        }
        bracketAdded = false;
      }
    }

    index = result.indexOf("()");
    while (index !== -1) {
      const s = mf.value.replace("()", "(?)");
      $("#fnDlg_function")[0].setValue(s);
      if (throwError) {
        Utility.displayErrorMessage(
          mf,
          `operand expected at char ${index + 2}`
        );
        return null;
      }
      index = result.indexOf("()", index + 1);
    }

    index = result.indexOf("log");
    while (index !== -1 && result[index + 3] !== "_") {
      result = result.replace("log", "log_(10)");
      index = result.indexOf("log", index + 3);
    }

    index = result.indexOf("log_(");
    while (index !== -1) {
      const n = result.indexOf(")", index);

      const base = Utility.getLogBase(result, index); //log_12(8)

      const obj = Utility.getOperand(result, `log_${base}`, index);
      if (obj.unmodifiedOperand) {
        result = result.replace(obj.unmodifiedOperand, obj.operand);
      }
      let operand = obj.operand;

      result = result.replace(
        `log_${base}${operand}`,
        `log(${operand},${base})`
      );
      index = result.indexOf("log_(");
    }

    index = result.indexOf("log_");
    while (index !== -1) {
      //const n = result.indexOf(")", index);
      const base = result[index + 4]; //log_2(8)
      const obj = Utility.getOperand(result, `log_${base}`, index);
      if (obj.unmodifiedOperand) {
        result = result.replace(obj.unmodifiedOperand, obj.operand);
      }
      let operand = obj.operand;

      result = result.replace(
        `log_${base}${operand}`,
        `log(${operand},${base})`
      );

      index = result.indexOf("log_");
    }

    result = Utility.insertProductSignOnPi(result);

    result = result.replace(/\(,\)/g, "_()");

    if (result[0] == "'") {
      Utility.displayErrorMessage(
        mf,
        `valid expressions cannot start with char prime`
      );
      return null;
    }
    if (result[result.length - 1] == "'") {
      Utility.displayErrorMessage(
        mf,
        `valid expressions cannot end with char prime`
      );
      return null;
    }
    index = result.indexOf("'");
    let pos = 0;
    while (index !== -1 && result[index + 1]) {
      for (let i = index + 1; i < result.length; i++) {
        pos = i;
        if (result[i] == "'") {
          continue;
        }
        if (result[i] == "(") {
          break;
        }
        Utility.displayErrorMessage(mf, `"(" expected after char ${i + 1}`);
        return null;
      }
      index = result.indexOf("'", pos);
    }

    const arr = result.split("=");

    for (let i = 0; i < arr.length; i++) {
      index = arr[i].indexOf("{");
      if (index !== -1) {
        arr[i] = arr[i].substring(0, index);
      }
      //Ensure we have a expression that mathjs can parse
      if (throwError && !Utility.isParametricFunction(arr[i])) {
        try {
          math.parse(arr[i]);
        } catch (error) {
          Utility.displayErrorMessage(mf, error.message);
          return null;
        }
      }
    }

    if (Utility.missingClosingPar(result)) {
      result = result.replace(/\?/g, ")");
    }

    return result;
  } */

  static displayErrorMessage(mf, errorMessage) {
    if (errorMessage) {
      Utility.toolTip = $(mf).attr("data-original-title");
      mf.applyStyle({ backgroundColor: "red" }, { range: [-1, 0] });
      $(mf).addClass("red-tooltip").attr("data-original-title", errorMessage);
    } else {
      $(mf).tooltip("hide");
      $(mf).attr("data-original-title", Utility.toolTip);
      $(mf).removeClass("red-tooltip");
    }
  }

  static tex2svgMultiline(
    latex,
    lengthHint = 24,
    options = { em: 16, ex: 6, display: false }
  ) {
    //////Helpers//////////
    const mj = function (tex) {
      return MathJax.tex2svg(tex, options);
    };

    const indexBetweenCurly = function (str, index) {
      const m_substring = str.substring(0, index);
      const matchOpenCurly = m_substring.match(/{/g);
      const matchCloseCurly = m_substring.match(/}/g);
      if (matchOpenCurly == null && matchCloseCurly == null) {
        return false;
      }
      if (matchOpenCurly && matchCloseCurly == null) {
        return true;
      }
      if (matchOpenCurly == null && matchCloseCurly) {
        return true;
      }
      if (matchOpenCurly.length !== matchCloseCurly.length) {
        return true;
      }
      return false;
    };

    const indexBetweenParenthis = function (str, index) {
      const m_substring = str.substring(0, index);
      const matchOpenCurly = m_substring.match(/\(/g);
      const matchCloseCurly = m_substring.match(/\)/g);
      if (matchOpenCurly == null && matchCloseCurly == null) {
        return false;
      }
      if (matchOpenCurly && matchCloseCurly == null) {
        return true;
      }
      if (matchOpenCurly == null && matchCloseCurly) {
        return true;
      }
      if (matchOpenCurly.length !== matchCloseCurly.length) {
        return true;
      }
      return false;
    };

    const indexBetweenBracket = function (str, index) {
      if (!indexBetweenCurly(str, index)) {
        return indexBetweenParenthis(str, index);
      }
      return true;
    };

    //console.log(indexBetweenCurly("45+{{x-3}+25}+{}", 13));

    ////////////////////////////////

    if (latex.length <= lengthHint) {
      return mj(latex, options);
    }

    let substringsArr = [];

    let lag = latex;
    let indexOfPlus = lag.indexOf("+");
    let indexOfMinus = lag.indexOf("-");

    while (indexOfPlus > -1 || indexOfMinus > -1) {
      if (indexOfPlus > -1 && !indexBetweenBracket(lag, indexOfPlus)) {
        let lead = lag.substring(0, indexOfPlus);
        substringsArr.push(lead);
        lag = lag.substring(indexOfPlus);
        indexOfPlus = lag.indexOf("+", 1);
        indexOfMinus = lag.indexOf("-", 1);
        continue;
      } else if (indexOfMinus > -1 && !indexBetweenBracket(lag, indexOfMinus)) {
        let lead = lag.substring(0, indexOfMinus);
        substringsArr.push(lead);
        lag = lag.substring(indexOfMinus);
        indexOfPlus = lag.indexOf("+", 1);
        indexOfMinus = lag.indexOf("-", 1);
        continue;
      }
      if (indexOfPlus !== -1) indexOfPlus = lag.indexOf("+", indexOfPlus + 1);
      if (indexOfMinus !== -1)
        indexOfMinus = lag.indexOf("-", indexOfMinus + 1);
    }
    if (lag.length) {
      substringsArr.push(lag);
    }

    let m_substringsArr = [];
    let s = substringsArr[0];
    for (let i = 1; i < substringsArr.length; i++) {
      if ((s + substringsArr[i]).length < lengthHint) {
        s += substringsArr[i];
        continue;
      }
      m_substringsArr.push(s);
      s = substringsArr[i];
    }
    m_substringsArr.push(s);

    //let tooltipParts1_arr = tooltipParts1.split("#");
    let child = mj(m_substringsArr[0]);
    //let childInnerHtml = "";
    for (let i = 1; i < m_substringsArr.length; i++) {
      const element = m_substringsArr[i];
      child.innerHTML = child.innerHTML + `<br>` + mj(element).innerHTML;
    }
    return child;
  }

  /////////////////////////////////////////////////////////////
  /*static loggerSetup() {
    var stepper = (function () {
      "use strict";
      var core = nerdamer.getCore(),
        _ = core.PARSER,
        //the container for the function steps
        stepper = {},
        //nerdamer makes recursive calls when adding, subtracting, etc. Making
        //sure the stack is clear ensures that we're at the first call
        stack = [];
      //a function to add calls to the stack
      var wrapper = function (f, a, b) {
        stack.push("lock");
        var r = f(a, b);
        stack.pop();
        return r;
      };
      //This logging function makes sure that there aren't any items on the stack
      //before logging
      var logger = function () {
        if (stack.length === 0 && typeof this === "function")
          this.apply(undefined, arguments);
      };

      var expression = null;

      //the semi-globals
      var add, subtract, divide, multiply, pow, fcall;

      var load = function () {
        //ADD
        add = _.add;
        var step_add = function (a, b) {
          var result;
          logger.call(stepper.pre_add, a, b);
          var wrapper_result = wrapper(
            function (a, b) {
              result = add.call(_, a.clone(), b.clone());
              return result;
            },
            a,
            b
          );
          logger.call(stepper.post_add, result, a, b);
          return wrapper_result;
        };
        _.add = step_add;
        //SUBTRACT
        subtract = _.subtract;
        var step_subtract = function (a, b) {
          var result;
          logger.call(stepper.pre_subtract, a, b);
          var wrapper_result = wrapper(
            function (a, b) {
              result = subtract.call(_, a.clone(), b.clone());
              return result;
            },
            a,
            b
          );
          logger.call(stepper.post_subtract, result, a, b);
          return wrapper_result;
        };
        _.subtract = step_subtract;
        //DIVIDE
        divide = _.divide;
        var step_divide = function (a, b) {
          var result;
          logger.call(stepper.pre_divide, a, b);
          var wrapper_result = wrapper(
            function (a, b) {
              result = divide.call(_, a.clone(), b.clone());
              return result;
            },
            a,
            b
          );
          logger.call(stepper.post_divide, result, a, b);
          return wrapper_result;
        };
        _.divide = step_divide;
        //MULTIPLY
        multiply = _.multiply;
        var step_multiply = function (a, b) {
          var result;
          logger.call(stepper.pre_multiply, a, b);
          var wrapper_result = wrapper(
            function (a, b) {
              result = multiply.call(_, a.clone(), b.clone());
              return result;
            },
            a,
            b
          );
          logger.call(stepper.post_multiply, result, a, b);
          return wrapper_result;
        };
        _.multiply = step_multiply;
        //POW
        pow = _.pow;
        var step_pow = function (a, b) {
          var result;
          logger.call(stepper.pre_pow, a, b);
          var wrapper_result = wrapper(
            function (a, b) {
              result = pow.call(_, a.clone(), b.clone());
              return result;
            },
            a,
            b
          );
          logger.call(stepper.post_pow, result, a, b);
          return wrapper_result;
        };
        _.pow = step_pow;
        //CALLFUNCTION
        //function calls are not recursive and can have more than one call on the stack
        //because of this we don't use the wrapper
        fcall = _.callfunction;
        var step_fcall = function (fname, args) {
          if (
            stepper.pre_function_call &&
            typeof stepper.pre_function_call === "function"
          )
            stepper.pre_function_call.call(undefined, fname, args);
          var f = fcall.call(_, fname, args);
          if (
            stepper.post_function_call &&
            typeof stepper.post_function_call === "function"
          )
            stepper.post_function_call.call(undefined, f, fname, args);
          return f;
        };
        _.callfunction = step_fcall;
      };

      //load(); //fire away

      var xport = function (o, override) {
        for (var x in o) {
          if (!stepper[x] || (stepper[x] && override)) stepper[x] = o[x];
        }
      };

      xport.unload = function () {
        _.add = add;
        _.subtract = subtract;
        _.multiply = multiply;
        _.divide = divide;
        _.pow = pow;
        _.callfunction = fcall;
      };

      function write(str) {
        console.log(str);
      }

      var rmBrackets = Utility.removeUnwantedParentheses;

      function reWriteExpression(expression) {
        let _expression = nerdamer(`sort(${expression})`).toString();
        if (_expression[0] !== "[") {
          //simplified expression returned
          return { exp: _expression, change: "simplified" };
        }

        _expression = _expression
          .replace("[", "")
          .replace("]", "")
          .replace(/,/g, "+");

        let test = math.simplify(`${_expression} - ${expression}`).toString();
        //Replace the whitespace delimiters stripped out by simplify()
        test = test.replaceAll("mod", " mod ");
        if (test !== "0" && test !== "+0" && test !== "-0") {
          return { exp: expression, change: "unchanged" };
        }

        if (math.compareText(_expression, expression) !== 0) {
          return { exp: _expression, change: "rearranged" };
        }

        return { exp: expression, change: "unchanged" };
      }

      var updateExp = function (oper, result, a, b = null) {
        //result = result.toString();
        if (oper == "+") {
          expression = expression.replace(`${a}+${b}`, result + "");
        }
        if (oper == "-") {
          expression = expression.replace(`${a}-${b}`, result + "");
        }
        if (oper == "*") {
          expression = expression.replace(`${a}*${b}`, result + "");
        }
        if (oper == "/") {
          expression = expression.replace(`${a}/${b}`, result + "");
        }
      };

      // var findInExpression = function (s) {
      //   const str = s.toString();
      //   if (expression.indexOf(str) !== -1) {
      //     return str;
      //   }

      //   return null;
      // };

      xport.log = function (_exp, type = "Simplify") {
        const expEqu = type === "Simplify" ? "expression" : "equation";
        write(`${type} ${expEqu} "${_exp}"\n`);
        _exp = _exp.replaceAll(" ", "");
        //const e = reWriteExpression(rmBrackets(exp));
        const { exp, change } = reWriteExpression(_exp);
        if (change === "simplified") {
          write(`Simplifying:-\n\tWe get: ${exp}\n`);
        } else if (change === "rearranged") {
          write(`Re-writing the equation.\n\tWe get: ${exp}\n`);
        } else {
          write(`No simplification:-\n\tWe get: ${exp}\n`);
        }

        expression = exp;

        load();
        nerdamer(expression);
        xport.unload();
      };

      xport.clear = function () {
        stepper = {};
      };

      xport.load = load;

      xport.exp = function () {
        return expression;
      };

      xport.write = write;

      xport.expression = expression;
      xport.updateExp = updateExp;

      return xport;
    })();

    stepper({
      pre_add: function (a, b) {
        //console.log("Adding " + a + " to " + b);
      },
      pre_subtract: function (a, b) {
        //console.log("Subtracting " + b + " from " + a);
      },
      pre_multiply: function (a, b) {
        //console.log("Multiplying " + a + " by " + b);
      },
      pre_divide: function (a, b) {
        //console.log("Dividing " + a + " by " + b);
      },
      pre_pow: function (a, b) {
        //console.log("Raising " + a + " to the power of " + b);
      },
      pre_function_call: function (fname, args) {
        console.log(
          "The function " + fname + " was called with arguments " + args
        );
      },
      post_function_call: function (f) {
        console.log("Afterwards this resulted in " + f + "\n");
      },
      post_add: function (result, a, b) {
        stepper.updateExp("+", result, a, b);
        stepper.write(`Adding ${a} to ${b}:\n\tWe get: ${stepper.exp()}`);
      },
      post_subtract: function (result, a, b) {
        stepper.updateExp("-", result, a, b);
        stepper.write(
          `Subtracting ${b} from ${a}:\n\tWe get: ${stepper.exp()}`
        );
      },
      post_multiply: function (result, a, b) {
        stepper.updateExp("*", result, a, b);
        stepper.write(`Multiplying ${a} by ${b}:\n\tWe get: ${stepper.exp()}`);
      },
      post_divide: function (result, a, b) {
        stepper.updateExp("/", result, a, b);
        stepper.write(`Dividing ${a} by ${b}:\n\tWe get: ${stepper.exp()}`);
        // console.log(
        //   "The result of dividing " + a + " by " + b + " was " + result + "\n"
        // );
      },
      post_pow: function (result, a, b) {
        console.log(
          "The result of raising " +
            a +
            " to the powe rof " +
            b +
            " was " +
            result +
            "\n"
        );
      },
    });

    return stepper;
  }*/

  ////////////////////////////////////////////////////////////////
}
Utility.promptErrorMsg = "";
Utility.promptProgress = false;
Utility.adjustDomain = 0;
Utility.warn = 1;
Utility.warnIgnore = 2;
Utility.silentIgnore = 3;
Utility.errorResponseChanged = false;
Utility.errorResponse = Utility.adjustDomain;
Utility.keywordMarkers = [];

Utility.mode = "deg";

Utility.stepsData = null;

define("utility", ["evaluateExp"], function(){});


/**
 * A collection of utility classes for painting to the canvas
 * @namespace
 */
var PaintUtil = {};
/**
 * Creates a ContextPainter object. (For internal use only)
 * @constructor
 * @param {CanvasRenderingContext2D} ctx context
 */
PaintUtil.ContextPainter = function (ctx) {
  var m_ctx = ctx;
  var penStyle = "";
  var m_font = null;

  class Transform {
    constructor() {
      var trans = m_ctx.getTransform();

      this.dx = function () {
        return trans.m41;
      };

      this.dy = function () {
        return trans.m42;
      };
      /*
            x' = m11*x + m21*y + dx
            y' = m22*y + m12*x + dy
            if (is not affine) {
                w' = m13*x + m23*y + m33
                x' /= w'
                y' /= w'
            }
            If rotation or shearing has been specified, this function returns the bounding rectangle. To retrieve the exact region the given rectangle maps to, use the mapToPolygon() function instead.
            */
      this.mapRect = function (rect) {
        var x = rect.left();
        var y = rect.top();
        return new Misc.Rect(
          trans.m11 * x + trans.m21 * y + this.dx(),
          trans.m22 * y + trans.m12 * x + this.dy(),
          rect.width(),
          rect.height()
        );
      };

      this.map = function (pt) {
        var x = pt.x;
        var y = pt.y;
        return new Misc.Point(
          trans.m11 * x + trans.m21 * y + this.dx(),
          trans.m22 * y + trans.m12 * x + this.dy()
        );
      };
    }
  }

  this.getTransform = function (x, y) {
    return new Transform();
  };

  this.textSize = function (str) {
    m_ctx.save();
    m_ctx.font =
      m_font.weight +
      " " +
      m_font.style +
      " " +
      m_font.th +
      "px " +
      m_font.name;
    var w = m_ctx.measureText(str).width;
    var h = m_ctx.measureText("M").width;
    m_ctx.restore();
    return new Misc.Size(w, h);
  };

  this.context = function () {
    return m_ctx;
  };

  this.canvasWidth = function () {
    return m_ctx.canvas.width;
  };

  this.canvasHeight = function () {
    return m_ctx.canvas.height;
  };

  this.save = function () {
    m_ctx.save();
  };

  this.restore = function () {
    m_ctx.restore();
  };

  this.translate = function (x, y) {
    m_ctx.translate(x, y);
  };

  this.rotate = function (rot) {
    m_ctx.rotate((rot * Math.PI) / 180);
  };

  this.scale = function (x, y) {
    m_ctx.scale(x, y);
  };

  /*style
      solid
      dash : ctx.setLineDash([10, 5])
      dashDot : ctx.setLineDash([12, 5, 3, 5])
      dashDotDot : ctx.setLineDash([12, 5, 3, 5, 3, 5])
      dot : ctx.setLineDash([2, 8])
    */
  this.setPen = function (pen) {
    if (this.style == Static.NoPen) m_ctx.strokeStyle = "transparent";
    else m_ctx.strokeStyle = pen.color;
    m_ctx.lineWidth = pen.width;
    if (pen.style === "dash") m_ctx.setLineDash([10, 5]);
    else if (pen.style === "dot") m_ctx.setLineDash([3, 8]);
    else if (pen.style === "dashDot") m_ctx.setLineDash([12, 5, 3, 5]);
    else if (pen.style === "dashDotDot") m_ctx.setLineDash([12, 5, 3, 5, 3, 5]);

    penStyle = pen.style;
  };

  this.pen = function () {
    var color = "";
    if (m_ctx.strokeStyle == "transparent") color = NoPen;
    else color = m_ctx.strokeStyle;
    return new Misc.Pen(color, m_ctx.lineWidth, penStyle);
  };

  this.setBrush = function (brush) {
    if (brush.color === undefined || brush.color === Static.NoBrush)
      m_ctx.fillStyle = "transparent";
    else m_ctx.fillStyle = brush.color;
  };

  this.brush = function () {
    return m_ctx.fillStyle;
  };

  this.setFont = function (font) {
    m_ctx.font =
      font.weight + " " + font.style + " " + font.th + "px " + font.name;
    if (typeof font.fontColor !== "") m_ctx.fillStyle = font.fontColor;

    m_font = font;
  };

  this.font = function () {
    return m_font;
  };

  this.fillRect = function (rect, brush) {
    if (brush.style !== Static.NoBrush) {
      //m_ctx.save();
      this.setBrush(brush);
      m_ctx.rect(rect.left(), rect.top(), rect.width(), rect.height());
      m_ctx.fill();
      //m_ctx.restore();
    }
  };

  this.drawPath = function (path) {
    m_ctx.beginPath();
    for (var i = 0; i < path.elementCount(); i++) {
      var element = path.elementAt(i);
      var x = element.x;
      var y = element.y;

      switch (element.type) {
        case Misc.MoveToElement: {
          //                        if ( doAlign )
          //                        {
          //                            x = qRound( x );
          //                            y = qRound( y );
          //                        }

          m_ctx.moveTo(x, y);
          break;
        }
        case Misc.LineToElement: {
          //                        if ( doAlign )
          //                        {
          //                            x = qRound( x );
          //                            y = qRound( y );
          //                        }

          m_ctx.lineTo(x, y);
          break;
        }
        case Misc.CurveToElement: {
          var element1 = path.elementAt(++i);
          var x1 = element1.x;
          var y1 = element1.y;

          var element2 = path.elementAt(++i);
          var x2 = element2.x;
          var y2 = element2.y;

          m_ctx.bezierCurveTo(x, y, x1, y1, x2, y2);

          break;
        }
        case Misc.CurveToDataElement: {
          break;
        }
      }
    }
    m_ctx.stroke();
    m_ctx.fill();
  };

  this.drawPoint = function (pt) {
    var pw = this.pen().width;
    m_ctx.fillStyle = this.pen().color;
    m_ctx.fillRect(
      pt.x - pw * 1.0 - 1,
      pt.y - pw * 1.0 - 1,
      pw * 2.0,
      pw * 2.0
    );
  };

  this.drawPoints = function (points) {
    m_ctx.fillStyle = this.pen().color;
    var pw = this.pen().width;
    for (var i = 0; i < points.length; ++i)
      m_ctx.fillRect(
        points[i].x - pw * 1.0 - 1,
        points[i].y - pw * 1.0 - 1,
        pw * 2.0,
        pw * 2.0
      );
  };

  this.drawLine = function (param1, param2, param3, param4) {
    m_ctx.beginPath();
    if (typeof param4 !== "undefined" && typeof param3 !== "undefined") {
      m_ctx.moveTo(param1, param2);
      m_ctx.lineTo(param3, param4);
      //m_ctx.stroke();
    } else {
      m_ctx.moveTo(param1.x, param1.y);
      m_ctx.lineTo(param2.x, param2.y);
    }
    m_ctx.stroke();
  };

  this.drawImage = function (image, param1, param2, param3, param4) {
    var x = 0,
      y = 0,
      w = image.width(),
      h = image.height();
    if (typeof param1 === "object") {
      //A rect
      x = param1.left();
      y = param1.top();
      w = param1.width();
      h = param1.height();
    }
    if (typeof param1 === "number" && typeof param2 === "number") {
      x = param1;
      y = param2;
    }
    if (typeof param3 === "number" && typeof param4 === "number") {
      w = param3;
      h = param4;
    }
    if (image.width() > 0 && image.height() > 0) {
      m_ctx.putImageData(image.imageData(), x, y, 0, 0, w, h);
    }
  };

  this.drawPolyline = function (polyline) {
    m_ctx.beginPath();
    //m_ctx.lineCap = "butt";
    m_ctx.moveTo(polyline[0].x, polyline[0].y);
    for (var i = 1; i < polyline.length; ++i)
      m_ctx.lineTo(polyline[i].x, polyline[i].y);
    m_ctx.stroke();
  };

  this.drawPolygon = function (polyline) {
    if (
      polyline[0].x !== polyline[polyline.length - 1].x ||
      polyline[0].y !== polyline[polyline.length - 1].y
    )
      polyline.push(polyline[0]);
    m_ctx.beginPath();
    this.drawPolyline(polyline);
    m_ctx.closePath();
    m_ctx.fill();
  };

  this.drawRect = function (x, y, width, height) {
    m_ctx.beginPath();
    if (typeof x == "number") m_ctx.rect(x, y, width, height);
    else {
      var rect = x;
      m_ctx.rect(rect.left(), rect.top(), rect.width(), rect.height());
    }
    m_ctx.stroke();
    m_ctx.fill();
    m_ctx.closePath();
  };

  this.drawCircle = function (x, y, radius) {
    m_ctx.beginPath();
    if (typeof x == "number")
      //m_ctx.rect(x, y, width, height);
      m_ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
    else {
      var pt = x;
      radius = y;
      m_ctx.arc(pt.x, pt.y, radius, 0, 2 * Math.PI, false);
    }
    m_ctx.stroke();
    m_ctx.fill();
    m_ctx.closePath();
  };

  //this.drawEllipse = function(centerX, centerY, width, height) {
  this.drawEllipse = function (rect) {
    var centerX = (rect.left() + rect.right()) / 2;
    var centerY = (rect.top() + rect.bottom()) / 2;
    var width = rect.width();
    var height = rect.height();
    // m_ctx.beginPath();

    // m_ctx.moveTo(centerX, centerY - height / 2); // A1

    // m_ctx.bezierCurveTo(
    //   centerX + width / 2,
    //   centerY - height / 2, // C1
    //   centerX + width / 2,
    //   centerY + height / 2, // C2
    //   centerX,
    //   centerY + height / 2
    // ); // A2

    // m_ctx.bezierCurveTo(
    //   centerX - width / 2,
    //   centerY + height / 2, // C3
    //   centerX - width / 2,
    //   centerY - height / 2, // C4
    //   centerX,
    //   centerY - height / 2
    // ); // A1
    // m_ctx.stroke();
    // m_ctx.fill();
    // m_ctx.closePath();
    // m_ctx.closePath();

    m_ctx.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, (2 * 22) / 7);
    m_ctx.stroke();
    m_ctx.fill();
  };

  //    this.drawRect2 = function(x, y, width, height ){
  //        m_ctx.beginPath();
  //        m_ctx.rect(x, y, width, height);
  //        m_ctx.stroke();
  //    }

  //rotation is clockwise from the x-axis
  this.drawRotatedText = function (txt, tx, ty, rotation) {
    // var bottomUp = -1;
    // if(typeof(topDown) !== "undefined"){
    //     if(topDown === true)
    //         bottomUp = 1;
    // }
    var thetaRad = (Math.PI * rotation) / 180; //radians
    var size = m_ctx.measureText(txt);
    m_ctx.save();
    // var x = tx;// + size.width/2;
    // var y = ty - bottomUp*size.width/2;
    var x = tx; // - size.width*0.5*Math.cos(thetaRad);
    var y = ty; // - size.width*0.5*Math.sin(thetaRad);
    m_ctx.translate(x, y);

    m_ctx.rotate(thetaRad);
    //m_ctx.translate(-x,-y);
    // if(bottomUp === -1)
    //m_ctx.textAlign = "start";
    m_ctx.textAlign = "left";

    m_ctx.fillText(txt, 0, 0);
    m_ctx.restore();
  };

  this.drawVerticalText = function (txt, tx, ty, topDown) {
    var bottomUp = -1;
    if (typeof topDown !== "undefined") {
      if (topDown === true) bottomUp = 1;
    }

    var size = m_ctx.measureText(txt);
    m_ctx.save();
    var x = tx; // + size.width/2;
    var y = ty - (bottomUp * size.width) / 2;
    m_ctx.translate(x, y);

    m_ctx.rotate((bottomUp * Math.PI) / 2);
    m_ctx.translate(-x, -y);
    if (bottomUp === -1) m_ctx.textAlign = "left";
    m_ctx.fillText(txt, x, y);
    m_ctx.restore();
  };

  function adjustedText(text, maxTextLength) {
    //if(text==undefined ||text=="")return ""
    var txt = text;
    var textLength = m_font.textSize(txt).width;
    while (textLength > maxTextLength) {
      if (!txt.substring) break;
      txt = txt.substring(0, txt.length - 1);
      textLength = m_font.textSize(txt).width;
    }
    return txt;
  }

  this.drawText = function (text, x, y, alignment, maxTextLength) {
    if (alignment !== undefined) {
      if (typeof alignment == "string") {
        m_ctx.textAlign = alignment;
        if (maxTextLength !== undefined) {
          text = adjustedText(text, maxTextLength);
        }
      } else if (typeof alignment == "number") {
        text = adjustedText(text, alignment);
      }
    }
    m_ctx.fillText(text, x, y);

    // if (typeof maxTextLength !== "undefined")
    //   text = adjustedText(text, maxTextLength);
    // if (typeof alignment !== "undefined") m_ctx.textAlign = alignment;
    // m_ctx.fillText(text, x, y);
  };

  this.toString = function () {
    return "[Painter: " + m_ctx + "]";
  };
};

/**
 * Creates a GraphicPainter object. (For internal use only)
 * @constructor
 * @param {Graphic} graphic Graphic
 */
PaintUtil.GraphicPainter = function (graphic) {
  var svgNS = "http://www.w3.org/2000/svg";
  var m_graphic = graphic;
  var m_pen = new Misc.Pen();
  m_pen.style = Static.NoPen;
  var m_brush = new Misc.Brush();

  var m_font = new Misc.Font();

  var elem = null;

  this.setBrush = function (b) {
    m_brush = b;
  };

  this.setPen = function (p) {
    m_pen = p;
  };

  /*style
      solid
      dash : ctx.setLineDash([10, 5])
      dashDot : ctx.setLineDash([12, 5, 3, 5])
      dashDotDot : ctx.setLineDash([12, 5, 3, 5, 3, 5])
      dot : ctx.setLineDash([2, 8])
    */
  function doSetPen() {
    if (m_pen.style === Static.NoPen) elem.attr("stroke", "transparent");
    else elem.attr("stroke", m_pen.color);
    elem.attr("stroke-Width", m_pen.width);
    if (m_pen.style === "dash") elem.attr("stroke-dasharray", [10, 5]);
    else if (m_pen.style === "dot") elem.attr("stroke-dasharray", [3, 8]);
    else if (m_pen.style === "dashDot")
      elem.attr("stroke-dasharray", [12, 5, 3, 5]);
    else if (m_pen.style === "dashDotDot")
      elem.attr("stroke-dasharray", [12, 5, 3, 5, 3, 5]);

    //penStyle = m_pen.style;
  }

  function doSetBrush() {
    if (m_brush.color === Static.NoBrush) elem.attr("fill", "transparent");
    else elem.attr("fill", m_brush.color);
  }

  this.pen = function () {
    return m_pen;
  };

  this.rotate = function (rotation, x, y) {
    xCenter = x || 0;
    yCenter = y || 0;
    if (rotation)
      elem.attr(
        "transform",
        " rotate(" + rotation + " " + xCenter + " " + yCenter + ")"
      );
  };

  this.transform = function (obj) {
    var xTrans = obj.translateX || 0;
    var yTrans = obj.translateY || 0;
    var xScale = obj.scaleX || 1;
    var yScale = obj.scaleY || 1;
    var rotation = obj.rotation || 0;
    var xCenter = obj.rotationX || 0;
    var yCenter = obj.rotationY || 0;

    var transformStr = "";
    if (xScale != 1 || yScale != 1)
      transformStr += " scale(" + xScale + " " + yScale + ")";
    if (rotation)
      transformStr +=
        " rotate(" + rotation + " " + xCenter + " " + yCenter + ")";
    if (xTrans != 1 || yTrans != 1)
      transformStr += " translate(" + xTrans + " " + yTrans + ")";

    elem.attr("transform", transformStr);
  };

  this.drawRect = function (x, y, w, h) {
    elem = $(document.createElementNS(svgNS, "rect"));
    elem.attr("x", x);
    elem.attr("y", y);
    elem.attr("width", w);
    elem.attr("height", h);

    /*if(rotation)
         elem.attr("transform", 
             " rotate("+rotation+' '+x+' '+y+ ")"
             );*/

    doSetBrush();
    //elem.attr("stroke",m_pen.color);
    //elem.attr("stroke-Width",1);
    doSetPen();
    elem.appendTo($(m_graphic.svg()));
  };

  this.drawPath = function (path) {
    elem = $(document.createElementNS(svgNS, "path"));
    var data = path.data;
    data.rotation = data.rotation || 0;
    var d = "";
    for (var i = 0; i < path.elementCount(); i++) {
      var element = path.elementAt(i);
      var x = element.x + data.xOffset;
      var y = element.y + data.yOffset;

      switch (element.type) {
        case Misc.MoveToElement: {
          d += "M" + x + " " + y + " ";
          break;
        }
        case Misc.LineToElement: {
          d += "L" + x + " " + y + " ";
          break;
        }
        case Misc.CurveToElement: {
          var element1 = path.elementAt(++i);
          var x1 = element1.x + data.xOffset;
          var y1 = element1.y + data.yOffset;

          var element2 = path.elementAt(++i);
          var x2 = element2.x + data.xOffset;
          var y2 = element2.y + data.yOffset;

          d +=
            "C " +
            x +
            " " +
            y +
            " " +
            x1 +
            " " +
            y1 +
            " " +
            x2 +
            " " +
            y2 +
            " ";
          break;
        }
        case Misc.CurveToDataElement: {
          break;
        }
      }
    }
    elem.attr("d", d);
    elem.attr(
      "transform",
      " scale(" +
        data.scale +
        ")" +
        " rotate(" +
        data.rotation +
        " " +
        data.xCenter +
        " " +
        data.yCenter +
        ")"
    );
    doSetBrush();
    //elem.attr("stroke",m_pen.color);
    //elem.attr("stroke-Width",1);
    doSetPen();
    elem.appendTo($(m_graphic.svg()));
  };

  this.fillRect = function (rect, brush) {
    elem = $(document.createElementNS(svgNS, "rect"));
    elem.attr("x", rect.left);
    elem.attr("y", rect.top);
    elem.attr("width", rect.width);
    elem.attr("height", rect.height);
    elem.attr("fill", brush.color);
    doSetPen();
    elem.appendTo($(m_graphic.svg()));
  };

  /*elem = $(document.createElementNS(svgNS,"rect"));
       elem.attr("x",x);
       elem.attr("y",y);
       elem.attr("width",w);
       elem.attr("height",h);
       doSetBrush();
       elem.attr("stroke",m_pen.color);
       elem.attr("stroke-Width",1);
       elem.appendTo($(m_graphic.svg()))   */

  this.drawCircle = function (x, y, radius) {
    /*elem = $(document.createElementNS(svgNS,"circle"));
        elem.attr("cx",x);
        elem.attr("cy",y);
        elem.attr("r",radius);
        elem.attr("fill","red");
        doSetPen();
        elem.appendTo($(m_graphic.svg()))*/

    elem = $(document.createElementNS(svgNS, "circle"));
    elem.attr("cx", x);
    elem.attr("cy", y);
    elem.attr("r", radius);
    doSetBrush();
    //elem.attr("stroke",m_pen.color);
    //elem.attr("stroke-Width",1);
    doSetPen();
    elem.appendTo($(m_graphic.svg()));
  };

  this.drawLine = function (x1, y1, x2, y2) {
    elem = $(document.createElementNS(svgNS, "line"));
    elem.attr("x1", x1);
    elem.attr("y1", y1);
    elem.attr("x2", x2);
    elem.attr("y2", y2);
    doSetPen();
    elem.appendTo($(m_graphic.svg()));
  };

  this.drawText = function (text, x, y) {
    elem = $(document.createElementNS(svgNS, "text"));
    elem.attr("x", x);
    elem.attr("y", y);
    doSetFont();
    doSetPen();
    doSetBrush();
    elem[0].textContent = text;
    elem.appendTo($(m_graphic.svg()));
  };

  this.textSize = function (text) {
    return m_font.textSize(text);
  };

  this.setFont = function (font) {
    m_font = font;
  };

  this.font = function () {
    return m_font;
  };

  function doSetFont() {
    elem.attr("font-size", m_font.th);
    elem.attr("font-family", m_font.name);
    elem.attr("font-weight", m_font.weight);
    elem.attr("font-style", m_font.style);
  }

  this.toString = function () {
    return "[GraphicPainter]";
  };
};

/**
 * @classdesc Creates a Painter object
 *
 * A Painter object provides highly optimized functions to do most of the drawing GUI programs require. It can draw
 * everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it
 * draws in a "natural" coordinate system, but it can also do view and world transformation. Painter can operate on any object
 * that inherits the Widget class.
 *
 * The argument passed during construction of this object determines the type of painter created. If argument
 * is a {@link Widget}, {@link CanvasRenderingContext2D} or undefined, a {@link PaintUtil.ContextPainter ContextPainter} is created.
 * If argument is {@link Graphic}  a {@link PaintUtil.GraphicPainter GraphicPainter} is created. {@link PaintUtil.ContextPainter ContextPainter} and {@link PaintUtil.GraphicPainter GraphicPainter} are for internal use only. Do not use them directly.
 * @constructor
 * @param {Graphic|CanvasRenderingContext2D} [param]
 *
 */
PaintUtil.Painter = function (param) {
  var m_painter = null;
  var m_graphicPainter = false;

  if (param.toString() === "[Graphic]") {
    m_graphicPainter = true;
    m_painter = new PaintUtil.GraphicPainter(param);
  } else if (param.toString() === "[object CanvasRenderingContext2D]") {
    m_painter = new PaintUtil.ContextPainter(param);
  } else {
    m_painter = new PaintUtil.ContextPainter(param.getContext());
  }

  /**
   *
   * @returns {boolean} true if painter is a graphic painter and fales otherwise.
   */
  this.isGraphicPainter = function () {
    return m_graphicPainter;
  };

  /**
   * Calculate the width and height of the text drawn with this Font and return it as a Misc.Size object.
   * @param {string} str text
   * @returns {Misc.Size} text size
   */
  this.textSize = function (str) {
    return m_painter.textSize(str);
  };

  /**
   *
   * @returns {CanvasRenderingContext2D} context in which the painter operates
   */
  this.context = function () {
    if (m_graphicPainter) {
      return;
    }
    return m_painter.context();
  };

  /**
   *
   * @returns {number} width of the drawing canvas
   */
  this.canvasWidth = function () {
    if (m_graphicPainter) return;
    return m_painter.canvasWidth();
  };

  /**
   *
   * @returns {number}  height of the drawing canvas
   */
  this.canvasHeight = function () {
    if (m_graphicPainter) return;
    return m_painter.canvasHeight();
  };

  /**
   * Saves the current painter state. A save() must be followed by a corresponding {@link PaintUtil.Painter#restore restore()}
   * @see {@link PaintUtil.Painter#restore restore()}.
   */
  this.save = function () {
    if (m_graphicPainter) return;
    m_painter.save();
  };

  /**
   * Restores the current painter state.
   * @see {@link PaintUtil.Painter#save save()}.
   */
  this.restore = function () {
    if (m_graphicPainter) return;
    m_painter.restore();
  };

  /**
   *
   * Translates the coordinate system by the vector (x, y).
   * @param {number} x x - offset
   * @param {number} y y - offset
   */
  this.translate = function (x, y) {
    if (m_graphicPainter) return;
    m_painter.translate(x, y);
  };

  /**
   *
   * Scales the coordinate system by (x, y)..
   * @param {number} x
   * @param {number} y
   */
  this.scale = function (x, y) {
    if (m_graphicPainter) return;
    m_painter.scale(x, y);
  };

  /**
   * Translates the coordinate system by the vector (x, y) and rotate it clockwise. The given angle parameter is in degrees.
   * @param {number} rot
   * @param {number} x
   * @param {number} y
   */
  this.rotate = function (rot, x, y) {
    //rot *= Math.PI / 180
    if (m_graphicPainter) return;
    m_painter.rotate(rot, x, y);
  };

  /**
   *
   * @param {object} obj
   * @returns {object} the world transformation matrix.
   */
  this.transform = function (obj) {
    if (obj == undefined) {
      return m_painter.getTransform();
    }
    //rot *= Math.PI / 180
    if (!m_graphicPainter) return;
    m_painter.transform(obj);
  };

  /**
   * Sets the painter's pen to be the given pen. The pen defines how to draw lines and outlines, and it also defines the
   * text color.
   * @param {Misc.Pen} pen
   */
  this.setPen = function (pen) {
    m_painter.setPen(pen);
  };

  /**
   *
   * @returns {Misc.Pen} the painter's pen.
   */
  this.pen = function () {
    return m_painter.pen();
  };

  /**
   * Sets a new brush that is use for painting and filling
   * @param {Misc.Brush} brush
   */
  this.setBrush = function (brush) {
    m_painter.setBrush(brush);
  };

  /**
   *
   * @returns {Misc.Brush} brush that is use for painting and filling
   */
  this.brush = function () {
    return m_painter.brush();
  };

  /**
   * Sets the font use for drawing text
   * @param {Misc.Font} font New font
   */
  this.setFont = function (font) {
    m_painter.setFont(font);
  };

  /**
   *
   * @returns {Misc.Font} The font use for drawing text
   */
  this.font = function () {
    return m_painter.font();
  };

  /**
   * Fill the rectangle  with the brush
   * @param {Misc.Rect} rect Rectangle to fill
   * @param {Misc.Brush} brush Brush filling the rectangle
   */
  this.fillRect = function (rect, brush) {
    m_painter.fillRect(rect, brush);
  };

  /**
   * Draws a path
   * @param {Misc.MPath} path Path
   */
  this.drawPath = function (path) {
    m_painter.drawPath(path);
  };

  /**
   * Draws a point
   *
   * The point is a filled rectangle of width == 1.9\*pw and height == 2\*pw (where pw == current pen width).
   *
   * The point is filled with the current pen color
   * @param {Misc.Point} pt The center of the point
   */
  this.drawPoint = function (pt) {
    if (m_graphicPainter) return;
    m_painter.drawPoint(pt);
  };

  /**
   * Draws a series of points
   * @param {Array<Misc.Point>} points List of points
   */
  this.drawPoints = function (points) {
    if (m_graphicPainter) return;
    m_painter.drawPoints(points);
  };

  /**
   * Draws a line. Overloaded (See example)
   * @param {Number|Misc.Point} param1
   * @param {Number|Misc.Point} param2
   * @param {Number} [param3]
   * @param {Number} [param4]
   * @example
   * const x1 = 2,
   * const x2 = 5;
   * const y1 =-10;
   * const y2 = 20;
   * const p1 = new Misc.Point(x1, y1);
   * const p2 = new Misc.Point(x2, y2);
   * ...
   * painter.drawLine(x1, y1, x2, y2);
   * painter.drawLine(p1, p2);
   *
   */
  this.drawLine = function (param1, param2, param3, param4) {
    m_painter.drawLine(param1, param2, param3, param4);
  };

  /**
   * Paints data from the given image object onto the canvas.
   *
   * This is an overloaded function. See example.
   * @param {Misc.Image} image Image to draw
   * @param {Misc.Rect|Number} param1 Bounding rectangle of the image or the horizontal position (x coordinate) at which to place the image data in the destination canvas. Defaults to 0.
   * @param {Number} [param2] The vertical position (y coordinate) at which to place the image data in the destination canvas. Defaults to 0.
   * @param {Number} [param3] The width of the rectangle to be painted. Defaults to the width of the image data.
   * @param {Number} [param4] The height of the rectangle to be painted. Defaults to the height of the image data.
   * @example
   * painter.drawImage(image);
   * painter.drawImage(image, 50, 50);
   * painter.drawImage(image, 50, 50, 20, 20);
   * painter.drawImage(image, new Misc.Rect(10,10, 20, 20));
   */
  this.drawImage = function (image, param1, param2, param3, param4) {
    m_painter.drawImage(image, param1, param2, param3, param4);
  };

  /**
   * Draws the polyline defined by the given points using the current pen.
   * @param {Array<Misc.Point>} polyline List of points
   */
  this.drawPolyline = function (polyline) {
    if (m_graphicPainter) return;
    m_painter.drawPolyline(polyline);
  };

  /**
   * Draws the polygon defined by the given points and fill it using the current brush.
   *
   * This method closes the polygon if it is not already closed
   * @param {Array<Misc.Point>} polyline Polygon.
   */
  this.drawPolygon = function (polyline) {
    if (m_graphicPainter) return;
    m_painter.drawPolygon(polyline);
  };

  /**
   * Draws the current rectangle with the current pen and brush.
   *
   * This is an overloaded function. See example.
   * @param {Number|Misc.Rect} x X - coordinate of the upper left corner or a Rectangle
   * @param {Number} [y] Y - coordinate of the upper left corner
   * @param {Number} [width] Width of the rectangle
   * @param {Number} [height] Height of the rectangle
   * @example
   * const x = 2,
   * const y =-10;
   * const w = 20;
   * const h = 30;
   * const rc = new Misc.Rect(x, y, w, h);
   * ...
   * painter.drawRect(x, y, w, h);
   * painter.drawRect(rc);
   */
  this.drawRect = function (x, y, width, height) {
    m_painter.drawRect(x, y, width, height);
  };

  /**
   * Draws vertical text
   * @param {String} txt Text to draw
   * @param {Number} tx The x-axis coordinate of the point at which to begin drawing the text, in pixels.
   * @param {Number} ty The y-axis coordinate of the baseline on which to begin drawing the text, in pixels.
   * @param {Boolean} [topDown] If true, the text is drawn from top to bottom. The default is false.
   */
  this.drawVerticalText = function (txt, tx, ty, topDown) {
    if (m_graphicPainter) return;
    m_painter.drawVerticalText(txt, tx, ty, topDown);
  };

  /**
   * Draws rotated text
   * @param {String} txt Text to draw
   * @param {Number} tx The x-axis coordinate of the point at which to begin drawing the text, in pixels.
   * @param {Number} ty The y-axis coordinate of the baseline on which to begin drawing the text, in pixels.
   * @param {Number} rotation Clockwise rotation measured in degrees.
   */
  this.drawRotatedText = function (txt, tx, ty, rotation) {
    if (m_graphicPainter) return;
    m_painter.drawRotatedText(txt, tx, ty, rotation);
  };

  /**
   * Draws text
   * @param {String} text Text to draw
   * @param {Number} tx The x-axis coordinate of the point at which to begin drawing the text, in pixels.
   * @param {Number} ty The y-axis coordinate of the baseline on which to begin drawing the text, in pixels.
   * @param {String} [alignment] Alignment.
   *
   * Possible values:
   * - `"left"`: The text is left-aligned.
   * - `"right"`: The text is right-aligned.
   * - `"center"`: The text is centered.
   * - `"start"`: The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).
   * - `"end"`: The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).
   *
   * The default value is `"start"`
   * @param {Number} [maxTextLength] Maximum width of the text in pixels. Text that is too long are clipped to this width.
   */
  this.drawText = function (text, x, y, alignment, maxTextLength) {
    m_painter.drawText(text, x, y, alignment, maxTextLength);
  };

  /**
   * Paints a circle to the canvas using the current brush and pen of the painter.
   * @param {number} x the x position of the center of the circle (positive to the right)
   * @param {number} y the y position of the center of the circle (positive downwards)
   * @param {number} radius radius of the circle
   */
  this.drawCircle = function (x, y, radius) {
    m_painter.drawCircle(x, y, radius);
  };

  /**
   * Paints an ellipse to the canvas using the current brush and pen of the painter.
   * @param {Misc.Rect} rect The bounding rectangle of the ellipse.
   */
  this.drawEllipse = function (rect) {
    m_painter.drawEllipse(rect);
  };

  /**
   *
   * @returns {string} A string representation of the object.
   */
  this.toString = function () {
    return m_painter.toString();
  };
};

define("painter", function(){});



/**
 * A class representing a scale division.
 *
 * A js-Qwt scale is defined by its boundaries and 3 list for the positions of the major, medium and minor ticks.
 * The {@link ScaleDiv#upperBound upperBound()} might be smaller than the {@link ScaleDiv#lowerBound lowerBound()} to indicate inverted scales.
 * Scale divisions can be calculated from a QwtScaleEngine.
 */
class ScaleDiv {
  /**
   * Overloaded constructor. See example for usage.
   * @param {Number} [arg1] lowerBound First boundary
   * @param {Number} [arg2] upperBound Second boundary
   * @param {Array<Number>} [arg3] minorTicks List of minor ticks
   * @param {Array<Number>} [arg4] mediumTicks List medium ticks
   * @param {Array<Number>} [arg5] majorTicks List of major ticks
   * @example
   *  //Construct a scale division - Default constructor
   *  new ScaleDiv()
   *
   *  //Construct a scale division
   *  new ScaleDiv(interval: Interval, ticks: Array<Array<Number>>)
   *  - Parameters
   *  - interval  Interval
   *  - ticks     List of major, medium and minor ticks
   *
   *  //Construct a scale division
   *  new ScaleDiv(lowerBound: Number, upperBound: Number, ticks: Array<Array<Number>>)
   *  Parameters
   *  - lowerBound  First boundary
   *  - upperBound  Second boundary
   *  - ticks       List of major, medium and minor ticks
   *
   *  //Construct a scale division
   *  new ScaleDiv(lowerBound: Number, upperBound: Number, minorTicks: Array<Number>, mediumTicks: Array<Number>, majorTicks: Array<Number>)
   *  Parameters
   *  - lowerBound  First boundary
   *  - upperBound  Second boundary
   *  - minorTicks  List of minor ticks
   *  - mediumTicks List medium ticks
   *  - majorTicks  List of major ticks
   */
  constructor(arg1, arg2, arg3, arg4, arg5) {
    var d_lowerBound = 0.0;
    var d_upperBound = 0.0;
    var d_ticks = []; //array of array of numbers
    if (typeof arg1 == "undefined" || typeof arg2 == "undefined") {
      //constructor 1
    } else if (
      typeof arg3 == "undefined" &&
      typeof arg1 == "object" &&
      typeof arg2 == "object"
    ) {
      //constructor 2
      var interval = arg1;
      var ticks = arg2;
      d_lowerBound = interval.minValue();
      d_upperBound = interval.maxValue();

      for (var i = 0; i < ScaleDiv.TickType.NTickTypes; i++)
        d_ticks[i] = ticks[i];
    } else if (typeof arg4 == "undefined") {
      //constructor 3
      d_lowerBound = arg1;
      d_upperBound = arg2;
      ticks = arg3;
      // d_lowerBound = lowerBound;
      // d_upperBound = upperBound;

      for (i = 0; i < ScaleDiv.TickType.NTickTypes; i++) d_ticks[i] = ticks[i];
    } else if (
      typeof arg1 == "undefined" &&
      typeof arg2 == "undefined" &&
      typeof arg3 == "undefined" &&
      typeof arg4 == "undefined" &&
      typeof arg5 == "undefined"
    ) {
      //constructor 3
      d_lowerBound = arg1;
      d_upperBound = arg2;
      minorTicks = arg3;
      mediumTicks = arg4;
      majorTicks = arg5;
      // d_lowerBound = lowerBound;
      // d_upperBound = upperBound;
      d_ticks[ScaleDiv.TickType.MinorTick] = minorTicks;
      d_ticks[ScaleDiv.TickType.MediumTick] = mediumTicks;
      d_ticks[ScaleDiv.TickType.MajorTick] = majorTicks;
    }

    /**
     * Change the interval
     *
     * lowerBound might be greater than upperBound for inverted scales.
     * @param {Number|object} arg1 If a number, first boundary. If an object, the interval.
     * @param {Number} [arg2] Second boundary.
     */
    this.setInterval = function (arg1, arg2) {
      if (typeof arg1 == "number" && typeof arg2 == "number") {
        d_lowerBound = arg1;
        d_upperBound = arg2;
        // d_lowerBound = lowerBound;
        // d_upperBound = upperBound;
      } else if (typeof arg1 == "object" && typeof arg2 == "undefined") {
        const interval = arg1;
        d_lowerBound = interval.minValue();
        d_upperBound = interval.maxValue();
      }
    };

    /**
     *
     * @returns {Interval} an Interval constructed from the current lowerBound and upperBound
     */
    this.interval = function () {
      return new Interval(d_lowerBound, d_upperBound);
    };

    /**
     * Set the first boundary
     * @param {Number} lowerBound First boundary
     */
    this.setLowerBound = function (lowerBound) {
      d_lowerBound = lowerBound;
    };

    /**
     *
     * @returns {Number} lower bound
     * @see {@link ScaleDiv#upperBound upperBound()}
     */
    this.lowerBound = function () {
      return d_lowerBound;
    };

    /**
     * Set the second boundary
     * @param {Number} upperBound Second boundary
     */
    this.setUpperBound = function (upperBound) {
      d_upperBound = upperBound;
    };

    /**
     *
     * @returns {Number} upper bound
     * @see {@link ScaleDiv#lowerBound lowerBound()}
     */
    this.upperBound = function () {
      return d_upperBound;
    };

    /**
     *
     * @returns {Number} upperBound() - lowerBound()
     */
    this.range = function () {
      return d_upperBound - d_lowerBound;
    };

    /**
     *
     * @returns {Boolean} true, if the scale division is empty. i.e ( lowerBound() == upperBound() )
     */
    this.isEmpty = function () {
      return d_lowerBound == d_upperBound;
    };

    /**
     *
     * @returns {Boolean} true, if the scale division is increasing. i.e. ( lowerBound() <= upperBound() )
     */
    this.isIncreasing = function () {
      return d_lowerBound <= d_upperBound;
    };

    /**
     * Return if a value is between lowerBound() and upperBound()
     * @param {Number} value Value
     * @returns {Boolean} true/false
     */
    this.contains = function (value) {
      var min = Math.min(d_lowerBound, d_upperBound);
      var max = Math.max(d_lowerBound, d_upperBound);
      return value >= min && value <= max;
    };

    /**
     * Invert the scale division
     * @see {@link ScaleDiv#inverted inverted()}
     */
    this.invert = function () {
      //qSwap( d_lowerBound, d_upperBound );
      var temp = d_lowerBound;
      d_lowerBound = d_upperBound;
      d_upperBound = temp;

      for (var i = 0; i < ScaleDiv.TickType.NTickTypes; i++) {
        //QList<double>& ticks = d_ticks[i];
        var ticks = d_ticks[i];
        var size = ticks.length;
        var size2 = size / 2;

        for (var j = 0; j < size2; j++) {
          //qSwap( ticks[j], ticks[size - 1 - j] );
          temp = ticks[j];
          ticks[j] = ticks[size - 1 - j];
          ticks[size - 1 - j] = temp;
        }
        d_ticks[i] = ticks;
      }
    };

    /**
     *
     * @returns {ScaleDiv} A scale division with inverted boundaries and ticks
     * @see {@link ScaleDiv#invert invert()}
     */
    this.inverted = function () {
      var other = new ScaleDiv(d_lowerBound, d_upperBound, d_ticks);
      other.invert();
      return other;
    };

    /**
     * Return a scale division with an interval [lowerBound, upperBound]
     * where all ticks outside this interval are removed
     * @param {Number} lowerBound Lower bound
     * @param {Number} upperBound Upper bound
     * @returns {ScaleDiv} Scale division with all ticks inside of the given interval
     */
    this.bounded = function (lowerBound, upperBound) {
      var min = Math.min(lowerBound, upperBound);
      var max = Math.max(lowerBound, upperBound);

      var sd = new ScaleDiv();
      sd.setInterval(lowerBound, upperBound);

      for (tickType = 0; tickType < ScaleDiv.TickType.NTickTypes; tickType++) {
        var ticks = d_ticks[tickType];

        var boundedTicks = [];
        for (i = 0; i < ticks.size(); i++) {
          var tick = ticks[i];
          if (tick >= min && tick <= max) boundedTicks.push(tick);
        }

        sd.setTicks(tickType, boundedTicks);
      }

      return sd;
    };

    /**
     * Assign ticks
     * @param {ScaleDiv.TickType} type ScaleDiv.TickType.MinorTick, ScaleDiv.TickType.MediumTick or ScaleDiv.TickType.MajorTick
     * @param {Array<Number>} ticks Values of the tick positions
     */
    this.setTicks = function (type, ticks) {
      if (type >= 0 && type < ScaleDiv.TickType.NTickTypes)
        d_ticks[type] = ticks;
    };

    /**
     * Return a list of ticks
     * @param {ScaleDiv.TickType} type ScaleDiv.TickType.MinorTick, ScaleDiv.TickType.MediumTick or ScaleDiv.TickType.MajorTick
     * @returns {Array<Number>} Tick list
     */
    this.ticks = function (type) {
      if (type >= 0 && type < ScaleDiv.TickType.NTickTypes) {
        // console.log(type)
        // console.log(d_ticks)
        return d_ticks[type];
      }
      return [];
    };
  }

  /**
   * @returns {String} a string representing the object.
   */
  toString() {
    return "[ScaleDiv]";
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link ScaleDiv.TickType}</div>
 *
 * Scale tick types.
 * @name ScaleDiv.TickType
 * @readonly
 * @property {Number} NoTick=-1             No ticks.
 * @property {Number} MinorTick             Minor ticks.
 * @property {Number} MediumTick            Medium ticks.
 * @property {Number} MajorTick             Major ticks.
 * @property {Number} NTickTypes            Number of valid tick types.
 */
Enumerator.enum(
  "TickType {	NoTick = -1 , MinorTick , MediumTick , MajorTick ,	NTickTypes }",
  ScaleDiv
);

define("scaleDiv", function(){});



/**
 * A class representing an interval.
 *
 * The interval is represented by 2 numbers, the lower and the upper limit.
 *
 */
class Interval {
  /**
   * The constructor is overloaded. See example.
   * @param {Number} [minValue] Minimum value
   * @param {Number} [maxValue] Maximum value
   * @param {Interval.BorderFlag} borderFlags=Interval.BorderFlag.IncludeBorders Include/Exclude borders
   * @example
   * const interval = new Interval(); //Creates an invalid interval [0.0, -1.0]
   * const interval = new Interval(4.5, 104.6); //Build an interval with from min/max values. Include borders.
   * const interval = new Interval(4.5, 104.6, Interval.BorderFlag.ExcludeBorders); //Build an interval with from min/max values. Exclude borders.
   */
  constructor(minValue, maxValue, borderFlags) {
    // if(minValue <= Number.MIN_VALUE && maxValue == 0){
    //     minValue = -0.5;
    //     maxValue = 0.5;
    // }

    // console.log(`min: ${minValue}`)
    // console.log(`max: ${maxValue}`)
    var d_minValue = 0.0;
    var d_maxValue = -1.0;
    var d_borderFlags = Interval.BorderFlag.IncludeBorders;

    //minValue, maxValue, borderFlags
    if (typeof minValue !== "undefined" && typeof maxValue !== "undefined") {
      d_minValue = minValue;
      d_maxValue = maxValue;
    }
    if (typeof borderFlags !== "undefined") d_borderFlags = borderFlags;

    /**
     * Change the border flags
     * @param {Interval.BorderFlag} borderFlags  Or'd BorderMode flags
     * @see {@link Interval#borderFlags borderFlags()}
     */
    this.setBorderFlags = function (borderFlags) {
      d_borderFlags = borderFlags;
    };

    /**
     *
     * @returns {Interval.BorderFlag} Border flags
     * @see {@link Interval#setBorderFlags setBorderFlags()}
     */
    this.borderFlags = function () {
      return d_borderFlags;
    };

    /**
     * Assigns the lower limit of the interval
     * @param {Number} minValue Minimum value
     */
    this.setMinValue = function (minValue) {
      d_minValue = minValue;
    };

    /**
     * Assigns the upper limit of the interval
     * @param {Number} maxValue Maximum value
     */
    this.setMaxValue = function (maxValue) {
      d_maxValue = maxValue;
    };

    /**
     *
     * @returns {Number} Lower limit of the interval
     */
    this.minValue = function () {
      return d_minValue;
    };

    /**
     *
     * @returns {Number} Upper limit of the interval
     */
    this.maxValue = function () {
      return d_maxValue;
    };
  }

  /**
   *
   * @returns {String} A string representation of the object.
   */
  toString() {
    return "[Interval]";
  }

  /**
   * Assigns the limits of the interval
   * @param {Numbe} minValue Minimum value
   * @param {Number} maxValue  Maximum value
   * @param {Interval.BorderFlag} borderFlags Include/Exclude borders
   */
  setInterval(minValue, maxValue, borderFlags) {
    this.setMinValue(minValue);
    this.setMaxValue(maxValue);
    this.setBorderFlags(borderFlags);
  }

  /**
   * A interval is valid when {@link Interval#minValue minValue()} <= {@link Interval#maxValue maxValue()}. In case of Interval.BorderFlag.ExcludeBorders it is true when {@link Interval#minValue minValue()} < {@link Interval#maxValue maxValue()}
   * @returns {Boolean} true, when the interval is valid
   */
  isValid() {
    if ((this.borderFlags() & Interval.BorderFlag.ExcludeBorders) === 0)
      return this.minValue() <= this.maxValue();
    else return this.minValue() < this.maxValue();
  }

  /**
   * Return the width of an interval
   *
   * The width of invalid intervals is 0.0, otherwise the result is {@link Interval#maxValue maxValue()} - {@link Interval#minValue minValue()}.
   * @returns {Number} Interval width
   * @see {@link Interval#isValid isValid()}
   */
  width() {
    return this.isValid() ? this.maxValue() - this.minValue() : 0.0;
  }

  /**
   *
   * @returns {Boolean} true, if {@link Interval#isValid isValid()} && ({@link Interval#minValue minValue()} >= {@link Interval#maxValue maxValue()})
   */
  isNull() {
    return this.isValid() && this.minValue() >= this.maxValue();
  }

  /**
   * Invalidate the interval
   *
   * The limits are set to interval [0.0, -1.0]
   * @see {@link Interval#isValid isValid()}
   */
  invalidate() {
    this.setMinValue(0.0);
    this.setMaxValue(-1.0);
  }

  /**
   * Normalize the limits of the interval
   *
   * If {@link Interval#maxValue maxValue()} < {@link Interval#minValue minValue()} the limits will be inverted.
   * @returns {Interval} Normalized interval
   * @see {@link Interval#isValid isValid()}
   * @see {@link Interval#inverted inverted()}
   */
  normalized() {
    if (this.minValue() > this.maxValue()) {
      return this.inverted();
    }
    if (
      this.minValue() == this.maxValue() &&
      this.borderFlags() == Interval.BorderFlag.ExcludeMinimum
    ) {
      return this.inverted();
    }

    return this;
  }

  /**
   * Invert the limits of the interval
   * @returns {Interval} Inverted interval
   * @see {@link Interval#normalized normalized()}
   */
  inverted() {
    var borderFlags = Interval.BorderFlag.IncludeBorders;
    if (this.borderFlags() & Interval.BorderFlag.ExcludeMinimum)
      borderFlags |= Interval.BorderFlag.ExcludeMaximum;
    if (this.borderFlags() & Interval.BorderFlag.ExcludeMaximum)
      borderFlags |= Interval.BorderFlag.ExcludeMinimum;

    return new Interval(this.maxValue(), this.minValue(), borderFlags);
  }

  /**
   * Test if a value is inside an interval
   * @param {Number} value Value
   * @returns {Boolean} true, if value >= {@link Interval#minValue minValue()} && value <= {@link Interval#maxValue maxValue()}
   */
  contains(value) {
    if (!this.isValid()) return false;

    if (value < this.minValue() || value > this.maxValue()) return false;

    if (
      value == this.minValue() &&
      this.borderFlags() & Interval.BorderFlag.ExcludeMinimum
    )
      return false;

    if (
      value == this.maxValue() &&
      this.borderFlags() & Interval.BorderFlag.ExcludeMaximum
    )
      return false;

    return true;
  }

  /**
   * Limit the interval, keeping the border modes
   * @param {Number} lowerBound Lower limit
   * @param {Number} upperBound Upper limit
   * @returns {Interval} Limited interval
   */
  limited(lowerBound, upperBound) {
    if (!this.isValid() || lowerBound > upperBound) return new Interval();

    var minValue = Math.max(this.minValue(), lowerBound);
    minValue = Math.min(minValue, upperBound);

    var maxValue = Math.max(this.maxValue(), lowerBound);
    maxValue = Math.min(maxValue, upperBound);

    return new Interval(minValue, maxValue, this.borderFlags());
  }

  /**
   * Adjust the limit that is closer to value, so that value becomes the center of the interval.
   * @param {Number} value Center
   * @returns {Interval} Interval with value as center
   */
  symmetrize(value) {
    if (!this.isValid()) return this;

    const delta = Math.max(
      Math.abs(value - this.maxValue()),
      Math.abs(value - this.minValue())
    );

    return new Interval(value - delta, value + delta);
  }

  /**
   * Extend the interval.
   *
   * If value is below {@link Interval#minValue minValue()},value becomes the lower limit. If value is above {@link Interval#maxValue maxValue()},value becomes the upper limit.
   * extend() has no effect for invalid intervals
   * @param {Number} value
   * @returns {Interval} extended interval
   */
  extend(value) {
    if (!this.isValid()) return this;

    return new Interval(
      Math.min(value, this.minValue()),
      Math.max(value, this.maxValue()),
      this.borderFlags()
    );
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link Interval.BorderFlag}</div>
 *
 * Flag indicating if a border is included or excluded
 * @name Interval.BorderFlag
 * @readonly
 * @property {Number} IncludeBorders=0x00             Min/Max values are inside the interval.
 * @property {Number} ExcludeMinimum=0x01             Min value is not included in the interval.
 * @property {Number} ExcludeMaximum=0x02             Max value is not included in the interval.
 * @property {Number} ExcludeBorders=0x03             Min/Max values are not included in the interval.
 */
Enumerator.enum(
  "BorderFlag { IncludeBorders = 0x00 , ExcludeMinimum = 0x01 , ExcludeMaximum = 0x02 , ExcludeBorders = 0x03 }",
  Interval
);

define("interval", function(){});



/**
 * A transformation between coordinate systems. When being mapped between the scale and the paint device
 * coordinate system, Transform manipulates values.
 * A transformation consists of 2 methods:{@link transform}and{@link invTransform} where one is is the inverse function of the other.
 *
 * A transformation consists of 2 methods:
 * - transform
 * - invTransform
 *
 * where one is is the inverse function of the other.
 *
 * When p1, p2 are the boundaries of the paint device coordinates and s1, s2 the boundaries of the scale, ScaleMap uses the following calculations:
 *
 * p = p1 + ( p2 - p1 ) * ( T( s ) - T( s1 ) / ( T( s2 ) - T( s1 ) );
 *
 * s = invT ( T( s1 ) + ( T( s2 ) - T( s1 ) ) * ( p - p1 ) / ( p2 - p1 ) );
 */
class Transform {
  constructor() {}
  /**
   *
   * @returns {String} A string representing the object.
   */
  toString() {
    return "[Transform]";
  }

  /**
   * Modify value to be a valid value for the transformation. The default implementation does nothing.
   * @param {*} value Value to be bounded
   * @returns {Number} unmodified value
   */
  bounded(value) {
    return value;
  }

  /**
   * Transformation function
   * @param {Number} value Value
   * @returns {Number} modified value
   * @see {@link Transform#invTransform invTransform()}
   */
  transform(value) {
    //Subclass must implement
  }

  /**
   * Inverse transformation function
   * @param {Number} value Value
   * @returns {Number} modified value
   * @see {@link Transform#transform transform()}
   */
  invTransform(value) {
    //Subclass must implement
  }

  /**
   *
   * @returns {Transform} Clone of the transformation
   */
  copy() {
    return new Transform();
  }
}

/**
 * Null transformation.
 *
 * NullTransform returns the values unmodified.
 * @extends Transform
 */
class NullTransform extends Transform {
  constructor() {
    super();
  }

  //Documented in base class
  toString() {
    return "[NullTransform]";
  }

  /**
   *
   * @param {Number} value Value to be transformed
   * @returns {Number} value unmodified
   */
  transform(value) {
    return value;
  }

  /**
   *
   * @param {Number} value Value to be transformed
   * @returns {Number} value unmodified
   */
  invTransform(value) {
    return value;
  }

  /**
   *
   * @returns {NullTransform} Clone of the transformation
   */
  copy() {
    return new NullTransform();
  }
}

/**
 * Logarithmic transformation.
 *
 * LogTransform modifies the values using log() and exp().
 * @extends Transform
 */
class LogTransform extends Transform {
  constructor() {
    super();
  }

  //Documented in base class
  toString() {
    return "[LogTransform]";
  }

  /**
   *
   * @param {Number} value Value to be transformed
   * @returns {Number} log( value )
   */
  transform(value) {
    return Math.log(value);
  }

  /**
   *
   * @param {Number} value Value to be transformed
   * @returns {Number} exp( value )
   */
  invTransform(value) {
    return Math.exp(value);
  }

  /**
   *
   * @param {Number} value Value to be bounded
   * @returns {Number} bounded value
   */
  bounded(value) {
    if (value > Number.MAX_VALUE) return Number.MAX_VALUE;
    if (value < Number.MIN_VALUE) return Number.MIN_VALUE;
    return value;
  }

  /**
   *
   * @returns {LogTransform} Clone of the transformation
   */
  copy() {
    return new LogTransform();
  }
}

/**
 *A transformation using pow()
 *
 * PowerTransform preserves the sign of a value. e.g. a transformation with
 * a factor of 2 transforms a value of -3 to -9 and vice-versa. Thus PowerTransform
 * can be used for scales including negative values.
 * @extends Transform
 */
class PowerTransform extends Transform {
  /**
   *
   * @param {Number} exponent Exponent
   */
  constructor(exponent) {
    super();
    this.d_exponent = exponent;
  }

  //Documented in base class
  toString() {
    return "[PowerTransform]";
  }

  /**
   *
   * @param {Number} value Value to be transformed
   * @returns {Number} Exponentiation preserving the sign
   */
  transform(value) {
    if (value < 0.0) return -Math.pow(-value, 1.0 / this.d_exponent);
    else return Math.pow(value, 1.0 / this.d_exponent);
  }

  /**
   *
   * @param {Number} value Value to be transformed
   * @returns {Number} Inverse exponentiation preserving the sign
   */
  invTransform(value) {
    if (value < 0.0) return -Math.pow(-value, this.d_exponent);
    else return Math.pow(value, this.d_exponent);
  }

  /**
   *
   * @returns {PowerTransform} Clone of the transformation
   */
  copy() {
    return new PowerTransform(this.d_exponent);
  }
}
;
define("transform", function(){});


/* Static.mTransformPath = function (xMap, yMap, path, doAlign) {
var shape = new Misc.MPath;
//shape.setFillRule( path.fillRule() );

for (var i = 0; i < path.elementCount(); i++) {
var element = path.elementAt(i);

var x = xMap.transform(element.x);
var y = yMap.transform(element.y);

switch (element.type) {
case Misc.MoveToElement: {
if (doAlign) {
x = Math.round(x);
y = Math.round(y);
}

shape.moveTo(x, y);
break;
}
case Misc.LineToElement: {
if (doAlign) {
x = Math.round(x);
y = Math.round(y);
}

shape.lineTo(x, y);
break;
}
case Misc.CurveToElement: {
var element1 = path.elementAt(++i);
var x1 = xMap.transform(element1.x);
var y1 = yMap.transform(element1.y);

var element2 = path.elementAt(++i);
var x2 = xMap.transform(element2.x);
var y2 = yMap.transform(element2.y);

shape.cubicTo(x, y, x1, y1, x2, y2);
break;
}
case Misc.CurveToDataElement: {
break;
}
}
}

return shape;
} */

/* Static.mInvTransform = function(xMap, yMap, rect) {
var x1 = xMap.invTransform(rect.left());
var x2 = xMap.invTransform(rect.right() - 1);
var y1 = yMap.invTransform(rect.top());
var y2 = yMap.invTransform(rect.bottom() - 1);
var r = new Misc.Rect(new Misc.Point(x1, y1), x2 - x1, y2 - y1);
//r.normalized()
return r.normalized();

}

Static.mTransform = function(xMap, yMap, rect) {
var x1 = xMap.transform(rect.left());
var x2 = xMap.transform(rect.right())// - 1);
var y1 = yMap.transform(rect.top());
var y2 = yMap.transform(rect.bottom())// - 1);
var r = new Misc.Rect(new Misc.Point(x1, y1), x2 - x1, y2 - y1);
//r.normalized()
return r.normalized();

}  */

/**
 * A scale map.
 * ScaleMap offers transformations from the coordinate system of a scale into the linear coordinate system
 * of a paint device and vice versa.
 */
class ScaleMap {
  /**
   * Transform a rectangle from paint to scale coordinates
   * @param {ScaleMap} xMap X map
   * @param {ScaleMap} yMap Y map
   * @param {Misc.Rect} rect Rectangle in paint coordinates
   * @returns {Misc.Rect}  Rectangle in scale coordinates
   */
  static invTransform_Rect(xMap, yMap, rect) {
    var x1 = xMap.invTransform(rect.left());
    var x2 = xMap.invTransform(rect.right() - 1);
    var y1 = yMap.invTransform(rect.top());
    var y2 = yMap.invTransform(rect.bottom() - 1);
    var r = new Misc.Rect(new Misc.Point(x1, y1), x2 - x1, y2 - y1);
    return r.normalized();
  }

  /**
   * Transform a rectangle from scale to paint coordinates
   * @param {ScaleMap} xMap X map
   * @param {ScaleMap} yMap Y map
   * @param {Misc.Rect} pos Rectangle in scale coordinates
   * @returns {Misc.Rect} Rectangle in paint coordinates
   */
  static transform_Rect(xMap, yMap, rect) {
    var x1 = xMap.transform(rect.left());
    var x2 = xMap.transform(rect.right()); // - 1);
    var y1 = yMap.transform(rect.top());
    var y2 = yMap.transform(rect.bottom()); // - 1);
    var r = new Misc.Rect(new Misc.Point(x1, y1), x2 - x1, y2 - y1);
    return r.normalized();
  }

  /**
   * Transform a point from paint to scale coordinates
   * @param {ScaleMap} xMap X map
   * @param {ScaleMap} yMap Y map
   * @param {Misc.Point} pos Position in paint coordinates
   * @returns {Misc.Point} Position in scale coordinates
   */
  static invTransform(xMap, yMap, pos) {
    return new Misc.Point(xMap.invTransform1(pos.x), yMap.invTransform1(pos.y));
  }

  /**
   * Transform a point from scale to paint coordinates
   * @param {ScaleMap} xMap X map
   * @param {ScaleMap} yMap Y map
   * @param {Misc.Point} pos Position in scale coordinates
   * @returns {Misc.Point} Position in paint coordinates
   */
  static transform(xMap, yMap, pos) {
    return new Misc.Point(xMap.transform1(pos.x), yMap.transform1(pos.y));
  }

  /**
   * Transform a path from scale to paint coordinates
   * @param {ScaleMap} xMap X map
   * @param {ScaleMap} yMap Y map
   * @param {Misc.MPath} path Path in scale coordinates
   * @param {Boolean} doAlign Alignment
   * @returns {Misc.MPath} Path in paint coordinates
   */
  static transformPath(xMap, yMap, path, doAlign) {
    var shape = new Misc.MPath();
    //shape.setFillRule( path.fillRule() );

    for (var i = 0; i < path.elementCount(); i++) {
      var element = path.elementAt(i);

      var x = xMap.transform(element.x);
      var y = yMap.transform(element.y);

      switch (element.type) {
        case Misc.MoveToElement: {
          if (doAlign) {
            x = Math.round(x);
            y = Math.round(y);
          }

          shape.moveTo(x, y);
          break;
        }
        case Misc.LineToElement: {
          if (doAlign) {
            x = Math.round(x);
            y = Math.round(y);
          }

          shape.lineTo(x, y);
          break;
        }
        case Misc.CurveToElement: {
          var element1 = path.elementAt(++i);
          var x1 = xMap.transform(element1.x);
          var y1 = yMap.transform(element1.y);

          var element2 = path.elementAt(++i);
          var x2 = xMap.transform(element2.x);
          var y2 = yMap.transform(element2.y);

          shape.cubicTo(x, y, x1, y1, x2, y2);
          break;
        }
        case Misc.CurveToDataElement: {
          break;
        }
      }
    }

    return shape;
  }
  constructor() {
    var d_s1 = 0.0;
    var d_s2 = 1.0;
    var d_p1 = 0.0;
    var d_p2 = 1.0;
    var d_cnv = 1.0;
    var d_ts1 = 0.0;
    var d_transform = null;

    this.setd_cnv = function (val) {
      d_cnv = val;
    };

    this.setd_ts1 = function (val) {
      d_ts1 = val;
    };

    /**
     * Initialize the map with a transformation
     * @param {Transform} trans Transformation
     */
    this.setTransformation = function (trans) {
      if (trans !== d_transform) {
        d_transform = trans;
      }

      this.setScaleInterval(d_s1, d_s2);
      //alert(d_transform)
    };

    /**
     *
     * @returns {Transform} The transformation.
     */
    this.transformation = function () {
      return d_transform;
    };

    /**
     * Specify the borders of the scale interval
     * @param {Number} s1 first border
     * @param {Number} s2 second border
     * scales might be aligned to
     * transformation depending boundaries
     */
    this.setScaleInterval = function (s1, s2) {
      d_s1 = s1;
      d_s2 = s2;
      if (d_transform) {
        d_s1 = d_transform.bounded(d_s1);
        d_s2 = d_transform.bounded(d_s2);
      }
      updateFactor();
    };

    /**
     * Specify the borders of the paint device interval
     * @param {Number} p1 first border
     * @param {Number} p2 second border
     */
    this.setPaintInterval = function (p1, p2) {
      d_p1 = p1;
      d_p2 = p2;
      updateFactor();
    };

    // this.copy = function () {
    //   var cpy = new ScaleMap();
    //   cpy.setScaleInterval(this.s1(), this.s2());
    //   cpy.setPaintInterval(this.p1(), this.p2());
    //   return cpy;
    // };

    //Private
    function updateFactor() {
      d_ts1 = d_s1;
      var ts2 = d_s2;
      if (d_transform) {
        d_ts1 = d_transform.transform(d_ts1);
        ts2 = d_transform.transform(ts2);
      }
      d_cnv = 1.0;
      if (d_ts1 != ts2) {
        d_cnv = (d_p2 - d_p1) / (ts2 - d_ts1);
      }
    }

    /**
     * Transform an paint device value into a value in the
     * interval of the scale.
     * @param {Number} p Value relative to the coordinates of the paint device
     * @returns {Number} Transformed value
     * @see {@link ScaleMap#transform transform()}
     */
    this.invTransform = function (p) {
      return this.invTransform1(p);
    };

    /**
     * Transform a point related to the scale interval into an point
     * related to the interval of the paint device
     * @param {Number} s Value relative to the coordinates of the scale
     * @returns {Number} Transformed value
     * @see {@link ScaleMap#invTransform invTransform()}
     */
    this.transform = function (s) {
      return this.transform1(s);
    };

    //Deprecated
    this.transform1 = function (s) {
      if (d_transform) {
        //alert(s)
        s = d_transform.transform(s);
        //alert(s)
      }

      return d_p1 + (s - d_ts1) * d_cnv;
    };

    //Deprecated
    this.invTransform1 = function (p) {
      var s = d_ts1 + (p - d_p1) / d_cnv;
      if (d_transform)
        //s = d_transform.invTransform1(s);
        s = d_transform.invTransform(s);
      return s;
    };

    /**
     *
     * @returns {Number} First border of the scale interval
     */
    this.s1 = function () {
      return d_s1;
    };

    /**
     *
     * @returns {Number} Second border of the scale interval
     */
    this.s2 = function () {
      return d_s2;
    };

    /**
     *
     * @returns {Number} First border of the paint interval
     */
    this.p1 = function () {
      return d_p1;
    };

    /**
     *
     * @returns {Number} Second border of the paint interval
     */
    this.p2 = function () {
      return d_p2;
    };

    /**
     *
     * @returns {ScaleMap} Deep copy
     */
    this.copy = function () {
      var cpy = new ScaleMap();
      cpy.setScaleInterval(d_s1, d_s2);
      cpy.setPaintInterval(d_p1, d_p2);
      cpy.setd_cnv(d_cnv);
      cpy.setd_ts1(d_ts1);
      if (this.transformation())
        cpy.setTransformation(this.transformation().copy());
      return cpy;
    };

    /**
     *
     * @returns {Boolean} True, when ( p1() < p2() ) != ( s1() < s2() )
     */
    this.isInverting = function () {
      return d_p1 < d_p2 != d_s1 < d_s2;
    };

    /**
     * Returns a string representing the object.
     * @returns {String}
     */
    this.toString = function () {
      return '[ScaleMap "' + d_cnv + '"]';
    };
  }
}
;
define("scaleMap", ["static","transform"], function(){});


/**
 * Layout engine for Plot. It is used by the Plot widget to organize its internal widgets or by Plot.print() to render its content.
 *
 */
class Layout {
  constructor(plotDiv, plot) {
    var self = this;
    var plt = plot;
    var leftOfLeftScaleDiv = 0;
    var topOfCentralDiv = 0;
    var bottomOfCentralDiv = 0;
    var rightOfCentralDiv = 0;
    var leftOfCentralDiv = 0;
    var rightOfRightScaleDiv = 0;
    var rightOfLegendDiv = 0;
    var bottomOfBottomScaleDiv = 0;
    var bottomOfFooterDiv = 0;
    var topOfTopScaleDiv = 0;

    if (!plotDiv) return;

    var plotDivContainer = plotDiv.parent();

    if (plotDiv.parent()[0] === document.body) {
      plotDiv.css("position", "absolute");
    }

    var titleDiv = $("<div />").attr({
      id: "titleDiv",
    });
    plotDiv.append(titleDiv);
    //if (titleDiv.css("top") !== "auto"); //topOfTitleDiv = parseFloat(titleDiv.css("top"))
    var topScaleDiv = $("<div />").attr({
      id: "topScaleDiv",
    });
    plotDiv.append(topScaleDiv);
    if (topScaleDiv.css("top") !== "auto")
      topOfTopScaleDiv = parseFloat(topScaleDiv.css("top"));
    var leftScaleDiv = $("<div />").attr({
      id: "leftScaleDiv",
    });
    plotDiv.append(leftScaleDiv);

    if (leftScaleDiv.css("left") !== "auto")
      leftOfLeftScaleDiv = parseFloat(leftScaleDiv.css("left"));
    var centralDiv = $("<div />").attr({
      id: "centralDiv",
    });
    plotDiv.append(centralDiv);
    if (centralDiv.css("top") !== "auto")
      topOfCentralDiv = parseFloat(centralDiv.css("top"));
    if (centralDiv.css("bottom") !== "auto")
      bottomOfCentralDiv = parseFloat(centralDiv.css("bottom"));
    if (centralDiv.css("right") !== "auto")
      rightOfCentralDiv = parseFloat(centralDiv.css("right"));
    if (centralDiv.css("left") !== "auto")
      leftOfCentralDiv = parseFloat(centralDiv.css("left"));

    /**
     *
     * @returns {object} Central DIV element selector (The Central DIV is where all PlotItems are drawn)
     */
    this.getCentralDiv = function () {
      return centralDiv;
    };
    var rightScaleDiv = $("<div />").attr({
      id: "rightScaleDiv",
    });
    plotDiv.append(rightScaleDiv);
    if (rightScaleDiv.css("right") !== "auto")
      rightOfRightScaleDiv = parseFloat(rightScaleDiv.css("right"));

    var legendDiv = $("<div/>").attr({
      id: "legendDiv",
    });
    plotDiv.append(legendDiv);
    if (legendDiv.css("right") !== "auto")
      rightOfLegendDiv = parseFloat(legendDiv.css("right"));
    var bottomScaleDiv = $("<div />").attr({
      id: "bottomScaleDiv",
    });
    plotDiv.append(bottomScaleDiv);
    if (bottomScaleDiv.css("bottom") !== "auto")
      bottomOfBottomScaleDiv = parseFloat(bottomScaleDiv.css("bottom"));

    var footerDiv = $("<div />").attr({
      id: "footerDiv",
    });
    plotDiv.append(footerDiv);
    if (footerDiv.css("bottom") !== "auto")
      bottomOfFooterDiv = parseFloat(footerDiv.css("bottom"));

    /**
     *
     * @returns {object} Plot DIV element selector
     */
    this.getPlotDiv = function () {
      return plotDiv;
    };

    /**
     *
     * @returns {object} Legend DIV element selector
     */
    this.getLegendDiv = function () {
      return legendDiv;
    };

    /**
     *
     * @returns {object} Title DIV element selector
     */
    this.getTitleDiv = function () {
      return titleDiv;
    };

    /**
     *
     * @returns {object} Footer DIV element selector
     */
    this.getFooterDiv = function () {
      return footerDiv;
    };

    var scaleDivElement = [
      leftScaleDiv,
      rightScaleDiv,
      bottomScaleDiv,
      topScaleDiv,
    ];

    /**
     *
     * @param {Axis.AxisId} type Axis Id
     * @returns {object} Scale DIV element selector
     */
    this.getScaleDivElement = function (type) {
      if (type < 0 || type >= Axis.AxisId.axisCnt) return null;
      return scaleDivElement[type];
    };

    //Usually called by methods that change font. It creates or reclaims space associted with font change.
    this.adjustLayout = function (domElement, newValue) {
      var dim = "width";
      if (
        domElement[0].id === "footerDiv" ||
        domElement[0].id === "titleDiv" ||
        domElement[0].id === "topScaleDiv" ||
        domElement[0].id === "bottomScaleDiv"
      )
        dim = "height";
      domElement.css(dim, newValue);
    };

    function topScaleAndTitle() {
      var titleHeight = parseFloat(titleDiv.css("height"));
      var topScaleHeight = parseFloat(topScaleDiv.css("height"));
      legendDiv.css("top", titleHeight);
      topScaleDiv.css("top", titleHeight);
      centralDiv.css("top", titleHeight + topScaleHeight);
      leftScaleDiv.css("top", titleHeight + topScaleHeight);
      rightScaleDiv.css("top", titleHeight + topScaleHeight);
    }

    function topScaleAndNotTitle() {
      var topScaleHeight = parseFloat(topScaleDiv.css("height"));
      legendDiv.css("top", 0);
      topScaleDiv.css("top", 0);
      centralDiv.css("top", topScaleHeight);
      leftScaleDiv.css("top", topScaleHeight);
      rightScaleDiv.css("top", topScaleHeight);
    }

    function titleAndNotTopScale() {
      var titleHeight = parseFloat(titleDiv.css("height"));
      legendDiv.css("top", titleHeight);
      centralDiv.css("top", titleHeight);
      leftScaleDiv.css("top", titleHeight);
      rightScaleDiv.css("top", titleHeight);
    }

    function notTitleAndNotTopScale() {
      legendDiv.css("top", 0);
      centralDiv.css("top", 0);
      leftScaleDiv.css("top", 0);
      rightScaleDiv.css("top", 0);
    }

    function adjustForTitle() {
      var titleVisible = titleDiv.css("display") == "none" ? true : false;
      if (plt.axisEnabled(Axis.AxisId.xTop)) {
        //case: top axis enabled
        if (titleVisible) {
          topScaleAndTitle();
        } else {
          topScaleAndNotTitle();
        }
      } else {
        //case: top axis not enabled
        if (titleVisible) {
          titleAndNotTopScale();
        } else {
          notTitleAndNotTopScale();
        }
      }
    }

    function adjustForTopScale() {
      var titleVisible = titleDiv.css("display") !== "none" ? true : false;
      if (titleVisible) {
        //case: title exist
        if (plt.axisEnabled(Axis.AxisId.xTop)) {
          topScaleAndTitle();
        } else {
          titleAndNotTopScale();
        }
      } else {
        //case: title does exist
        if (plt.axisEnabled(Axis.AxisId.xTop)) {
          topScaleAndNotTitle();
        } else {
          notTitleAndNotTopScale();
        }
      }
    }

    function bottomScaleAndFooter() {
      var footerHeight = parseFloat(footerDiv.css("height"));
      var bottomScaleHeight = parseFloat(bottomScaleDiv.css("height"));
      legendDiv.css("bottom", footerHeight);
      bottomScaleDiv.css("bottom", footerHeight);
      centralDiv.css("bottom", footerHeight + bottomScaleHeight);
      leftScaleDiv.css("bottom", footerHeight + bottomScaleHeight);
      rightScaleDiv.css("bottom", footerHeight + bottomScaleHeight);
    }

    function bottomScaleAndNotFooter() {
      var bottomScaleHeight = parseFloat(bottomScaleDiv.css("height"));
      legendDiv.css("bottom", 0);
      bottomScaleDiv.css("bottom", 0);
      centralDiv.css("bottom", bottomScaleHeight);
      leftScaleDiv.css("bottom", bottomScaleHeight);
      rightScaleDiv.css("bottom", bottomScaleHeight);
    }

    function footerAndNotBottomtScale() {
      var footerHeight = parseFloat(footerDiv.css("height"));
      legendDiv.css("bottom", footerHeight);
      centralDiv.css("bottom", footerHeight);
      leftScaleDiv.css("bottom", footerHeight);
      rightScaleDiv.css("bottom", footerHeight);
    }

    function notFooterAndNotBottomScale() {
      legendDiv.css("bottom", 0);
      centralDiv.css("bottom", 0);
      leftScaleDiv.css("bottom", 0);
      rightScaleDiv.css("bottom", 0);
    }

    function adjustForFooter() {
      var footerVisible = footerDiv.css("display") == "none" ? true : false;
      if (plt.axisEnabled(Axis.AxisId.xBottom)) {
        //case: bottom axis enabled
        if (footerVisible) {
          bottomScaleAndFooter();
        } else {
          bottomScaleAndNotFooter();
        }
      } else {
        //case: bottom axis not enabled
        if (footerVisible) {
          footerAndNotBottomtScale();
        } else {
          notFooterAndNotBottomScale();
        }
      }
    }
    function adjustForBottomScale() {
      var footerVisible = footerDiv.css("display") == "none" ? false : true;
      if (footerVisible) {
        //case: footer exist
        if (plt.axisEnabled(Axis.AxisId.xBottom)) {
          bottomScaleAndFooter();
        } else {
          footerAndNotBottomtScale();
        }
      } else {
        //case: footer does exist
        if (plt.axisEnabled(Axis.AxisId.xBottom)) {
          bottomScaleAndNotFooter();
        } else {
          notFooterAndNotBottomScale();
        }
      }
    }

    function rightScaleAndLegend() {
      var legendWidth = parseFloat(legendDiv.css("width"));
      var rightScaleWidth = parseFloat(rightScaleDiv.css("width"));
      titleDiv.css("right", legendWidth + rightScaleWidth + 14 + 3);
      topScaleDiv.css("right", legendWidth + rightScaleWidth + 14 + 3);
      footerDiv.css("right", legendWidth + rightScaleWidth + 14 + 3);
      bottomScaleDiv.css("right", legendWidth + rightScaleWidth + 14 + 3);
      legendDiv.css("right", 3);
      centralDiv.css("right", legendWidth + rightScaleWidth + 14 + 3);
      rightScaleDiv.css("right", legendWidth + 14 + 3);
    }
    function rightScaleAndNotLegend() {
      var rightScaleWidth = parseFloat(rightScaleDiv.css("width"));
      titleDiv.css("right", rightScaleWidth);
      topScaleDiv.css("right", rightScaleWidth);
      footerDiv.css("right", rightScaleWidth);
      bottomScaleDiv.css("right", rightScaleWidth);
      centralDiv.css("right", rightScaleWidth);
      rightScaleDiv.css("right", 0);
    }

    function legendAndNotRightScale() {
      var legendWidth = parseFloat(legendDiv.css("width"));
      centralDiv.css("right", legendWidth + 3 + 14);
      titleDiv.css("right", legendWidth + 3 + 14);
      topScaleDiv.css("right", legendWidth + 3 + 14);
      footerDiv.css("right", legendWidth + 3 + 14);
      bottomScaleDiv.css("right", legendWidth + 3 + 14);
      legendDiv.css("right", 3);
    }

    function notLegendAndNotRightScale() {
      titleDiv.css("right", 0);
      topScaleDiv.css("right", 0);
      footerDiv.css("right", 0);
      bottomScaleDiv.css("right", 0);
      centralDiv.css("right", 0);
    }

    function adjustForLegend() {
      if (plt.legend()) legendDiv.css("width", plt.legend().legendDivWidth());
      if (plt.axisEnabled(Axis.AxisId.yRight)) {
        //case: right axis enabled
        if (plt.isLegendEnabled()) {
          rightScaleAndLegend();
        } else {
          rightScaleAndNotLegend();
        }
      } else {
        //case: right axis not enabled
        if (plt.isLegendEnabled()) {
          legendAndNotRightScale();
        } else {
          notLegendAndNotRightScale();
        }
      }
    }

    function adjustForRightScale() {
      if (plt.isLegendEnabled()) {
        //case: legend exist
        if (plt.axisEnabled(Axis.AxisId.yRight)) {
          rightScaleAndLegend();
        } else {
          legendAndNotRightScale();
        }
      } else {
        //case: legend does not exist
        if (plt.axisEnabled(Axis.AxisId.yRight)) {
          rightScaleAndNotLegend();
        } else {
          notLegendAndNotRightScale();
        }
      }
    }

    function adjustForLeftScale() {
      var leftScaleWidth = parseFloat(leftScaleDiv.css("width"));
      if (plt.axisEnabled(Axis.AxisId.yLeft)) {
        titleDiv.css("left", leftScaleWidth);
        topScaleDiv.css("left", leftScaleWidth);
        footerDiv.css("left", leftScaleWidth);
        bottomScaleDiv.css("left", leftScaleWidth);
        centralDiv.css("left", leftScaleWidth);
      } else {
        titleDiv.css("left", 0);
        topScaleDiv.css("left", 0);
        footerDiv.css("left", 0);
        bottomScaleDiv.css("left", 0);
        centralDiv.css("left", 0);
      }
    }

    var plotDivContainerH = parseFloat(plotDivContainer.css("height"));

    /**
     *
     * Adjust the geometries of the various widgets to account for a change in geometry of any widget.
     */
    this.updateLayout = function () {
      if (typeof plt === "undefined") return;
      var plotDivContainerChangeInHeight =
        parseFloat(plotDivContainer.css("height")) - plotDivContainerH;
      plotDivContainerH = parseFloat(plotDivContainer.css("height"));
      plotDiv.css(
        "height",
        parseFloat(plotDiv.css("height")) + plotDivContainerChangeInHeight
      );

      adjustForTitle();
      adjustForTopScale();
      adjustForFooter();
      adjustForBottomScale();
      adjustForLegend();
      adjustForRightScale();
      adjustForLeftScale();

      //Static.trigger("layoutUpdated");
    };

    /**
     *
     * @returns {Boolean} true, if the Legend DIV element is visible
     */
    this.isLegendDivVisible = function () {
      if (legendDiv[0].style.display === "block") return true;
      return false;
    };

    /**
     * Sets the Plot for the layout
     * @param {Plot} plot
     */
    this.setPlot = function (plot) {
      plt = plot;
    };

    /**
     *
     * @returns {String} A string representation of the object
     */
    this.toString = function () {
      return "[Layout]";
    };
  }
}
;
define("layout", function(){});



/**
 * An abstract base class for drawing scales. It can be used to draw linear or logarithmic scales.
 * After a scale division has been specified as a {@link ScaleDiv} object, using setScaleDiv(), the scale can be drawn
 * with the{@link AbstractScaleDraw#draw draw()}member.
 * @see {@link AbstractScaleDraw#enableComponent enableComponent()}
 * @see {@link AbstractScaleDraw#hasComponent hasComponent()}
 *
 * @tutorial Tutorial_1
 *
 *
 */
class AbstractScaleDraw {
  constructor() {
    Utility.makeAbstract(this, AbstractScaleDraw);
    const Enum = Enumerator.getDefaultEnumNampespace();

    var m_components =
      AbstractScaleDraw.ScaleComponent.Backbone |
      AbstractScaleDraw.ScaleComponent.Ticks |
      AbstractScaleDraw.ScaleComponent.Labels;
    var m_tickLength = [];
    m_tickLength[ScaleDiv.TickType.MinorTick] = 4.0;
    m_tickLength[ScaleDiv.TickType.MediumTick] = 6.0;
    m_tickLength[ScaleDiv.TickType.MajorTick] = 8.0;
    var m_map = new ScaleMap();
    var m_scaleDiv = null;

    var m_decimalPlaces = 4; //For calculations only
    var m_precision = 4; //For display

    var m_spacing = 4;
    var m_penWidth = 1;
    this.data = {}; //any useful data can be stored here.

    /**
     * Get the number precison.
     * @returns {Number} Number precision
     * @see {@link AbstractScaleDraw#setPrecision setPrecision()}
     */
    this.precision = function () {
      return m_precision;
    };

    /**
     * Sets the number precison.
     * @param {Number} numberOfDigits The desired precision
     * @see {@link Utility.toPrecision Utility.toPrecision()}
     * @see {@link AbstractScaleDraw#precision precision()}
     */
    this.setPrecision = function (numberOfDigits) {
      m_precision = numberOfDigits;
    };

    /**
     * Get the number decimal places.
     * @returns {Number} Number decimal places
     * @see {@link AbstractScaleDraw#setDecimalPlaces setDecimalPlaces()}
     */
    this.decimalPlaces = function () {
      return m_decimalPlaces;
    };

    /**
     * Sets the number decimal places.
     * @param {Number} places
     * @see {@link AbstractScaleDraw#decimalPlaces decimalPlaces()}
     */
    this.setDecimalPlaces = function (places) {
      m_decimalPlaces = places;
    };

    /**
     * Get the character count of the longest label.
     * @returns {Number} Number of charaters in longest label.
     */
    this.longestLabel = function () {
      var m_longestLabel = "";
      var majorTicks = m_scaleDiv.ticks(ScaleDiv.TickType.MajorTick);
      majorTicks.forEach(function (tick, i) {
        if (i !== 0 && i !== majorTicks.length - 1) {
          //the first and last tick label are not drawn
          if (m_scaleDiv.contains(tick)) {
            tick = Utility.toPrecision(tick, m_precision);
            //if (tick > m_nonExponentNotationUpperLimit || tick < m_nonExponentNotationLowerLimit)
            //tick = parseFloat(tick).toExponential(m_decimalPlaces);
            if (tick.toString().length > m_longestLabel.length)
              m_longestLabel = tick.toString();
          }
        }
      });
      return m_longestLabel;
    };

    /**
     * En/Disable a component of the scale
     * @param {AbstractScaleDraw.ScaleComponent} component
     * @param {Boolean} enable On/Off
     * @see {@link AbstractScaleDraw#hasComponent hasComponent()}
     */
    this.enableComponent = function (component, enable) {
      if (enable) m_components |= component;
      else m_components &= ~component;
    };

    /**
     * Check if a component is enabled
     * @param {AbstractScaleDraw.ScaleComponent} component Component type
     * @returns {Boolean} true, when component is enabled
     * @see {@link AbstractScaleDraw#enableComponent enableComponent()}
     */
    this.hasComponent = function (component) {
      return m_components & component;
    };

    /**
     * Change the scale division
     * @param {ScaleDiv} scaleDiv New scale division
     */
    this.setScaleDiv = function (scaleDiv) {
      m_scaleDiv = scaleDiv;
      m_map.setScaleInterval(m_scaleDiv.lowerBound(), m_scaleDiv.upperBound());
      //d_data->labelCache.clear();
    };

    /**
     * Change the transformation of the scale
     * @param {Transform} trans New scale transformation
     */
    this.setTransformation = function (trans) {
      m_map.setTransformation(trans);
    };

    /**
     *
     * @returns {ScaleMap} Map how to translate between scale and pixel values
     */
    this.scaleMap = function () {
      return m_map;
    };

    /**
     *
     * @returns {ScaleDiv} scale division
     */
    this.scaleDiv = function () {
      return m_scaleDiv;
    };

    /**
     * Specify the width of the scale pen
     * @param {Number} width Pen width
     * @see {@link AbstractScaleDraw#penWidth penWidth()}
     */
    this.setPenWidth = function (width) {
      if (width <= 0) width = 1;

      if (width !== m_penWidth) m_penWidth = width;
    };

    /**
     * @returns {Number} Scale pen width
     * @see {@link AbstractScaleDraw#setPenWidth setPenWidth()}
     */
    this.penWidth = function () {
      return m_penWidth;
    };

    /**
     * Draw the scale
     * @param {PaintUtil.Painter } painter The painter
     */
    this.draw = function (painter) {
      if (this.orientation() === Static.Horizontal)
        m_map.setPaintInterval(0, painter.canvasWidth());
      else m_map.setPaintInterval(painter.canvasHeight(), 0);
      if (this.hasComponent(AbstractScaleDraw.ScaleComponent.Labels)) {
        var majorTicks = m_scaleDiv.ticks(ScaleDiv.TickType.MajorTick);
        for (var i = 0; i < majorTicks.length; i++) {
          var v = majorTicks[i];
          if (m_scaleDiv.contains(v)) this.drawLabel(painter, v);
        }
      }
      if (this.hasComponent(AbstractScaleDraw.ScaleComponent.Ticks)) {
        painter.save();
        painter.setPen(new Misc.Pen("grey", m_penWidth));
        for (
          var tickType = ScaleDiv.TickType.MinorTick;
          tickType < ScaleDiv.TickType.NTickTypes;
          tickType++
        ) {
          var ticks = m_scaleDiv.ticks(tickType);
          for (i = 0; i < ticks.length; i++) {
            var v = ticks[i];
            if (m_scaleDiv.contains(v))
              this.drawTick(painter, v, m_tickLength[tickType]);
          }
        }
        painter.restore();
      }
      if (this.hasComponent(AbstractScaleDraw.ScaleComponent.Backbone)) {
        painter.save();
        painter.setPen(new Misc.Pen("grey", m_penWidth));
        this.drawBackbone(painter);
        painter.restore();
      }
    };

    /**
     * Set the spacing between tick and labels
     *
     * The spacing is the distance between ticks and labels. The default spacing is 4 pixels.
     * @param {Number} spacing Spacing
     * @see {@link AbstractScaleDraw#spacing spacing()}
     */
    this.setSpacing = function (spacing) {
      if (spacing < 0) spacing = 0;

      m_spacing = spacing;
    };

    /**
     * Get the spacing
     * The spacing is the distance between ticks and labels. The default spacing is 4 pixels.         *
     * @returns {Number} Spacing
     * @see {@link AbstractScaleDraw#setSpacing setSpacing()}
     */
    this.spacing = function () {
      return m_spacing;
    };

    /**
     * Set the length of the ticks
     * @param {ScaleDiv.TickType} tickType Tick type
     * @param {Number} length New length
     */
    this.setTickLength = function (tickType, length) {
      if (
        tickType < ScaleDiv.TickType.MinorTick ||
        tickType > ScaleDiv.TickType.MajorTick
      ) {
        return;
      }
      if (length < 0.0) length = 0.0;
      var maxTickLen = 1000.0;
      if (length > maxTickLen) length = maxTickLen;
      m_tickLength[tickType] = length;
    };

    /**
     * Returns Length of the ticks
     * @param {ScaleDiv.TickType} tickType
     * @returns {Number} tick length
     * @see {@link AbstractScaleDraw#setTickLength setTickLength()}
     * @see {@link AbstractScaleDraw#maxTickLength maxTickLength()}
     */
    this.tickLength = function (tickType) {
      if (
        tickType < ScaleDiv.TickType.MinorTick ||
        tickType > ScaleDiv.TickType.MajorTick
      ) {
        return 0;
      }
      return m_tickLength[tickType];
    };

    /**
     * Returns the length of the longest tick. Useful for layout calculations.
     * @returns {Number}
     * @see {@link AbstractScaleDraw#tickLength tickLength()}
     * @see {@link AbstractScaleDraw#setTickLength setTickLength()}
     */
    this.maxTickLength = function () {
      var length = 0.0;
      for (var i = 0; i < ScaleDiv.TickType.NTickTypes; i++)
        length = Math.max(length, m_tickLength[i]);

      return length;
    };

    /**
     * Convert a value into its representing label. The value is converted to a plain text using Number.toLocaleString()
     *
     * @param {Number} value Value
     * @returns {String} Label string.
     */
    this.label = function (value) {
      if (Utility.mFuzzyCompare(value, Static._eps))
        //DELETED
        value = 0.0;
      return value.toString();
      //return parseFloat(value).toLocaleString(Static.getFullLangCode());
      //return parseFloat(value).toLocaleString();
    };

    /**
     * 
     * @returns {String} A string representing the object.
.
     */
    this.toString = function () {
      return "[AbstractScaleDraw]";
    };
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link AbstractScaleDraw.ScaleComponent}</div>
 *
 * Components of a scale.
 * @name AbstractScaleDraw.ScaleComponent
 * @readonly
 * @property {Number} Backbone    The line where the ticks are located = 0x01
 * @property {Number} Ticks       Ticks                                = 0x02
 * @property {Number} Labels      Labels                               = 0x04
 */
Enumerator.enum(
  "ScaleComponent { Backbone = 0x01 , Ticks = 0x02 , Labels = 0x04 }",
  AbstractScaleDraw
);

define("abstractScaleDraw", function(){});



/**
 * A class for drawing scales.
 * 
 * ScaleDraw can be used to draw linear or logarithmic scales. A scale has a position, an 
 * alignment and a length, which can be specified.
 * After a scale division has been specified as a ScaleDiv object using {@link AbstractScaleDraw#setScaleDiv setScaleDiv()}, the 
 * scale can be drawn with the {@link AbstractScaleDraw#draw draw()} member.
 * @extends AbstractScaleDraw
 */
class ScaleDraw extends AbstractScaleDraw {
  constructor() {
    super();
    const Enum = Enumerator.getDefaultEnumNampespace();
    //AbstractScaleDraw.call(this);
    var m_alignment = ScaleDraw.Alignment.BottomScale;    

    /**
     * Return the orientation
     * 
     * TopScale, BottomScale are horizontal (Static.Horizontal) scales, 
     * LeftScale, RightScale are vertical (Static.Vertical) scales.
     * @returns {Number} Orientation of the scale
     * @see {@link ScaleDraw#alignment alignment()}
     */
    this.orientation = function () {
      if (
        m_alignment === ScaleDraw.Alignment.TopScale ||
        m_alignment === ScaleDraw.Alignment.BottomScale
      )
        return Static.Horizontal;
      return Static.Vertical;
    };

    
    /**
     * Return alignment of the scale
     * @returns {ScaleDraw.Alignment} Alignment of the scale
     * @see {@link ScaleDraw#setAlignment setAlignment()}
     */
    this.alignment = function () {
      return m_alignment;
    };
    

    /**
     * Sets the alignment of the scale
     * 
     * The default alignment is ScaleDraw.Alignment.BottomScale
     * @param {ScaleDraw.Alignment} align Alignment of the scale
     * @see {@link ScaleDraw#alignment alignment()}
     */
    this.setAlignment = function (align) {
      m_alignment = align;
    };

    
    /**
     *  Determine the minimum border distance
     * 
     * This member function returns the minimum space needed to draw the 
     * mark labels at the scale's endpoints.
     * @param {Misc.Font} font Font
     * @param {object} startAndEndObj Object with start and end properties
     */
    this.getBorderDistHint = function (font, startAndEndObj) {
      /*start = 0;
            end = 1.0;

            if ( !hasComponent( QwtAbstractScaleDraw::Labels ) )
            return;

            const QList<double> &ticks = scaleDiv().ticks( ScaleDiv.TickType.MajorTick );
            if ( ticks.count() == 0 )
            return;

            // Find the ticks, that are mapped to the borders.
            // minTick is the tick, that is mapped to the top/left-most position
            // in widget coordinates.

            double minTick = ticks[0];
            double minPos = scaleMap().transform( minTick );
            double maxTick = minTick;
            double maxPos = minPos;

            for ( int i = 1; i < ticks.count(); i++ ){
            const double tickPos = scaleMap().transform( ticks[i] );
            if ( tickPos < minPos ){
            minTick = ticks[i];
            minPos = tickPos;
            }
            if ( tickPos > scaleMap().transform( maxTick ) ){
            maxTick = ticks[i];
            maxPos = tickPos;
            }
            }

            double e = 0.0;
            double s = 0.0;
            if ( orientation() == Qt::Vertical ){
            s = -labelRect( font, minTick ).top();
            s -= qAbs( minPos - qRound( scaleMap().p2() ) );

            e = labelRect( font, maxTick ).bottom();
            e -= qAbs( maxPos - scaleMap().p1() );
            }
            else{
            s = -labelRect( font, minTick ).left();
            s -= qAbs( minPos - scaleMap().p1() );

            e = labelRect( font, maxTick ).right();
            e -= qAbs( maxPos - scaleMap().p2() );
            }

            if ( s < 0.0 )
            s = 0.0;
            if ( e < 0.0 )
            e = 0.0;

            start = qCeil( s );
            end = qCeil( e );*/
    };

    

    /**
     * 
     * @returns  {String}  A string representing the object.
     */
    this.toString = function () {
      return "[ScaleDraw]";
    };

    /**
     * Draw a tick
     * @param {PaintUtil.Painter} painter Painter
     * @param {Number} value Value of the tick
     * @param {Number} len Length of the tick
     * @see {@link ScaleDraw#drawBackbone drawBackbone()}
     * @see {@link ScaleDraw#drawLabel drawLabel()}
     */
    this.drawTick = function (painter, value, len) {
      if (len <= 0) return;
      var bwAdjust = 0; //this.data.plotBorderWidth-1
      var tval = this.scaleMap().transform(value) + bwAdjust;

      var bb = this.hasComponent(AbstractScaleDraw.ScaleComponent.Backbone);

      switch (this.alignment()) {
        case ScaleDraw.Alignment.LeftScale: {
          var x1 = painter.canvasWidth();
          if (bb) x1 -= 2;
          var x2 = x1 - len;
          painter.drawLine(x1, tval, x2, tval);
          break;
        }

        case ScaleDraw.Alignment.RightScale: {
          var x1 = 0;
          if (bb) x1 += 2;
          var x2 = x1 + len;
          painter.drawLine(x1, tval, x2, tval);
          break;
        }

        case ScaleDraw.Alignment.BottomScale: {
          var y1 = 0;
          if (bb) y1 += 2;
          var y2 = y1 + len;
          painter.drawLine(tval, y1, tval, y2);
          break;
        }

        case ScaleDraw.Alignment.TopScale: {
          var y1 = painter.canvasHeight();
          if (bb) y1 -= 2;
          var y2 = y1 - len;
          painter.drawLine(tval, y1, tval, y2);
          break;
        }
      }
    };

    
    /**
     * Draws the baseline of the scale
     * @param {PaintUtil.Painter} painter Painter
     * @see {@link ScaleDraw#drawLabel drawLabel()}
     * @see {@link ScaleDraw#drawTick drawTick()}
     */
    this.drawBackbone = function (painter) {
      var off = 0.5 * painter.pen().width;
      var bb = this.hasComponent(AbstractScaleDraw.ScaleComponent.Backbone);

      switch (this.alignment()) {
        case ScaleDraw.Alignment.LeftScale: {
          var x = painter.canvasWidth() - off;
          if (bb) x -= 2;
          painter.drawLine(x, 0, x, painter.canvasHeight());
          break;
        }
        case ScaleDraw.Alignment.RightScale: {
          var x = off;
          if (bb) x += 2;
          painter.drawLine(x, 0, x, painter.canvasHeight());
          break;
        }
        case ScaleDraw.Alignment.TopScale: {
          var y = painter.canvasHeight() - off;
          if (bb) y -= 2;
          painter.drawLine(0, y, painter.canvasWidth(), y);
          break;
        }
        case ScaleDraw.Alignment.BottomScale: {
          var y = off;
          if (bb) y += 2;
          painter.drawLine(0, y, painter.canvasWidth(), y);
          break;
        }
      }
    };

    
    /**
     * Find the position, where to paint a label.
     * 
     * The position has a distance that depends on the length of the ticks 
     * in direction of the alignment().
     * @param {object} ctx 2d context for the central div canvas
     * @param {Number} value Value
     * @returns {Misc.Point} Position, where to paint a label
     */
    this.labelPosition = function (ctx, value) {
      ctx.save();
      var tval = this.scaleMap().transform(value);

      var dist = this.spacing();

      if (this.hasComponent(AbstractScaleDraw.ScaleComponent.Backbone))
        dist += 1; //qMax( 1, penWidth() );

      if (this.hasComponent(AbstractScaleDraw.ScaleComponent.Ticks))
        dist += this.tickLength(ScaleDiv.TickType.MajorTick);

      //alert(dist)
      var bwAdjust = 0; //this.data.plotBorderWidth-1

      var px = 0;
      var py = 0;
      var th = ctx.measureText("M").width;

      switch (this.alignment()) {
        case ScaleDraw.Alignment.RightScale: {
          px = dist;
          py = tval + 0.5 * th + bwAdjust;
          break;
        }
        case ScaleDraw.Alignment.LeftScale: {
          px = ctx.canvas.width - dist;
          py = tval + 0.5 * th + bwAdjust;
          break;
        }
        case ScaleDraw.Alignment.BottomScale: {
          px = tval + bwAdjust;
          py = dist + th;
          break;
        }
        case ScaleDraw.Alignment.TopScale: {
          px = tval + bwAdjust;
          py = ctx.canvas.height - dist;
          break;
        }
      }
      ctx.restore();
      return new Misc.Point(px, py);
    };

    
    /**
     * Draws the label for a major scale tick
     * @param {PaintUtil.Painter} painter 
     * @param {Number} value Value
     * @see {@link ScaleDraw#drawTick drawTick()}
     * @see {@link ScaleDraw#drawBackbone drawBackbone()}
     * 
     */
    this.drawLabel = function (painter, value) {
      value = Utility.toPrecision(value, this.precision());
      //var limits = this.getNonExponentNotationLimits()
      //if (value > limits.upper || value < limits.lower)
      //value = parseFloat(value).toExponential(this.decimalPlaces());
      var lbl = this.label(value);
      if (lbl === "") return;

      var pos = this.labelPosition(painter.context(), value);
      if (
        this.orientation() == Static.Horizontal &&
        (pos.x === 0 || pos.x == painter.canvasWidth())
      )
        return;

      var tsz = painter.textSize(lbl);
      var th = tsz.height;
      if (
        this.orientation() == Static.Vertical &&
        (Math.abs(pos.y - 0.5 * th - 0) < th ||
          Math.abs(pos.y - 0.5 * th - painter.canvasHeight()) < th)
      )
        return;

      var alignment = "center";
      var maxTextLength = "undefined";

      if (this.alignment() === ScaleDraw.Alignment.LeftScale) {
        alignment = "right";
        maxTextLength = "undefined";
      } else if (this.alignment() === ScaleDraw.Alignment.RightScale) {
        alignment = "left";
        maxTextLength = "undefined";
      } else {
        maxTextLength =
          painter.canvasWidth() /
            (this.scaleDiv().ticks(ScaleDiv.TickType.MajorTick).length - 1) -
          5;
        var textWidth = tsz.width;
        if (textWidth > maxTextLength) textWidth = maxTextLength;
        if (
          pos.x - textWidth / 2 < 0 ||
          pos.x + textWidth / 2 > painter.canvasWidth()
        ) {
          return;
        }
      }

      painter.drawText(lbl, pos.x, pos.y, alignment, maxTextLength);
    };
  }
}
/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link ScaleDraw.Alignment}</div>
 * 
 * Alignment of the scale
 * @name ScaleDraw.Alignment
 * @readonly
 * @property {Number} BottomScale             The scale is below..
 * @property {Number} TopScale                The scale is above.
 * @property {Number} LeftScale               The scale is left.
 * @property {Number} RightScale              The scale is right.
 */
Enumerator.enum(
  "Alignment { BottomScale , TopScale , LeftScale , RightScale }",
  ScaleDraw
);

define("scaleDraw", ["static","abstractScaleDraw"], function(){});


Static.mLog = function (base, value) {
  return Math.log(value) / Math.log(base);
};

Static.mLogInterval = function (base, interval) {
  return new Interval(
    Static.mLog(base, interval.minValue()),
    Static.mLog(base, interval.maxValue())
  );
};

Static.mPowInterval = function (base, interval) {
  return new Interval(
    Math.pow(base, interval.minValue()),
    Math.pow(base, interval.maxValue())
  );
};

Static.mStepSize = function (intervalSize, maxSteps, base) {
  //return 41.666666;
  if (maxSteps <= 0) return 0.0;

  if (maxSteps > 2) {
    for (var numSteps = maxSteps; numSteps > 1; numSteps--) {
      var stepSize = intervalSize / numSteps;

      var p = Math.floor(Math.log(stepSize) / Math.log(base));
      var fraction = Math.pow(base, p);

      for (var n = base; n > 1; n /= 2) {
        if (Utility.mFuzzyCompare(stepSize, n * fraction)) return stepSize;

        if (n === 3 && base % 2 === 0) {
          if (Utility.mFuzzyCompare(stepSize, 2 * fraction)) return stepSize;
        }
      }
      //return stepSize; //added without proof
    }
  }
  return intervalSize * 0.5;
};

/**
 * Arithmetic including a tolerance.
 */
class ScaleArithmetic {
  /**
   * Calculate a step size for a given interval
   *
   * @param {Number} intervalSize Interval size
   * @param {Number} numSteps Number of steps
   * @param {Number} base Base for the division ( usually 10 )
   * @returns {Number} Calculated step size
   */
  static divideInterval(intervalSize, numSteps, base) {
    if (numSteps <= 0) return 0.0;

    var v = ScaleArithmetic.divideEps(intervalSize, numSteps);
    //    alert(v)
    if (v === 0.0) return 0.0;

    var lx = Static.mLog(base, Math.abs(v));
    var p = Math.floor(lx);

    var fraction = Math.pow(base, lx - p);

    var n = base;
    while (n > 1 && fraction <= n / 2) n /= 2;

    var stepSize = n * Math.pow(base, p);
    if (v < 0) stepSize = -stepSize;

    return stepSize;
  }

  /**
   * Ceil a value, relative to an interval
   * @param {Number} value  Value to be ceiled
   * @param {Number} intervalSize Interval size
   * @returns {Number} Rounded value
   * @see {@link ScaleArithmetic#floorEps floorEps()}
   */
  static ceilEps(value, intervalSize) {
    var eps = Static._eps * intervalSize;

    value = (value - eps) / intervalSize;
    return Math.ceil(value) * intervalSize;
  }

  /**
   * Floor a value, relative to an interval
   * @param {Number} value  Value to be floored
   * @param {Number} intervalSize Interval size
   * @returns {Number} Rounded value
   * @see {@link ScaleArithmetic#ceilEps ceilEps()}
   */
  static floorEps(value, intervalSize) {
    var eps = Static._eps * intervalSize;

    value = (value + eps) / intervalSize;
    return Math.floor(value) * intervalSize;
  }

  /**
   * Divide an interval into steps
   * @param {Number} intervalSize Interval size
   * @param {Number} numSteps Number of steps
   * @returns {Number} Step size
   */
  static divideEps(intervalSize, numSteps) {
    if (numSteps === 0.0 || intervalSize === 0.0) return 0.0;

    return (intervalSize - Static._eps * intervalSize) / numSteps;
  }
}

/**
 * Base class for scale engines.
 *
 * A scale engine tries to find "reasonable" ranges and step sizes for scales. The layout of the scale can
 * be varied with setAttribute(). js-Qwt offers implementations for logarithmic and linear scales.
 */
class ScaleEngine {
  /**
   *
   * @param {Number} bs=10 Base of the scale engine
   */
  constructor(bs) {
    var m_base = 10;
    var m_lowerMargin = 0.0;
    var m_upperMargin = 0.0;
    if (typeof bs !== "undefined") m_base = bs;
    var m_transform = null;
    var m_referenceValue = 0.0;

    var m_attributes = 0;

    /**
     *
     * @returns {Number} The margin at the lower end of the scale. The default margin is 0.
     * @see {@link ScaleEngine#setMargins setMargins()}
     */
    this.lowerMargin = function () {
      return m_lowerMargin;
    };

    /**
     *
     * @returns {Number} The margin at the upper end of the scale. The default margin is 0.
     * @see {@link ScaleEngine#setMargins setMargins()}
     */
    this.upperMargin = function () {
      return m_upperMargin;
    };

    /**
     * Specify margins at the scale's endpoints
     *
     * Margins can be used to leave a minimum amount of space between the enclosed intervals and the boundaries of the scale.
     *
     * LogScaleEngine measures the margins in decades.
     * @param {Number} lower minimum distance between the scale's lower boundary and the smallest enclosed value
     * @param {Number} upper minimum distance between the scale's upper boundary and the greatest enclosed value
     * @see {@link ScaleEngine#upperMargin upperMargin()}
     * @see {@link ScaleEngine#lowerMargin lowerMargin()}
     */
    this.setMargins = function (lower, upper) {
      m_lowerMargin = Math.max(lower, 0.0);
      m_upperMargin = Math.max(upper, 0.0);
    };

    /**
     * Assign a transformation
     *
     * The transformation object is used as factory for clones that are returned by {@link ScaleEngine#transformation transformation()}
     * @param {Transfor} transform Transformation
     * @see {@link ScaleEngine#copy copy()}
     */
    this.setTransformation = function (transform) {
      if (transform !== m_transform) {
        //delete m_transform;
        m_transform = transform;
      }
    };

    /**
     * Create and return a clone of the transformation of the engine. When the engine
     * has no special transformation null is returned, indicating no transformation.
     * @returns {Transform} A clone of the transfomation
     * @see {@link ScaleEngine#setTransformation setTransformation()}
     */
    this.transformation = function () {
      var transform = null;
      if (m_transform) {
        transform = m_transform.copy();
      }

      return transform;
    };

    /**
     * Calculate a step size for an interval size
     * @param {Number} intervalSize Interval size
     * @param {Number} numSteps Number of steps
     * @returns {Number} Step size
     */
    this.divideInterval = function (intervalSize, numSteps) {
      return ScaleArithmetic.divideInterval(intervalSize, numSteps, m_base);
    };

    /**
     * Calculate a scale division.
     *
     * Implemented in {@link LogScaleEngine} and {@link LinearScaleEngine}.
     * @param {Number} x1 First interval limit
     * @param {Number} x2 Second interval limit
     * @param {Number} maxMajorSteps Maximum for the number of major steps
     * @param {Number} maxMinorSteps Maximum number of minor steps
     * @param {Number} stepSize Step size. If stepSize == 0.0, the scaleEngine calculates one.
     * @returns {ScaleDiv} Calculated scale division.
     */
    this.divideScale = function (
      x1,
      x2,
      maxMajorSteps,
      maxMinorSteps,
      stepSize
    ) {
      console.warn("Subclass must implement divideScale()");
    };

    /**
     * Check if an interval "contains" a value
     * @param {Interval} interval Interval
     * @param {Number} value Value
     * @returns {Boolean} true, when the value is inside the interval
     */
    this.contains = function (interval, value) {
      if (!interval.isValid()) return false;

      if (
        Utility.m3FuzzyCompare(value, interval.minValue(), interval.width()) < 0
      )
        return false;

      if (
        Utility.m3FuzzyCompare(value, interval.maxValue(), interval.width()) > 0
      )
        return false;

      return true;
    };

    /**
     * Remove ticks from a list, that are not inside an interval
     * @param {Array} ticks Tick list
     * @param {Interval} interval Interval
     * @returns {Array} Stripped tick list
     */
    this.strip = function (ticks, interval) {
      if (!interval.isValid() || ticks.length === 0) return [];

      if (
        this.contains(interval, ticks[0]) &&
        this.contains(interval, ticks[ticks.length - 1])
      ) {
        return ticks;
      }

      var strippedTicks = [];
      for (var i = 0; i < ticks.length; i++) {
        if (this.contains(interval, ticks[i])) strippedTicks.push(ticks[i]);
      }
      return strippedTicks;
    };

    /**
     * Build an interval around a value
     *
     * In case of v == 0.0 the interval is [-0.5, 0.5], otherwide it is [0.5 * v, 1.5 * v]
     * @param {Number} value Initial value
     * @returns {Interval} Calculated interval
     */
    this.buildInterval = function (value) {
      var delta = value === 0.0 ? 0.5 : Math.abs(0.5 * value);

      if (Number.MAX_VALUE - delta < value)
        return new Interval(Number.MAX_VALUE - delta, Number.MAX_VALUE);

      if (-Number.MAX_VALUE + delta > value)
        return new Interval(-Number.MAX_VALUE, -Number.MAX_VALUE + delta);

      return new Interval(value - delta, value + delta);
    };

    /**
     * Change a scale attribute
     * @param {ScaleEngine.Attributes} attribute
     * @param {Boolean} on On/Off
     */
    this.setAttribute = function (attribute, on) {
      if (on) m_attributes |= attribute;
      else m_attributes &= ~attribute;
    };

    /**
     *
     * @param {ScaleEngine.Attributes} attribute Attribute to be tested
     * @returns {Boolean} true, if attribute is enabled.
     */
    this.testAttribute = function (attribute) {
      return m_attributes & attribute;
    };

    /**
     * Change the scale attribute
     * @param {ScaleEngine.Attributes} attributes Set scale attributes
     */
    this.setAttributes = function (attributes) {
      m_attributes = attributes;
    };

    /**
     *
     * @returns {ScaleEngine.Attributes} Scale attributes
     */
    this.attributes = function () {
      return m_attributes;
    };

    /**
     * Set the base of the scale engine
     *
     * While a base of 10 is what 99.9% of all applications need certain scales might need a different base: e.g. 2.
     * The default setting is 10
     * @param {Number} base Base of the engine
     * @see {@link ScaleEngine#base base()}
     */
    this.setBase = function (base) {
      m_base = Math.max(base, 2);
    };

    /**
     *
     * @returns {Number} Base of the scale engine
     * @see {@link ScaleEngine#setBase setBase()}
     */
    this.base = function () {
      return m_base;
    };

    /**
     * Specify a reference point
     *
     * The reference point is needed if options IncludeReference or Symmetric are active. Its default value is 0.0.
     * @param {Number} r new reference value
     */
    this.setReference = function (r) {
      m_referenceValue = r;
    };

    /**
     *
     * @returns {Number} the reference value
     * @see {@link ScaleEngine#setReference setReference()}
     *
     */
    this.reference = function () {
      return m_referenceValue;
    };
  }

  /**
   * @returns {String} a string representing the object.
   */
  toString() {
    return "[ScaleEngine]";
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link ScaleEngine.Attributes}</div>
 *
 * Layout attributes
 * @name ScaleEngine.Attributes
 * @readonly
 * @property {Number} NoAttribute=0x00             No attributes.
 * @property {Number} IncludeReference=0x01        Build a scale which includes the {@link ScaleEngine#reference reference()} value.
 * @property {Number} Symmetric=0x02               Build a scale which is symmetric to the {@link ScaleEngine#reference reference()} value.
 * @property {Number} Floating=0x04                The endpoints of the scale are supposed to be equal the outmost included values plus the specified margins (see {@link ScaleEngine#setMargins setMargins()}). If this attribute is not set, the endpoints of the scale will be integer multiples of the step size.
 * @property {Number} Inverted=0x08                Turn the scale upside down. ( = 0x08)
 */
Enumerator.enum(
  "Attributes{  NoAttribute = 0x00 , IncludeReference = 0x01 , Symmetric = 0x02 , Floating = 0x04 ,  Inverted = 0x08}",
  ScaleEngine
);

/**
 * A scale engine for linear scales.
 * @extends ScaleEngine
 */
class LinearScaleEngine extends ScaleEngine {
  constructor(bs) {
    super(bs);

    /**
     * Align and divide an interval
     * @param {Number} maxNumSteps Max. number of steps
     * @param {object} xValueObject An object with with two properties: x1(First limit of the interval - In/Out) and x2(Second limit of the interval - In/Out).
     * @param {Number} stepSize Step size (Out)
     */
    this.autoScale = function (maxNumSteps, xValueObject, stepSize) {
      var interval = new Interval(xValueObject["x1"], xValueObject["x2"]);
      interval = interval.normalized();

      interval.setMinValue(interval.minValue() - this.lowerMargin());
      interval.setMaxValue(interval.maxValue() + this.upperMargin());

      if (this.testAttribute(ScaleEngine.Attributes.Symmetric))
        interval = interval.symmetrize(this.reference());

      if (this.testAttribute(ScaleEngine.Attributes.IncludeReference))
        interval = interval.extend(this.reference());

      if (interval.width() === 0.0)
        interval = this.buildInterval(interval.minValue());

      stepSize = ScaleArithmetic.divideInterval(
        interval.width(),
        Math.max(maxNumSteps, 1),
        this.base()
      );

      if (!this.testAttribute(ScaleEngine.Attributes.Floating))
        interval = this.align(interval, stepSize);

      xValueObject["x1"] = interval.minValue();
      xValueObject["x2"] = interval.maxValue();

      if (this.testAttribute(ScaleEngine.Attributes.Inverted)) {
        //qSwap(x1, x2);
        xValueObject["x2"] = interval.minValue();
        xValueObject["x1"] = interval.maxValue();
        stepSize = -stepSize;
      }
    };

    //Documented in base class
    this.divideScale = function (
      x1,
      x2,
      maxMajorSteps,
      maxMinorSteps,
      stepSize
    ) {
      if (typeof stepSize === "undefined") stepSize = 0.0;
      var interval = new Interval(x1, x2).normalized();
      if (interval.width() <= 0) return new ScaleDiv();

      stepSize = Math.abs(stepSize);
      if (stepSize === 0.0) {
        if (maxMajorSteps < 1) maxMajorSteps = 1;

        stepSize = ScaleArithmetic.divideInterval(
          interval.width(),
          maxMajorSteps,
          this.base()
        );
      }

      var scaleDiv = new ScaleDiv();

      if (stepSize !== 0.0) {
        var ticks = [];

        this.buildTicks(interval, stepSize, maxMinorSteps, ticks);
        scaleDiv = new ScaleDiv(interval, ticks);
        //console.log(interval.width())
        //console.log(ticks)
      }

      if (x1 > x2) scaleDiv.invert();

      return scaleDiv;
    };

    /**
     * Calculate ticks for an interval
     * @param {Interval} interval Interval
     * @param {Number} stepSize Step size
     * @param {Number} maxMinorSteps Maximum number of minor steps
     * @param {Array<Array<Number>>} ticks Arrays to be filled with the calculated ticks
     * @see {@link LinearScaleEngine#buildMajorTicks buildMajorTicks()}
     * @see {@link LinearScaleEngine#buildMinorTicks buildMinorTicks()}
     */
    this.buildTicks = function (interval, stepSize, maxMinorSteps, ticks) {
      var boundingInterval = this.align(interval, stepSize);

      ticks[ScaleDiv.TickType.MajorTick] = this.buildMajorTicks(
        boundingInterval,
        stepSize
      );

      if (maxMinorSteps > 0) {
        var minorTicks = [];
        var mediumTicks = [];
        this.buildMinorTicks(
          ticks[ScaleDiv.TickType.MajorTick],
          maxMinorSteps,
          stepSize,
          minorTicks,
          mediumTicks
        );
        ticks[ScaleDiv.TickType.MinorTick] = minorTicks;
        ticks[ScaleDiv.TickType.MediumTick] = mediumTicks;
      }

      for (var i = 0; i < ScaleDiv.TickType.NTickTypes; i++) {
        var obj = this.strip(ticks[i], interval);
        ticks[i] = [];
        ticks[i] = obj;

        // ticks very close to 0.0 are
        // explicitely set to 0.0

        for (var j = 0; j < ticks[i].length; j++) {
          if (Utility.m3FuzzyCompare(ticks[i][j], 0.0, stepSize) === 0)
            ticks[i][j] = 0.0;
        }
      }
    };

    /**
     * Calculate major ticks for an interval
     * @param {Interval} interval Interval
     * @param {Number} stepSize Step size
     * @returns {Array<Number>} Calculated ticks
     */
    this.buildMajorTicks = function (interval, stepSize) {
      var numTicks = Math.round(interval.width() / stepSize) + 1;
      if (numTicks > 10000) numTicks = 10000;

      var ticks = [];

      ticks.push(interval.minValue());
      for (var i = 1; i < numTicks - 1; i++)
        ticks.push(interval.minValue() + i * stepSize);
      ticks.push(interval.maxValue());

      //console.log(ticks)
      return ticks;
    };

    /**
     * Calculate minor/medium ticks for major ticks
     * @param {Array<Number>} majorTicks Major ticks
     * @param {Number} maxMinorSteps Maximum number of minor steps
     * @param {Number} stepSize Step size
     * @param {Array<Number>} minorTicks Array to be filled with the calculated minor ticks
     * @param {Array<Number>} mediumTicks Array to be filled with the calculated medium ticks
     */
    this.buildMinorTicks = function (
      majorTicks,
      maxMinorSteps,
      stepSize,
      minorTicks,
      mediumTicks
    ) {
      var minStep = Static.mStepSize(stepSize, maxMinorSteps, this.base());
      if (minStep === 0.0) return;

      // # ticks per interval
      var numTicks = Math.ceil(Math.abs(stepSize / minStep)) - 1;

      var medIndex = -1;
      if (numTicks % 2) medIndex = numTicks / 2;

      // calculate minor ticks

      for (var i = 0; i < majorTicks.length; i++) {
        var val = majorTicks[i];
        for (var k = 0; k < numTicks; k++) {
          val += minStep;

          var alignedValue = val;
          if (Utility.m3FuzzyCompare(val, 0.0, stepSize) === 0)
            alignedValue = 0.0;

          if (k == medIndex) mediumTicks.push(alignedValue);
          else minorTicks.push(alignedValue);
        }
      }
    };

    /**
     * Align an interval to a step size
     *
     * The limits of an interval are aligned that both are integer multiples of the step size.
     * @param {Interval} interval
     * @param {Number} stepSize
     * @returns {Interval} Aligned interval
     */
    this.align = function (interval, stepSize) {
      var x1 = interval.minValue();
      var x2 = interval.maxValue();

      if (-Number.MAX_VALUE + stepSize <= x1) {
        var x = ScaleArithmetic.floorEps(x1, stepSize);
        if (Utility.m3FuzzyCompare(x1, x, stepSize) !== 0) x1 = x;
      }

      if (Number.MAX_VALUE - stepSize >= x2) {
        var x = ScaleArithmetic.ceilEps(x2, stepSize);
        if (Utility.m3FuzzyCompare(x2, x, stepSize) !== 0) x2 = x;
      }

      return new Interval(x1, x2);
    };
  }

  /**
   *
   * @returns {String}  A string representing the object. .
   */
  toString() {
    return "[LinearScaleEngine]";
  }
}

/**
 * A scale engine for logarithmic scales.
 * @extends ScaleEngine
 */
class LogScaleEngine extends ScaleEngine {
  constructor(bs) {
    super(bs);
    //ScaleEngine.call(this, bs);

    this.setTransformation(new LogTransform());

    /**
     * Align and divide an interval
     * @param {Number} maxNumSteps  Max. number of steps
     * @param {object} xValueObject An object with with two properties: x1(First limit of the interval - In/Out) and x2(Second limit of the interval - In/Out).
     * @param {Number} stepSize Step size (Out)
     */
    this.autoScale = function (maxNumSteps, xValueObject, stepSize) {
      //if ( x1 > x2 )
      //qSwap( x1, x2 );

      if (xValueObject["x1"] > xValueObject["x2"]) {
        const temp = xValueObject["x1"];
        xValueObject["x1"] = xValueObject["x2"];
        xValueObject["x2"] = temp;
      }

      var logBase = this.base();

      var interval = new Interval(
        xValueObject["x1"] / Math.pow(logBase, this.lowerMargin()),
        xValueObject["x2"] * Math.pow(logBase, this.upperMargin())
      );

      if (interval.maxValue() / interval.minValue() < logBase) {
        // scale width is less than one step -> try to build a linear scale

        var linearScaler = new LinearScaleEngine();
        linearScaler.setAttributes(this.attributes());
        linearScaler.setReference(this.reference());
        linearScaler.setMargins(this.lowerMargin(), this.upperMargin());

        linearScaler.autoScale(maxNumSteps, xValueObject, stepSize);

        var linearInterval = new Interval(
          xValueObject["x1"],
          xValueObject["x2"]
        );
        linearInterval.normalized();

        linearInterval = linearInterval.limited(1.0e-100, 1.0e100);

        if (linearInterval.maxValue() / linearInterval.minValue() < logBase) {
          // the aligned scale is still less than one step
          if (stepSize < 0.0)
            stepSize = -Static.mLog(logBase, Math.abs(stepSize));
          else stepSize = Static.mLog(logBase, stepSize);

          return;
        }
      }

      var logRef = 1.0;
      if (this.reference() > 1.0e-100 / 2)
        logRef = Math.min(this.reference(), 1.0e100 / 2);

      if (this.testAttribute(ScaleEngine.Attributes.Symmetric)) {
        const delta = Math.max(
          interval.maxValue() / logRef,
          logRef / interval.minValue()
        );
        interval.setInterval(logRef / delta, logRef * delta);
      }

      if (this.testAttribute(ScaleEngine.Attributes.IncludeReference))
        interval = interval.extend(logRef);

      interval = interval.limited(1.0e-100, 1.0e100);

      if (interval.width() == 0.0)
        interval = this.buildInterval(interval.minValue());

      stepSize = this.divideInterval(
        Static.mLogInterval(logBase, interval).width(),
        Math.max(maxNumSteps, 1)
      );
      if (stepSize < 1.0) stepSize = 1.0;

      if (!this.testAttribute(ScaleEngine.Attributes.Floating))
        interval = this.align(interval, stepSize);

      xValueObject["x1"] = interval.minValue();
      xValueObject["x2"] = interval.maxValue();

      if (this.testAttribute(ScaleEngine.Attributes.Inverted)) {
        //qSwap(x1, x2);
        xValueObject["x2"] = interval.minValue();
        xValueObject["x1"] = interval.maxValue();
        stepSize = -stepSize;
      }
    };

    //Documented in base class
    this.divideScale = function (
      x1,
      x2,
      maxMajorSteps,
      maxMinorSteps,
      stepSize
    ) {
      //alert(456)
      var interval = new Interval(x1, x2);
      interval.normalized();
      interval = interval.limited(1.0e-100, 1.0e100);

      if (interval.width() <= 0) return new ScaleDiv();

      var logBase = this.base();

      if (interval.maxValue() / interval.minValue() < logBase) {
        // scale width is less than one decade -> build linear scale

        var linearScaler = new LinearScaleEngine();
        linearScaler.setAttributes(this.attributes());
        linearScaler.setReference(this.reference());
        linearScaler.setMargins(this.lowerMargin(), this.upperMargin());

        if (stepSize != 0.0) {
          if (stepSize < 0.0) stepSize = -Math.pow(logBase, -stepSize);
          else stepSize = Math.pow(logBase, stepSize);
        }

        return linearScaler.divideScale(
          x1,
          x2,
          maxMajorSteps,
          maxMinorSteps,
          stepSize
        );
      }

      stepSize = Math.abs(stepSize);
      if (stepSize == 0.0) {
        if (maxMajorSteps < 1) maxMajorSteps = 1;
        //alert(mLogInterval( logBase, interval ).width())
        stepSize = ScaleArithmetic.divideInterval(
          Static.mLogInterval(logBase, interval).width(),
          maxMajorSteps,
          this.base()
        );
        //alert(stepSize)
        if (stepSize < 1.0) stepSize = 1.0; // major step must be >= 1 decade
      }

      var scaleDiv = new ScaleDiv();
      //alert(stepSize)
      if (stepSize != 0.0) {
        //alert(stepSize)
        var ticks = [];

        this.buildTicks(interval, stepSize, maxMinorSteps, ticks);
        scaleDiv = new ScaleDiv(interval, ticks);

        //alert(432)
      }

      if (x1 > x2) scaleDiv.invert();

      return scaleDiv;
    };

    /**
     * Calculate ticks for an interval
     * @param {Interval} interval Interval
     * @param {Number} stepSize Step size
     * @param {Number} maxMinorSteps Maximum number of minor steps
     * @param {Array<Array<Number>>} ticks Arrays to be filled with the calculated ticks
     * @see {@link LinearScaleEngine#buildMajorTicks buildMajorTicks()}
     * @see {@link LinearScaleEngine#buildMinorTicks buildMinorTicks()}
     */
    this.buildTicks = function (interval, stepSize, maxMinorSteps, ticks) {
      var boundingInterval = this.align(interval, stepSize);

      ticks[ScaleDiv.TickType.MajorTick] = this.buildMajorTicks(
        boundingInterval,
        stepSize
      );

      if (maxMinorSteps > 0) {
        var minorTicks = [];
        var mediumTicks = [];
        this.buildMinorTicks(
          ticks[ScaleDiv.TickType.MajorTick],
          maxMinorSteps,
          stepSize,
          minorTicks,
          mediumTicks
        );
        ticks[ScaleDiv.TickType.MinorTick] = minorTicks;
        ticks[ScaleDiv.TickType.MediumTick] = mediumTicks;
      }

      for (var i = 0; i < ScaleDiv.TickType.NTickTypes; i++) {
        var obj = this.strip(ticks[i], interval);
        ticks[i] = [];
        ticks[i] = obj;

        // ticks very close to 0.0 are
        // explicitely set to 0.0

        for (var j = 0; j < ticks[i].length; j++) {
          if (Utility.m3FuzzyCompare(ticks[i][j], 0.0, stepSize) === 0)
            ticks[i][j] = 0.0;
        }
      }
    };

    /**
     * Calculate major ticks for an interval
     * @param {Interval} interval Interval
     * @param {Number} stepSize Step size
     * @returns {Array<Number>} Calculated ticks
     */
    this.buildMajorTicks = function (interval, stepSize) {
      var width = Static.mLogInterval(this.base(), interval).width();

      var numTicks = Math.round(width / stepSize) + 1;
      if (numTicks > 10000) numTicks = 10000;

      var lxmin = Math.log(interval.minValue());
      var lxmax = Math.log(interval.maxValue());
      var lstep = (lxmax - lxmin) / (numTicks - 1);

      var ticks = [];

      ticks.push(interval.minValue());

      for (var i = 1; i < numTicks - 1; i++)
        ticks.push(Math.exp(lxmin + i * lstep));

      ticks.push(interval.maxValue());

      //alert(ticks)

      return ticks;
    };

    /**
     * Calculate minor/medium ticks for major ticks
     * @param {Array<Number>} majorTicks Major ticks
     * @param {Number} maxMinorSteps Maximum number of minor steps
     * @param {Number} stepSize Step size
     * @param {Array<Number>} minorTicks Array to be filled with the calculated minor ticks
     * @param {Array<Number>} mediumTicks Array to be filled with the calculated medium ticks
     */
    this.buildMinorTicks = function (
      majorTicks,
      maxMinorSteps,
      stepSize,
      minorTicks,
      mediumTicks
    ) {
      var logBase = this.base();

      if (stepSize < 1.1) {
        // major step width is one base
        var minStep = this.divideInterval(stepSize, maxMinorSteps + 1);
        if (minStep == 0.0) return;

        var numSteps = Math.round(stepSize / minStep);

        var mediumTickIndex = -1;
        if (numSteps > 2 && numSteps % 2 == 0) mediumTickIndex = numSteps / 2;

        for (i = 0; i < majorTicks.length - 1; i++) {
          var v = majorTicks[i];
          var s = logBase / numSteps;

          if (s >= 1.0) {
            for (j = 2; j < numSteps; j++) {
              minorTicks.push(v * j * s);
            }
          } else {
            for (j = 1; j < numSteps; j++) {
              var tick = v + (j * v * (logBase - 1)) / numSteps;
              if (j == mediumTickIndex) mediumTicks.push(tick);
              else minorTicks.push(tick);
            }
          }
        }
      } else {
        var minStep = this.divideInterval(stepSize, maxMinorSteps);
        if (minStep == 0.0) return;

        if (minStep < 1.0) minStep = 1.0;

        // # subticks per interval
        var numTicks = Math.round(stepSize / minStep) - 1;

        // Do the minor steps fit into the interval?
        if (
          Utility.m3FuzzyCompare((numTicks + 1) * minStep, stepSize, stepSize) >
          0
        ) {
          numTicks = 0;
        }

        if (numTicks < 1) return;

        var mediumTickIndex = -1;
        if (numTicks > 2 && numTicks % 2) mediumTickIndex = numTicks / 2;

        // substep factor = base^substeps
        var minFactor = Math.max(Math.pow(logBase, minStep), logBase);

        for (var i = 0; i < majorTicks.length; i++) {
          var tick = majorTicks[i];
          for (var j = 0; j < numTicks; j++) {
            tick *= minFactor;

            if (j == mediumTickIndex) mediumTicks.push(tick);
            else minorTicks.push(tick);
          }
        }
      }
    };

    /**
     * Align an interval to a step size
     *
     * The limits of an interval are aligned that both are integer multiples of the step size.
     * @param {Interval} interval
     * @param {Number} stepSize
     * @returns {Interval} Aligned interval
     */
    this.align = function (interval, stepSize) {
      var intv = Static.mLogInterval(this.base(), interval);

      var x1 = ScaleArithmetic.floorEps(intv.minValue(), stepSize);
      if (Utility.m3FuzzyCompare(interval.minValue(), x1, stepSize) == 0)
        x1 = interval.minValue();

      var x2 = ScaleArithmetic.ceilEps(intv.maxValue(), stepSize);
      if (Utility.m3FuzzyCompare(interval.maxValue(), x2, stepSize) == 0)
        x2 = interval.maxValue();

      return Static.mPowInterval(this.base(), new Interval(x1, x2));
    };
  }

  /**
   *
   * @returns {String}  A string representing the object. .
   */
  toString() {
    return "[LogScaleEngine]";
  }
}
;
define("scaleEngine", ["static"], function(){});


// Mapping points with filtering out consecutive
// points mapped to the same position

Static.mToPolylineFiltered = function (xMap, yMap, series, from, to, round) {
  // in curves with many points consecutive points
  // are often mapped to the same position. As this might
  // result in empty lines ( or symbols hidden by others )
  // we try to filter them out

  //var polyline = [];//( to - from + 1 );
  //Point *points = polyline.data();
  var points = [];

  var sample0 = series.sample(from);

  //points.push({x:Math.round( xMap.transform( sample0.x ) ), y:Math.round( yMap.transform( sample0.y ) )})
  //points.push(new Misc.Point(Math.round(xMap.transform(sample0.x)), Math.round(yMap.transform(sample0.y))));
  points[0] = new Misc.Point(
    Math.round(xMap.transform(sample0.x)),
    Math.round(yMap.transform(sample0.y))
  );

  var pos = 0;
  for (var i = from + 1; i <= to; i++) {
    var sample = series.sample(i);
    var p;
    if (round)
      //p = { x:Math.round( xMap.transform( sample.x ) ), y:Math.round( yMap.transform( sample.y ) ) };
      p = new Misc.Point(
        Math.round(xMap.transform(sample.x)),
        Math.round(yMap.transform(sample.y))
      );
    //            p = { x: xMap.transform( sample.x ), y: yMap.transform( sample.y )  };
    else p = new Misc.Point(xMap.transform(sample.x), yMap.transform(sample.y));

    if (points[pos].x === p.x && points[pos].y === p.y) continue;
    pos++;
    //points.push(p);
    points[pos] = p;
  }

  //polyline.resize( pos + 1 );
  return points;
};

// mapping points without any filtering - beside checking
// the bounding rectangle

Static.mToPoints = function (
  boundingRect,
  xMap,
  yMap,
  series,
  from,
  to,
  round
) {
  //Polygon polyline( to - from + 1 );
  var points = [];

  var numPoints = 0;

  if (
    boundingRect.left() <= boundingRect.right() &&
    boundingRect.top() <= boundingRect.bottom()
  ) {
    // iterating over all values
    // filtering out all points outside of
    // the bounding rectangle

    for (i = from; i <= to; i++) {
      var sample = series.sample(i);

      var x = xMap.transform(sample.x);
      var y = yMap.transform(sample.y);

      if (
        x >= boundingRect.left() &&
        x <= boundingRect.right() &&
        y >= boundingRect.top() &&
        y <= boundingRect.bottom()
      ) {
        if (round) {
          //                    points.push({x:Math.round( x ), y:Math.round( y )});
          points.push(new Misc.Point(Math.round(x), Math.round(y)));
        } else {
          //                    points.push({x:x, y:y});
          points.push(new Misc.Point(x, y));
        }
        numPoints++;
      }
    }

    //polyline.resize( numPoints );
  } else {
    // simply iterating over all values
    // without any filtering

    for (var i = from; i <= to; i++) {
      var sample = series.sample(i);

      var x = xMap.transform(sample.x) - 1; //minus 1 why
      var y = yMap.transform(sample.y) - 1; //minus 1 why

      if (round) {
        //                points.push({x:Math.round( x ), y:Math.round( y )});
        points.push(new Misc.Point(Math.round(x), Math.round(y)));
      } else {
        //                points.push({x:x, y:y});
        points.push(new Misc.Point(x, y));
      }

      numPoints++;
    }
  }
  return points;
};

/**
 * A helper class for translating a series of points.
 *
 * PointMapper is a collection of methods and optimizations for translating a series of points into paint device coordinates. It is used by {@link Curve} but might also be useful for similar plot items displaying a {@link SeriesData}.
 */
class PointMapper {
  constructor() {
    var m_flags = 0;
    //var m_boundingRect = { left:0.0, top:0.0, right:-1.0, bottom:-1.0, width:-1.0, height:-1 };
    var m_boundingRect = new Misc.Rect();

    /**
     * Set a bounding rectangle for the point mapping algorithm
     *
     * A valid bounding rectangle can be used for optimizations
     * @param {Misc.Rect} rect Bounding rectangle
     * @see {@link PointMapper#boundingRect boundingRect()}
     */
    this.setBoundingRect = function (rect) {
      m_boundingRect = rect;
    };

    /**
     *
     * @returns {Misc.Rect} Bounding rectangle
     * @see {@link PointMapper#setBoundingRect setBoundingRect()}
     */
    this.boundingRect = function () {
      return m_boundingRect;
    };

    /**
     * Modify a flag affecting the transformation process
     * @param {PointMapper.TransformationFlag} flag Flag type
     * @param {Boolean} on Value
     * @see {@link PointMapper#setFlags setFlags()}
     */
    this.setFlag = function (flag, on) {
      if (on) m_flags |= flag;
      else m_flags &= ~flag;
    };

    /**
     * Set the flags affecting the transformation process
     * @param {PointMapper.TransformationFlag} flags 	Flags
     * @see {@link PointMapper#flags flags()}
     * @see {@link PointMapper#setFlag setFlag()}
     */
    this.setFlags = function (flags) {
      m_flags = flags;
    };

    /**
     *
     * @returns {Number} Flags affecting the transformation process
     * @see {@link PointMapper#setFlags setFlags()}
     * @see {@link PointMapper#setFlag setFlag()}
     */
    this.flags = function () {
      return m_flags;
    };

    /**
     *
     * @param {PointMapper.TransformationFlag} flag Flag type
     * @returns {Boolean} True, when the flag is set
     * @see {@link PointMapper#setFlag setFlag()}
     * @see {@link PointMapper#setFlags setFlags()}
     */
    this.testFlag = function (flag) {
      return m_flags & flag;
    };

    /**
     * Translate a series of points into a QPolygonF
     *
     * When the WeedOutPoints flag is enabled consecutive points, that are mapped to the same position will be one point.
     *
     * When PointMapper.TransformationFlag.RoundPoints is set all points are rounded to integers.
     * @param {Number} xMap x map
     * @param {Number} yMap y map
     * @param {SeriesData} series Series of points to be mapped
     * @param {Number} from Index of the first point to be painted
     * @param {Number} to Index of the last point to be painted
     * @returns {Array<Misc.Point>} Translated polygon
     */
    this.toPolygonF = function (xMap, yMap, series, from, to) {
      var polyline = [];

      if (m_flags & PointMapper.TransformationFlag.WeedOutPoints) {
        if (m_flags & PointMapper.TransformationFlag.RoundPoints) {
          polyline = Static.mToPolylineFiltered(
            xMap,
            yMap,
            series,
            from,
            to,
            true
          );
        } else {
          polyline = Static.mToPolylineFiltered(
            xMap,
            yMap,
            series,
            from,
            to,
            false
          );
        }
      } else {
        if (m_flags & PointMapper.TransformationFlag.RoundPoints) {
          polyline = Static.mToPoints(
            new Misc.Rect(0.0, 0.0, -1.0, -1),
            xMap,
            yMap,
            series,
            from,
            to,
            true
          );
        } else {
          polyline = Static.mToPoints(
            new Misc.Rect(0.0, 0.0, -1.0, -1),
            xMap,
            yMap,
            series,
            from,
            to,
            false
          );
          //alert(polyline)
        }
      }

      return polyline;
    };

    /**
     * Translate a series into a Array<Misc.Point>
     *
     * WeedOutPoints & PointMapper.TransformationFlag.RoundPoints & boundingRect().isValid()
     *
     * All points that are mapped to the same position will be one point. Points outside of the bounding rectangle are ignored.
     *
     * WeedOutPoints & PointMapper.TransformationFlag.RoundPoints & !boundingRect().isValid(). All consecutive points that are mapped to the same position will one point.
     *
     * !WeedOutPoints & boundingRect().isValid(). Points outside of the bounding rectangle are ignored.
     *
     * When PointMapper.TransformationFlag.RoundPoints is set all points are rounded to integers.
     * @param {Number} xMap x map
     * @param {Number} yMap y map
     * @param {SeriesData} series Series of points to be mapped
     * @param {Number} from Index of the first point to be painted
     * @param {Number} to Index of the last point to be painted
     * @returns {Array<Misc.Point>} Translated polygon
     */
    this.toPointsF = function (xMap, yMap, series, from, to) {
      var points; //= [];

      if (m_flags & PointMapper.TransformationFlag.WeedOutPoints) {
        if (m_flags & PointMapper.TransformationFlag.RoundPoints) {
          if (
            m_boundingRect.left() <= m_boundingRect.right() &&
            m_boundingRect.top() <= m_boundingRect.bottom()
          ) {
            points = Static.mToPointsFiltered(
              m_boundingRect,
              xMap,
              yMap,
              series,
              from,
              to
            );
          } else {
            // without a bounding rectangle all we can
            // do is to filter out duplicates of
            // consecutive points

            points = Static.mToPolylineFiltered(
              xMap,
              yMap,
              series,
              from,
              to,
              true
            );
          }
        } else {
          // when rounding is not allowed we can't use
          // qwtToPointsFilteredF

          points = Static.mToPolylineFiltered(
            xMap,
            yMap,
            series,
            from,
            to,
            false
          );
        }
      } else {
        if (m_flags & PointMapper.TransformationFlag.RoundPoints) {
          points = Static.mToPoints(
            m_boundingRect,
            xMap,
            yMap,
            series,
            from,
            to,
            true
          );
        } else {
          points = Static.mToPoints(
            m_boundingRect,
            xMap,
            yMap,
            series,
            from,
            to,
            false
          );
        }
      }

      return points;
    };
  }

  /**
   *
   * @returns {String} A string representation of the object.
   */
  toString() {
    return "[PointMapper]";
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link PointMapper.TransformationFlag}</div>
 *
 * Flags affecting the transformation process.
 * @name PointMapper.TransformationFlag
 * @readonly
 * @property {Number} RoundPoints=0x01                Round points to integer values.
 * @property {Number} WeedOutPoints=0x02              Try to remove points, that are translated to the same position.
 */
Enumerator.enum(
  "TransformationFlag { RoundPoints = 0x01 , WeedOutPoints = 0x02}",
  PointMapper
);

define("pointMapper", ["static"], function(){});


/**
 * Axis position
 */
class Axis {}
/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link Axis.AxisId}</div>
 *
 * Axis position.
 * @name Axis.AxisId
 * @readonly
 * @property {Number} yLeft             Y axis left of the canvas.
 * @property {Number} yRight            Y axis right of the canvas.
 * @property {Number} xBottom           X axis below the canvas.
 * @property {Number} xTop              X axis above the canvas.
 * @property {Number} axisCnt           Number of axes
 */
Enumerator.enum("AxisId{yLeft, yRight, xBottom, xTop, axisCnt}", Axis);

class AxisData {
  constructor() {
    this.axisName = "";
    this.isEnabled = false;
    this.doAutoScale = true;
    this.minValue; // = -1000.0;
    this.maxValue; // = 1000.0;
    this.stepSize; // = 0;
    this.maxMajor; // = 10;
    this.maxMinor; // = 100;
    this.isValid = true;
    this.scaleDiv = null;
    this.scaleEngine = null;
    this.scaleWidget = null;
    this.scaleDomDiv = null;
    this.canvas = null;
  }

  toString() {
    return "[AxisData]";
  }
}

/**
 * A 2-D plotting widget.
 * Plot is a widget for plotting two-dimensional graphs. An unlimited number of plot items can be displayed on its canvas. Plot
 * items can be curves (PlotCurve), markers (PlotMarker), the grid (PlotGrid), or anything else derived from PlotItem.
 * A plot can have up to four axes, with each plot item attached to an x- and a y axis. The scales at the axes can be explicitly
 * set (ScaleDiv), or are calculated from the plot items, using algorithms (ScaleEngine) which can be configured separately
 * for each axis.
 *
 */
class Plot {
  /**
   *
   * @param {(string|jQuery)} _plotDiv plot parent. If this parameter is a string, it is converted to a jQuery selector object: $("#plotDiv")
   * @param {string} [pTitle] Title of the plot
   * @example
   *    <!--index.html-->

        <!DOCTYPE html>
        <html lang="en">

          <head>
              ...
          </head>

          <body>
              <div id="plotDiv" class="plotContainer"></div>
              ...
          </body>

        </html>



        //app.js
        require([      
          'plot'
        ], function(){         
            const plot = new Plot($("#plotDiv")); //or new Plot() since Plot assumes the div id is "plotDiv"
            plot.setAutoReplot(true);	
        })

   */
  constructor(_plotDiv, pTitle) {
    this.plotDiv = null;
    if (_plotDiv == undefined) {
      this.plotDiv = $("#plotDiv");
    } else {
      this.plotDiv = _plotDiv;
    }

    this.plotDiv.addClass("plotDivPrint");

    /* If plotDiv parent is not a DIV, we give it a new parent that is a DIV */
    if (this.plotDiv.parent()[0].tagName !== "DIV") {
      var plotDivParent = $(
        '<div style="position: absolute; width:100%; height: 98%;"></div>'
      );
      this.plotDiv.parent().append(plotDivParent);
      var element = this.plotDiv.detach();
      plotDivParent.append(element);
      plotDivParent.addClass("plotDivPrint");
    } else {
      this.plotDiv.parent().addClass("plotDivPrint");
    }

    const self = this; //'self' is used in place of 'this' in callbacks
    var m_plotItemStore = [];
    var d_axisData = [];
    var plotDivHeightAsPercentOfPlotDivParent = 0;

    var plotDivContainer = this.plotDiv.parent();

    var plotDivContainerWidth = parseFloat(plotDivContainer.css("width"));
    var plotDivContainerHeight = parseFloat(plotDivContainer.css("height"));

    var beforePrintCb = null;
    var afterPrintCb = null;
    //var m_sidebarVisible = false;

    var _title = "";
    var m_footer = "";
    var legendEnable = false;
    var m_cursor = "";
    var m_defaultCursor = "";

    var m_autoReplot = false;
    var m_legend = null;

    var m_legendFont = new Misc.Font();

    this.zoomer = null; //stores zoomer known to the plot
    this.panner = null; //stores panner known to the plot

    /**
     * Change the legend's font
     * @param {Misc.Font} font New font
     */
    this.setLegendFont = function (font) {
      m_legendFont = font;
    };

    /**
     *
     * @returns {Misc.Font} font use in legend
     */
    this.legendFont = function () {
      return m_legendFont;
    };

    /**
     * Replots the plot if autoReplot() is true.
     */
    this.autoRefresh = function () {
      if (m_autoReplot) {
        this.replot();
        //this.updateLayout
      }
    };

    /**
     * Set or reset the autoReplot option. If the autoReplot option is set, the plot will be
     * updated implicitly by manipulating member functions. Since this may be time-consuming, it is recommended to leave this
     * option switched off and call replot() explicitly if necessary.
     *
     * The autoReplot option is set to false by default, which means that the user has to call replot() in order to make
     * changes visible.
     * @param {boolean} tf  true or false. Defaults to true.
     * @see {@link Plot#replot replot()}
     */
    this.setAutoReplot = function (tf) {
      m_autoReplot = tf;
    };

    /**
     * @returns {boolean} true if the autoReplot option is set.
     * @see {@link Plot#setAutoReplot setAutoReplot}
     */
    this.autoReplot = function () {
      return m_autoReplot;
    };

    /**
     *
     * @returns {Array<PlotItem>} List of attached plotItems
     * @see {@link Plot#itemList itemList()}
     */
    this.plotItemStore = function () {
      return m_plotItemStore;
    };

    var m_titleFont = new Misc.Font(12);

    var m_footerFont = new Misc.Font(12);

    var layout = new Layout(this.plotDiv, this);

    /**
     * @returns {Layout} the plot's layout
     */
    this.getLayout = function () {
      return layout;
    };

    /**
     * Return the current interval of the specified axis
     *
     * This is only a convenience function for axisScaleDiv( axisId ).interval();
     * @param {Axis.AxisId} axisId Axis index
     * @returns {Interval} Scale interval
     * @see {@link ScaleDiv}
     * @see {@link Plot#axisScaleDiv axisScaleDiv()}
     */
    this.axisInterval = function (axisId) {
      if (!this.axisValid(axisId)) return new Interval();

      return d_axisData[axisId].scaleDiv.interval();
    };

    /**
     * Format a number to a specified length
     * @param {Number} axisId Axis id
     * @param {Number} places Length
     *
     */
    this.setAxisPrecision = function (axisId, places) {
      if (!this.axisValid(axisId)) return;
      this.axisScaleDraw(axisId).setPrecision(places);

      this.autoRefresh();
    };

    /**
     * Sets the decimal places used by an axis
     * @param {Axis.AxisId} axisId Axis id
     * @param {Number} places Decimal places
     */
    this.setAxisDecimalPlaces = function (axisId, places) {
      if (!this.axisValid(axisId)) return;
      this.axisScaleDraw(axisId).setDecimalPlaces(places);

      this.autoRefresh();
    };

    /* this.setNonExponentNotationLimits = function (lower, upper) {
      for (var axisId = 0; axisId < Axis.AxisId.axisCnt; ++axisId) {
        this.axisScaleDraw(axisId).setNonExponentLimits(lower, upper);
      }
      this.autoRefresh();
    };

    this.getNonExponentNotationLimits = function () {
      return this.axisScaleDraw(0).getNonExponentNotationLimits();
    }; */

    /**
     *
     * @param {Axis.AxisId} axisId Axis id
     * @returns {Number} The number precision
     * @see {@link Plot#setAxisPrecision setAxisPrecision()}
     */
    this.axisPrecision = function (axisId) {
      if (!this.axisValid(axisId)) return 3;

      return this.axisScaleDraw(axisId).precision();
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis id
     * @returns {Number} Decimal places for the axis
     * @see {@link Plot#setAxisDecimalPlaces setAxisDecimalPlaces()}
     */
    this.axisDecimalPlaces = function (axisId) {
      if (!this.axisValid(axisId)) return 3;

      return this.axisScaleDraw(axisId).decimalPlaces();
    };

    var centralWidget = new Widget(layout.getCentralDiv());
    var titleWidget = new Widget(layout.getTitleDiv());
    var footerWidget = new Widget(layout.getFooterDiv());

    centralWidget.setEnabled_1(true);

    centralWidget.plot = this;

    /**
     *
     * @returns {Widget} The central widget. The central widget is the parent of all plotItems
     */
    this.getCentralWidget = function () {
      return centralWidget;
    };

    /**
     *
     * @returns {Widget} The title widget.
     */
    this.getTitleWidget = function () {
      return titleWidget;
    };

    /**
     *
     * @returns {Widget} The footer widget.
     */
    this.getFooterWidget = function () {
      return footerWidget;
    };

    //! Initialize axes
    const initAxesData = function () {
      var axisId;

      for (axisId = 0; axisId < Axis.AxisId.axisCnt; axisId++)
        d_axisData[axisId] = new AxisData();

      d_axisData[Axis.AxisId.yLeft].axisName = "AxisYLeft";
      d_axisData[Axis.AxisId.yRight].axisName = "AxisYRight";
      d_axisData[Axis.AxisId.xTop].axisName = "AxisXTop";
      d_axisData[Axis.AxisId.xBottom].axisName = "AxisXBottom";

      /* d_axisData[Axis.AxisId.yLeft].scaleDomDiv = layout.getScaleDivElement(Axis.AxisId.yLeft);
            d_axisData[Axis.AxisId.yRight].scaleDomDiv = layout.getScaleDivElement(Axis.AxisId.yRight);
            d_axisData[Axis.AxisId.xTop].scaleDomDiv = layout.getScaleDivElement(Axis.AxisId.xTop);
            d_axisData[Axis.AxisId.xBottom].scaleDomDiv = layout.getScaleDivElement(Axis.AxisId.xBottom); */

      d_axisData[Axis.AxisId.yLeft].scaleWidget = new ScaleWidget(
        self,
        layout.getScaleDivElement(Axis.AxisId.yLeft),
        ScaleDraw.Alignment.LeftScale
      );
      d_axisData[Axis.AxisId.yRight].scaleWidget = new ScaleWidget(
        self,
        layout.getScaleDivElement(Axis.AxisId.yRight),
        ScaleDraw.Alignment.RightScale
      );
      d_axisData[Axis.AxisId.xTop].scaleWidget = new ScaleWidget(
        self,
        layout.getScaleDivElement(Axis.AxisId.xTop),
        ScaleDraw.Alignment.TopScale
      );
      d_axisData[Axis.AxisId.xBottom].scaleWidget = new ScaleWidget(
        self,
        layout.getScaleDivElement(Axis.AxisId.xBottom),
        ScaleDraw.Alignment.BottomScale
      );

      //#if 1
      // better find the font sizes from the application font
      //QFont fscl( fontInfo().family(), 10 );
      //QFont fttl( fontInfo().family(), 12, QFont::Bold );
      //#endif

      for (axisId = 0; axisId < Axis.AxisId.axisCnt; axisId++) {
        var d = d_axisData[axisId];

        d.scaleEngine = new LinearScaleEngine();
        d.scaleWidget.setTransformation(d.scaleEngine.transformation());

        //d.scaleWidget->setFont( fscl );
        //d.scaleWidget->setMargin( 2 );

        //QwtText text = d.scaleWidget->title();
        //text.setFont( fttl );
        //d.scaleWidget->setTitle( text );

        d.doAutoScale = true;
        d.minValue = 0.0;
        d.maxValue = 1000.0;
        d.stepSize = 0.0;
        d.maxMinor = 5;
        d.maxMajor = 8;
        d.isValid = false;
      }
      d_axisData[Axis.AxisId.yLeft].isEnabled = true;
      d_axisData[Axis.AxisId.yRight].isEnabled = true;
      d_axisData[Axis.AxisId.xBottom].isEnabled = true;
      d_axisData[Axis.AxisId.xTop].isEnabled = true;
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {Number} The maximum number of minor ticks for a specified axis
     */
    this.axisMaxMinor = function (axisId) {
      if (this.axisValid(axisId)) return d_axisData[axisId].maxMinor;
      return 0;
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {Number} The maximum number of major ticks for a specified axis
     */
    this.axisMaxMajor = function (axisId) {
      if (this.axisValid(axisId)) return d_axisData[axisId].maxMajor;
      return 0;
    };

    /**
     * Sets the maximum number of minor scale intervals for a specified axis
     * @param {Axis.AxisId} axisId Axis index
     * @param {Number} maxMinor Maximum number of minor steps
     * @see {@link Plot#axisMaxMinor axisMaxMinor()}
     */
    this.setAxisMaxMinor = function (axisId, maxMinor) {
      if (this.axisValid(axisId)) {
        var maxMinor = Utility.qBound(0, maxMinor, 100);

        var d = d_axisData[axisId];
        if (maxMinor != d.maxMinor) {
          d.maxMinor = maxMinor;
          d.isValid = false;
          this.autoRefresh();
        }
      }
    };

    /**
     * Sets the maximum number of major scale intervals for a specified axis
     * @param {Axis.AxisId} axisId Axis index
     * @param {Number} maxMajor Maximum number of minor steps
     * @see {@link Plot#axisMaxMajor axisMaxMajor()}
     */
    this.setAxisMaxMajor = function (axisId, maxMajor) {
      if (this.axisValid(axisId)) {
        var maxMajor = Utility.qBound(1, maxMajor, 10000);

        var d = d_axisData[axisId];
        if (maxMajor != d.maxMajor) {
          d.maxMajor = maxMajor;
          d.isValid = false;
          this.autoRefresh();
        }
      }
    };

    /**
     *
     * @param {Axis.AxisId} axisId axis index
     * @returns {Boolean} true if the specified axis exists, otherwise false
     */
    this.axisValid = function (axisId) {
      return axisId >= Axis.AxisId.yLeft && axisId < Axis.AxisId.axisCnt;
    };

    /**
     * Change the scale engine for an axis
     * @param {Axis.AxisId} axisId Axis index
     * @param {scaleEngine} engine Scale engine
     * @see {@link Plot#axisScaleEngine axisScaleEngine()}
     */
    this.setAxisScaleEngine = function (axisId, engine) {
      if (this.axisValid(axisId) && engine !== null) {
        var d = d_axisData[axisId];
        //alert(d.scaleEngine)

        d.scaleEngine = engine;
        //alert(d.scaleEngine)

        d_axisData[axisId].scaleWidget.setTransformation(
          engine.transformation()
        );
        //alert(d_axisData[axisId].scaleWidget.scaleDraw().scaleMap().transformation())

        d.isValid = false;

        this.autoRefresh();
      }
    };

    /**
     *
     * @returns {Legend} the plot's legend
     * @see {@link Plot#insertLegend insertLegend()}
     */
    this.legend = function () {
      return m_legend;
    };

    /**
     * Insert a legend.
     *
     * The legend is organized in one column from top to down on the right of the plot.
     * insertLegend() sets the plot widget as parent for the legend. The legend is deleted when the plot is destroyed or when another
     * legend is inserted.
     * insertLegend() triggers the "legendInserted" event.
     * @param {Legend} legend Legend
     * @see {@link Plot#legend legend()}
     */
    this.insertLegend = function (legend) {
      m_legend = legend;
      m_legend.setLegendDiv(layout.getLegendDiv());
      m_legend.setPlot(this);
      //We add any items attached to the plot before insertLegend was called.
      for (var i = 0; i < m_plotItemStore.length; ++i) {
        insertLegendItem(m_plotItemStore[i]);
      }
      Static.trigger("legendInserted", m_legend);
    };

    /*if the legend is not enabled, it is enabled when an item is added.*/
    const insertLegendItem = function (plotItem, rowNumber) {
      if (m_legend === null || plotItem == null) return;
      if (plotItem.testItemAttribute(PlotItem.ItemAttribute.Legend)) {
        m_legend.addItem(plotItem, rowNumber);
      }
      if (!m_legend.isEmpty()) {
        //legendEnable = true;
        if (legendEnable) {
          m_legend.legendDiv().show();
        }
      }
      //this.enableLegend(true);
    };

    /*if the legend is enabled, it is disabled when the last item is removed.*/
    const removeLegendItem = function (plotItem) {
      if (m_legend === null) return;
      //var row = m_legend.rowNumberFromName(plotItem.title());
      //if(row >=0){
      var rowNumber = m_legend.removeItem(plotItem);
      if (m_legend.isEmpty()) {
        //legendEnable = false;
        m_legend.legendDiv().hide();
      }
      //this.enableLegend(legendEnable);
      // }
      return rowNumber;
    };

    /**
     * Keep the legend item in sync with the plotitem it represents
     * @param {PlotItem} plotItem Plot item
     * @see {@link PlotItem#legendData legendData()}
     */
    this.updateLegend = function (plotItem) {
      if (plotItem == null) return;

      if (plotItem.testItemAttribute(PlotItem.ItemAttribute.Legend)) {
        //reinsert legend item so that legend data changes are accounted for.
        //Alternatively, we could have tried to rehabilitate the legend item in place!!
        var rowNumber = removeLegendItem(plotItem);
        insertLegendItem(plotItem, rowNumber);

        Static.trigger("legendUpdated", plotItem);
      }
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {ScaleEngine} Scale engine for a specific axis
     */
    this.axisScaleEngine = function (axisId) {
      if (this.axisValid(axisId)) return d_axisData[axisId].scaleEngine;
      else return null;
    };

    /**
     * Enable autoscaling for a specified axis
     *
     * This member function is used to switch back to autoscaling mode after a fixed scale has been set.
     * Autoscaling is enabled by default.
     * @param {Axis.AxisId} axisId Axis index
     * @param {Boolean} on On/Off
     * @see {@link Plot#setAxisScale setAxisScale()}
     * @see {@link Plot#setAxisScaleDiv setAxisScaleDiv()}
     * @see {@link Plot#updateAxes updateAxes()}
     */
    this.setAxisAutoScale = function (axisId, on) {
      if (this.axisValid(axisId) && d_axisData[axisId].doAutoScale !== on) {
        d_axisData[axisId].doAutoScale = on;
        Static.trigger("autoScaleChanged", on);
        this.autoRefresh();
      }
    };

    /**
     * Enable autoscaling for a specified axis
     *
     * This member function is used to switch back to autoscaling mode after a fixed scale has been set.
     * Autoscaling is enabled by default.
     * @param {Axis.AxisId} axisId Axis index
     * @param {Boolean} on On/Off
     * @see {@link Plot#setAxisScale setAxisScale()}
     * @see {@link Plot#setAxisScaleDiv setAxisScaleDiv()}
     * @see {@link Plot#updateAxes updateAxes()}
     */
    this.setAxesAutoScale = function (on) {
      let changed = false;
      for (let i = 0; i < 4; i++) {
        if (d_axisData[i].doAutoScale !== on) {
          d_axisData[i].doAutoScale = on;
          changed = true;
        }
      }
      if (!changed) return;
      Static.trigger("autoScaleChanged", on);
      this.autoRefresh();
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {Boolean} true, if autoscaling is enabled
     */
    this.axisAutoScale = function (axisId) {
      if (this.axisValid(axisId)) return d_axisData[axisId].doAutoScale;
      else return false;
    };

    /**
     * Disable autoscaling and specify a fixed scale for a selected axis.
     *
     * In updateAxes() the scale engine calculates a scale division from the specified parameters, that will be
     * assigned to the scale widget. So updates of the scale widget usually happen delayed with the next replot.
     * @param {Axis.AxisId} axisId Axis index
     * @param {Number} min Minimum of the scale
     * @param {Number} max Maximum of the scale
     * @param {Number} stepSize Major step size. If <code>step == 0</code>, the step size is
     * calculated automatically using the maxMajor setting.
     * @see {@link Plot#setAxisMaxMajor setAxisMaxMajor()}
     * @see {@link Plot#setAxisAutoScale setAxisAutoScale()}
     * @see {@link ScaleEngine#divideScale divideScale()}
     */
    this.setAxisScale = function (axisId, min, max, stepSize) {
      const autoReplot = self.autoReplot();
      self.setAutoReplot(false);
      var step = 0;
      if (typeof stepSize !== "undefined") step = stepSize;
      if (this.axisValid(axisId)) {
        var d = d_axisData[axisId];
        d.doAutoScale = false;
        d.isValid = false;
        d.minValue = min;
        d.maxValue = max;
        d.stepSize = step;

        Static.trigger("rescaled", [axisId, min, max]);
        self.setAutoReplot(autoReplot);
        this.autoRefresh();
      }
    };

    /**
     * Enable or disable a specified axis
     *
     * When an axis is disabled, this only means that it is not visible on the screen. Curves and markers
     * can be attached to disabled axes and transformation of screen coordinates
     * into values works as normal.
     * @param {Axis.setAxisScaleDiv} axisId Axis index
     * @param {Boolean} tf true (enabled) or false (disabled)
     */
    this.enableAxis = function (axisId, tf) {
      if (this.axisValid(axisId) && tf !== d_axisData[axisId].isEnabled) {
        d_axisData[axisId].isEnabled = tf;
        if (tf) d_axisData[axisId].scaleWidget.show();
        else d_axisData[axisId].scaleWidget.hide();
        this.autoRefresh();
      }
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {Boolean} true, if a specified axis is enabled
     */
    this.axisEnabled = function (axisId) {
      if (this.axisValid(axisId)) return d_axisData[axisId].isEnabled;
      else return false;
    };

    /**
     * Change the title of a specified axis
     * @param {Axis.AxisId} axisId Axis index
     * @param {String} title Axis title
     */
    this.setAxisTitle = function (axisId, title) {
      if (this.axisValid(axisId)) {
        d_axisData[axisId].scaleWidget.setTitle(title);
        this.autoRefresh();
      }
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {String} Title of a specified axis
     */
    this.axisTitle = function (axisId) {
      if (this.axisValid(axisId)) return d_axisData[axisId].scaleWidget.title();
      else return "";
    };

    /**
     * Return the scale division of a specified axis
     *
     * axisScaleDiv(axisId).lowerBound(), axisScaleDiv(axisId).upperBound() are the current limits of the axis scale.
     * @param {Axis.AxisId} axisId Axis index
     * @returns {ScaleDiv} The scale division of a specified axis
     * @see {@link ScaleDiv}
     * @see {@link Plot#setAxisScaleDiv setAxisScaleDiv()}
     * @see {@link ScaleEngine#divideScale divideScale()}
     */
    this.axisScaleDiv = function (axisId) {
      return d_axisData[axisId].scaleDiv;
    };

    /**
     * Disable autoscaling and specify a fixed scale for a selected axis.
     *
     * The scale division will be stored locally only until the next call of updateAxes(). So updates of the
     * scale widget usually happen delayed with the next replot.
     * @param {Axis.AxisId} axisId Axis index
     * @param {ScaleDiv} scaleDiv Scale division
     * @see {@link Plot#setAxisScale setAxisScale()}
     * @see {@link Plot#setAxisAutoScale setAxisAutoScale()}
     */
    this.setAxisScaleDiv = function (axisId, scaleDiv) {
      if (this.axisValid(axisId)) {
        var d = d_axisData[axisId];
        d.doAutoScale = false;
        d.scaleDiv = scaleDiv;
        d.isValid = true;
        this.autoRefresh();
      }
    };

    /**
     * Return the scale draw of a specified axis
     * @param {Axis.AxisId} axisId Axis index
     * @returns {ScaleDraw} Specified scaleDraw for axis, or null if axis is invalid.
     */
    this.axisScaleDraw = function (axisId) {
      if (!this.axisValid(axisId)) return null;
      return this.axisWidget(axisId).scaleDraw();
    };

    /**
     * Change the font of an axis
     *
     * This function changes the font of the tick labels, not of the axis title.
     * @param {Axis.AxisId} axisId Axis index
     * @param {Misc.Font} fontObj Font
     */
    this.setAxisLabelFont = function (axisId, fontObj) {
      if (this.axisValid(axisId)) {
        this.axisWidget(axisId).setLabelFont(fontObj);
        this.autoRefresh();
      }
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {Misc.Font} The font of the scale labels for a specified axis
     */
    this.axisLabelFont = function (axisId) {
      if (this.axisValid(axisId)) return this.axisWidget(axisId).labelFont();
      return null;
    };

    /**
     * Change the font of an axis title
     *
     * @param {Axis.AxisId} axisId Axis index
     * @param {Misc.Font} fontObj Font
     */
    this.setAxisTitleFont = function (axisId, fontObj) {
      if (this.axisValid(axisId)) {
        this.axisWidget(axisId).setTitleFont(fontObj);
        this.autoRefresh();
      }
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {Misc.Font} The font of the title for a specified axis
     */
    this.axisTitleFont = function (axisId) {
      if (this.axisValid(axisId)) return this.axisWidget(axisId).titleFont();
      return null;
    };

    initAxesData();

    /**
     *
     * @returns {Boolean} true, if a cursor is set
     */
    this.isCursorSet = function () {
      return m_cursor !== "";
    };

    /**
     *
     *
     * @returns {String} The current cursor
     */
    this.cursor = function () {
      return m_cursor;
    };

    /**
     * Sets the mouse cursor to be displayed when pointing over the central widget. (The central widget is where plotitems are drawn)
     *
     * Calling unsetCursor() restores the default cursor.
     * @param {String} cursor A string representing a valid HTML cursor. The default is "crosshair".
     * @see {@link Plot#unsetCursor unsetCursor()}
     * @see {@link Plot#setDefaultCursor setDefaultCursor()}
     */
    this.setCursor = function (cursor) {
      if (cursor == m_cursor) return;
      var previousCursor = m_cursor;
      m_cursor = cursor;
      layout.getCentralDiv().css("cursor", m_cursor);
      return previousCursor;
    };

    /**
     * Sets the default mouse cursor to be displayed when pointing over the central widget. (The central widget is where plotitems are drawn)
     *
     * Calling unsetCursor() restores the default cursor.
     * @param {String} cursor A string representing a valid HTML cursor. The default is "crosshair".
     * @see {@link Plot#unsetCursor unsetCursor()}
     * @see {@link Plot#setCursor setCursor()}
     */
    this.setDefaultCursor = function (cursor) {
      if (m_defaultCursor == cursor) return;
      m_defaultCursor = cursor;
    };

    /**
     * Restores the default mouse cursor to be displayed when pointing over the central widget. (The central widget is where plotitems are drawn)
     *
     * @param {String} cursor A string representing a valid HTML cursor. The default is "crosshair".
     * @see {@link Plot#setDefaultCursor setDefaultCursor()}
     * @see {@link Plot#setCursor setCursor()}
     */
    this.unsetCursor = function () {
      if (m_defaultCursor == m_cursor) return;
      m_cursor = m_defaultCursor;
      layout.getCentralDiv()[0].style.cursor = m_cursor;
    };

    /**
     * @returns {string} Title of the plot.
     */
    this.title = function () {
      return _title;
    };

    /**
     * Hides the widget that displays the title
     * @see {@link Plot#showTitle showTitle()}
     */
    this.hideTitle = function () {
      if (_title == "") return;
      layout.getTitleDiv().hide();
      layout.updateLayout();
      this.autoRefresh();
    };

    /**
     * Shows the widget that displays the title
     * @see {@link Plot#hideTitle hideTitle()}
     */
    this.showTitle = function () {
      if (_title == "") return;
      layout.getTitleDiv().show();
      layout.updateLayout();
      this.autoRefresh();
    };

    /**
     * Change the plot's title.
     * @param {string} ttl New title.
     */
    this.setTitle = function (ttl) {
      if (_title !== ttl) {
        _title = ttl;

        if (ttl.trim(" ").length == 0) _title = "";

        if (_title !== "") {
          layout.getTitleDiv().show(); //ensure the div is visible
          Static.trigger("titleAdded", true);
        } else {
          layout.getTitleDiv().hide();
          Static.trigger("titleAdded", false);
        }
        layout.updateLayout();
        this.autoRefresh();
        //console.log("setTitle called")
      }
    };

    /**
     * Change the font of the title
     *
     * @param {Misc.Font} fontObj Font
     */
    this.setTitleFont = function (fontObj) {
      if (fontObj.th < 0 || fontObj.name === "" || fontObj.style === "") return;
      m_titleFont = fontObj;
      layout.adjustLayout(layout.getTitleDiv(), fontObj.th * 2);
      this.autoRefresh();
    };
    this.setTitleFont(new Misc.Font(20, "Arial", "normal", "bold"));

    /**
     *
     * @returns {Misc.Font} The title font
     */
    this.titleFont = function () {
      return m_titleFont;
    };

    /**
     *
     * @returns {String} The footer
     */
    this.footer = function () {
      return m_footer;
    };

    /**
     * Hides the widget that displays the footer
     * @see {@link Plot#showFooter showFooter()}
     */
    this.hideFooter = function () {
      if (m_footer == "") return;
      layout.getFooterDiv().hide();
      layout.updateLayout();
      this.autoRefresh();
    };

    /**
     * Shows the widget that displays the footer
     * @see {@link Plot#hideFooter hideFooter()}
     */
    this.showFooter = function () {
      if (m_footer == "") return;
      layout.getFooterDiv().show();
      layout.updateLayout();
      this.autoRefresh();
    };

    /**
     * Change the plot's footer.
     * @param {string} ttl New footer.
     */
    this.setFooter = function (ftr) {
      if (m_footer !== ftr) {
        m_footer = ftr;
        if (ftr.trim(" ").length == 0) m_footer = "";
        if (m_footer !== "") {
          layout.getFooterDiv().show(); //ensure the div is visible
          Static.trigger("footerAdded", true);
        } else {
          layout.getFooterDiv().hide();
          Static.trigger("footerAdded", false);
        }
        layout.updateLayout();
        this.autoRefresh();
      }
    };
    layout.getFooterDiv().hide();

    /**
     * Change the font of the footer
     *
     * @param {Misc.Font} fontObj Font
     */
    this.setFooterFont = function (fontObj) {
      if (fontObj.th < 0 || fontObj.name === "" || fontObj.style === "") return;
      m_footerFont = fontObj;
      layout.adjustLayout(layout.getFooterDiv(), fontObj.th * 2);
      this.autoRefresh();
    };
    this.setFooterFont(new Misc.Font(15, "Arial", "normal", "bold"));

    /**
     *
     * @returns {Misc.Font} The footer font
     */
    this.footerFont = function () {
      return m_footerFont;
    };

    /**
     * Toggle the legend visibility.
     *
     * An empty legend, though enabled, is not visible.
     * @param {Boolean} on If true, the legend is enabled.
     *
     */
    this.enableLegend = function (on) {
      //if (on == legendEnable)
      //return;
      legendEnable = on;
      if (!m_legend || m_legend.isEmpty()) return;
      //legendEnable = on;
      if (on) {
        //layout.getLegendDiv().show();
        m_legend.legendDiv().show();
      } else {
        //layout.getLegendDiv().hide();
        m_legend.legendDiv().hide();
      }
      this.autoRefresh();
    };

    /**
     *
     * @returns {Boolean} true, if the legend is enabled
     */
    this.isLegendEnabled = function () {
      //console.log(layout.getLegendDiv()[0].style.display)
      if (!m_legend) {
        return false;
      }
      return !(m_legend.legendDiv()[0].style.display == "none"); //legendEnable;
    };

    /**
     * Transform the x or y coordinate of a position in the drawing region into a value.
     * @param {Axis.AxisId} axisId Axis index
     * @param {Number} pos position
     * @returns {Number} Position as axis coordinate
     * The position can be an x or a y coordinate, depending on the specified axis.
     */
    this.invTransform = function (axisId, pos) {
      if (this.axisValid(axisId))
        return this.canvasMap(axisId).invTransform(pos);
      else return 0.0;
    };

    /**
     * Transform a value into a coordinate in the plotting region
     * @param {Axis.AxisId} axisId Axis index
     * @param {Number} value value
     * @returns {Number} X or Y coordinate in the plotting region corresponding to the value.
     */
    this.transform = function (axisId, value) {
      if (this.axisValid(axisId))
        return this.canvasMap(axisId).transform(value);
      else return 0.0;
    };

    var _plotBackGround = "";

    /**
     * Sets the background color of the central widget. (The central widget is where plotitems are drawn)
     * @param {String} color A valid HTML color
     * @see {@link Plot#plotBackground plotBackground()}
     */
    this.setPlotBackground = function (color) {
      this.getCentralWidget().getElement().css("background-color", color);
    };
    this.setPlotBackground("rgb(255, 255, 200)");

    /**
     * Gets the background color of the central widget. (The central widget is where plotitems are drawn)
     * @returns {String} color
     * @see {@link Plot#setPlotBackground setPlotBackground()}
     */
    this.plotBackground = function () {
      return this.getCentralWidget().getElement().css("background-color");
    };

    /**
     * Sets the border radius of the central widget. (The central widget is where plotitems are drawn)
     * @param {Number} radius The radius
     * @see {@link Plot#borderRadius borderRadius()}
     */
    this.setBorderRadius = function (radius) {
      var cw = this.getCentralWidget();
      //cw.getElement().css("border-radius", radius)
      cw.getCanvas().css("border-radius", radius);
    };

    /**
     *
     * @returns {Number} The border radius
     */
    this.borderRadius = function () {
      return m_borderRadius;
    };

    /**
     * Gets the first plot item with the title. This method is useful if plot items have a unique title.
     * @param {String} title Plot item title
     * @returns {Curve} The the first plot item with the title or null
     */
    this.findPlotCurve = function (title) {
      var list = this.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].title() === title) return list[i];
      }
      list = this.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].title() === title) return list[i];
      }
      list = this.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].title() === title) return list[i];
      }
      list = this.itemList(PlotItem.RttiValues.Rtti_PlotZone);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].title() === title) return list[i];
      }
      list = this.itemList(PlotItem.RttiValues.Rtti_PlotMarker);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].title() === title) return list[i];
      }
      return null;
    };

    /**
     *
     * @param {String} title PlotMarker title
     * @returns {PlotMarker} The PlotMarker with the title or null
     */
    this.findPlotMarker = function (title) {
      var list = this.itemList(PlotItem.RttiValues.Rtti_PlotMarker);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].title() === title) return list[i];
      }
      return null;
    };

    /**
     *
     * @param {String} title PlotItem title
     * @returns {PlotMarker} The PlotItem with the title or null
     */
    this.findPlotItem = function (title) {
      var list = this.itemList();
      for (var i = 0; i < list.length; ++i) {
        if (list[i].title() === title) return list[i];
      }
      return null;
    };

    /**
     *
     * @returns {Boolean} true, if the plot has at least one visible Curve
     */
    this.hasVisiblePlotCurve = function () {
      var list = this.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].isVisible()) return true;
      }
      return false;
    };

    /**
     *
     * @returns {Boolean} true, if the plot has at least one visible PlotCurve or PlotSpectroCurve or PlotSpectrogram
     */
    this.hasVisibleCurveSpectrocurveOrSpectrogram = function () {
      var list = this.itemList(PlotItem.RttiValues.Rtti_PlotCurve)
        .concat(this.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
        .concat(this.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
        .concat(this.itemList(PlotItem.RttiValues.Rtti_PlotZone));
      for (var i = 0; i < list.length; ++i) {
        if (list[i].isVisible()) return true;
      }
      return false;
    };

    /**
     *
     * @returns {Boolean} true, if the plot has at least one visible SpectroCurve
     */
    this.hasVisiblePlotSpectroCurve = function () {
      var list = this.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].isVisible()) return true;
      }
      return false;
    };

    /**
     *
     * @returns {Boolean} true, if the plot has at least one visible PlotSpectrogram
     */
    this.hasVisiblePlotSpectrogram = function () {
      var list = this.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram);
      for (var i = 0; i < list.length; ++i) {
        if (list[i].isVisible()) return true;
      }
      return false;
    };

    /**
     *
     * @returns {Boolean} true, if the plot has at least one Curve
     */
    this.hasPlotCurve = function () {
      return this.itemList(PlotItem.RttiValues.Rtti_PlotCurve).length > 0;
    };

    /**
     *
     * @returns {Boolean} true, if the plot has at least one SpectroCurve
     */
    this.hasPlotSpectroCurve = function () {
      return (
        this.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve).length > 0
      );
    };

    /**
     *
     * @returns {Boolean} true, if the plot has at least one PlotSpectrogram
     */
    this.hasPlotSpectrogram = function () {
      return this.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram).length > 0;
    };

    /**
     * Draws the background
     */
    this.drawBackGround = function () {
      var painter = new PaintUtil.Painter(centralWidget);
      painter.fillRect(
        new Misc.Rect(0, 0, centralWidget.width(), centralWidget.height()),
        _plotBackGround
      );
      painter = null;
    };

    /**
     * Draws the title
     */
    this.drawTitle = function () {
      if (_title === "") return;
      var painter = new PaintUtil.Painter(titleWidget);
      painter.setFont(m_titleFont);
      painter.drawText(
        _title,
        titleWidget.width() / 2,
        (2.6 * m_titleFont.th) / 2,
        "center"
      );
      painter = null;
    };

    /**
     * Draws the footer
     */
    this.drawFooter = function () {
      if (m_footer === "") return;
      var painter = new PaintUtil.Painter(footerWidget);
      painter.setFont(m_footerFont);
      painter.drawText(
        m_footer,
        footerWidget.width() / 2,
        (2.6 * m_footerFont.th) / 2,
        "center"
      );
      painter = null;
    };

    /**
     *
     * @param {PlotItem.RttiValues} [type] Rtti value of the plotItem. If this argument is not provided, all attached plotItems are returned.
     * @returns {Array<PlotItem>} List of plotitems with PlotItem.RttiValues == type or a list of all attached plotItems.
     */
    this.itemList = function (type) {
      if (typeof type === "undefined") return m_plotItemStore;
      return _.filter(m_plotItemStore, function (item) {
        return item.rtti === type;
      });
    };

    const insertItem = function (item) {
      m_plotItemStore.push(item);
    };

    const removeItem = function (item) {
      var index = m_plotItemStore.indexOf(item);
      if (index > -1) {
        m_plotItemStore.splice(index, 1);
      }
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis
     * @returns {ScaleMap} Map for the axis on the canvas. With this map pixel coordinates can translated to plot coordinates and vice versa.
     * @see {@link ScaleMap}
     * @see {@link Plot#transform transform()}
     * @see {@link Plot#invTransform invTransform()}
     */
    this.canvasMap = function (axisId) {
      var map = new ScaleMap();
      //        if ( !d_data->canvas )
      //            return map;

      map.setTransformation(this.axisScaleEngine(axisId).transformation());

      var sd = this.axisScaleDiv(axisId);
      map.setScaleInterval(sd.lowerBound(), sd.upperBound());

      if (1) {
        //this.axisEnabled(axisId)) {
        var s = this.axisWidget(axisId);
        if (axisId == Axis.AxisId.yLeft || axisId == Axis.AxisId.yRight) {
          //var y = s->y() + s->startBorderDist() - d_data->canvas->y();
          var h = s.height();
          map.setPaintInterval(h, 0);
        } else {
          //double x = s->x() + s->startBorderDist() - d_data->canvas->x();
          var w = s.width();
          map.setPaintInterval(0, w);
        }
      }
      /*else {

            // int margin = 0;
            //if ( !plotLayout()->alignCanvasToScale( axisId ) )
            // margin = plotLayout()->canvasMargin( axisId );

            //const QRect &canvasRect = d_data->canvas->contentsRect();
            if (axisId == Axis.AxisId.yLeft || axisId == Axis.AxisId.yRight) {
            map.setPaintInterval(centralWidget.height(), 0);
            } else {
            map.setPaintInterval(0, centralWidget.width());
            }
            }*/
      return map;
    };

    /**
     *
     * @param {Axis.AxisId} axisId Axis index
     * @returns {ScaleWidget} Scale widget of the specified axis, or null if axisId is invalid.
     */
    this.axisWidget = function (axisId) {
      if (this.axisValid(axisId)) return d_axisData[axisId].scaleWidget;

      return null;
    };

    /**
     * Rebuild the axes scales
     *
     * In case of autoscaling the boundaries of a scale are calculated from the bounding rectangles
     * of all plot items, having the PlotItem.ItemAttribute.AutoScale flag enabled ( ScaleEngine.autoScale() ).
     * Then a scale division is calculated ( ScaleEngine.didvideScale() ) and assigned to scale widget.
     * When the scale boundaries have been assigned with setAxisScale() a scale division is
     * calculated ( QwtScaleEngine::didvideScale() ) for this interval and assigned to the scale widget.
     * When the scale has been set explicitly by setAxisScaleDiv() the locally stored scale division gets
     * assigned to the scale widget. The scale widget indicates modifications by triggering the scaleDivChanged event.
     * updateAxes() is usually called by replot().
     * @see {@link Plot#setAxisAutoScale setAxisAutoScale()}
     * @see {@link Plot#setAxisScale setAxisScale()}
     * @see {@link Plot#setAxisScaleDiv setAxisScaleDiv()}
     * @see {@link Plot#replot replot()}
     * @see {@link PlotItem#boundingRect boundingRect()}
     */
    this.updateAxes = function () {
      // Find bounding interval of the item data
      // for all axes, where autoscaling is enabled

      var intv = [
        new Interval(Number.MAX_VALUE, -Number.MAX_VALUE),
        new Interval(Number.MAX_VALUE, -Number.MAX_VALUE),
        new Interval(Number.MAX_VALUE, -Number.MAX_VALUE),
        new Interval(Number.MAX_VALUE, -Number.MAX_VALUE),
      ];

      let prevRect = new Misc.Rect();

      for (var i = 0; i < m_plotItemStore.length; ++i) {
        var item = m_plotItemStore[i];
        if (!item.testItemAttribute(PlotItem.ItemAttribute.AutoScale)) continue;

        if (!item.isVisible()) continue;

        if (
          this.axisAutoScale(item.xAxis()) ||
          this.axisAutoScale(item.yAxis())
        ) {
          //alert(item)
          var rect = item.boundingRect();
          //if (!rect.isValid()) continue;

          if (rect.isEqual(prevRect)) continue;
          prevRect = rect;

          //console.log(rect.toString());

          if (rect.width() >= 0.0) {
            //intv[item.xAxis()] |= new Interval( rect.left(), rect.right());
            if (rect.left() < intv[item.xAxis()].minValue())
              intv[item.xAxis()].setMinValue(rect.left());
            if (rect.right() > intv[item.xAxis()].maxValue())
              intv[item.xAxis()].setMaxValue(rect.right());
            //intv[item.xAxis()].setInterval(rect.left(), rect.right())
          }

          if (rect.height() >= 0.0) {
            //intv[item.yAxis()] |= new Interval( rect.top(), rect.bottom );
            if (rect.top() < intv[item.yAxis()].minValue())
              intv[item.yAxis()].setMinValue(rect.top());
            if (rect.bottom() > intv[item.yAxis()].maxValue())
              intv[item.yAxis()].setMaxValue(rect.bottom());
          }

          if (item.rtti == PlotItem.RttiValues.Rtti_PlotMarker) {
            if (item.xValue() < intv[item.xAxis()].minValue())
              intv[item.xAxis()].setMinValue(item.xValue());
            if (item.xValue() > intv[item.xAxis()].maxValue())
              intv[item.xAxis()].setMaxValue(item.xValue());

            if (item.yValue() < intv[item.yAxis()].minValue())
              intv[item.yAxis()].setMinValue(item.yValue());
            if (item.yValue() > intv[item.yAxis()].maxValue())
              intv[item.yAxis()].setMaxValue(item.yValue());
          }
        }
      }

      // Adjust scales

      for (var axisId = 0; axisId < Axis.AxisId.axisCnt; axisId++) {
        var d = d_axisData[axisId];
        var minValue = d.minValue;
        var maxValue = d.maxValue;
        var stepSize = d.stepSize;
        //alert(d.doAutoScale)

        if (d.doAutoScale && intv[axisId].isValid()) {
          //console.log(this);
          //alert("here")
          d.isValid = false;

          minValue = intv[axisId].minValue();
          maxValue = intv[axisId].maxValue();

          if (Utility.mFuzzyCompare(maxValue, minValue)) {
            //minValue = minValue - 1.0e-6;
            minValue = minValue - Static._eps;
          }

          var xValues = {
            x1: minValue,
            x2: maxValue,
          };
          d.scaleEngine.autoScale(d.maxMajor, xValues, stepSize);
          minValue = xValues["x1"];
          maxValue = xValues["x2"];
        }
        if (!d.isValid) {
          //alert("or here")
          d.scaleDiv = d.scaleEngine.divideScale(
            minValue,
            maxValue,
            d.maxMajor,
            d.maxMinor,
            stepSize
          );
          d.isValid = true;
          //alert(d.scaleDiv.ticks(2))
        }
        var scaleWidget = this.axisWidget(axisId);
        scaleWidget.setScaleDiv(d.scaleDiv);

        //var startDist, endDist;
        var startAndEndObj = {
          start: undefined,
          end: undefined,
        };
        scaleWidget.getBorderDistHint(startAndEndObj);
        scaleWidget.setBorderDist(startAndEndObj.start, startAndEndObj.end);
      }

      m_plotItemStore.forEach(function (item) {
        if (item.testItemInterest(PlotItem.ItemInterest.ScaleInterest)) {
          item.updateScaleDiv(
            self.axisScaleDiv(item.xAxis()),
            self.axisScaleDiv(item.yAxis())
          );
        }
      });
    };

    /**
     * Attach/Detach a plot item
     * @param {PlotItem} plotItem Plot item
     * @param {Boolean} on When true attach the item, otherwise detach it
     */
    this.attachItem = function (plotItem, on) {
      if (on) {
        if (!plotItem.getCanvas()) {
          return plotItem.attach(this);
        }
        insertItem(plotItem);
        if (plotItem.testItemAttribute(PlotItem.ItemAttribute.Legend)) {
          insertLegendItem(plotItem);
        }
      } else {
        plotItem.getCanvas().remove();
        if (plotItem.testItemAttribute(PlotItem.ItemAttribute.Legend)) {
          removeLegendItem(plotItem);
        }
        removeItem(plotItem);
      }
      Static.trigger("itemAttached", [plotItem, on]);
      //if (!on) plotItem = null;
      this.autoRefresh();
    };

    /**
     * Redraw the plot.
     *
     * If the autoReplot option is not set (which is the default) or if any curves are
     * attached to raw data, the plot has to be refreshed explicitly in order to make changes visible.
     * @see {@link Plot#updateAxes updateAxes()}
     * @see {@link Plot#setAutoReplot setAutoReplot()}
     */
    this.replot = function () {
      if (parseInt(this.getLayout().getCentralDiv().css("width")) < 60) return;

      var doAutoReplot = this.autoReplot();
      this.setAutoReplot(false);
      this.updateAxes();

      //Without a border of width 1px gridlines will not align with scale ticks.
      //var centralDiv = this.getLayout().getCentralDiv()
      //if(centralDiv.css("border-style") =="none")
      //centralDiv.css("border-style", "solid")
      //if(centralDiv.css("border-width") !=="1px")
      //centralDiv.css("border-width", 1)

      /*m_scaleDraw.data.plotCanvasBorderWidth =
            parseFloat(m_plot.getLayout().getCentralDiv().
            css("border-width"))*/

      for (var axisId = 0; axisId < Axis.AxisId.axisCnt; axisId++) {
        var axisWidget = d_axisData[axisId].scaleWidget;
        axisWidget.scaleDraw().data.plotBorderWidth = parseFloat(
          this.getLayout().getCentralDiv().css("border-width")
        );
        axisWidget.draw();
      }

      this.drawTitle();
      this.drawFooter();

      //var i = 0;
      for (var i = 0; i < m_plotItemStore.length; ++i) {
        if (!m_plotItemStore[i].isVisible()) continue;
        m_plotItemStore[i].draw(
          this.axisScaleDraw(m_plotItemStore[i].xAxis()).scaleMap(),
          this.axisScaleDraw(m_plotItemStore[i].yAxis()).scaleMap()
        );
      }
      Static.trigger("replot");
      this.setAutoReplot(doAutoReplot);
    };

    this.setAutoReplot(true);

    layout.getTitleDiv().hide();
    if (typeof pTitle !== "undefined") {
      this.setTitle(pTitle);
    }

    m_defaultCursor = layout.getCentralDiv().css("cursor");
    this.setCursor("crosshair");

    this.enableAxis(Axis.AxisId.yRight, false);
    this.enableAxis(Axis.AxisId.xTop, false);
    layout.getFooterDiv().hide(); //initially hidden
    if (m_legend) m_legend.legendDiv().hide();
    //initially hidden
    else layout.getLegendDiv().hide(); //initially hidden

    this.setAutoReplot(false);

    this.toString = function () {
      return '[Plot "' + _title + '"]';
    };

    this.print = function () {
      window.print();
    };

    this.registerPrintCb = function (type, cb) {
      if (type == "beforePrint") beforePrintCb = cb;
      if (type == "afterPrint") afterPrintCb = cb;
    };

    Static.bind("plotDivResized", function () {
      var pH = parseFloat(self.plotDiv.parent().css("height"));
      var h = parseFloat(self.plotDiv.css("height"));
      plotDivHeightAsPercentOfPlotDivParent = (h / pH) * 100;
    });

    window.matchMedia("print").addListener(function (mql) {
      if (mql.matches) {
        if (beforePrintCb) {
          beforePrintCb();
          return;
        }
        self.autoRefresh(); //ensure the plot is up-to-date
      } else {
        if (afterPrintCb) {
          afterPrintCb();
          //return;
        }
        self.plotDiv.css("height", plotDivHeightAsPercentOfPlotDivParent + "%");
      }
    });

    Static.bind("resize", function () {
      plotDivContainerWidth = parseFloat(plotDivContainer.css("width"));
      plotDivContainerHeight = parseFloat(plotDivContainer.css("height"));
      self.autoRefresh();
    });

    this.plotDivContainerSize = function () {
      return new Misc.Size(plotDivContainerWidth, plotDivContainerHeight);
    };

    var _prevH = parseFloat(plotDivContainer.css("height"));
    var _prevH2 = parseFloat(self.plotDiv.css("height"));
    //console.log(_prevH)

    Static.onHtmlElementResize(self.plotDiv[0], function () {
      var changeOfHeight = parseFloat(self.plotDiv.css("height")) - _prevH2;
      _prevH2 = parseFloat(self.plotDiv.css("height"));
      Static.trigger("plotDivResized", [self.plotDiv, changeOfHeight]);
      self.autoRefresh();
    });

    Static.onHtmlElementResize(plotDivContainer[0], function () {
      var changeOfHeight = parseFloat(plotDivContainer.css("height")) - _prevH;
      _prevH = parseFloat(plotDivContainer.css("height"));
      Static.trigger("plotDivContainerResized", [
        plotDivContainer,
        changeOfHeight,
      ]);
    });
  }
}
;
define("plot", ["static","widget","scaleWidget","utility","enumerator","miscObjects","painter","scaleDiv","interval","scaleMap","scaleWidget","transform","layout","scaleDraw","scaleEngine","pointMapper","graphic","enumerator"], function(){});



/**
 * 
 * Abstract interface for iterating over samples

Qwt offers several implementations of the QwtSeriesData API,
but in situations, where data of an application specific format
needs to be displayed, without having to copy it, it is recommended
to implement an individual data access.

A subclass of SeriesData must implement:

- size(): Should return number of data points.

- sample(): Should return values x and y values of the sample at specific position
as Misc.Point object.

- boundingRect(): Should return the bounding rectangle of the data series.
It is used for autoscaling and might help certain algorithms for displaying
the data. You can use {@link SeriesData.mBoundingRectPoint mBoundingRectPoint()} for an implementation
but often it is possible to implement a more efficient algorithm
depending on the characteristics of the series.
The member d_boundingRect is intended for caching the calculated rectangle.
 */
class SeriesData {
  /**
   *
   * @param {Misc.Point} sample Sample point
   * @returns {Misc.Rect} Bounding rectangle
   */
  static mBoundingRectPoint(sample) {
    return new Misc.Rect(sample.x, sample.y, 0, 0); //{ left:sample.x, top:sample.y, right:sample.x, bottom:sample.y, width:0.0, height:0.0};
  }
  constructor() {
    Utility.makeAbstract(this, SeriesData);
    this.d_boundingRect = new Misc.Rect(); //{ left:0.0, top:0.0, right:-1.0, bottom:-1.0, width:-1.0, height:-1 };

    /**
     * Calculate the bounding rectangle of a series subset.
     *
     * Slow implementation, that iterates over the series.
     * @param {SeriesData} series Series
     * @param {Number} [from] Index of the first sample, <= 0 means from the beginning
     * @param {Number} [to] Index of the last sample, < 0 means to the end
     * @returns {Misc.Rect} Bounding rectangle
     */
    this.mBoundingRect = function (series, from, to) {
      var boundingRect = new Misc.Rect(); //{ left:0.0, top:0.0, right:-1.0, bottom:-1.0, width:-1.0, height:-1 }; // invalid;

      if (typeof from == "undefined") from = 0;

      if (typeof to == "undefined") to = series.size() - 1;

      if (to < from) return boundingRect;

      var i;
      for (i = from; i <= to; i++) {
        var rect = SeriesData.mBoundingRectPoint(series.sample(i));
        //console.log(boundingRect.width())
        if (rect.width() >= 0.0 && rect.height() >= 0.0) {
          boundingRect = rect;

          i++;
          break;
        }
      }
      //console.log(i)
      for (; i <= to; i++) {
        var rect = SeriesData.mBoundingRectPoint(series.sample(i));
        if (rect.width() >= 0.0 && rect.height() >= 0.0) {
          boundingRect.setRect(
            Math.min(boundingRect.left(), rect.left()),
            Math.min(boundingRect.top(), rect.top()),
            Math.max(boundingRect.right(), rect.right()) -
              Math.min(boundingRect.left(), rect.left()),
            Math.max(boundingRect.bottom(), rect.bottom()) -
              Math.min(boundingRect.top(), rect.top())
          );
        }
      }
      //
      return boundingRect;
    };

    /**
     * Set a the "rect of interest"
     *
     * {@link PlotSeriesItem} defines the current area of the plot canvas as "rectangle of interest" ( {@link PlotSeriesItem#updateScaleDiv updateScaleDiv()} ). It can be used to implement
     * different levels of details. The default implementation does nothing.
     * @param {Misc.Rect} rect Rectangle of interest
     */
    this.setRectOfInterest = function (rect) {
      //console.warn("Subclass must reimplement this method");
    };

    /**
     *
     * @returns Returns a string representing the object.
     */
    this.toString = function () {
      return "[SeriesData]";
    };
  }
}

/**
 * Class for data that is organized as an Array.
 * @extends SeriesData
 *
 */
class ArraySeriesData extends SeriesData {
  constructor(samples) {
    super();
    var d_samples = [];
    if (typeof samples !== "undefined") d_samples = samples;

    /**
     * Assign an array of samples
     * @param {Array<Misc.Point>} samples Array of samples
     */
    this.setSamples = function (samples) {
      this.d_boundingRect = new Misc.Rect(); //{ left:0.0, top:0.0, right:-1.0, bottom:-1.0, width:-1.0, height:-1 };
      d_samples = samples;
    };

    /**
     *
     * @returns {Array<Misc.Point>} Array of samples
     */
    this.samples = function () {
      return d_samples;
    };

    /**
     *
     * @returns {Number} Number of samples
     */
    this.size = function () {
      return d_samples.length;
    };

    /**
     *
     * @param {Number} i index
     * @returns {Misc.Point} Sample at a specific position
     */
    this.sample = function (i) {
      return d_samples[i];
    };

    /**
     *
     * @returns Returns a string representing the object.
     */
    this.toString = function () {
      return "[ArraySeriesData]";
    };
  }
}

/**
 * Class for iterating over an array of points.
 * @extends ArraySeriesData
 */
class PointSeriesData extends ArraySeriesData {
  constructor(samples) {
    super(samples);

    /**
     * Calculate the bounding rectangle
     *
     * The bounding rectangle is calculated once by iterating over all points and is stored for all following requests.
     * @returns {Misc.Rect} Bounding rectangle
     */
    this.boundingRect = function () {
      if (this.d_boundingRect.width() < 0.0)
        this.d_boundingRect = this.mBoundingRect(this);

      return this.d_boundingRect;
    };

    /**
     *
     * @returns Returns a string representing the object.
     */
    this.toString = function () {
      return "[PointSeriesData]";
    };
  }
}

/**
 * Class for iterating over an array of 3D points.
 * @extends ArraySeriesData
 */
class Point3DSeriesData extends ArraySeriesData {
  constructor(samples) {
    super(samples);

    /**
     * Calculate the bounding rectangle
     *
     * The bounding rectangle is calculated once by iterating over all points and is stored for all following requests.
     * @returns {Misc.Rect} Bounding rectangle
     */
    this.boundingRect = function () {
      if (this.d_boundingRect.width() < 0.0)
        this.d_boundingRect = this.mBoundingRect(this);

      return this.d_boundingRect;
    };

    /**
     *
     * @returns Returns a string representing the object.
     */
    this.toString = function () {
      return "[Point3DSeriesData]";
    };
  }
}

/**
 * Base class for plot items representing a series of samples.
 * @extends PlotItem
 */
class PlotSeriesItem extends PlotItem {
  /**
   *
   * @param {String} tle Title of the curve
   */
  constructor(tle) {
    super(tle);

    var d_series = null;
    var m_orientation = Static.Vertical;

    /**
     * Set the orientation of the item.
     *
     * The orientation() might be used in specific way by a plot item. e.g. a Curve uses it to identify
     * how to display the curve PlotCurve.CurveStyle.Steps or PlotCurve.CurveStyle.Sticks style.
     * @param {Number} orientation New orientation of the plot item
     */
    this.setOrientation = function (orientation) {
      if (m_orientation != orientation) {
        m_orientation = orientation;

        //legendChanged();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Number} Orientation of the plot item
     * @see {@link PlotSeriesItem#setOrientation setOrientation()}
     */
    this.orientation = function () {
      return m_orientation;
    };

    /**
     * Draw the complete series
     * @param {ScaleMap} xMap Maps x-values into pixel coordinates.
     * @param {ScaleMap} yMap Maps y-values into pixel coordinates.
     */
    this.draw = function (xMap, yMap) {
      this.drawSeries(xMap, yMap, 0, -1);
    };

    /**
     * Update the item to changes of the axes scale division.
     *
     * When the axes of plot have changed, update the item. The default implementation does nothing, but
     * items that depend on the scale division (like PlotGrid()) have to
     * reimplement updateScaleDiv(). updateScaleDiv() is only called when the
     * ScaleInterest interest is enabled. The default implementation does
     * nothing.
     * @param {ScaleDiv} xScaleDiv Scale division of the x-axis
     * @param {ScaleDiv} yScaleDiv Scale division of the y-axis
     */
    this.updateScaleDiv = function (xScaleDiv, yScaleDiv) {
      var rect = new Misc.Rect(
        new Misc.Point(xScaleDiv.lowerBound(), yScaleDiv.lowerBound()),
        xScaleDiv.range(),
        yScaleDiv.range()
      );

      this.setRectOfInterest(rect);
    };

    this.data = function () {
      return d_series;
    };

    this.sample = function (index) {
      return d_series ? d_series.sample(index) : null;
    };

    this.setData = function (series) {
      if (d_series != series) {
        d_series = series;
        //dataChanged();
      }
    };

    this.dataSize = function () {
      if (d_series == null) return 0;

      return d_series.size();
    };

    this.dataRect = function () {
      if (d_series == null) return new Misc.Rect(); //{left: 1.0, top:1.0, width:-2.0, height:-2.0 }; // invalid

      return d_series.boundingRect();
    };

    this.setRectOfInterest = function (rect) {
      if (d_series) d_series.setRectOfInterest(rect);
    };

    this.swapData = function (series) {
      var swappedSeries = d_series;
      d_series = series;

      return swappedSeries;
    };

    /**
     *
     * @returns Returns a string representing the object.
     */
    this.toString = function () {
      return "[PlotSeriesItem]";
    };
  }

  /**
   *
   * @returns {Misc.Rect} Bounding rectangle
   */
  boundingRect() {
    return this.dataRect();
  }
}
;
define("seriesData", ["static","plotItem"], function(){});


/*!
Constructor

\param size Number of points
\param interval Bounding interval for the points

\sa setInterval(), setSize()
 */

/**
 * @extends SeriesData
 */
class SyntheticPointData extends SeriesData {
  constructor(size, interval) {
    // Call the parent constructor, making sure (using Function#call)
    // that "this" is set correctly during the call
    //SeriesData.call(this);
    super();
    var d_size = size;
    var d_interval = interval || new Interval();
    //console.log(d_interval)
    var d_rectOfInterest;
    var d_intervalOfInterest = new Interval(0.0, 10.0); //???

    this.setSize = function (size) {
      d_size = size;
    };

    this.size = function () {
      return d_size;
    };

    /*!
        Set the bounding interval

        \param interval Interval
        \sa interval(), setSize()
         */
    this.setInterval = function (interval) {
      d_interval = interval.normalized();
    };

    /*!
        \return Bounding interval
        \sa setInterval(), size()
         */
    this.interval = function () {
      return d_interval;
    };

    /*!
        Set a the "rectangle of interest"

        QwtPlotSeriesItem defines the current area of the plot canvas
        as "rect of interest" ( QwtPlotSeriesItem::updateScaleDiv() ).

        If interval().isValid() == false the x values are calculated
        in the interval rect.left() -> rect.right().

        \sa rectOfInterest()
         */
    this.setRectOfInterest = function (rect) {
      d_rectOfInterest = rect;
      d_intervalOfInterest = new Interval(
        rect.left(),
        rect.right()
      ).normalized();
    };

    /*!
        \return "rectangle of interest"
        \sa setRectOfInterest()
         */
    this.rectOfInterest = function () {
      return d_rectOfInterest;
    };

    /*!
        \brief Calculate the bounding rectangle

        This implementation iterates over all points, what could often
        be implemented much faster using the characteristics of the series.
        When there are many points it is recommended to overload and
        reimplement this method using the characteristics of the series
        ( if possible ).

        \return Bounding rectangle
         */
    this.boundingRect = function () {
      if (
        d_size == 0 ||
        !(d_interval.isValid() || d_intervalOfInterest.isValid())
      ) {
        return new Misc.Rect(1.0, 1.0, -2.0, -2.0); // something invalid
      }

      return this.mBoundingRect(this);
    };

    this.y = function (_x) {
      throw 'subclass must implement "this.y"';
    };

    /*!
        Calculate a x-value from an index

        x values are calculated by dividing an interval into
        equidistant steps. If !interval().isValid() the
        interval is calculated from the "rectangle of interest".

        \param index Index of the requested point
        \return Calculated x coordinate

        \sa interval(), rectOfInterest(), y()
         */
    this.x = function (index) {
      var interval = d_interval.isValid() ? d_interval : d_intervalOfInterest;

      if (!interval.isValid() || d_size == 0 || index >= d_size) return 0.0;

      var dx = interval.width() / d_size;
      return interval.minValue() + index * dx;
    };

    this.toString = function () {
      return "[SyntheticPointData]";
    };
  }

  /*!
  Calculate the point from an index

  \param index Index
  \return QPointF(x(index), y(x(index)));

  \warning For invalid indices ( index < 0 || index >= size() )
  (0, 0) is returned.
    */
  sample(index) {
    if (index >= this.size()) return new Misc.Point(0, 0);

    var xValue = this.x(index);
    var yValue = this.y(xValue);
    //console.log(this.y)

    return new Misc.Point(xValue, yValue);
  }
}

/////////////////////////////////////////////////////////end
;
define("pointData", ["static","seriesData"], function(){});

"include ['pointData']";

class FunctionData extends SyntheticPointData {
  constructor(yCb, numOfPoints) {
    super(numOfPoints);
    this.discontinuitySamples = null;
    var d_y = yCb;
    var parser = new EvaluateExp(d_y);

    this.setFn = function (fn) {
      d_y = fn;
      parser.setExpString(d_y);
    };

    this.y = function (_x) {
      if (parser.error) return 0;
      return parser.eval({
        x: _x,
      });
    };
  }

  sample(index) {
    if (this.discontinuitySamples) {
      if (index >= this.discontinuitySamples.length)
        return new Misc.Point(0, 0);
      return this.discontinuitySamples[index];
    }

    return super.sample(index);
  }
}
;
define("functionData", ["pointData"], function(){});



/**
 * A class which draws a coordinate grid.
 *
 * The PlotGrid class can be used to draw a coordinate grid. A coordinate grid consists of major and minor vertical and horizontal grid lines. The locations of the grid lines are determined by the X and Y scale divisions which can be assigned with setXDiv() and setYDiv(). The draw() member draws the grid within a bounding rectangle.
 * @extends PlotItem
 */
class PlotGrid extends PlotItem {
  /**
   *
   * @param {String} tle Title of grid
   */
  constructor(tle) {
    super(tle);

    this.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);

    // Initialize our PlotGrid-specific properties
    // Enables major grid, disables minor grid
    var xEnabled = true;
    var yEnabled = true;
    var xMinEnabled = false;
    var yMinEnabled = false;

    var xScaleDiv = null;
    var yScaleDiv = null;

    var _majorPen = /* "rgb(192, 192, 192)"; */ "grey";
    var _minorPen = /* "rgb(221, 221, 221)"; */ "lightGrey";

    this.rtti = PlotItem.RttiValues.Rtti_PlotGrid;

    /**
     * Assign a pen color for major grid lines
     * @param {String} penColor pen color
     */
    this.setMajorPen = function (penColor) {
      if (_majorPen !== penColor) {
        _majorPen = penColor;
        this.itemChanged();
        //Static.trigger("itemChanged", [this, on]);
      }
    };

    /**
     *
     * @returns {Misc.Pen} the pen for the major grid lines
     * @see {@link PlotGrid#setMajorPen setMajorPen()}
     */
    this.majorPen = function () {
      return _majorPen;
    };

    /**
     * Assign a pen color for minor grid lines
     * @param {String} penColor pen color
     */
    this.setMinorPen = function (penColor) {
      if (_minorPen !== penColor) {
        _minorPen = penColor;
        this.itemChanged();
        //Static.trigger("itemChanged", [this, on]);
      }
    };

    /**
     *
     * @returns {Misc.Pen} the pen for the minor grid lines
     * @see {@link PlotGrid#setMinorPen setMinorPen()}
     */
    this.minorPen = function () {
      return _minorPen;
    };

    /**
     * Enable or disable vertical grid lines.
     * @param {Boolean} on Enable (true) or disable
     */
    this.enableX = function (on) {
      if (xEnabled != on) {
        xEnabled = on;
        //this.plot().autoRefresh()
        //legendChanged();
        this.itemChanged();
        Static.trigger("itemChanged", [this, on]);
      }
    };

    /**
     *
     * @returns {Boolean} true if vertical grid lines are enabled
     */
    this.xEnabled = function () {
      return xEnabled;
    };

    /**
     * Enable or disable horizontal grid lines.
     * @param {Boolean} on Enable (true) or disable
     */
    this.enableY = function (on) {
      if (yEnabled != on) {
        yEnabled = on;
        //this.plot().autoRefresh()
        //legendChanged();
        this.itemChanged();
        Static.trigger("itemChanged", [this, on]);
      }
    };

    /**
     *
     * @returns {Boolean} true if horizontal grid lines are enabled
     */
    this.yEnabled = function () {
      return yEnabled;
    };

    /**
     * Enable or disable minor vertical grid lines.
     * @param {Boolean} on Enable (true) or disable
     */
    this.enableXMin = function (on) {
      if (xMinEnabled != on) {
        xMinEnabled = on;
        //this.plot().autoRefresh()

        //legendChanged();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Boolean} true if minor vertical grid lines are enabled
     * @see {@link PlotGrid#enableXMin enableXMin()}
     */
    this.xMinEnabled = function () {
      return xMinEnabled;
    };

    /**
     * Enable or disable minor horizontal grid lines.
     * @param {Boolean} on Enable (true) or disable
     */
    this.enableYMin = function (on) {
      if (yMinEnabled != on) {
        yMinEnabled = on;
        //this.plot().autoRefresh()

        //legendChanged();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Boolean} true if minor horizontal grid lines are enabled
     * @see {@link PlotGrid#enableYMin enableYMin()}
     */
    this.yMinEnabled = function () {
      return yMinEnabled;
    };

    /**
     * Assign a x axis division
     * @param {ScaleDiv} scaleDiv Scale division
     */
    this.setXDiv = function (scaleDiv) {
      if (xScaleDiv !== scaleDiv) {
        xScaleDiv = scaleDiv;
        //itemChanged();
      }
    };

    /**
     *
     * @returns {ScaleDiv} The scale division of the x axis
     */
    this.xDiv = function () {
      return xScaleDiv;
    };

    /**
     * Assign a y axis division
     * @param {ScaleDiv} scaleDiv Scale division
     */
    this.setYDiv = function (scaleDiv) {
      if (yScaleDiv !== scaleDiv) {
        yScaleDiv = scaleDiv;
        //itemChanged();
      }
    };

    /**
     *
     * @returns {ScaleDiv} The scale division of the y axis
     */
    this.yDiv = function () {
      return yScaleDiv;
    };

    /**
     * Draw the grid
     *
     * The grid is drawn in the bounding rectangle such that grid lines begin and end at the rectangle's borders.
     * The X and Y maps are used to map the scale divisions into the drawing region screen.
     * @param {ScaleMap} xMap X axis map
     * @param {ScaleMap} yMap Y axis map
     */
    this.draw = function (xMap, yMap) {
      var p = this.plot();
      var xScaleDiv = p.axisScaleDiv(this.xAxis());
      var yScaleDiv = p.axisScaleDiv(this.yAxis());

      var ctx = this.getContext();

      //ctx.clearRect ( 0 , 0 , ctx.canvas.width, ctx.canvas.height );
      ctx.strokeStyle = _minorPen;

      if (xEnabled && xMinEnabled) {
        drawLines(
          ctx,
          "vertical",
          xMap,
          xScaleDiv.ticks(ScaleDiv.TickType.MinorTick)
        );
        drawLines(
          ctx,
          "vertical",
          xMap,
          xScaleDiv.ticks(ScaleDiv.TickType.MediumTick)
        );
      }

      if (yEnabled && yMinEnabled) {
        drawLines(
          ctx,
          "horizontal",
          yMap,
          yScaleDiv.ticks(ScaleDiv.TickType.MinorTick)
        );
        drawLines(
          ctx,
          "horizontal",
          yMap,
          yScaleDiv.ticks(ScaleDiv.TickType.MediumTick)
        );
      }
      //ctx.stroke();

      //  draw major grid lines
      ctx.strokeStyle = _majorPen;

      //ctx.beginPath();

      if (xEnabled) {
        drawLines(
          ctx,
          "vertical",
          xMap,
          xScaleDiv.ticks(ScaleDiv.TickType.MajorTick)
        );
      }

      if (yEnabled) {
        drawLines(
          ctx,
          "horizontal",
          yMap,
          yScaleDiv.ticks(ScaleDiv.TickType.MajorTick)
        );
      }

      //ctx.stroke();
    };

    const drawLines = function (context, orientation, scaleMap, values) {
      var x1 = 0;
      var x2 = context.canvas.width - 1.0;

      var y1 = 0; //canvasRect.top()();
      var y2 = context.canvas.height - 1.0;

      var painter = new PaintUtil.Painter(context);
      var lineThickness = painter.pen().width;

      for (var i = 0; i < values.length; i++) {
        var value = scaleMap.transform(values[i]);
        //if ( doAlign )
        //value = Math.round( value );

        if (orientation === "horizontal") {
          painter.drawLine(
            x1,
            value - lineThickness,
            x2,
            value - lineThickness
          );
        } else {
          painter.drawLine(
            value - lineThickness,
            y1,
            value - lineThickness,
            y2
          );
        }
      }
      painter = null;
    };

    /**
     * Update the grid to changes of the axes scale division
     * @param {ScaleDiv} xScale_div Scale division of the x-axis
     * @param {ScaleDiv} yScale_div Scale division of the y-axis
     * @see {@link Plot#updateAxes updateAxes()}
     */
    this.updateScaleDiv = function (xScale_div, yScale_div) {
      this.setXDiv(xScale_div);
      this.setYDiv(yScale_div);
    };

    /**
     *
     * @returns {String} Returns a string representing the object.
     */
    this.toString = function () {
      return "[PlotGrid]";
    };
  }
}
;
define("plotGrid", ["static","plotItem"], function(){});

/**
 * Copyright (c) 2010, Jason Davies.
 *
 * All rights reserved.  This code is based on Bradley White's Java version,
 * which is in turn based on Nicholas Yue's C++ version, which in turn is based
 * on Paul D. Bourke's original Fortran version.  See below for the respective
 * copyright notices.
 *
 * See http://paulbourke.net/papers/conrec for the original
 * paper by Paul D. Bourke.
 *
 * The vector conversion code is based on http://apptree.net/conrec.htm by
 * Graham Cox.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996-1997 Nicholas Yue
 *
 * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
 * Bourke's CONREC.F routine.
 *
 * The authors hereby grant permission to use, copy, and distribute this
 * software and its documentation for any purpose, provided that existing
 * copyright notices are retained in all copies and that this notice is
 * included verbatim in any distributions. Additionally, the authors grant
 * permission to modify this software and its documentation for any purpose,
 * provided that such modifications are not distributed without the explicit
 * consent of the authors and that existing copyright notices are retained in
 * all copies. Some of the algorithms implemented by this software are
 * patented, observe all applicable patent law.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
 * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */

var Conrec = (function() {
  var EPSILON = 1e-20;

  var pointsEqual = function(a, b) {
    var x = a.x - b.x, y = a.y - b.y;
    return x * x + y * y < EPSILON;
  }

  var reverseList = function(list) {
    var pp = list.head;

    while (pp) {
      // swap prev/next pointers
      var temp = pp.next;
      pp.next = pp.prev;
      pp.prev = temp;

      // continue through the list
      pp = temp;
    }

    // swap head/tail pointers
    var temp = list.head;
    list.head = list.tail;
    list.tail = temp;
  }

  var ContourBuilder = function(level) {
    this.level = level;
    this.s = null;
    this.count = 0;
  }
  ContourBuilder.prototype.remove_seq = function(list) {
    // if list is the first item, static ptr s is updated
    if (list.prev) {
      list.prev.next = list.next;
    } else {
      this.s = list.next;
    }

    if (list.next) {
      list.next.prev = list.prev;
    }
    --this.count;
  }
  ContourBuilder.prototype.addSegment = function(a, b) {
    var ss = this.s;
    var ma = null;
    var mb = null;
    var prependA = false;
    var prependB = false;

    while (ss) {
      if (ma == null) {
        // no match for a yet
        if (pointsEqual(a, ss.head.p)) {
          ma = ss;
          prependA = true;
        } else if (pointsEqual(a, ss.tail.p)) {
          ma = ss;
        }
      }
      if (mb == null) {
        // no match for b yet
        if (pointsEqual(b, ss.head.p)) {
          mb = ss;
          prependB = true;
        } else if (pointsEqual(b, ss.tail.p)) {
          mb = ss;
        }
      }
      // if we matched both no need to continue searching
      if (mb != null && ma != null) {
        break;
      } else {
        ss = ss.next;
      }
    }

    // c is the case selector based on which of ma and/or mb are set
    var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);

    switch(c) {
      case 0:   // both unmatched, add as new sequence
        var aa = {p: a, prev: null};
        var bb = {p: b, next: null};
        aa.next = bb;
        bb.prev = aa;

        // create sequence element and push onto head of main list. The order
        // of items in this list is unimportant
        ma = {head: aa, tail: bb, next: this.s, prev: null, closed: false};
        if (this.s) {
          this.s.prev = ma;
        }
        this.s = ma;

        ++this.count;    // not essential - tracks number of unmerged sequences
      break;

      case 1:   // a matched, b did not - thus b extends sequence ma
        var pp = {p: b};

        if (prependA) {
          pp.next = ma.head;
          pp.prev = null;
          ma.head.prev = pp;
          ma.head = pp;
        } else {
          pp.next = null;
          pp.prev = ma.tail;
          ma.tail.next = pp;
          ma.tail = pp;
        }
      break;

      case 2:   // b matched, a did not - thus a extends sequence mb
        var pp = {p: a};

        if (prependB) {
          pp.next = mb.head;
          pp.prev = null;
          mb.head.prev = pp;
          mb.head = pp;
        } else {
          pp.next = null;
          pp.prev = mb.tail;
          mb.tail.next = pp;
          mb.tail = pp;
        }
      break;

      case 3:   // both matched, can merge sequences
        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)

        if (ma === mb) {
          var pp = {p: ma.tail.p, next: ma.head, prev: null};
          ma.head.prev = pp;
          ma.head = pp;
          ma.closed = true;
          break;
        }

        // there are 4 ways the sequence pair can be joined. The current setting of prependA and
        // prependB will tell us which type of join is needed. For head/head and tail/tail joins
        // one sequence needs to be reversed
        switch((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
          case 0:   // tail-tail
            // reverse ma and append to mb
            reverseList(ma);
            // fall through to head/tail case
          case 1:   // head-tail
            // ma is appended to mb and ma discarded
            mb.tail.next = ma.head;
            ma.head.prev = mb.tail;
            mb.tail = ma.tail;

            //discard ma sequence record
            this.remove_seq(ma);
          break;

          case 3:   // head-head
            // reverse ma and append mb to it
            reverseList(ma);
            // fall through to tail/head case
          case 2:   // tail-head
            // mb is appended to ma and mb is discarded
            ma.tail.next = mb.head;
            mb.head.prev = ma.tail;
            ma.tail = mb.tail;

            //discard mb sequence record
            this.remove_seq(mb);
        break;
      }
    }
  }

  /**
   * Implements CONREC.
   *
   * @param {function} drawContour function for drawing contour.  Defaults to a
   *                               custom "contour builder", which populates the
   *                               contours property.
   */
  var Conrec = function(drawContour) {
    if (!drawContour) {
      var c = this;
      c.contours = {};
      /**
       * drawContour - interface for implementing the user supplied method to
       * render the countours.
       *
       * Draws a line between the start and end coordinates.
       *
       * @param startX    - start coordinate for X
       * @param startY    - start coordinate for Y
       * @param endX      - end coordinate for X
       * @param endY      - end coordinate for Y
       * @param contourLevel - Contour level for line.
       */
      this.drawContour = function(startX, startY, endX, endY, contourLevel, k) {
        var cb = c.contours[k];
        if (!cb) {
          cb = c.contours[k] = new ContourBuilder(contourLevel);
        }
        cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});
      }
      this.contourList = function() {
        var l = [];
        var a = c.contours;
        for (var k in a) {
          var s = a[k].s;
          var level = a[k].level;
          while (s) {
            var h = s.head;
            var l2 = [];
            l2.level = level;
            l2.k = k;
            while (h && h.p) {
              l2.push(h.p);
              h = h.next;
            }
            l.push(l2);
            s = s.next;
          }
        }
        l.sort(function(a, b) { return b.k - a.k });
        return l;
      }
    } else {
      this.drawContour = drawContour;
    }
    this.h  = new Array(5);
    this.sh = new Array(5);
    this.xh = new Array(5);
    this.yh = new Array(5);
  }

  /**
   * contour is a contouring subroutine for rectangularily spaced data
   *
   * It emits calls to a line drawing subroutine supplied by the user which
   * draws a contour map corresponding to real*4data on a randomly spaced
   * rectangular grid. The coordinates emitted are in the same units given in
   * the x() and y() arrays.
   *
   * Any number of contour levels may be specified but they must be in order of
   * increasing value.
   *
   *
   * @param {number[][]} d - matrix of data to contour
   * @param {number} ilb,iub,jlb,jub - index bounds of data matrix
   *
   *             The following two, one dimensional arrays (x and y) contain
   *             the horizontal and vertical coordinates of each sample points.
   * @param {number[]} x  - data matrix column coordinates
   * @param {number[]} y  - data matrix row coordinates
   * @param {number} nc   - number of contour levels
   * @param {number[]} z  - contour levels in increasing order.
   */
  Conrec.prototype.contour = function(d, ilb, iub, jlb, jub, x, y, nc, z) {
    var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
    var drawContour = this.drawContour;
    this.contours = {};

    /** private */
    var xsect = function(p1, p2){
      return (h[p2]*xh[p1]-h[p1]*xh[p2])/(h[p2]-h[p1]);
    }

    var ysect = function(p1, p2){
      return (h[p2]*yh[p1]-h[p1]*yh[p2])/(h[p2]-h[p1]);
    }
    var m1;
    var m2;
    var m3;
    var case_value;
    var dmin;
    var dmax;
    var x1 = 0.0;
    var x2 = 0.0;
    var y1 = 0.0;
    var y2 = 0.0;

    // The indexing of im and jm should be noted as it has to start from zero
    // unlike the fortran counter part
    var im = [0, 1, 1, 0];
    var jm = [0, 0, 1, 1];

    // Note that castab is arranged differently from the FORTRAN code because
    // Fortran and C/C++ arrays are transposed of each other, in this case
    // it is more tricky as castab is in 3 dimensions
    var castab = [
      [
        [0, 0, 8], [0, 2, 5], [7, 6, 9]
      ],
      [
        [0, 3, 4], [1, 3, 1], [4, 3, 0]
      ],
      [
        [9, 6, 7], [5, 2, 0], [8, 0, 0]
      ]
    ];

    for (var j=(jub-1);j>=jlb;j--) {
      for (var i=ilb;i<=iub-1;i++) {
        var temp1, temp2;
        temp1 = Math.min(d[i][j],d[i][j+1]);
        temp2 = Math.min(d[i+1][j],d[i+1][j+1]);
        dmin  = Math.min(temp1,temp2);
        temp1 = Math.max(d[i][j],d[i][j+1]);
        temp2 = Math.max(d[i+1][j],d[i+1][j+1]);
        dmax  = Math.max(temp1,temp2);

        if (dmax>=z[0]&&dmin<=z[nc-1]) {
          for (var k=0;k<nc;k++) {
            if (z[k]>=dmin&&z[k]<=dmax) {
              for (var m=4;m>=0;m--) {
                if (m>0) {
                  // The indexing of im and jm should be noted as it has to
                  // start from zero
                  h[m] = d[i+im[m-1]][j+jm[m-1]]-z[k];
                  xh[m] = x[i+im[m-1]];
                  yh[m] = y[j+jm[m-1]];
                } else {
                  h[0] = 0.25*(h[1]+h[2]+h[3]+h[4]);
                  xh[0]=0.5*(x[i]+x[i+1]);
                  yh[0]=0.5*(y[j]+y[j+1]);
                }
                if (h[m]>0.0) {
                  sh[m] = 1;
                } else if (h[m]<0.0) {
                  sh[m] = -1;
                } else
                  sh[m] = 0;
              }
              //
              // Note: at this stage the relative heights of the corners and the
              // centre are in the h array, and the corresponding coordinates are
              // in the xh and yh arrays. The centre of the box is indexed by 0
              // and the 4 corners by 1 to 4 as shown below.
              // Each triangle is then indexed by the parameter m, and the 3
              // vertices of each triangle are indexed by parameters m1,m2,and
              // m3.
              // It is assumed that the centre of the box is always vertex 2
              // though this isimportant only when all 3 vertices lie exactly on
              // the same contour level, in which case only the side of the box
              // is drawn.
              //
              //
              //      vertex 4 +-------------------+ vertex 3
              //               | \               / |
              //               |   \    m-3    /   |
              //               |     \       /     |
              //               |       \   /       |
              //               |  m=2    X   m=2   |       the centre is vertex 0
              //               |       /   \       |
              //               |     /       \     |
              //               |   /    m=1    \   |
              //               | /               \ |
              //      vertex 1 +-------------------+ vertex 2
              //
              //
              //
              //               Scan each triangle in the box
              //
              for (m=1;m<=4;m++) {
                m1 = m;
                m2 = 0;
                if (m!=4) {
                    m3 = m+1;
                } else {
                    m3 = 1;
                }
                case_value = castab[sh[m1]+1][sh[m2]+1][sh[m3]+1];
                if (case_value!=0) {
                  switch (case_value) {
                    case 1: // Line between vertices 1 and 2
                      x1=xh[m1];
                      y1=yh[m1];
                      x2=xh[m2];
                      y2=yh[m2];
                      break;
                    case 2: // Line between vertices 2 and 3
                      x1=xh[m2];
                      y1=yh[m2];
                      x2=xh[m3];
                      y2=yh[m3];
                      break;
                    case 3: // Line between vertices 3 and 1
                      x1=xh[m3];
                      y1=yh[m3];
                      x2=xh[m1];
                      y2=yh[m1];
                      break;
                    case 4: // Line between vertex 1 and side 2-3
                      x1=xh[m1];
                      y1=yh[m1];
                      x2=xsect(m2,m3);
                      y2=ysect(m2,m3);
                      break;
                    case 5: // Line between vertex 2 and side 3-1
                      x1=xh[m2];
                      y1=yh[m2];
                      x2=xsect(m3,m1);
                      y2=ysect(m3,m1);
                      break;
                    case 6: //  Line between vertex 3 and side 1-2
                      x1=xh[m3];
                      y1=yh[m3];
                      x2=xsect(m1,m2);
                      y2=ysect(m1,m2);
                      break;
                    case 7: // Line between sides 1-2 and 2-3
                      x1=xsect(m1,m2);
                      y1=ysect(m1,m2);
                      x2=xsect(m2,m3);
                      y2=ysect(m2,m3);
                      break;
                    case 8: // Line between sides 2-3 and 3-1
                      x1=xsect(m2,m3);
                      y1=ysect(m2,m3);
                      x2=xsect(m3,m1);
                      y2=ysect(m3,m1);
                      break;
                    case 9: // Line between sides 3-1 and 1-2
                      x1=xsect(m3,m1);
                      y1=ysect(m3,m1);
                      x2=xsect(m1,m2);
                      y2=ysect(m1,m2);
                      break;
                    default:
                      break;
                  }
                  // Put your processing code here and comment out the printf
                  //printf("%f %f %f %f %f\n",x1,y1,x2,y2,z[k]);
                  drawContour(x1,y1,x2,y2,z[k],k);
                }
              }
            }
          }
        }
      }
    }
  }
  return Conrec;
})();
if (typeof exports !== "undefined") {
  exports.Conrec = Conrec;
};
define("conrec", function(){});

/**
 * A class, which displays raster data.
 *
 * Raster data is a grid of pixel values, that can be represented as a Image. It is used for the spectrograms.
 *
 * Using {@link PlotRasterItem#setAlpha setAlpha()} raster items can be stacked easily.
 * PlotRasterItem is only implemented for images of the following formats: {@link ColorMap.Format Format.Indexed}, {@link ColorMap.Format Format.RGB}.
 * @extends PlotItem
 */
class PlotRasterItem extends PlotItem {
  static useCache(policy, painter) {
    var doCache = false;

    if (policy == PlotRasterItem.CachePolicy.PaintCache) {
      // Caching doesn't make sense, when the item is
      // not painted to screen

      switch (/* painter.paintEngine().type() */ 1) {
        /* case QPaintEngine::SVG:
                case QPaintEngine::Pdf:
                case QPaintEngine::PostScript:
                case QPaintEngine::MacPrinter:
                case QPaintEngine::Picture:
                break; */
        default:
          doCache = true;
      }
    }

    return doCache;
  }

  static qwtToRgba(from, alpha) {
    var alphaImage = from.copy();
    alphaImage.setAlpha(alpha);
    return alphaImage;
  }

  /**
   *
   * @param {String} tle Title of the RasterItem
   */
  constructor(tle) {
    super(tle);

    // /*!
    //     When the image is rendered according to the data pixels
    //     ( QwtRasterData::pixelHint() ) it can be expanded to paint
    //     device resolution before it is passed to QPainter.
    //     The expansion algorithm rounds the pixel borders in the same
    //     way as the axis ticks, what is usually better than the
    //     scaling algorithm implemented in Qt.
    //     Disabling this flag might make sense, to reduce the size of a
    //     document/file. If this is possible for a document format
    //     depends on the implementation of the specific QPaintEngine.
    //      */
    // Enum.PaintAttribute = {
    //   PaintInDeviceResolution: 1,
    // };

    class PrivateData {
      constructor() {
        this.cache = {
          policy: null,
          area: null,
          size: null,
          image: null,
        };
        this.alpha = -1;
        this.paintAttributes =
          PlotRasterItem.PaintAttribute.PaintInDeviceResolution;
        this.cache.policy = PlotRasterItem.CachePolicy.NoCache;
      }
    }
    /* data */
    var d_data = null;

    var m_pixelSize = new Misc.Size(1, 1);

    /* Mehods */
    this.init = function () {
      d_data = new PrivateData();
      this.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
      this.setItemAttribute(PlotItem.ItemAttribute.Legend, false);
      this.setZ(8.0);
    };

    /**
     * Specify an attribute how to draw the raster item
     * @param {PlotRasterItem.PaintAttribute} attribute Paint attribute
     * @param {Boolean} on On/Off
     * @see {@link PlotRasterItem.PaintAttribute PaintAttribute}
     * @see {@link PlotRasterItem#testPaintAttribute testPaintAttribute()}
     */
    this.setPaintAttribute = function (attribute, on) {
      if (on) d_data.paintAttributes |= attribute;
      else d_data.paintAttributes &= ~attribute;
    };

    /**
     *
     * @param {PlotRasterItem.PaintAttribute} attribute
     * @returns {Boolean} True, when attribute is enabled
     * @see {@link PlotRasterItem.PaintAttribute PaintAttribute}
     * @see {@link PlotRasterItem#setPaintAttribute setPaintAttribute()}
     */
    this.testPaintAttribute = function (attribute) {
      return d_data.paintAttributes & attribute;
    };

    /**
     * Set an alpha value for the raster data
     * Often a plot has several types of raster data organized in layers. ( f.e a geographical map, with weather statistics ). Using setAlpha() raster items can be stacked easily.
     * The alpha value is a value [0, 255] to control the transparency of the image. 0 represents a fully transparent color, while 255 represents a fully opaque color.
     * @param {Number} alpha Alpha value - alpha >= 0
     * All alpha values of the pixels returned by renderImage() will be set to alpha, beside those with an alpha value of 0 (invalid pixels).
     * - alpha < 0
     * The alpha values returned by renderImage() are not changed.
     * The default alpha value is -1.
     * @see {@link PlotRasterItem#alpha alpha()}
     */
    this.setAlpha = function (alpha) {
      if (alpha < 0) alpha = -1;
      if (alpha > 255) alpha = 255;
      if (alpha != d_data.alpha) {
        d_data.alpha = alpha;
        this.invalidateCache();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Number} Alpha value of the raster item
     * @see {@link PlotRasterItem#setAlpha setAlpha()}
     */
    this.alpha = function () {
      return d_data.alpha;
    };

    /**
     * Change the cache policy
     * The default policy is NoCache
     * @param {PlotRasterItem.CachePolicy} policy Cache policy
     * @see {@link PlotRasterItem.CachePolicy CachePolicy}
     * @see {@link PlotRasterItem#cachePolicy cachePolicy()}
     */
    this.setCachePolicy = function (policy) {
      if (d_data.cache.policy != policy) {
        d_data.cache.policy = policy;
        this.invalidateCache();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {PlotRasterItem.CachePolicy} Cache policy
     * @see {@link PlotRasterItem#setCachePolicy setCachePolicy()}
     */
    this.cachePolicy = function () {
      return d_data.cache.policy;
    };

    /**
     * Invalidate the paint cache
     * @see {@link PlotRasterItem#setCachePolicy setCachePolicy()}
     */
    this.invalidateCache = function () {
      d_data.cache.image = new Misc.Image();
      d_data.cache.area = new Misc.Rect();
      d_data.cache.size = new Misc.Size();
    };

    /**
     * This method is intended to be reimplemented by derived classes.
     * The default implementation returns an invalid interval.
     * @param {Number} axis  X, Y, or Z axis
     * @returns {Interval} Bounding interval for an axis
     */
    this.interval = function (axis) {
      /* Q_UNUSED( axis ); */
      return new Interval();
    };

    /**
     *
     * @returns {Misc.Size} Theoritical pixel size
     * @see {@link PlotRasterItem#setPixelSize setPixelSize()}
     */
    this.pixelSize = function () {
      return m_pixelSize;
    };

    /**
     * Some algorithms do calaculations that are applied to every pixel. This may cause performance issues in some cases. To do calculations that are applied to more than one pixel we can increase the pixel size fromm 1x1 to some theoretical size.
     *
     * For example, to apply the same calculation to 4 pixels, call setPixelSize(New Misc.Size(2, 2)). Now your theoretical pixel is 2x2 (i.e. 4 pixels)
     * @param {Misc.Size} sz New theoritical pixel size
     * @see {@link PlotRasterItem#pixelSize pixelSize()}
     */
    this.setPixelSize = function (sz) {
      m_pixelSize = sz;
      this.invalidateCache();
    };

    //Hellper
    this.compose = function compose(
      xMap,
      yMap,
      imageArea,
      paintRect,
      imageSize,
      doCache
    ) {
      var image = new Misc.Image();
      if (imageArea.isEmpty() || paintRect.isEmpty() || imageSize.isEmpty())
        return image;

      if (doCache) {
        if (
          !d_data.cache.image.isNull() &&
          d_data.cache.area.isEqual(imageArea) &&
          d_data.cache.size.isEqual(paintRect.size())
        ) {
          image = d_data.cache.image;
        }
      }

      if (image.isNull()) {
        var xxMap = this.imageMap(
          Static.Horizontal,
          xMap,
          imageArea,
          imageSize
        );
        var yyMap = this.imageMap(Static.Vertical, yMap, imageArea, imageSize);
        image = this.renderImage(xxMap, yyMap, imageArea, imageSize);

        if (doCache) {
          d_data.cache.area = imageArea.copy();
          d_data.cache.size = paintRect.size().copy();
          d_data.cache.image = image.copy();
        }
      }

      // if (d_data.alpha >= 0 && d_data.alpha < 255) {
      //   image = PlotRasterItem.qwtToRgba(image, d_data.alpha);
      // }
      return image;
    };

    /**
     *
     * @param {Number} orientation
     * @param {ScaleMap} map Scale map for rendering the plot item
     * @param {Misc.Rect} area Area to be painted on the image
     * @param {Misc.Size} imageSize Image size
     * @returns {ScaleMap} Calculated scale map
     */
    this.imageMap = function (orientation, map, area, imageSize) {
      var p1, p2, s1, s2;

      if (orientation == Static.Horizontal) {
        p1 = 0.0;
        p2 = imageSize.width;
        s1 = area.left();
        s2 = area.right();
      } else {
        p1 = 0.0;
        p2 = imageSize.height;
        s1 = area.top();
        s2 = area.bottom();
      }

      if (map.isInverting() && s1 < s2) {
        var temp = s1;
        s1 = s2;
        s2 = temp;
      }

      var newMap = map.copy();
      newMap.setPaintInterval(p1, p2);
      newMap.setScaleInterval(s1, s2);

      return newMap;
    };

    this.dataRasterItemPrivateData = function () {
      return d_data;
    };
    this.init();
  }

  /**
   *
   * @returns {Misc.Rect} Bounding rectangle of the data
   * @see {@link PlotRasterItem#interval interval()}
   */
  boundingRect() {
    /* var intervalX = new Interval(Static.XAxis);
        var intervalY = new Interval(YAxis); */

    var intervalX = this.interval(Static.XAxis);
    var intervalY = this.interval(Static.YAxis);

    if (!intervalX.isValid() && !intervalY.isValid()) return new Misc.Rect(); // no bounding rect

    var r = new Misc.Rect();

    if (intervalX.isValid()) {
      r.setLeft(intervalX.minValue());
      r.setRight(intervalX.maxValue());
    } else {
      r.setLeft(-0.5 * Number.MAX_VALUE);
      r.setWidth(Number.MAX_VALUE);
    }

    if (intervalY.isValid()) {
      r.setTop(intervalY.minValue());
      r.setBottom(intervalY.maxValue());
    } else {
      r.setTop(-0.5 * Number.MAX_VALUE);
      r.setHeight(Number.MAX_VALUE);
    }

    return r.normalized();
  }

  /**
   * Draw the raster data
   * @param {PaintUtil.Painter} painter Painter
   * @param {ScaleMap} xMap X-Scale Map
   * @param {ScaleMap} yMap Y-Scale Map
   * @param {ScaleMap} canvasRect Contents rectangle of the plot canvas
   *
   */
  draw(painter, xMap, yMap, canvasRect) {
    var d_data = this.dataRasterItemPrivateData();
    if (canvasRect.isEmpty() || d_data.alpha == 0) return;

    var doCache = PlotRasterItem.useCache(d_data.cache.policy, painter);

    var area = ScaleMap.invTransform_Rect(xMap, yMap, canvasRect);

    var paintRectAsSize = new Misc.Size(
      canvasRect.width(),
      canvasRect.height()
    );
    var image = this.compose(
      xMap,
      yMap,
      area,
      canvasRect,
      paintRectAsSize,
      doCache
    );
    if (image.isNull()) return;

    painter.save();

    painter.drawImage(image, canvasRect);

    painter.restore();
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link PlotRasterItem.CachePolicy}</div>
 *
 * Cache policy The default policy is NoCache.
 * @name PlotRasterItem.CachePolicy
 * @readonly
 * @property {Number} NoCache               renderImage() is called each time the item has to be repainted.
 * @property {Number} PaintCache           renderImage() is called, whenever the image cache is not valid, or the scales, or the size of the canvas has changed. This type of cache is useful for improving the performance of hide/show operations or manipulations of the alpha value. All other situations are handled by the canvas backing store
 */
Enumerator.enum("CachePolicy {NoCache = 0, PaintCache = 1}", PlotRasterItem);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link PlotRasterItem.PaintAttribute}</div>
 *
 * Attributes to modify the drawing algorithm.
 * @name PlotRasterItem.PaintAttribute
 * @readonly
 * @property {Number} PaintInDeviceResolution               When the image is rendered according to the data pixels ( QwtRasterData::pixelHint() ) it can be expanded to paint device resolution before it is passed to QPainter. The expansion algorithm rounds the pixel borders in the same way as the axis ticks, what is usually better than the scaling algorithm implemented in Qt. Disabling this flag might make sense, to reduce the size of a document/file. If this is possible for a document format depends on the implementation of the specific QPaintEngine.
 */
Enumerator.enum("PaintAttribute {PaintInDeviceResolution = 1}", PlotRasterItem);

define("plotRasterItem", ["static","plotItem"], function(){});



Static.XAxis = 0;
Static.YAxis = 1;
Static.ZAxis = 2;

/**
 * A plot item, which displays a spectrogram.
 * A spectrogram displays 3-dimensional data, where the 3rd dimension ( the intensity ) is displayed using colors. The colors are calculated from the values using a color map.
 * On multi-core systems the performance of the image composition can often be improved by dividing the area into tiles - each of them rendered in a different thread ( see QwtPlotItem::setRenderThreadCount() ).
 * In ContourMode contour lines are painted for the contour levels.
 */
class PlotSpectrogram extends PlotRasterItem {
  /**
   *
   * @param {String} tle Title of the spectrogram
   */
  constructor(tle) {
    super(tle);

    class PrivateData {
      constructor() {
        /* QwtRasterData */
        this.data = null;
        this.colorMap = new LinearColorMap();
        this.displayMode = PlotSpectrogram.DisplayMode.ImageMode;
        this.contourLevels = [];
        this.defaultContourPen = new Misc.Pen();
        this.numberOfContourPlanes = 10;
      }
    }
    var self = this;
    var gridSzX = 80;
    var gridSzY = 80;
    var d_data = new PrivateData();
    this.privateData = function () {
      return d_data;
    };

    this.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
    this.setItemAttribute(PlotItem.ItemAttribute.Legend, false);

    this.setZ(8.0);

    this.rtti = PlotItem.RttiValues.Rtti_PlotSpectrogram;

    /**
     * The display mode controls how the raster data will be represented.
     * @param {PlotSpectrogram.DisplayMode} mode Display mode
     * @param {Boolean} on On/Off
     * @see {@link PlotSpectrogram.DisplayMode DisplayMode}
     */
    this.setDisplayMode = function (mode, on) {
      if (on != (mode & d_data.displayMode)) {
        if (on) d_data.displayMode |= mode;
        else d_data.displayMode &= ~mode;

        this.legendChanged();
        this.itemChanged();
      }

      /* this.legendChanged();
            this.itemChanged(); */
    };

    /**
     * The display mode controls how the raster data will be represented.
     * @param {PlotSpectrogram.DisplayMode} mode Display mode
     * @returns {Boolean} true if mode is enabled
     */
    this.testDisplayMode = function (mode) {
      return d_data.displayMode & mode;
    };

    /**
     * Change the color map
     * Often it is useful to display the mapping between intensities and
     * colors as an additional plot axis, showing a color bar.
     * @param {ColorMap} colorMap Color Map
     */
    this.setColorMap = function (colorMap) {
      if (d_data.colorMap != colorMap) {
        d_data.colorMap = colorMap;
      }

      this.invalidateCache();

      this.legendChanged();
      this.itemChanged();
    };

    /**
     *
     * @returns {ColorMap} Color Map used for mapping the intensity values to colors
     * @see {@link PlotSpectrogram#setColorMap setColorMap()}
     */
    this.colorMap = function () {
      return d_data.colorMap;
    };

    /**
     * Set the default pen for the contour lines
     * @param {Misc.Pen|String} color Pen or color
     * @param {Number} [width] Pen width
     * @param {String} [style] Pen style
     * @see {@link PlotSpectrogram#defaultContourPen defaultContourPen()}
     * @see {@link PlotSpectrogram#contourPen contourPen()}
     */
    this.setDefaultContourPen = function (color, width, style) {
      var pen = color;
      if (typeof pen !== "object") pen = new Misc.Pen(color, width, style);
      doSetDefaultContourPen(pen);
    };

    function doSetDefaultContourPen(pen) {
      if (!pen.isEqual(d_data.defaultContourPen)) {
        d_data.defaultContourPen = pen;
        self.legendChanged();
        self.itemChanged();
      }
    }

    /**
     *
     * @returns {Misc.Pen} Default contour pen
     * @see {@link PlotSpectrogram#setDefaultContourPen setDefaultContourPen()}
     */
    this.defaultContourPen = function () {
      return d_data.defaultContourPen;
    };

    /**
     * Calculate the pen for a contour line
     * contourPen is only used if defaultContourPen().style == Static.NoPen
     * @param {Number} level Contour level
     * @returns {Misc.Pen} Pen for the contour line
     * @see {@link PlotSpectrogram#setDefaultContourPen setDefaultContourPen()}
     * @see {@link PlotSpectrogram#setColorMap setColorMap()}
     * @see {@link PlotSpectrogram#setContourLevels setContourLevels()}
     */
    this.contourPen = function (level) {
      if (d_data.data == null || d_data.colorMap == null) return new Misc.Pen();

      var intensityRange = d_data.data.interval(Static.ZAxis);
      var c = d_data.colorMap.rgb(intensityRange, level);

      return new Misc.Pen(c.toString());
    };

    /**
     * Calculate the levels of the contour lines
     *
     * {@link PlotSpectrogram#contourLevels contourLevels()} returns the same levels but sorted.
     * @param {Number} numberOfPlanes The number of contour planes
     * @param {Number} minZ lowest point
     * @param {Number} maxZ highest point
     * @returns {Array<Number>} array of levels
     */
    this.calculateContourLevels = function (numberOfPlanes, minZ, maxZ) {
      if (numberOfPlanes < 1) return [];
      var zInterval = d_data.data.interval(Static.ZAxis);
      if (minZ == undefined) {
        minZ = zInterval.minValue();
        maxZ = zInterval.maxValue();
      }

      var cI = /* Math.round */ (maxZ - minZ) / numberOfPlanes;

      var contourLevels = [];

      for (var level = minZ + 0.5 * cI; level < maxZ; level += cI)
        contourLevels.push(level);

      return contourLevels;
    };

    let numberOfContourPlanes = 10;

    /**
     *
     * @returns {Number} The number of contour planes
     */
    this.numberOfContourPlanes = function () {
      return numberOfContourPlanes;
    };

    this.setNumberOfContourPlanes = function (numberOfPlanes) {
      numberOfContourPlanes = numberOfPlanes;
      this.setContourLevels(this.calculateContourLevels(numberOfPlanes));
    };

    /**
     * Set the levels of the contour lines
     *
     * {@link PlotSpectrogram#contourLevels contourLevels()} returns the same levels but sorted.
     * @param {Array<Number>} levels Values of the contour levels
     */
    this.setContourLevels = function (/* const QList<double> & */ levels) {
      d_data.contourLevels = levels;
      _.sortBy(d_data.contourLevels);

      this.legendChanged();
      this.itemChanged();
    };

    /**
     * The levels are sorted in increasing order.
     * @returns {Array<Number>} Levels of the contour lines.
     */
    this.contourLevels = function () {
      return d_data.contourLevels;
    };

    /**
     * Set the data to be displayed
     * @param {object} data Spectrogram Data
     */
    this.setData = function (/* QwtRasterData * */ data) {
      if (data != d_data.data) {
        d_data.data = data;

        this.invalidateCache();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {object} Spectrogram data
     */
    this.data = function () {
      return d_data.data;
    };

    /**
     * The default implementation returns the interval of the associated raster data object.
     * @param {Number} axis X, Y, or Z axis
     * @returns {Interval} Bounding interval for an axis
     */
    this.interval = function (/* Qt::Axis */ axis) {
      if (d_data.data == null) return new Interval();

      return d_data.data.interval(axis);
    };

    /**
     * Render an image from data and color map.
     * For each pixel of area the value is mapped into a color.
     * @param {ScaleMap} xMap X-Scale Map
     * @param {ScaleMap} yMap Y-Scale Map
     * @param {Misc.Rect} area Requested area for the image in scale coordinates
     * @param {Misc.Size} imageSize Size of the requested image
     * @returns {Misc.Image} An Image
     */
    this.renderImage = function (xMap, yMap, area, imageSize) {
      if (
        imageSize.isEmpty() ||
        d_data.data == null ||
        d_data.colorMap == null
      ) {
        return new Misc.Image();
      }

      var intensityRange = d_data.data.interval(Static.ZAxis);
      if (!intensityRange.isValid()) return new Misc.Image();

      var image = new Misc.Image(imageSize);

      if (d_data.colorMap.format() == ColorMap.Format.Indexed)
        image.setColorTable(d_data.colorMap.colorTable(intensityRange));

      //d_data.data.initRaster(area, image.size());

      var tile = new Misc.Rect(0, 0, imageSize.width, imageSize.height);
      this.renderTile(xMap, yMap, tile, image);

      //d_data.data.discardRaster();

      return image;
    };

    /**
     * Render a tile of an image.
     * Rendering in tiles can be used to composite an image
     * We always use the default alpha value of 255
     * @param {ScaleMap} xMap X-Scale Map
     * @param {ScaleMap} yMap Y-Scale Map
     * @param {Misc.Rect} tile Geometry of the tile in image coordinates
     * @param {Misc.Image} image Image to be rendered
     *
     */
    this.renderTile = function (xMap, yMap, tile, image) {
      //console.time();
      var range = d_data.data.interval(Static.ZAxis);
      if (!range.isValid()) return;

      var extraPixelW = this.pixelSize().width - 1;
      var extraPixelH = this.pixelSize().height - 1;

      var incrementW = extraPixelW + 1;
      var incrementH = extraPixelH + 1;

      var y,
        x,
        top = tile.top(), //+ extraPixelH,
        bottom = tile.bottom(),
        left = tile.left(), // + extraPixelW,
        right = tile.right();

      if (d_data.colorMap.format() == ColorMap.Format.RGB) {
        for (y = top; y < bottom; y += incrementH) {
          var ty = yMap.invTransform(y);

          for (x = left; x < right; x += incrementW) {
            var tx = xMap.invTransform(x);
            var rgba = d_data.colorMap.rgb(range, d_data.data.value(tx, ty));
            rgba.a = this.alpha(); //the default alpha value of 255
            for (var yy = extraPixelH; yy >= 0; --yy) {
              for (var xx = extraPixelW; xx >= 0; --xx) {
                image.setPixel(
                  x + xx - extraPixelW,
                  y + yy - extraPixelH,
                  rgba
                );
              }
            }
          }
        }
      } else if (d_data.colorMap.format() == ColorMap.Format.Indexed) {
        for (y = top; y < bottom; y += incrementH) {
          var ty = yMap.invTransform(y);

          for (x = left; x < right; x += incrementW) {
            var tx = xMap.invTransform(x);
            var rgba = image.pixel(
              d_data.colorMap.colorIndex(range, d_data.data.value(tx, ty))
            );
            rgba.a = this.alpha(); //the default alpha value of 255
            for (var yy = extraPixelH; yy >= 0; --yy) {
              for (var xx = extraPixelW; xx >= 0; --xx) {
                image.setPixel(
                  x + xx - extraPixelW,
                  y + yy - extraPixelH,
                  rgba
                );
              }
            }
          }
        }
      }
      //console.timeEnd();
    };

    /**
     * Calculate and draw contour lines
     * @param {PaintUtil.Painter} painter
     * @param {ScaleMap} xMap X-Scale Map
     * @param {ScaleMap} yMap Y-Scale Map
     *
     */
    this.renderContourLines = function (painter, xMap, yMap) {
      function drawContour(startX, startY, endX, endY, contourLevel, k) {
        var pen = self.defaultContourPen();
        if (pen.style == Static.NoPen) pen = self.contourPen(contourLevel);

        if (pen.style == Static.NoPen) return;

        painter.setPen(pen);
        painter.drawLine(
          xMap.transform(startX),
          yMap.transform(startY),
          xMap.transform(endX),
          yMap.transform(endY)
        );
      }

      if (d_data.data == null) return;
      var levels = d_data.contourLevels;
      var data = d_data.data.contourLinesData(/* levels,  */ gridSzX, gridSzY);
      var c = new Conrec(drawContour);
      c.contour(
        data.d,
        0,
        data.x.length - 1,
        0,
        data.y.length - 1,
        data.x,
        data.y,
        levels.length,
        levels
      );
    };
  }

  /**
   * Draw the spectrogram
   * @param {ScaleMap} xMap Maps x-values into pixel coordinates.
   * @param {ScaleMap} yMap Maps y-values into pixel coordinates.
   * @see {@link PlotSpectrogram#setDisplayMode setDisplayMode()}
   * @see {@link PlotSpectrogram#renderImage renderImage()}
   * @see {@link PlotSpectrogram#renderContourLines renderContourLines()}
   * @see {@link PlotRasterItem#draw PlotRasterItem.draw()}
   */
  draw(xMap, yMap) {
    var d_data = this.privateData();
    var canvasRect = this.getCanvasRect();
    var painter = new PaintUtil.Painter(this);
    if (d_data.displayMode & PlotSpectrogram.DisplayMode.ImageMode)
      super.draw(painter, xMap, yMap, canvasRect);

    if (d_data.displayMode & PlotSpectrogram.DisplayMode.ContourMode) {
      var area = ScaleMap.invTransform_Rect(xMap, yMap, canvasRect);

      var br = this.boundingRect();

      if (br.isValid()) {
        area.united(br);
        if (area.isEmpty()) return;
      }
      this.renderContourLines(painter, xMap, yMap, canvasRect);
    }
  }
}

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link PlotSpectrogram.DisplayMode}</div>
 *
 * The display mode controls how the raster data will be represented.
 * @name PlotSpectrogram.DisplayMode
 * @readonly
 * @property {Number} ImageMode               The values are mapped to colors using a color map.
 * @property {Number} ContourMode             The data is displayed using contour lines
 */
Enumerator.enum(
  "DisplayMode {ImageMode = 0x01 /* The values are mapped to colors using a color map*/, ContourMode = 0x02 /* The data is displayed using contour lines */}",
  PlotSpectrogram
);

define("plotSpectrogram", ["static","conrec","plotRasterItem"], function(){});



class ColorStop {
  constructor(p, c) {
    this.pos;
    this.m_rgb;
    //var r, g, b, a;
    /*this.r
        this.g
        this.b
        this.a*/

    // precalculated values
    //var rStep, gStep, bStep, aStep;
    /*this.r0
        this.g0
        this.b0
        this.a0
        this.posStep;*/

    if (p == undefined) {
      this.pos = 0.0;
      this.m_rgb = 0;
    } else {
      this.pos = p;
      this.m_rgb = c;
      if (c.indexOf("#") !== -1) this.m_rgb = Utility.HTMLToRGB(c);
      this.r = this.m_rgb.r;
      this.g = this.m_rgb.g;
      this.b = this.m_rgb.b;
      this.a = this.m_rgb.a; //qAlpha( rgb );
      if (this.a === undefined) this.a = 255;

      /*
            when mapping a value to rgb we will have to calcualate:
            - const int v = int( ( s1.v0 + ratio * s1.vStep ) + 0.5 );

            Thus adding 0.5 ( for rounding ) can be done in advance
             */
      this.r0 = this.r + 0.5;
      this.g0 = this.g + 0.5;
      this.b0 = this.b + 0.5;
      this.a0 = this.a + 0.5;

      this.rStep = 0.0;
      this.gStep = 0.0;
      this.bStep = 0.0;
      this.aStep = 0.0;
      this.posStep = 0.0;
    }

    this.updateSteps = function (nextStop) {
      this.rStep = nextStop.r - this.r;
      this.gStep = nextStop.g - this.g;
      this.bStep = nextStop.b - this.b;
      this.aStep = nextStop.a - this.a;
      this.posStep = nextStop.pos - this.pos;
    };
  }
}

class ColorStops {
  constructor() {
    var m_doAlpha = false;
    var m_stops = []; //new Array(256);

    this.findUpper = function (pos) {
      var index = 0;
      var n = m_stops.length;

      while (n > 0) {
        var half = n >> 1;
        var middle = index + half;

        if (m_stops[middle].pos <= pos) {
          index = middle + 1;
          n -= half + 1;
        } else n = half;
      }
      return index;
    };

    this.insert = function (pos, color) {
      // Lookups need to be very fast, insertions are not so important.
      // Anyway, a balanced tree is what we need here. TODO ...
      if (color[0] !== "#") color = Utility.colorNameToHex(color);

      if (pos < 0.0 || pos > 1.0) return;

      var index;
      if (m_stops.length == 0) {
        index = 0;
        m_stops.resize(1);
      } else {
        index = this.findUpper(pos);
        if (
          index == m_stops.length ||
          Math.abs(m_stops[index].pos - pos) >= 0.001
        ) {
          m_stops.resize(m_stops.length + 1);
          for (var i = m_stops.length - 1; i > index; i--)
            m_stops[i] = m_stops[i - 1];
        }
      }

      m_stops[index] = new ColorStop(pos, color);
      if (color.alpha != 255) m_doAlpha = true;

      if (index > 0) m_stops[index - 1].updateSteps(m_stops[index]);

      if (index < m_stops.length - 1)
        m_stops[index].updateSteps(m_stops[index + 1]);
    };

    this.rgb = function (mode, pos) {
      if (pos <= 0.0) return m_stops[0].m_rgb;
      if (pos >= 1.0) return m_stops[m_stops.length - 1].m_rgb;

      var index = this.findUpper(pos);
      if (mode == LinearColorMap.Mode.FixedColors) {
        return m_stops[index - 1].m_rgb;
      } else {
        var s1 = m_stops[index - 1];

        var ratio = (pos - s1.pos) / s1.posStep;

        var r = Math.round(s1.r0 + ratio * s1.rStep);
        var g = Math.round(s1.g0 + ratio * s1.gStep);
        var b = Math.round(s1.b0 + ratio * s1.bStep);

        if (m_doAlpha) {
          if (s1.aStep) {
            var a = s1.a0 + ratio * s1.aStep;
            return Utility.mRgba(r, g, b, a);
          } else {
            return Utility.mRgba(r, g, b, s1.a);
          }
        }
        return Utility.mRgb(r, g, b);
      }
    };

    this.stops = function () {
      var positions = new Array(m_stops.length);
      for (var i = 0; i < m_stops.length; i++) positions[i] = m_stops[i].pos;
      return positions;
    };
  }
}

/**
 * ColorMap is an abstract class used to map values into colors.
 *
 * For displaying 3D data on a 2D plane the 3rd dimension is often displayed using
 * colors, like, for example, in a spectrogram. Each color map is optimized to return
 * colors for only one of the following image formats: ColorMap.Format.RGB or ColorMap.Format.Indexed.
 * @abstract
 *
 */
class ColorMap {
  /**
   *
   * @param {ColorMap.Format} [format=ColorMap.Format.RGB] Format of the color map
   */
  constructor(format = ColorMap.Format.RGB) {
    Utility.makeAbstract(this, ColorMap);
    var m_format = format;

    this.format = function () {
      return m_format;
    };

    /**
     * Set the format of the color map
     *
     * @param {ColorMap.Format} format Format of the color map.
     * @inheritdoc
     *
     */
    this.setFormat = function (format) {
      m_format = format;
    };

    /**
     *
     * Map a value of a given interval into a color index.
     *
     * @param {Number} numColors Number of colors
     * @param {Interval} interval Range for all values
     * @param {Number} value Value to map into a color index
     */
    this.colorIndex = function (numColors, interval, value) {
      var width = interval.width();
      if (width <= 0.0) return 0;

      if (value <= interval.minValue()) return 0;

      var maxIndex = numColors - 1;
      if (value >= interval.maxValue()) return maxIndex;

      var v = maxIndex * ((value - interval.minValue()) / width);
      return v + 0.5;
    };

    /**
     * Build and return a color map of 256 colors.
     *
     * The color table is needed for rendering indexed images in combination with using{@link ColorMap#colorIndex colorIndex()}.
     * @param {Interval} interval Range for the values
     * @returns {} A color table, that can be used for a Image
     * @inheritdoc
     *
     */
    this.colorTable = function (interval) {
      var table = new Array(256);
      if (interval.isValid()) {
        var step = interval.width() / (table.length - 1);
        for (var i = 0; i < table.length; i++)
          table[i] = this.rgb(interval, interval.minValue() + step * i);
      }
      return table;
    };

    /**
     * This is a pure virtual method that must be reimplement by the subclass.
     *
     * Maps a value of a given interval into a RGB value.
     *
     * @param {Interval} interval Range for all values.
     * @param {Number} value Value to map into a RGB value.
     * @returns {object} An object such as {red:255, g:0, b:0} represnting a RGB color for the value.
     *
     */
    this.rgb = function (interval, value) {
      //pure virtual method. Makes the class an abstract class
    };
  }
  /**
   *
   * @returns {String} A string representing the object.
   */
  toString() {
    return "[ColorMap]";
  }
}
/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link ColorMap.Format}</div>
 *
 * Format for color mapping
 * @name ColorMap.Format
 * @readonly
 * @property {Number} RGB               The map is intended to map into RGB values.
 * @property {Number} Indexed           Map values into 8 bit values, that are used as indexes into the color table. Indexed
 *                                      color maps are used to generate ColorMap.Format.Indexed images. The calculation of the
 *                                      color index is usually faster and the resulting image has a lower memory footprint.
 * @see {@link ColorMap#colorIndex colorIndex()}
 * @see {@link ColorMap#colorTable colorTable()}
 *
 */
Enumerator.enum("Format { RGB , Indexed }", ColorMap);

/**
 * Builds a color map from color stops.
 *
 * A color stop is a color at a specific position. The valid range for the positions is [0.0, 1.0]. When mapping a value into
 * a color it is translated into this interval according to mode().
 *
 * @extends ColorMap
 *
 */
class LinearColorMap extends ColorMap {
  /**
   * Build a color map with two stops at 0.0 and 1.0. If one or no arguments are provided, the color at 0.0 and 1.0 is
   * blue and yellow respectively.
   *
   * The overloaded version: <strong><i>LinearColorMap(format = ColorMap.Format.RGB).</i></strong>
   * Thus, you may provide one or no arguments. "#0000FF" and "#FFFF00" are used as color1 and color2 respectively.
   *
   *
   * @param {string|object} [color1]    Color used for the minimum value of the value interval. This could be a string
   *                                  representing a color (e.g "red", "#ff0000", "rgb(255, 0, 0)", etc.) or an object
   *                                  representing a RGB color (e.g. {red:255, g:0, b:0})
   * @param {string|object} [color2]    Color used for the maximum value of the value interval. This could be a string
   *                                  representing a color (e.g "red", "#ff0000", "rgb(255, 0, 0)", etc.) or an object
   *                                  representing a RGB color (e.g. {red:255, g:0, b:0})
   * @param {ColorMap.Format} [format=ColorMap.Format.RGB] 	Preferred format for the color map.
   *
   *
   */
  constructor(color1, color2, format) {
    var singleParam = format == undefined;
    if (singleParam) format = color1;
    super(format);

    var m_colorStops;

    this.m_mode = LinearColorMap.Mode.ScaledColors;

    /**
     * Set the color range
     *
     * Add stops at 0.0 and 1.0.
     * @param {string|object} color1    Color used for the minimum value of the value interval. This could be a string
     *                                  representing a color (e.g "red", "#ff0000", "rgb(255, 0, 0)", etc.) or an object
     *                                  representing a RGB color (e.g. {red:255, g:0, b:0})
     * @param {string|object} color2    Color used for the minimum value of the value interval. This could be a string
     *                                  representing a color (e.g "red", "#ff0000", "rgb(255, 0, 0)", etc.) or an object
     *                                  representing a RGB color (e.g. {red:255, g:0, b:0})
     * @see {@link LinearColorMap#color1 color1()}
     * @see {@link LinearColorMap#color1 color1()}
     */
    this.setColorInterval = function (color1, color2) {
      m_colorStops = new ColorStops();
      m_colorStops.insert(0.0, color1);
      m_colorStops.insert(1.0, color2);
    };

    if (!singleParam) this.setColorInterval(color1, color2);
    else this.setColorInterval("#0000FF", "#FFFF00"); //blue, yellow

    /**
     * Set the mode of the color map
     *
     * FixedColors means the color is calculated from the next lower color stop. ScaledColors means the color is calculated
     * by interpolating the colors of the adjacent stops.
     * @param {LinearColorMap.Mode} mode The mode.
     * @see {@link LinearColorMap#mode mode()}
     */
    this.setMode = function (mode) {
      this.m_mode = mode;
    };

    /**
     *
     * @returns {LinearColorMap.Mode} Mode of the color map
     * @see {@link LinearColorMap#setMode setMode()}
     */
    this.mode = function () {
      return this.m_mode;
    };

    /**
     * Add a color stop
     *
     * The value has to be in the range [0.0, 1.0]. For example, a stop at position 17.0 for a range [10.0,20.0] must be
     * passed as: (17.0 - 10.0) / (20.0 - 10.0)
     * @param {Number} value Value between [0.0, 1.0]
     * @param {string|object} color     Color stop. This could be a string representing a color (e.g "red", "#ff0000",
     *                                  "rgb(255, 0, 0)", etc.) or an object representing a RGB color (e.g. {red:255, g:0, b:0})
     */
    this.addColorStop = function (value, color) {
      if (value >= 0.0 && value <= 1.0) m_colorStops.insert(value, color);
    };

    /**
     *
     * @returns {Array<number>} Positions of color stops in increasing order
     */
    this.colorStops = function () {
      return m_colorStops.stops();
    };

    /**
     *
     * @returns {object}    An object such as {red:255, g:0, b:0} represnting a RGB color that is the first color of the
     *                      color range.
     * @see {@link LinearColorMap#setColorInterval setColorInterval()}
     */
    this.color1 = function () {
      return m_colorStops.rgb(this.m_mode, 0.0);
    };

    /**
     *
     * @returns {object}    An object such as {red:255, g:0, b:0} represnting a RGB color that is the second color of the
     *                      color range.
     * @see {@link LinearColorMap#setColorInterval setColorInterval()}
     */
    this.color2 = function () {
      return m_colorStops.rgb(this.m_mode, 1.0);
    };

    this.rgb = function (interval, value) {
      if (isNaN(value)) return 0; //0u;

      var width = interval.width();
      if (width <= 0.0) return 0; //0u;

      var ratio = (value - interval.minValue()) / width;
      return m_colorStops.rgb(this.m_mode, ratio);
    };

    //Use base class doc.
    this.colorIndex = function (interval, value) {
      var width = interval.width();

      if (isNaN(value) || width <= 0.0 || value <= interval.minValue())
        return 0;

      if (value >= interval.maxValue()) return 255;

      var ratio = (value - interval.minValue()) / width;

      var index;
      if (this.m_mode == LinearColorMap.Mode.FixedColors)
        index = /*static_cast<unsigned char>*/ ratio * 255;
      // always floor
      else index = /*static_cast<unsigned char>*/ ratio * 255 + 0.5;

      return index;
    };
  }
  /**
   * 
   * @returns {String} A string representing the object.
.
   */
  toString() {
    return "[LinearColorMap]";
  }
}
/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link LinearColorMap.Mode}</div>
 *
 * Mode of color map
 * @name LinearColorMap.Mode
 * @readonly
 * @property {Number} FixedColors             Return the color from the next lower color stop
 * @property {Number} ScaledColors            Interpolating the colors of the adjacent stops.
 * @see {@link LinearColorMap#setMode setMode()}
 */
Enumerator.enum("Mode { FixedColors , ScaledColors }", LinearColorMap);

define("colorMap", ["static"], function(){});

/**
 * RasterData defines an interface to any type of raster data.
 *
 * RasterData is an abstract interface, that is used by PlotRasterItem to find the values at the pixels of its raster.
 *
 *
 */
class RasterData {
  constructor() {
    var d_intervals = [null, null, null];

    /**
     * Sets the bounding interval for the x, y or z coordinates.
     * @param {Axis.AxisId} axis Axis
     * @param {Interval} interval Bounding interval
     * @see {@link RasterData#interval interval()}
     */
    this.setInterval = function (axis, interval) {
      d_intervals[axis] = interval;
    };

    /**
     *
     * @param {Axis.AxisId} axis Axis
     * @returns {Interval} Bounding interval for an axis
     * @see {@link RasterData#setInterval setInterval()}
     */
    this.interval = function (axis) {
      return d_intervals[axis];
    };

    /**
     * Build contour data object. The properties of the object are:
     * - d: Array of Array of Number (the value at the intersection a column and row. This is the z value for the (x, y, z) sample).
     * - x: Array of Number (x values. This is the x value for the (x, y, z) sample)
     * - y: Array of Number (y values. This is the y value for the (x, y, z) sample)
     *
     * A valid 3D sample, for example, is `(x[2], y[4], d[2][4])`
     *
     * @param {Number} gridSizeX Number of columns in grid
     * @param {Number} gridSizeY Number of rows in grid
     * @returns {object} contour data object
     */
    this.contourLinesData = function (gridSizeX, gridSizeY) {
      var gridSzX = gridSizeX || 100;
      var gridSzY = gridSizeY || 100;
      var intervalX = this.interval(Static.XAxis);
      var intervalY = this.interval(Static.YAxis);
      var dx = intervalX.width() / (gridSzX - 1);
      var dy = intervalY.width() / (gridSzY - 1);
      var x = [];
      var xMin = intervalX.minValue();
      var y = [];
      var yMin = intervalY.minValue();

      for (var i = 0; i < gridSzX; i++) {
        x.push(xMin + i * dx);
      }
      for (var i = 0; i < gridSzY; i++) {
        y.push(yMin + i * dy);
      }
      //Correct last point
      x[gridSzX - 1] = intervalX.maxValue();
      y[gridSzY - 1] = intervalY.maxValue();

      var d = []; //array of arrarys

      for (var xi = 0; xi < x.length; xi++) {
        var col = [];
        for (var yi = 0; yi < y.length; yi++) {
          col.push(this.value(x[xi], y[yi]));
        }
        d.push(col);
      }
      return { d: d, x: x, y: y };
    };
  }

  value(x, y) {}
}
;
define("rasterData", function(){});

"include ['rasterData']";


class RasterFileData extends RasterData {
  constructor(fileData) {
    RasterFileData.InterpolationType = { cubic: 0, linear: 1 };
    super();
    this._interpolationType = RasterFileData.InterpolationType.linear;
    var arr = fileData.array;
    this.samples3D = [];
    var columnX;

    var columnLen = 0,
      i,
      n = arr.length;
    for (i = 0; i < n; i++) {
      if (i == 0) {
        columnX = arr[i].x;
        columnLen++;
        continue;
      }
      if (columnX === arr[i].x) {
        columnLen++;
      } else {
        break;
      }
    }
    this.samples3D = _.chunk(arr, columnLen);

    this.minX = this.samples3D[0][0].x;
    this.maxX = this.samples3D[this.samples3D.length - 1][0].x;
    var col0 = this.samples3D[0];
    this.minY = col0[0].y;
    this.maxY = col0[col0.length - 1].y;
    this.setInterval(Static.XAxis, new Interval(this.minX, this.maxX));
    this.setInterval(Static.YAxis, new Interval(this.minY, this.maxY));
    this.setInterval(Static.ZAxis, new Interval(fileData.minZ, fileData.maxZ));
  }

  interpolaionType() {
    return this._interpolationType;
  }

  setInterpolaionType(type) {
    if (
      type < RasterFileData.InterpolationType.cubic ||
      type > RasterFileData.InterpolationType.linear
    )
      return;
    this._interpolationType = type;
  }

  value(x, y) {
    //prevent out-of-range
    if (x > this.maxX) x = this.maxX;
    if (x < this.minX) x = this.minX;
    if (y > this.maxY) y = this.maxY;
    if (y < this.minY) y = this.minY;

    if (this.interpolaionType() == RasterFileData.InterpolationType.cubic)
      return Utility.bicubicInterpolate(this.samples3D, x, y);
    else if (this.interpolaionType() == RasterFileData.InterpolationType.linear)
      return Utility.bilinearInterpolate(this.samples3D, x, y);
  }
}

Enumerator.enum("InterpolationType {cubic, linear}", RasterFileData);

define("rasterFileData", ["rasterData"], function(){});

"include ['rasterData']";


class RasterFunctionData extends RasterData {
  constructor(functionData) {
    super();
    var fn = functionData.fx;
    fn = fn.replaceAll(functionData.variable, "_x");
    fn = fn.replaceAll(functionData.variableY, "_y");

    this.parser = new EvaluateExp(fn);
    if (this.parser.error) {
      Utility.alert(this.parser.errorMessage);
      return null;
    }

    this.minX = functionData.minX;
    this.maxX = functionData.maxX;
    this.minY = functionData.minY;
    this.maxY = functionData.maxY;
    this.setInterval(Static.XAxis, new Interval(this.minX, this.maxX));
    this.setInterval(Static.YAxis, new Interval(this.minY, this.maxY));
    this.setInterval(
      Static.ZAxis,
      new Interval(functionData.minZ, functionData.maxZ)
    );
  }

  value(x, y) {
    //prevent out-of-range
    if (x >= this.maxX) x = this.maxX;
    if (x < this.minX) x = this.minX;
    if (y >= this.maxY) y = this.maxY;
    if (y < this.minY) y = this.minY;

    return this.parser.eval({ _x: x, _y: y });
  }
}
;
define("rasterFunctionData", ["rasterData"], function(){});



"include ['static', 'plotSpectrogram', 'colorMap', 'rasterFileData', 'rasterFunctionData']";

class LinearColorMapRGB extends LinearColorMap {
  constructor() {
    super(ColorMap.Format.RGB);
    this.setColorInterval("darkCyan", "red");
    this.addColorStop(0.1, "cyan");
    this.addColorStop(0.6, "green");
    this.addColorStop(0.95, "yellow");
  }
}

class LinearColorMapIndexed extends LinearColorMap {
  constructor() {
    super(ColorMap.Format.Indexed);
    this.setColorInterval("darkCyan", "red");
    this.addColorStop(0.1, "cyan");
    this.addColorStop(0.6, "green");
    this.addColorStop(0.95, "yellow");
  }
}

class Spectrogram extends PlotSpectrogram {
  constructor(title) {
    super(title);
    var self = this;
    // let Enum = {};
    // Enum.ColorMap = {
    //   RGBMap: 0,
    //   IndexMap: 1,
    //   HueMap: 2,
    //   AlphaMap: 3,
    // };

    var d_alpha = 255;
    var d_mapType;

    self.setColorMap(new LinearColorMapRGB());
    //self->setRenderThreadCount( 0 ); // use system specific thread count
    self.setAlpha(d_alpha);
    self.setCachePolicy(PlotRasterItem.CachePolicy.PaintCache);
    /* QList<double> */ var contourLevels = [];
    for (var level = 0.5; level < 10.0; level += 1.0) contourLevels.push(level);
    self.setContourLevels(contourLevels);

    this.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
    //this.setLegendAttribute(Static.LegendCheckable, false)

    //self.setData( new SpectrogramData() );
    //var zInterval = self.data().interval( Static.ZAxis );

    /* // A color bar on the right axis
			var rightAxis = this.axisWidget( Axis.AxisId.yRight );
			rightAxis.setTitle( "Intensity" ); */
    //rightAxis.setColorBarEnabled( true );

    /* this.setAxisScale( Axis.AxisId.yRight, zInterval.minValue(), zInterval.maxValue() );
			this.enableAxis( Axis.AxisId.yRight, true );
			
			

			//plotLayout()->setAlignCanvasToScales( true );

			//setColorMap( Plot::RGBMap );
			
			// LeftButton for the zooming
			// MidButton for the panning
			// RightButton: zoom out by 1
			// Ctrl+RighButton: zoom out to full size
			
			/* var zoomer = new MyZoomer( this );
			zoomer.setMousePattern( EventPattern.MousePatternCode.MouseSelect2,
				Static.RightButton, Static.ControlModifier );
			zoomer.setMousePattern( EventPattern.MousePatternCode.MouseSelect3,
				Static.RightButton ); */

    /* var panner = new Panner( this );
			panner.enableAxis( Axis.AxisId.yRight, false );
			panner.setMouseButton( Static.MidButton ); */

    // Avoid jumping when labels with more/less digits
    // appear/disappear when scrolling vertically

    /* const QFontMetrics fm( axisWidget( QwtPlot::yLeft )->font() );
			QwtScaleDraw *sd = axisScaleDraw( QwtPlot::yLeft );
			sd->setMinimumExtent( fm.width( "100.00" ) ); */

    /* zoomer.setRubberBandPen( new Misc.Pen("darkBlue") );
			zoomer.setTrackerPen( new Misc.Pen("darkBlue") ); */

    //this.setPixelSize(new Misc.Size(2, 2));

    // Static.unbind("magnifyingEnd");
    // Static.unbind("magnifyingStart");

    const mgEnd = function () {
      self.setPixelSize(new Misc.Size(1, 1));
      self.itemChanged();
    };

    Static.bind("magnifyingEnd", mgEnd);

    const mgStart = function () {
      self.setPixelSize(new Misc.Size(3, 3));
    };

    Static.bind("magnifyingStart", mgStart);

    this.showContour = function (on) {
      this.setDisplayMode(PlotSpectrogram.DisplayMode.ContourMode, on);
      self.itemChanged();
    };

    this.showSpectrogram = function (on) {
      this.setDisplayMode(PlotSpectrogram.DisplayMode.ImageMode, on);
      this.setDefaultContourPen(
        on ? new Misc.Pen("black", 0) : new Misc.Pen(Static.NoPen)
      );
    };

    this.setSpectrogramColorMap = function (type) {
      var plot = this.plot();
      const autoReplot = plot.autoReplot();
      plot.setAutoReplot(false);
      var axis = plot.axisWidget(Axis.AxisId.yRight);
      var zInterval = this.data().interval(Static.ZAxis);

      d_mapType = type;

      var alpha = d_alpha;
      switch (type) {
        case Spectrogram.ColorMap.HueMap: {
          /* d_spectrogram->setColorMap( new HueColorMap() );
						axis->setColorMap( zInterval, new HueColorMap() );
						break; */
        }
        case Spectrogram.ColorMap.AlphaMap: {
          /* alpha = 255;
						d_spectrogram->setColorMap( new AlphaColorMap() );
						axis->setColorMap( zInterval, new AlphaColorMap() );
						break; */
        }
        case Spectrogram.ColorMap.IndexMap: {
          const oldColorMap = this.colorMap();
          const colorMap = new LinearColorMapIndexed();
          colorMap.setColorInterval(oldColorMap.color1(), oldColorMap.color2());
          colorMap.addColorStop(0.1, "cyan");
          colorMap.addColorStop(0.6, "green");
          colorMap.addColorStop(0.95, "yellow");
          this.setColorMap(colorMap);
          //axis.setColorMap( zInterval, new LinearColorMapIndexed() );
          break;
        }
        case Spectrogram.ColorMap.RGBMap:
        default: {
          const oldColorMap = this.colorMap();
          const colorMap = new LinearColorMapRGB();
          colorMap.setColorInterval(oldColorMap.color1(), oldColorMap.color2());
          colorMap.addColorStop(0.1, "cyan");
          colorMap.addColorStop(0.6, "green");
          colorMap.addColorStop(0.95, "yellow");
          this.setColorMap(colorMap);
        }
      }
      this.setSpectrogramAlpha(alpha);
      plot.setAutoReplot(autoReplot);

      self.itemChanged();
    };

    this.setSpectrogramAlpha = function (alpha) {
      //var plot = this.plot();
      // setting an alpha value doesn't make sense in combination
      // with a color map interpolating the alpha value

      d_alpha = alpha;
      if (d_mapType != Spectrogram.ColorMap.AlphaMap) {
        this.setAlpha(alpha);
        self.itemChanged();
      }
    };

    this.cleanUp = function () {
      Static.unbind("magnifyingEnd", mgEnd);
      Static.unbind("magnifyingStart", mgStart);
    };
  }

  delete() {
    this.cleanUp();
    super.delete(); //Call the base class
  }
}
Enumerator.enum("ColorMap {RGBMap, IndexMap, HueMap, AlphaMap}", Spectrogram);

class SpectrogramFileData extends RasterFileData {
  constructor(fileData) {
    super(fileData);
    this.setInterval(Static.ZAxis, new Interval(0.0, 10.0));
    //this.setInterpolaionType(Spectrogram.InterpolationType.linear)
  }
}

class SpectrogramFunctionData extends RasterFunctionData {
  constructor(functionData) {
    super(functionData);
    //this.setInterval( Static.ZAxis, new Interval( 0.0, 10.0 ) );
  }
}
;
define("spectrogram", ["static","plotSpectrogram","colorMap","rasterFileData","rasterFunctionData"], function(){});

"include ['myLegend', 'curveClosestPoint', 'plot', 'functionData', 'plotGrid', 'spectrogram']";

/*function decimalPlaces(num) {
  var match = (''+num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  if (!match) { return 0; }
  return Math.max(
       0,
       // Number of digits right of decimal point.
       (match[1] ? match[1].length : 0)
       // Adjust for scientific notation.
       - (match[2] ? +match[2] : 0));
}*/

class MyPlot extends Plot {
  constructor(plotDiv, plotTitle) {
    super(plotDiv, plotTitle);

    //fileSystemUIinit();
    var self = this;
    var m_curveShapeEnabledByPlotSettings = true;

    this.grid = new PlotGrid();

    this.fileSystemServices = null;

    Static.curvePropPane = 0;
    Static.plotPropPane = 1;
    Static.infoPropPane = 2;

    this.grid.attach(this);
    Utility.minorGridLines(this.grid, true);
    //console.log(this.grid)

    this.insertLegend(new MyLegend());
    this.enableLegend(true);

    /* var m_settings = new MSettings();        
        this.settings = function () {
          return m_settings;
        }
        m_settings.setPlot(this); */

    /* const constructors = {
      curveConstructor: MyCurve,
      markerConstructor: PlotMarker,
      //arrowSymbolConstructor: PointMarkerSymbol
    }; */

    //this.defines = new MDefines(this /* , constructors */);
    this.file = new MFile(this /* , constructors */);

    this.trashDlg = new Trash(this);

    this.transformation = new Transformation(this);

    this.markerDlg = new MMarkerDlg();
    this.pointEntryDlg = new MPointEntryDlg();
    this._functionDlg = new MFunctionDlg(this);

    this.curveFitDlg = new MCurveFitDlg();
    this.curveStyleDlg = new MCurveStyleDlg();
    //this.functionCombinationDlg = new FunctionCombinationDlg(this);
    this.axisDlg = new MAxisDlg();

    this.zoneDlg = new ZoneDlg();
    this.curveAttributeDlg = new MCurveLegendAttributeDlg();

    //this.curveSettings = new MCurveSettings(this);

    function getCoffsVal() {
      var result = [];
      var coeffs = self._functionDlg.coeffs || [];
      for (var i = 0; i < coeffs.length; ++i) {
        result.push(1.0);
      }
      return result;
    }
    this.addCurveInit = function (curve) {
      curve.coeffs = self._functionDlg.coeffs;
      curve.variable = self._functionDlg.variable;
      curve.parametric_variable = self._functionDlg.parametric_variable;
      curve.coeffsVal = getCoffsVal();
      //curve.fn = self._functionDlg.fn;
      curve.fn = self._functionDlg.expandedFn;
      curve.parametricFnX = self._functionDlg.expandedParametricFnX;
      curve.parametricFnY = self._functionDlg.expandedParametricFnY;
      curve.unboundedRange = self._functionDlg.unboundedRange;
      curve.lowerX = parseFloat(self._functionDlg.lowerLimit);
      curve.upperX = parseFloat(self._functionDlg.upperLimit);
      curve.numOfSamples = self._functionDlg.numOfPoints;
    };

    function addCurve(title, samples, upload, fn) {
      if (!samples || samples.length == 0) {
        return null;
      }
      if (self.findPlotCurve(title)) {
        Utility.alert(title + " already exist");
        return null;
      }

      var curve = new MyCurve(title);
      curve.expandedFn = fn;

      if (!upload) self.addCurveInit(curve);

      curve.setSamples(samples);
      curve.setPen(new Misc.Pen(Utility.randomColor()));
      self.curveAttributeDlg.defaultIconSize = new Misc.Size(
        curve.getLegendIconSize()
      );
      var attribute = "";
      if (Static.showline && Static.showsymbol) {
        attribute = "lineAndSymbol";
      } else if (Static.showline) {
        attribute = "line";
      } else if (Static.showsymbol) {
        attribute = "symbol";
      }
      Utility.setLegendAttribute(curve, attribute, curve.getLegendIconSize()); //attribute = "line" or "symbol" or "lineAndSymbol"

      curve.functionDlgData = getFunctionDlgData(curve.rtti);

      //curve.attach(self);
      //self.enableLegend(enabled);
      self.rv.setCurrentCurve(curve);
      if (self.sidebar) {
        self.sidebar.initSidebar();
        self.rv.refresh(); //Added 06/17/2020
      }
      return curve;
    }

    function addSpectrocurve(title, color1, color2, _data, upload) {
      var samples, minZ, maxZ;
      if (!upload) {
        samples = _data.data;
        minZ = _data.zLimits.min;
        maxZ = _data.zLimits.max;
      } else {
        samples = _data.array;
        minZ = _data.minZ;
        maxZ = _data.maxZ;
      }
      if (!samples || samples.length == 0) {
        return null;
      }
      if (self.findPlotCurve(title)) {
        Utility.alert(title + " already exist");
        return null;
      }
      var curve = new SpectroCurve(title);
      curve.minZ = minZ;
      curve.maxZ = maxZ;
      curve.setSamples(samples);
      curve.setPenWidth(4);
      curve.setColorInterval(color1, color2);
      curve.setColorRange(new Interval(minZ, maxZ));

      curve.functionDlgData = getFunctionDlgData(curve.rtti);
      if (!upload) curve.fn = curve.functionDlgData.fn;

      //curve.attach(self);
      return curve;
    }

    Static.bind("addSpectrocurve", function (e, fileName, samples, upload) {
      addSpectrocurve(fileName, "red", "green", samples, upload).attach(self);
      //newCurve.attach(self);
    });

    function addSpectrogram(title, color1, color2, data, upload) {
      var sgram = new Spectrogram(title);
      sgram.upload = upload;
      sgram.spectrogramData = data;
      if (upload) {
        sgram.setData(new SpectrogramFileData(data));
      } else {
        sgram.setData(new SpectrogramFunctionData(data));
      }

      sgram.setNumberOfContourPlanes(10);
      //sgram.setContourLevels(sgram.calculateContourLevels(10));

      //color1 = color1 || "darkCyan";
      //color2 = color2 || "red";

      //console.log(1000, sgram.colorMap())
      const colorMap = sgram.colorMap();
      colorMap.setColorInterval(color1, color2);
      colorMap.addColorStop(0.1, "cyan");
      colorMap.addColorStop(0.6, "green");
      colorMap.addColorStop(0.95, "yellow");

      //console.log(1000, colorMap)

      // A color bar on the right axis
      /* var rightAxis = self.axisWidget( Axis.AxisId.yRight );
             rightAxis.setTitle( "Intensity" );
             var zInterval = sgram.data().interval( Static.ZAxis );
             self.setAxisScale( Axis.AxisId.yRight, zInterval.minValue(), zInterval.maxValue() );
          	
             self.enableAxis( Axis.AxisId.yRight, true ); */

      sgram.functionDlgData = getFunctionDlgData(sgram.rtti);
      if (!upload) sgram.fn = sgram.functionDlgData.fn;

      //sgram.attach(self); //attach early

      //zoomer.setZoomBase();

      // Static.bind("alphaChanged", function (e, alpha) {
      //   //sgram.invalidateCache()
      //   sgram.setAlpha(alpha);
      // });

      // Static.bind("showSpectrogram", function (e, on) {
      //   sgram.setDisplayMode(PlotSpectrogram.DisplayMode.ImageMode, on);
      //   sgram.setDefaultContourPen(
      //     on ? new Misc.Pen("black", 0) : new Misc.Pen(Static.NoPen)
      //   );
      // });

      // Static.bind("showContour", function (e, on) {
      //   sgram.setDisplayMode(PlotSpectrogram.DisplayMode.ContourMode, on);
      // });

      // Static.bind("numberOfPlanes", function (e, val) {
      //   console.log(4441);
      //   sgram.setContourLevels(sgram.calculateContourLevels(val));
      // });

      //sgram.setAlpha( 50 )
      return sgram;
    }

    this.uploadSpectrogram = function (displayData, spectrogramData, upload) {
      const sgram = addSpectrogram(
        displayData.title,
        displayData.color1,
        displayData.color2,
        spectrogramData,
        upload
      );
      sgram.setNumberOfContourPlanes(displayData.numberOfContourPlanes);
      sgram.showContour(displayData.showContour);
      sgram.showSpectrogram(displayData.showSpectrogram);

      //sgram.attach(self);

      return sgram;
    };

    Static.bind("addSpectrogram", function (e, fileName, samples, upload) {
      const sgram = addSpectrogram(
        fileName,
        "#008b8b",
        "#ff0000",
        samples,
        upload
      );
      sgram.attach(self);
    });

    Static.bind("addCurve", function (e, title, samples, upload, result) {
      let curve = addCurve(title, samples, upload);
      curve.attach(self);
    });

    function addUnboundedCurve(title, fn, numOfPoints) {
      if (self.findPlotCurve(title)) {
        Utility.alert(title + " already exist");
        return null;
      }
      //self.setAxisScale(Axis.AxisId.xBottom, 1.0, 10.0);
      self.setAxisScale(
        Axis.AxisId.xBottom,
        self._functionDlg.lowerLimit,
        self._functionDlg.upperLimit
      );
      let curve = new MyCurve(title);
      self.addCurveInit(curve);
      curve.functionData = new FunctionData(fn, numOfPoints);
      //console.log(1000, curve.functionData)
      curve.setData(
        curve.functionData /*  new FunctionData(fn, numOfPoints) */
      );
      //curve.setPen(new Misc.Pen(colorList[numberOfCurves(self) % 6]))
      curve.setPen(new Misc.Pen(Utility.randomColor()));
      self.curveAttributeDlg.defaultIconSize = new Misc.Size(
        curve.getLegendIconSize()
      );

      if (Static.showline) {
        curve.setLegendAttribute(LegendShowLine, true);
      }
      if (Static.showsymbol) curve.setLegendAttribute(LegendShowSymbol, true);
      //console.log(r)
      //curve.attach(self);

      //setAutoScale(true)
      //Utility.setAutoScale(self, true);

      return curve;
    }

    this.createCurve = function (rtti, title) {
      if (rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        return new MyCurve(title);
      }
      if (rtti == PlotItem.RttiValues.Rtti_PlotMarker) {
        return new PlotMarker(title);
      }
      if (rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve) {
        return new SpectroCurve(title);
      }
    };

    function getFunctionDlgData(rtti) {
      let functionDlgData = {};
      functionDlgData.rtti = rtti;
      if (rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        functionDlgData.coeffs = self._functionDlg.coeffs;
        functionDlgData.expandedFn = self._functionDlg.expandedFn;
        functionDlgData.parametricFnX = self._functionDlg.expandedParametricFnX;
        functionDlgData.parametricFnY = self._functionDlg.expandedParametricFnY;
        functionDlgData.fn = self._functionDlg.fn;
        functionDlgData.lowerLimit = self._functionDlg.lowerLimit;
        functionDlgData.numOfPoints = self._functionDlg.numOfPoints;
        functionDlgData.threeD = self._functionDlg.threeD;
        functionDlgData.title = self._functionDlg.title;
        functionDlgData.unboundedRange = self._functionDlg.unboundedRange;
        functionDlgData.upperLimit = self._functionDlg.upperLimit;
        functionDlgData.variable = self._functionDlg.variable;
        functionDlgData.parametric_variable =
          self._functionDlg.parametric_variable;
      }
      if (rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve) {
        functionDlgData.color1 = self._functionDlg.color1;
        functionDlgData.color2 = self._functionDlg.color2;
        functionDlgData.expandedFn = self._functionDlg.expandedFn;
        functionDlgData.fn = self._functionDlg.fn;
        functionDlgData.lowerLimit = self._functionDlg.lowerLimit;
        functionDlgData.lowerLimitFxy = self._functionDlg.lowerLimitFxy;
        functionDlgData.lowerLimitY = self._functionDlg.lowerLimitY;
        functionDlgData.numOfPoints = self._functionDlg.numOfPoints;
        functionDlgData.threeD = self._functionDlg.threeD;
        functionDlgData.threeDType = self._functionDlg.threeDType;
        functionDlgData.title = self._functionDlg.title;
        functionDlgData.upperLimit = self._functionDlg.upperLimit;
        functionDlgData.upperLimitFxy = self._functionDlg.upperLimitFxy;
        functionDlgData.upperLimitY = self._functionDlg.upperLimitY;
        functionDlgData.variable = self._functionDlg.variable;
        functionDlgData.variableY = self._functionDlg.variableY;
      }
      if (rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram) {
        functionDlgData.color1 = self._functionDlg.color1;
        functionDlgData.color2 = self._functionDlg.color2;
        functionDlgData.expandedFn = self._functionDlg.expandedFn;
        functionDlgData.fn = self._functionDlg.fn;
        functionDlgData.lowerLimit = self._functionDlg.lowerLimit;
        functionDlgData.lowerLimitFxy = self._functionDlg.lowerLimitFxy;
        functionDlgData.lowerLimitY = self._functionDlg.lowerLimitY;
        functionDlgData.numOfPoints = self._functionDlg.numOfPoints;
        functionDlgData.threeD = self._functionDlg.threeD;
        functionDlgData.threeDInterpolationType =
          self._functionDlg.threeDInterpolationType;
        functionDlgData.threeDType = self._functionDlg.threeDType;
        functionDlgData.title = self._functionDlg.title;
        functionDlgData.upperLimit = self._functionDlg.upperLimit;
        functionDlgData.upperLimitFxy = self._functionDlg.upperLimitFxy;
        functionDlgData.upperLimitY = self._functionDlg.upperLimitY;
        functionDlgData.variable = self._functionDlg.variable;
        functionDlgData.variableY = self._functionDlg.variableY;
      }
      return functionDlgData;
    }

    function setFunctionDlgData(functionDlgData) {
      if (functionDlgData.rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        self._functionDlg.coeffs = functionDlgData.coeffs;
        self._functionDlg.expandedFn = functionDlgData.expandedFn;
        //_plot._functionDlg.fn = functionDlgData.fn;
        self._functionDlg.lowerLimit = functionDlgData.lowerLimit;
        self._functionDlg.numOfPoints = functionDlgData.numOfPoints;
        self._functionDlg.threeD = functionDlgData.threeD;
        self._functionDlg.title = functionDlgData.title;
        self._functionDlg.unboundedRange = functionDlgData.unboundedRange;
        self._functionDlg.upperLimit = functionDlgData.upperLimit;
        self._functionDlg.variable = functionDlgData.variable;
      }
      if (functionDlgData.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve) {
        self._functionDlg.color1 = functionDlgData.color1;
        self._functionDlg.color2 = functionDlgData.color2;
        self._functionDlg.expandedFn = functionDlgData.expandedFn;
        self._functionDlg.fn = functionDlgData.fn;
        self._functionDlg.lowerLimit = functionDlgData.lowerLimit;
        self._functionDlg.lowerLimitFxy = functionDlgData.lowerLimitFxy;
        self._functionDlg.lowerLimitY = functionDlgData.lowerLimitY;
        self._functionDlg.numOfPoints = functionDlgData.numOfPoints;
        self._functionDlg.threeD = functionDlgData.threeD;
        self._functionDlg.threeDType = functionDlgData.threeDType;
        self._functionDlg.title = functionDlgData.title;
        self._functionDlg.upperLimit = functionDlgData.upperLimit;
        self._functionDlg.upperLimitFxy = functionDlgData.upperLimitFxy;
        self._functionDlg.upperLimitY = functionDlgData.upperLimitY;
        self._functionDlg.variable = functionDlgData.variable;
        self._functionDlg.variableY = functionDlgData.variableY;
      }
      if (functionDlgData.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram) {
        self._functionDlg.color1 = functionDlgData.color1;
        self._functionDlg.color2 = functionDlgData.color2;
        self._functionDlg.expandedFn = functionDlgData.expandedFn;
        self._functionDlg.fn = functionDlgData.fn;
        self._functionDlg.lowerLimit = functionDlgData.lowerLimit;
        self._functionDlg.lowerLimitFxy = functionDlgData.lowerLimitFxy;
        self._functionDlg.lowerLimitY = functionDlgData.lowerLimitY;
        self._functionDlg.numOfPoints = functionDlgData.numOfPoints;
        self._functionDlg.threeD = functionDlgData.threeD;
        self._functionDlg.threeDInterpolationType =
          functionDlgData.threeDInterpolationType;
        self._functionDlg.threeDType = functionDlgData.threeDType;
        self._functionDlg.title = functionDlgData.title;
        self._functionDlg.upperLimit = functionDlgData.upperLimit;
        self._functionDlg.upperLimitFxy = functionDlgData.upperLimitFxy;
        self._functionDlg.upperLimitY = functionDlgData.upperLimitY;
        self._functionDlg.variable = functionDlgData.variable;
        self._functionDlg.variableY = functionDlgData.variableY;
      }
    }

    /*
     functionDlgData=
      {
        lowerLimit: undefined, //Number
        upperLimit: undefined, //Number
        threeD: false
        title: null, //String
        variable: null, //String
        fn: null, //String
        expandedFn: null, //String
        numOfPoints: undefined, //Number
        unboundedRange: false, //Boolean
        coeffs: null, //Array
        threeDType: null, //String e.g. "spectrocurve"
        threeDInterpolationType: null, //String e.g. "bilinear"
        lowerLimitY: undefined, //Number
        upperLimitY: undefined, //Number
        lowerLimitFxy: undefined, //Number
        upperLimitFxy: undefined, //Number
        variableY: null, //String
        color1: "#008b8b", //String
        color2: "#ff0000" //String
      }
      */
    function initializeCoeff(m_fn) {
      let m_fnCpy = m_fn;
      // if (self._functionDlg.expandedParametricFnX === m_fn) {
      //   fnX = true;
      // }
      let coeffs = self._functionDlg.coeffs;

      if (m_fn) {
        m_fn = m_fn.replace(/\s/g, "");
        let fnc = Utility.purgeAndMarkKeywords(m_fn);
        for (var i = 0; i < coeffs.length; ++i) {
          let n = fnc.indexOf(coeffs[i]);
          while (
            n > 0 &&
            fnc[n - 1] !== "," &&
            fnc[n - 1] !== "*" &&
            fnc[n - 1] !== "/" &&
            fnc[n - 1] !== "+" &&
            fnc[n - 1] !== "-" &&
            fnc[n - 1] !== "%" &&
            fnc[n - 1] !== "(" &&
            fnc[n - 1] !== "^"
          ) {
            fnc = fnc.replace(coeffs[i], "*" + coeffs[i]);
            n = fnc.indexOf(coeffs[i]);
          }
        }
        m_fn = Utility.replaceKeywordMarkers(fnc);
        if (self._functionDlg.expandedFn) {
          self._functionDlg.expandedFn = m_fn;
        } else if (
          self._functionDlg.expandedParametricFnX &&
          self._functionDlg.expandedParametricFnY
        ) {
          if (m_fnCpy === self._functionDlg.expandedParametricFnX)
            self._functionDlg.expandedParametricFnX = m_fn;
          if (m_fnCpy === self._functionDlg.expandedParametricFnY)
            self._functionDlg.expandedParametricFnY = m_fn;
        }

        if (coeffs && self._functionDlg.coeffs.length) {
          let _fn = Utility.purgeAndMarkKeywords(m_fn);
          for (var i = 0; i < coeffs.length; ++i) {
            while (_fn.indexOf(coeffs[i]) != -1) {
              _fn = _fn.replace(coeffs[i], 1 + 1e-15); //log(x,a) don't work with a==1;
            }
          }
          m_fn = Utility.replaceKeywordMarkers(_fn);
        }
      }
      return m_fn;
    }

    this.functionDlgCb = function (functionDlgData = null) {
      // const xDecimalPlaces = self.axisDecimalPlaces(Axis.AxisId.xBottom);
      // const yDecimalPlaces = self.axisDecimalPlaces(Axis.AxisId.yLeft);
      //console.log(functionDlgData);
      let newCurve = null;
      if (functionDlgData) {
        setFunctionDlgData(functionDlgData);
      }

      var title = self._functionDlg.title,
        fn = self._functionDlg.expandedFn,
        lowerLimit = self._functionDlg.lowerLimit,
        upperLimit = self._functionDlg.upperLimit,
        numOfPoints = self._functionDlg.numOfPoints;

      //console.log(self._functionDlg.domainRangeRestriction);

      if (self._functionDlg.threeD) {
        //console.log("do 3d")
        if (self._functionDlg.threeDType === "spectrocurve") {
          var s = Utility.makeSamples({
            fx: fn,
            threeD: true,
            variable: self._functionDlg.variable,
            variableY: self._functionDlg.variableY,
            lowerX: parseFloat(self._functionDlg.lowerLimit),
            upperX: parseFloat(self._functionDlg.upperLimit),
            lowerY: parseFloat(self._functionDlg.lowerLimitY),
            upperY: parseFloat(self._functionDlg.upperLimitY),
            numOfSamples: self._functionDlg.numOfPoints,
            ok_fn: self._functionDlg.ok,
          });
          if (!s) return;
          if (s.length == 0) {
            Utility.alert(
              "Unable to derive samples from the provided domain. Check the function and limits for possible divide-by-zero error"
            );
            //self._functionDlg.close();
            //self._functionDlg.closeDlg = true;
            return;
          }

          newCurve = addSpectrocurve(
            title,
            self._functionDlg.color1,
            self._functionDlg.color2,
            s
          );

          newCurve.latex = self._functionDlg.latex;
          // newCurve.fn = fn;
          // newCurve.functionDlgData = getFunctionDlgData(newCurve.rtti);

          newCurve.attach(self);

          if (newCurve && self._functionDlg.close) {
            //self._functionDlg.close();
            //self._functionDlg.closeDlg = true;
          }
          return newCurve;
        }
        if (self._functionDlg.threeDType === "spectrogram") {
          //var fnData = {fn: "1 / ( v1 * v1 + v2 * v2 )", minX: -1.5, maxX: 1.5, minY: -1.5, maxY: 1.5, minZ: 0, maxZ: 10};
          var fnData = {
            /* fn: self._functionDlg.fn, */ fx: fn,
            variable: self._functionDlg.variable,
            variableY: self._functionDlg.variableY,
            minX: parseFloat(self._functionDlg.lowerLimit),
            maxX: parseFloat(self._functionDlg.upperLimit),
            minY: parseFloat(self._functionDlg.lowerLimitY),
            maxY: parseFloat(self._functionDlg.upperLimitY),
            minZ: parseFloat(self._functionDlg.lowerLimitFxy),
            maxZ: parseFloat(self._functionDlg.upperLimitFxy),
          };
          newCurve = addSpectrogram(
            title,
            self._functionDlg.color1,
            self._functionDlg.color2,
            fnData
          );
          newCurve.latex = self._functionDlg.latex;
          //newCurve.attach(self);
          if (!functionDlgData) newCurve.attach(self);
          // newCurve.fn = fn;
          // newCurve.functionDlgData = getFunctionDlgData(newCurve.rtti);

          if (newCurve && self._functionDlg.close) {
            //self._functionDlg.close();
            //self._functionDlg.closeDlg = true;
          }
        }
        return newCurve;
      }

      /* If we get here, we have a 2D curve*/
      /* let coeffs = self._functionDlg.coeffs;

      if(self._functionDlg.expandedFn){
        self._functionDlg.expandedFn = self._functionDlg.expandedFn.replace(
          /\s/g,
          ""
        );
        let fnc = Utility.purgeAndMarkKeywords(self._functionDlg.expandedFn);
        for (var i = 0; i < coeffs.length; ++i) {
          let n = fnc.indexOf(coeffs[i]);
          while (n > 0 && fnc[n - 1] !== "*" && fnc[n - 1] !== "/" && fnc[n - 1] !== "+" && fnc[n - 1] !== "-" && fnc[n - 1] !== "%") {
            fnc = fnc.replace(
              coeffs[i],
              "*" + coeffs[i]
            );
            n = fnc.indexOf(coeffs[i]);
          }
        }
        fn = self._functionDlg.expandedFn = Utility.replaceKeywordMarkers(fnc);

        if (coeffs && self._functionDlg.coeffs.length) {
          let _fn = Utility.purgeAndMarkKeywords(fn);
          for (var i = 0; i < coeffs.length; ++i) {
            while (_fn.indexOf(coeffs[i]) != -1) {
              _fn = _fn.replace(coeffs[i], 1);
            }
          }
          fn = Utility.replaceKeywordMarkers(_fn);
        }
      } */
      let parametricFnX, parametricFnY;
      if (self._functionDlg.expandedFn) {
        fn = /* self._functionDlg.expandedFn = */ initializeCoeff(
          self._functionDlg.expandedFn
        );
      } else if (
        self._functionDlg.expandedParametricFnX &&
        self._functionDlg.expandedParametricFnY
      ) {
        parametricFnX = initializeCoeff(
          self._functionDlg.expandedParametricFnX
        );
        parametricFnY = initializeCoeff(
          self._functionDlg.expandedParametricFnY
        );
      }

      let makeSamplesData = {
        fx: fn,
        parametricFnX,
        parametricFnY,
        parametric_variable: self._functionDlg.parametric_variable,
        variable: self._functionDlg.variable,
        lowerX: parseFloat(self._functionDlg.lowerLimit),
        upperX: parseFloat(self._functionDlg.upperLimit),
        numOfSamples: self._functionDlg.numOfPoints,
        //ok_fn: self._functionDlg.ok,
        warnIgnoreCb: function () {
          Static.enterButton.click();
        },
      };

      let discont = [];

      try {
        discont = Utility.discontinuity(
          fn,
          makeSamplesData.lowerX,
          makeSamplesData.upperX,
          self._functionDlg.variable
        );
      } catch (error) {
        //discont = [];
      }
      //console.log(discont);
      // discont = discont.sort(function (a, b) {
      //   return a - b;
      // });

      if (self._functionDlg.unboundedRange) {
        newCurve = addUnboundedCurve(title, fn, numOfPoints);
        newCurve.discontinuity = discont;
        //newCurve.setAxis = false;
        newCurve.latex = self._functionDlg.latex;
        newCurve.attach(self);
        if (newCurve && self._functionDlg.close) {
          //self._functionDlg.close();
          //self._functionDlg.closeDlg = true;
        }
      } else {
        /* let makeSamplesData = {
          fx: fn,
          variable: self._functionDlg.variable,
          lowerX: parseFloat(self._functionDlg.lowerLimit),
          upperX: parseFloat(self._functionDlg.upperLimit),
          numOfSamples: self._functionDlg.numOfPoints,
          //ok_fn: self._functionDlg.ok,
          warnIgnoreCb: function () {
            Static.enterButton.click();
          },
        }; */

        /* let discont = [];

        try {
          discont = Utility.discontinuity(
            fn,
            makeSamplesData.lowerX,
            makeSamplesData.upperX
          );
        } catch (error) {
          //discont = [];
        }
        //console.log(discont)
        discont = discont.sort(function (a, b) {
          return a - b;
        }); */

        if (discont.length && Utility.errorResponse == Utility.adjustDomain) {
          if (discont[0] == makeSamplesData.lowerX && discont.length == 1) {
            makeSamplesData.lowerX =
              discont[0] +
              (makeSamplesData.upperX - makeSamplesData.lowerX) / 300;
          } else if (
            discont[0] == makeSamplesData.lowerX &&
            discont.length > 1
          ) {
            makeSamplesData.lowerX =
              discont[0] +
              (makeSamplesData.upperX - makeSamplesData.lowerX) / 300;
            makeSamplesData.upperX =
              discont[1] -
              (makeSamplesData.upperX - makeSamplesData.lowerX) / 300;
          } else {
            makeSamplesData.upperX =
              discont[0] -
              (makeSamplesData.upperX - makeSamplesData.lowerX) / 300;
          }
        }
        makeSamplesData.discontinuity = discont;
        // makeSamplesData.xDecimalPlaces = xDecimalPlaces;
        // makeSamplesData.yDecimalPlaces = yDecimalPlaces;
        const samples = Utility.makeSamples(makeSamplesData);
        if (!samples) return;
        if (samples.length == 0) {
          Utility.alert(
            "Unable to derive samples from the provided domain. Check the function and limits for possible divide-by-zero error"
          );
          //self._functionDlg.close();
          //self._functionDlg.closeDlg = true;
          return;
        }
        newCurve = addCurve(title, samples, false, fn);
        newCurve.turningPoints = makeSamplesData.turningPoints;
        newCurve.latex = self._functionDlg.latex;
        if (!newCurve) return;
        if (samples.length == 1) {
          const color = Utility.randomColor();
          let sym = new Symbol2(
            Symbol2.Style.Ellipse,
            new Misc.Brush(Utility.invert(color)),
            new Misc.Pen(color),
            new Misc.Size(8, 8)
          );
          newCurve.setSymbol(sym);
          let attribute = "";
          if (Static.showline && Static.showsymbol) {
            attribute = "lineAndSymbol";
          } else if (Static.showline) {
            attribute = "line";
          } else if (Static.showsymbol) {
            attribute = "symbol";
          }
          Utility.setLegendAttribute(
            newCurve,
            attribute,
            newCurve.getLegendIconSize()
          ); //attribute = "line" or "symbol" or "lineAndSymbol"
        }
        //Utility.addSymbol(newCurve, Symbol2.Style.Ellipse);
        newCurve.discontinuity = discont;
        //newCurve.setAxis = false;
        newCurve.xIsDependentVariable = self._functionDlg.xIsDependentVariable;

        // if (!functionDlgData) newCurve.attach(self);

        var decimalPlacesY = 4;
        var decimalPlacesX = 4;
        let m_samples = newCurve.data().samples();
        if (!Static.userDecimalPlacesForCalculation) {
          const obj = Utility.grapherDeterminedDecimalPlaces(newCurve);
          decimalPlacesY = obj.decimalPlacesY;
          decimalPlacesX = obj.decimalPlacesX;
        } else {
          var decimalPlacesY = self.axisDecimalPlaces(newCurve.yAxis());
          var decimalPlacesX = self.axisDecimalPlaces(newCurve.xAxis());
        }

        m_samples = m_samples.map(function (e) {
          return new Misc.Point(
            Utility.adjustForDecimalPlaces(e.x, decimalPlacesX),
            Utility.adjustForDecimalPlaces(e.y, decimalPlacesY)
          );
        });
        newCurve.setSamples(m_samples);

        if (!functionDlgData) newCurve.attach(self);

        //newCurve.functionDlgData = getFunctionDlgData(newCurve.rtti);

        if (newCurve && self._functionDlg.close) {
          //self._functionDlg.close();
          //self._functionDlg.closeDlg = true;
        }

        newCurve.domainRangeRestriction =
          self._functionDlg.domainRangeRestriction;

        return newCurve;
      }
    };

    this._functionDlg.init(self.functionDlgCb);

    this.addRemovePoint = new AddRemovePointPicker(this);
    // this.addRemovePoint.setAddRemoveMousePattern(
    //   EventPattern.MousePatternCode.MouseSelect1,
    //   Static.LeftButton,
    //   Static.ShiftModifier
    // );
    //this.addRemovePoint.activate(true);

    var rulers = new Rulers(this);
    //this.sidebar = new SideBar1(this);
    //this.sidebar.setRulers(self.rv);

    //p.showSidebar(true)
    Static.watchCentroidWithArea = true;
    Static.bind("watchCentroidWithArea", function (e, on) {
      Static.watchCentroidWithArea = on;
      Static.trigger("invalidateWatch");

      rulers.updateWatchesAndTable();
    });

    this.tbar = new MToolBar(
      this,
      {
        zIndex: 1003,
      },
      self.plotDiv
    );

    /* Static.watchCentroidWithArea = true;					
        Static.bind("watchCentroidWithArea", function (e, on) {
          Static.watchCentroidWithArea = on;
        }); */

    this.curveClosestPoint = new CurveClosestPoint(this);
    // this.curveClosestPoint.setMousePattern(
    //   Static.LeftButton,
    //   Static.AltModifier
    // );

    //let functions = [];
    //let curves = [];
    // let firstSelectedCurve = null;
    // let secondSelectedCurve = null;

    Static.bind("curveRenamed", function (e, curve, oldName, newName) {
      if (curve.rtti === PlotItem.RttiValues.Rtti_PlotMarker) {
        let oldLabel = curve.label();
        let newLabel = oldLabel.replace(oldName, newName);
        curve.setLabel(newLabel);
        curve.plot().replot();
      }
    });

    function doCombine(curves) {
      let precisionY, precisionX, decimalPlacesY, decimalPlacesX;
      if (curves[0]) {
        precisionY = curves[0].plot().axisPrecision(curves[0].yAxis());
        precisionX = curves[0].plot().axisPrecision(curves[0].xAxis());
        decimalPlacesY = curves[0].plot().axisDecimalPlaces(curves[0].yAxis());
        decimalPlacesX = curves[0].plot().axisDecimalPlaces(curves[0].xAxis());
      }

      function getArrowSymbolCount() {
        let list = self.itemList(PlotItem.RttiValues.Rtti_PlotMarker);
        if (!list.length) {
          return 0;
        }
        list = list.filter(function (e) {
          return e.symbol() && e.symbol().toString() === "[PointMarkerSymbol]";
        });
        return list.length;
      }

      function getArrowSymbolProperties() {
        let m = getArrowSymbolCount();
        const odd = m % 2;
        let result = {};
        result.spacing = 0;
        result.align = Static.AlignRight;
        result.angle = -45;
        if (!odd) {
          result.spacing = 0;
          result.align = Static.AlignLeft;
          result.angle = 45;
        }
        return result;
      }

      //console.log(curves[0]);
      let functions = [];
      let lowerLimit = undefined;
      let upperLimit = undefined;
      const operationType = self.curveSelector.operationType;
      self.curveSelector.operationType = null;

      if (curves.length == 0) {
        return;
      }

      let variable = curves[0].variable;
      if (!(operationType == "Join" || operationType == "Join and keep")) {
        if (curves.length > 1 && operationType !== "Intersection") {
          for (let i = 1; i < curves.length; i++) {
            if (curves[i].variable !== variable) {
              alert("Selected functions have different idependent vaiables.");
              return;
            }
          }
        }
      }

      if (
        operationType == "Translate" ||
        operationType == "Scale" ||
        operationType == "Reflect x-axis" ||
        operationType == "Reflect y-axis" ||
        operationType == "Reflect x and y-axes"
      ) {
        if (operationType == "Translate") {
          let entry = "1,1";
          Utility.prompt(
            "Enter comma separated values",
            entry,
            function (csvStr) {
              if (csvStr) {
                const arr = csvStr.split(",");
                if (arr.length !== 2) {
                  Utility.promptErrorMsg = `Improper translate values.\nExpected a comma separated value (csv).`;
                  return false;
                }

                let m_translateX = Number.MAX_VALUE,
                  m_translateY = Number.MAX_VALUE;

                try {
                  let parser = new EvaluateExp(
                    arr[0],
                    self.defines.expandDefines
                  );
                  m_translateX = parser.eval();
                  if (!math.isNumeric(m_translateX))
                    m_translateX = Number.MAX_VALUE;
                } catch (error) {
                  m_translateX = Number.MAX_VALUE;
                }
                try {
                  let parser = new EvaluateExp(
                    arr[1],
                    self.defines.expandDefines
                  );
                  m_translateY = parser.eval();
                  if (!math.isNumeric(m_translateY))
                    m_translateY = Number.MAX_VALUE;
                } catch (error) {
                  m_translateY = Number.MAX_VALUE;
                }
                // if (arr.length == 2) {
                if (
                  m_translateX == Number.MAX_VALUE &&
                  m_translateY == Number.MAX_VALUE
                ) {
                  Utility.promptErrorMsg = `\"${arr[0]},${arr[1]}\" represent improper translate values.`;
                  entry = csvStr;
                  return false;
                }
                if (m_translateX == Number.MAX_VALUE) {
                  Utility.promptErrorMsg = `\"${arr[0]}\" is an improper translate values.`;
                  entry = csvStr;
                  return false;
                }
                if (m_translateY == Number.MAX_VALUE) {
                  Utility.promptErrorMsg = `\"${arr[1]}\" is an improper translate values.`;
                  entry = csvStr;
                  return false;
                }
                //entry = csvStr;
                //} else {
                //validInput = true;
                // const m_translateX = math.evaluate(arr[0]);
                // const m_translateY = math.evaluate(arr[1]);

                const plot = curves[0].plot();
                // const doAutoReplot = plot.autoReplot();
                // plot.setAutoReplot(false);
                for (let i = 0; i < curves.length; i++) {
                  self.transformation.transform(
                    curves[i],
                    "Translate",
                    m_translateX,
                    m_translateY
                  );
                }
                // plot.setAutoReplot(doAutoReplot);
                // plot.autoRefresh();
                //}
              } else {
                return false;
              }

              // console.log(str); //If the visitor clicks OK, the input is log to the console.
              // Utility.promptErrorMsg = "Invalid input. Expected a number.";
              return true;
            }
          );
        }
        if (operationType == "Scale") {
          // let validInput = false;
          // while (!validInput) {
          let entry = "2";
          Utility.prompt("Enter a scale factor", entry, function (csvStr) {
            if (csvStr) {
              if (isNaN(parseFloat(csvStr))) {
                Utility.promptErrorMsg =
                  "Improper scale factor receive. Expected a number.";
                return false;
              } else {
                const scale = parseFloat(csvStr);
                for (let i = 0; i < curves.length; i++) {
                  self.transformation.transform(curves[i], "Scale", scale);
                }
              }
            } else {
              return false;
            }
            return true;
          });
        }
        if (operationType == "Reflect x-axis") {
          for (let i = 0; i < curves.length; i++) {
            self.transformation.transform(curves[i], "Reflect x-axis");
          }
        }
        if (operationType == "Reflect y-axis") {
          for (let i = 0; i < curves.length; i++) {
            self.transformation.transform(curves[i], "Reflect y-axis");
          }
        }

        if (operationType == "Reflect x and y-axes") {
          for (let i = 0; i < curves.length; i++) {
            self.transformation.transform(curves[i], "Reflect x and y-axis");
          }
        }
      }

      let coeffs = [];

      if (
        operationType == "Add" ||
        operationType == "Subtract" ||
        operationType == "Divide" ||
        operationType == "Multiply" ||
        operationType == "Composite" ||
        operationType == "Join" ||
        operationType == "Join and keep"
      ) {
        for (let i = 0; i < curves.length; i++) {
          if (!(operationType == "Join" || operationType == "Join and keep")) {
            if (!curves[i].expandedFn) {
              Utility.alert(
                `Your selection, "${curves[
                  i
                ].title()}", is not described by a know function.`
              );
              self.curveSelector.abortSelection();
              functions = [];
              return;
            }
          }
          if (curves[i].coeffs) {
            coeffs = coeffs.concat(curves[i].coeffs);
          }
          //functions.push(curves[i].expandedFn);
          functions.push(curves[i].fn);
        }

        coeffs = _.uniq(coeffs);

        let combinedFn = null;

        if (functions.length > 1 || curves.length > 1) {
          self.curveSelector.setEnabled(false);

          for (let i = 0; i < curves.length; i++) {
            /* if (!curves[i].expandedFn) {
            Utility.alert(
              `Your selection, "${curves[
                i
              ].title()}", is not described by a know function.`
            );
            functions = [];
            curves = [];
            lowerLimit = undefined;
            upperLimit = undefined;
            return;
          } */
            if (lowerLimit == undefined) {
              lowerLimit = curves[i].minXValue();
            } else if (curves[i].minXValue() < lowerLimit) {
              lowerLimit = curves[i].minXValue();
            }

            if (upperLimit == undefined) {
              upperLimit = curves[i].maxXValue();
            } else if (curves[i].maxXValue() > upperLimit) {
              upperLimit = curves[i].maxXValue();
            }
          }

          if (operationType == "Add") {
            let fn = "";
            for (let i = 0; i < functions.length; i++) {
              fn += functions[i];
              if (i < functions.length - 1) fn += "+";
            }
            combinedFn = math
              .simplify(math.parse(fn), {}, { exactFractions: false })
              .toString()
              .replace(/\s/g, "")
              .replaceAll("+-", "-");
            //Replace the whitespace delimiters stripped out by simplify()
            combinedFn = combinedFn.replaceAll("mod", " mod ");
          }
          if (operationType == "Subtract") {
            let fn = "";
            for (let i = 0; i < functions.length; i++) {
              fn += `(${functions[i]})`;
              if (i < functions.length - 1) fn += "-";
            }
            combinedFn = math
              .simplify(math.parse(fn), {}, { exactFractions: false })
              .toString()
              .replace(/\s/g, "")
              .replaceAll("+-", "-");
            //Replace the whitespace delimiters stripped out by simplify()
            combinedFn = combinedFn.replaceAll("mod", " mod ");
          }
          if (operationType == "Multiply") {
            let fn = "";
            for (let i = 0; i < functions.length; i++) {
              fn += `(${functions[i]})`;
              if (i < functions.length - 1) fn += "*";
            }
            combinedFn = math
              .simplify(math.parse(fn), {}, { exactFractions: false })
              .toString()
              .replace(/\s/g, "")
              .replaceAll("+-", "-");
            //Replace the whitespace delimiters stripped out by simplify()
            combinedFn = combinedFn.replaceAll("mod", " mod ");
          }
          if (operationType == "Divide") {
            let fn = "";
            for (let i = 0; i < functions.length; i++) {
              fn += `(${functions[i]})`;
              if (i < functions.length - 1) fn += "/";
            }
            combinedFn = math
              .simplify(math.parse(fn), {}, { exactFractions: false })
              .toString()
              .replace(/\s/g, "")
              .replaceAll("+-", "-");
            //Replace the whitespace delimiters stripped out by simplify()
            combinedFn = combinedFn.replaceAll("mod", " mod ");
          }
          if (operationType == "Composite") {
            let fn = functions[0];
            for (let i = 1; i < functions.length; i++) {
              const gx = functions[i];
              fn = fn.replaceAll(variable, "(" + gx + ")");
            }
            combinedFn = math
              .simplify(math.parse(fn), {}, { exactFractions: false })
              .toString()
              .replace(/\s/g, "")
              .replaceAll("+-", "-");
            //Replace the whitespace delimiters stripped out by simplify()
            combinedFn = combinedFn.replaceAll("mod", " mod ");
          }

          function doJoin() {
            curves = curves.sort(function (a, b) {
              const samplesA = a.data().samples();
              const samplesB = b.data().samples();
              return samplesA[0].x - samplesB[0].x;
            });
            // for (let i = 0; i < curves.length; i++) {
            //   console.log(curves[i].title());
            // }
            let samples = curves[0].data().samples();
            for (let i = 1; i < curves.length; i++) {
              const samples2 = curves[i].data().samples();
              if (samples2[0].x >= samples[samples.length - 1].x) {
                if (samples[0].x > samples[samples.length - 1].x)
                  samples = samples.reverse();
                samples = samples.concat(samples2);
              } else {
                samples = [];
                curves = [];
                Utility.alert(
                  "Improper selection order or overlapping domain.",
                  "small"
                );
              }
            }
            //console.log(samples);
            if (samples.length) {
              const curve = new MyCurve(
                Utility.generateCurveName(self, "joined_")
              );
              curve.setSamples(samples);
              curve.attach(self);
            }
          }

          if (operationType == "Join") {
            doJoin();
            for (let i = 0; i < curves.length; i++) {
              curves[i].detach();
            }
          }

          if (operationType == "Join and keep") {
            doJoin();
          }

          //self.curveSelector.abortSelection();
          functions = [];
          curves = [];

          if (operationType == "Join" || operationType == "Join and keep")
            return;

          const functionDlgData = {
            rtti: PlotItem.RttiValues.Rtti_PlotCurve,
            lowerLimit, //Number
            upperLimit, //Number
            threeD: false,
            title: Utility.generateCurveName(self, "comb_"), //eq + domain[0], //String
            variable, //String
            fn: combinedFn, //String
            expandedFn: combinedFn, //String
            numOfPoints: undefined, //Number
            unboundedRange: false, //Boolean
            coeffs, //: null, //Array
            threeDType: null, //String e.g. "spectrocurve"
            threeDInterpolationType: null, //String e.g. "bilinear"
            lowerLimitY: undefined, //Number
            upperLimitY: undefined, //Number
            lowerLimitFxy: undefined, //Number
            upperLimitFxy: undefined, //Number
            variableY: undefined, //String
            color1: "#008b8b", //String
            color2: "#ff0000", //String
          };

          const curve = self.functionDlgCb(functionDlgData);
          lowerLimit = undefined;
          upperLimit = undefined;
          curve.attach(self);
        } //
      }

      if (operationType == "Create table") {
        //$("html").addClass("wait");
        curves[0].plot().plotPropertiesPane.generateTable(curves[0]);
        //$("html").removeClass("wait");
        return;
      }

      if (operationType == "Copy curve") {
        Utility.copyCurves(curves);
        return;
      }

      if (operationType == "Discontinuity point") {
        let precisionX = curves[0].plot().axisPrecision(curves[0].xAxis());
        //const precision = Math.min(precisionX, precisionY);
        let decimalPlacesX = curves[0]
          .plot()
          .axisDecimalPlaces(curves[0].xAxis());

        const discontinuity = curves[0].discontinuity.map(function (e) {
          return Utility.toPrecision(
            Utility.adjustForDecimalPlaces(e, Math.min(decimalPlacesX, 9)),
            precisionX
          );
        });

        let n = discontinuity.length;
        let isAre = "is",
          discont = "discontinuity";
        let values = "value";
        if (discontinuity && n > 1) {
          (isAre = "are"), (discont = "discontinuities"), (values = "values");
        }
        let str = `There ${isAre} ${n} ${discont}.`;
        if (n) {
          str += ` Abscissa ${values}:\n` + discontinuity.toString();
        }
        alert(str);
      }

      if (
        operationType == "Turning point" ||
        operationType == "Inflection point"
      ) {
        //console.log(curves);
        // let precisionY = curves[0].plot().axisPrecision(curves[0].yAxis());
        // let precisionX = curves[0].plot().axisPrecision(curves[0].xAxis());
        // let decimalPlacesY = curves[0]
        //   .plot()
        //   .axisDecimalPlaces(curves[0].yAxis());
        // let decimalPlacesX = curves[0]
        //   .plot()
        //   .axisDecimalPlaces(curves[0].xAxis());
        let str = "";
        let m = 0;
        for (let i = 0; i < curves.length; i++) {
          //const points = Utility.curveTurningPoint(curves[i]);//fn, variable, samples
          let points;
          if (operationType == "Turning point") {
            // points = Utility.curveTurningPoint(
            //   curves[i].expandedFn,
            //   curves[i].variable,
            //   curves[i].data().samples(),
            //   decimalPlacesX,
            //   decimalPlacesY
            // );
            const curve = curves[i];
            points = curve.turningPoints;

            for (let n = 0; n < points.length; n++) {
              const odd = m % 2;
              m++;
              const { spacing, align } = getArrowSymbolProperties();
              const element = points[n];
              const tpName = Utility.generateCurveName(self, "T");
              const marker = new PlotMarker(tpName);
              marker.toolTipValueName = "Turning point:";
              marker.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
              marker.setXAxis(curve.xAxis());
              marker.setYAxis(curve.yAxis());

              // const sym = new Symbol2();
              // sym.setBrush(new Misc.Brush(Static.NoBrush));
              // sym.setSize(new Misc.Size(10, 10));
              // sym.setStyle(Symbol2.Style.Ellipse);
              // marker.setSymbol(sym);

              marker.setSymbol(new PointMarkerSymbol());

              marker.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
              marker.setLegendIconSize(new Misc.Size(10, 10));

              marker.setValue(element);
              marker.setLabel(tpName);
              var m_symbol = marker.symbol();
              m_symbol.setSize(new Misc.Size(10, 10));
              marker.setLabelAlignment(align | Static.AlignBottom);
              marker.setSpacing(spacing);

              marker.setLabelFont(
                new Misc.Font({
                  fontColor: "#0B00FC",
                  name: "Times New Roman",
                  style: "normal",
                  th: 12,
                  weight: "bold",
                })
              );

              marker.attach(self);
            }
          }

          if (operationType == "Inflection point") {
            points = Utility.curveInflectionPoint(
              curves[i].expandedFn,
              curves[i].variable,
              curves[i].data().samples(),
              decimalPlacesX,
              decimalPlacesY
            );

            const curve = curves[i];

            for (let n = 0; n < points.length; n++) {
              const element = points[n];
              const { spacing, align } = getArrowSymbolProperties();
              const ipName = Utility.generateCurveName(self, "I");
              const marker = new PlotMarker(ipName);
              marker.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
              marker.setXAxis(curve.xAxis());
              marker.setYAxis(curve.yAxis());

              // const sym = new Symbol2();
              // sym.setBrush(new Misc.Brush(Static.NoBrush));
              // sym.setSize(new Misc.Size(10, 10));
              // sym.setStyle(Symbol2.Style.Ellipse);
              // marker.setSymbol(sym);

              marker.setSymbol(new PointMarkerSymbol());
              marker.toolTipValueName = "Inflection point:";

              marker.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
              marker.setLegendIconSize(new Misc.Size(10, 10));

              marker.setValue(element);
              marker.setLabel(ipName);
              var m_symbol = marker.symbol();
              m_symbol.setSize(new Misc.Size(10, 10));
              marker.setLabelAlignment(align | Static.AlignBottom);
              marker.setSpacing(spacing);

              marker.setLabelFont(
                new Misc.Font({
                  fontColor: "#FF0000",
                  name: "Times New Roman",
                  style: "normal",
                  th: 12,
                  weight: "bold",
                })
              );

              marker.attach(self);
            }
          }
          if (!points.length) {
            let pointType = "turning";
            if (operationType == "Inflection point") pointType = "inflection";
            str += `${curves[i].title()} (0 ${pointType} point)\n`;
          }
        }
        if (str.length) alert(str);
      }

      if (operationType == "Intersection") {
        //console.log(curves);
        if (curves.length > 1) {
          if (curves[0].title() == curves[1].title()) {
            alert("Cannot find the intersection of a curve with itself.");
            return;
          }

          if (curves[0].xAxis() !== curves[1].xAxis()) {
            alert(
              "Cannot find the intersection of a curve with different x-axis."
            );
            return;
          }

          if (curves[0].yAxis() !== curves[1].yAxis()) {
            alert(
              "Cannot find the intersection of a curve with different y-axis."
            );
            return;
          }

          // let precisionY = curves[0].plot().axisPrecision(curves[0].yAxis());
          // let precisionX = curves[0].plot().axisPrecision(curves[0].xAxis());
          // let decimalPlacesY = curves[0]
          //   .plot()
          //   .axisDecimalPlaces(curves[0].yAxis());
          // let decimalPlacesX = curves[0]
          //   .plot()
          //   .axisDecimalPlaces(curves[0].xAxis());

          let res = [];

          if (curves[0].expandedFn && curves[1].expandedFn) {
            // Utility.logStep(Static.operation, {
            //   equations: [curves[0].expandedFn, curves[1].expandedFn],
            //   variable: curves[0].variable,
            // });
            // Utility.logStep(Static.constructEquation, operationType);
            let simplifiedExp = math
              .simplify(`(${curves[0].expandedFn})-(${curves[1].expandedFn})`)
              .toString();
            //Replace the whitespace delimiters stripped out by simplify()
            simplifiedExp = simplifiedExp.replaceAll("mod", " mod ");
            //Utility.logStep(Static.rearrangeEquation, operationType);
            if (simplifiedExp.indexOf(curves[0].variable) == -1) {
              alert(`0 points of intersection:\n`);
              return;
            }

            nerdamer.flush();
            var eq = nerdamer(
              `(${curves[0].expandedFn})-(${curves[1].expandedFn})=0`
            );
            Static.expression = `(${curves[0].expandedFn})-(${curves[1].expandedFn})=0`;
            //Utility.logStep(Static.solveEquation, operationType);
            var solution = eq.solveFor(curves[0].variable);
            //Static.stepper.unload();
            //console.log(solution[0].toString(), solution[1].toString());
            if (solution && solution.length < 20) {
              const fn = curves[0].expandedFn.replaceAll(
                curves[0].variable,
                "Z"
              );

              for (let i = 0; i < solution.length; i++) {
                const val = math.evaluate(solution.at(i).valueOf());

                res.push({
                  x: val,
                  y: math.evaluate(fn, {
                    Z: val,
                  }),
                });
              }

              const xLower = Math.max(curves[0].lowerX, curves[1].lowerX);
              const xUpper = Math.min(curves[0].upperX, curves[1].upperX);
              //console.log(xLower, xUpper);

              const m_l = res.length;

              res = res.filter(function (e) {
                return e.x >= xLower && e.x <= xUpper;
              });

              if (res.length == 0) {
                //Utility.logStep("info", `No solution(s) within domain [${xLower}, ${xUpper}]`);
              }

              if (m_l == res.length) {
                //Utility.logStep("info", `All solution(s) within domain [${xLower}, ${xUpper}]`);
              }

              const { spacing, align, angle } = getArrowSymbolProperties();

              let str = "";
              for (let i = 0; i < res.length; i++) {
                const element = res[i];
                const { spacing, align } = getArrowSymbolProperties();
                const ipName = Utility.generateCurveName(self, "X");
                const marker = new PlotMarker(ipName);
                marker.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
                marker.setXAxis(curves[0].xAxis());
                marker.setYAxis(curves[0].yAxis());

                // const sym = new Symbol2();
                // sym.setBrush(new Misc.Brush(Static.NoBrush));
                // sym.setSize(new Misc.Size(10, 10));
                // sym.setStyle(Symbol2.Style.Ellipse);
                // marker.setSymbol(sym);

                marker.setSymbol(new PointMarkerSymbol());
                marker.toolTipValueName = "Intersection point:";

                marker.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
                marker.setLegendIconSize(new Misc.Size(10, 10));

                marker.setValue(element);
                marker.setLabel(ipName);
                var m_symbol = marker.symbol();
                m_symbol.setSize(new Misc.Size(10, 10));
                marker.setLabelAlignment(align | Static.AlignBottom);
                marker.setSpacing(spacing);

                marker.setLabelFont(
                  new Misc.Font({
                    fontColor: "#000000",
                    name: "Times New Roman",
                    style: "normal",
                    th: 12,
                    weight: "bold",
                  })
                );

                marker.attach(self);
              }

              //const ptStr = res.length > 1 ? "points" : "point";

              //alert(`${res.length} ${ptStr} of intersection:\n` + str);
              return;
            }
          }

          //console.log(decimalPlacesX, decimalPlacesY);

          //const round = 30;
          const m_eps = 1e-14;
          let samples1 = curves[0].data().samples();
          let samples2 = curves[1].data().samples();

          if (samples2.length == 2 && samples1.length > 2) {
            const temp = samples1;
            samples1 = samples2;
            samples2 = temp;
          }

          if (
            (samples1.length == 2 ||
              Utility.linearEquationFromPoints(samples1[0], samples1[1], 10) ==
                Utility.linearEquationFromPoints(
                  samples1[1],
                  samples1[2],
                  10
                )) &&
            (samples2.length == 2 ||
              Utility.linearEquationFromPoints(samples2[0], samples2[1], 10) ==
                Utility.linearEquationFromPoints(samples2[1], samples2[2], 10))
          ) {
            //Intersect line
            let point1Line1 = [samples1[0].x, samples1[0].y];
            let point2Line1 = [
              samples1[samples1.length - 1].x,
              samples1[samples1.length - 1].y,
            ];

            let point1Line2 = [samples2[0].x, samples2[0].y];
            let point2Line2 = [
              samples2[samples2.length - 1].x,
              samples2[samples2.length - 1].y,
            ];

            let point = math.intersect(
              point1Line1,
              point2Line1,
              point1Line2,
              point2Line2
            );

            // let precisionY = curves[0].plot().axisPrecision(curves[0].yAxis());
            // let precisionX = curves[0].plot().axisPrecision(curves[0].xAxis());
            // //const precision = Math.min(precisionX, precisionY);
            // let decimalPlacesY = curves[0]
            //   .plot()
            //   .axisDecimalPlaces(curves[0].yAxis());
            // let decimalPlacesX = curves[0]
            //   .plot()
            //   .axisDecimalPlaces(curves[0].xAxis());

            let x = Utility.toPrecision(
              Utility.adjustForDecimalPlaces(point[0], decimalPlacesX),
              precisionX
            );
            let y = Utility.toPrecision(
              Utility.adjustForDecimalPlaces(point[1], decimalPlacesY),
              precisionY
            );

            if (x == "Infinity" || y == "Infinity") {
              alert(`0 points of intersection:\n`);
              return;
            }

            const element = new Misc.Point(x, y);
            const { spacing, align } = getArrowSymbolProperties();
            const ipName = Utility.generateCurveName(self, "X");
            const marker = new PlotMarker(ipName);
            marker.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
            marker.setXAxis(curves[0].xAxis());
            marker.setYAxis(curves[0].yAxis());

            // const sym = new Symbol2();
            // sym.setBrush(new Misc.Brush(Static.NoBrush));
            // sym.setSize(new Misc.Size(10, 10));
            // sym.setStyle(Symbol2.Style.Ellipse);
            // marker.setSymbol(sym);

            marker.setSymbol(new PointMarkerSymbol());
            marker.toolTipValueName = "Intersection point:";

            marker.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
            marker.setLegendIconSize(new Misc.Size(10, 10));

            marker.setValue(element);
            marker.setLabel(ipName);
            var m_symbol = marker.symbol();
            m_symbol.setSize(new Misc.Size(10, 10));
            marker.setLabelAlignment(align | Static.AlignBottom);
            marker.setSpacing(spacing);

            marker.setLabelFont(
              new Misc.Font({
                fontColor: "#000000",
                name: "Times New Roman",
                style: "normal",
                th: 12,
                weight: "bold",
              })
            );

            marker.attach(self);
            return;
          }

          /////////////////////////////////////////////////////////////

          for (let i = 0; i < samples1.length; i++) {
            for (let n = 0; n < samples2.length; n++) {
              if (
                samples1[i].x == samples2[n].x &&
                samples1[i].y == samples2[n].y
              ) {
                res.push(samples2[n]);
              }
            }
          }

          for (let i = 1; i < samples1.length; i++) {
            let point1Line1 = [
              samples1[i - 1].x,
              Math.abs(samples1[i - 1].y) < m_eps ? 0 : samples1[i - 1].y,
            ];
            let point2Line1 = [
              samples1[i].x,
              Math.abs(samples1[i].y) < m_eps ? 0 : samples1[i].y,
            ];

            let rect1 = new Misc.Rect(
              point1Line1[0],
              point1Line1[1],
              point2Line1[0] - point1Line1[0],
              point2Line1[1] - point1Line1[1]
            ).normalized();

            for (let j = 1; j < samples2.length; j++) {
              let point1Line2 = [
                samples2[j - 1].x,
                Math.abs(samples2[j - 1].y) < m_eps ? 0 : samples2[j - 1].y,
              ];
              let point2Line2 = [
                samples2[j].x,
                Math.abs(samples2[j].y) < m_eps ? 0 : samples2[j].y,
              ];

              let rect2 = new Misc.Rect(
                point1Line2[0],
                point1Line2[1],
                point2Line2[0] - point1Line2[0],
                point2Line2[1] - point1Line2[1]
              ).normalized();

              if (rect1.intersects(rect2)) {
                let point = math.intersect(
                  point1Line1,
                  point2Line1,
                  point1Line2,
                  point2Line2
                );

                let pt = new Misc.Point(point[0], point[1]);

                function resHasPoint(pt) {
                  for (let i = 0; i < res.length; i++) {
                    //if (res[i].isEqual(pt)) return true;
                    if (
                      Utility.adjustForDecimalPlaces(
                        res[i].x,
                        decimalPlacesX
                      ) ==
                        Utility.adjustForDecimalPlaces(pt.x, decimalPlacesX) &&
                      Utility.adjustForDecimalPlaces(
                        res[i].y,
                        decimalPlacesY
                      ) == Utility.adjustForDecimalPlaces(pt.y, decimalPlacesY)
                    ) {
                      return true;
                    }
                  }
                  return false;
                }

                if (
                  (point &&
                    rect2.contains(pt, false) &&
                    rect1.contains(pt, false)) ||
                  (rect1.height() == 0 && rect2.contains(pt, false)) ||
                  (rect2.height() == 0 && rect1.contains(pt, false))
                ) {
                  if (!resHasPoint(pt)) res.push(pt);
                }
              }
            }
          }

          let str = "";
          for (let i = 0; i < res.length; i++) {
            const element = res[i];
            const { spacing, align } = getArrowSymbolProperties();
            const ipName = Utility.generateCurveName(self, "X");
            const marker = new PlotMarker(ipName);
            marker.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
            marker.setXAxis(curves[0].xAxis());
            marker.setYAxis(curves[0].yAxis());

            // const sym = new Symbol2();
            // sym.setBrush(new Misc.Brush(Static.NoBrush));
            // sym.setSize(new Misc.Size(10, 10));
            // sym.setStyle(Symbol2.Style.Ellipse);
            // marker.setSymbol(sym);

            marker.setSymbol(new PointMarkerSymbol());
            marker.toolTipValueName = "Intersection point:";

            marker.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
            marker.setLegendIconSize(new Misc.Size(10, 10));

            marker.setValue(element);
            marker.setLabel(ipName);
            var m_symbol = marker.symbol();
            m_symbol.setSize(new Misc.Size(10, 10));
            marker.setLabelAlignment(align | Static.AlignBottom);
            marker.setSpacing(spacing);

            marker.setLabelFont(
              new Misc.Font({
                fontColor: "#000000",
                name: "Times New Roman",
                style: "normal",
                th: 12,
                weight: "bold",
              })
            );

            marker.attach(self);
          }

          if (res.length == 0) alert(`0 points of intersection:\n`);
        }
      }
    }

    function curveSelectorCb(curves) {
      doCombine(curves);
    }

    this.curveSelector = new CurveSelector(this);

    Static.bind("selectedCurves", function (e, curves) {
      //console.log(curves);
      curveSelectorCb(curves);
    });

    // this.curveSelector.setMousePattern(Static.LeftButton, Static.AltModifier);

    // this.curveSelector.setAbortMousePattern(
    //   Static.MidButton,
    //   Static.AltModifier
    // );

    // this.curveSelector.setAbortLastMousePattern(
    //   Static.MidButton,
    //   Static.ControlModifier
    // );

    // Static.bind("selectionAborted", function () {
    //   functions = [];
    //   curves = [];
    // });

    // Static.bind("lastSelectionAborted", function () {
    //   functions.pop();
    //   curves.pop();
    // });

    this.cs = new CurveShapeItem(this);
    //this.cs.attach(this);

    this.curveShapeEnabledByPlotSettings = function () {
      return m_curveShapeEnabledByPlotSettings;
    };

    this.setCurveShapeEnabledByPlotSettings = function (on) {
      m_curveShapeEnabledByPlotSettings = on;
    };

    this.setAxisTitle(Axis.AxisId.xBottom, "Bottom scale");
    this.setAxisTitle(Axis.AxisId.xTop, "Top scale");
    this.setAxisTitle(Axis.AxisId.yLeft, "Left scale");
    this.setAxisTitle(Axis.AxisId.yRight, "Right scale");

    this.magnifier = new Magnifier(this);

    Static.bind("magnifyingStart", function () {
      self.setAxesAutoScale(false);
    });

    this.pan = new Panner(this);
    this.pan.setCursor("move");
    this.pan.setEnabled(false);

    this.zm = new MyPlotZoomer(this);
    var m_settings = null;
    this.leftSidebar = new PlotSideBar(this, self.plotDiv);
    this.leftSidebar.setTop(parseInt($("#toolBar1").css("height")) + 2);
    var pp = new CurvePropertiesPane(
      this.leftSidebar.gridItem(0).bodyElement,
      this,
      Static.curvePropPane
    );
    m_settings = new PlotPropertiesPane(
      this.leftSidebar.gridItem(1).bodyElement,
      this,
      Static.plotPropPane
    );
    this.plotPropertiesPane = m_settings;

    this.leftSidebar.showGridItem(1, true);

    this.rightSidebar = new InfoSideBar(this, self.plotDiv);
    this.rightSidebar.setTop(parseInt($("#toolBar1").css("height")) + 2);
    var pp = new InfoPropertiesPane(
      this.rightSidebar.gridItem(0).bodyElement,
      this,
      Static.infoPropPane
    );
    //this.rightSidebar.showGridItem(0, true);
    this.rightSidebar.showSidebar(false);

    //var m_settings = new MSettings();
    this.settings = function () {
      return m_settings;
    };
    //m_settings.setPlot(this);

    this.setFooter("Footer");

    var legendMenu = new LegendMenu(this);
    function axisDlgFn() {
      var curve = legendMenu.getCurve();
      if (!curve) return;
      self.axisDlg.axisCb(curve);
    }
    legendMenu.modifyMenu(null, {
      pos: 2,
      name: "axis",
      img: "images/axis.png",
      title: "Sets the axes associated with the curve.",
      fun: axisDlgFn,
    });

    legendMenu.setMenuModificationCb(function () {
      var curve = legendMenu.getCurve();

      if (Static.aspectRatioOneToOne) {
        legendMenu.modifyMenu("axis", {});
      } else {
        legendMenu.modifyMenu(null, {
          pos: 2,
          name: "axis",
          img: "images/axis.png",
          title: "Sets the axes associated with the curve.",
          fun: axisDlgFn,
        });
      }

      if (
        curve.rtti === PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
        curve.rtti === PlotItem.RttiValues.Rtti_PlotSpectrogram ||
        curve.rtti === PlotItem.RttiValues.Rtti_PlotZone ||
        curve.rtti === PlotItem.RttiValues.Rtti_PlotMarker
      ) {
        legendMenu.modifyMenu("curve brush", {}); //index 0
        legendMenu.modifyMenu("curve style", {}); //index 1
        legendMenu.modifyMenu("legend attribute", {}); //index 3
        legendMenu.modifyMenu("fit", {}); //index 6
        legendMenu.modifyMenu("symbol", {}); //index 7
        legendMenu.modifyMenu("pen", {}); //index 8
        legendMenu.modifyMenu("Zone", {}); //index 9
      } else {
        legendMenu.modifyMenu(null, [
          {
            pos: 0,
            name: "curve brush",
            img: "images/brush.png",
            title: "Set the fill color.",
            fun: function () {
              Utility.setCurveBrush(m_curve, function (curve) {
                Static.trigger("curveBrushChanged", curve);
              });
            },
          },
          {
            pos: 1,
            name: "curve style",
            img: "images/style.png",
            title: "Sets the style of the curve.",
            fun: function () {
              var curve = legendMenu.getCurve();
              if (!curve) return;
              self.curveStyleDlg.curveStyleCb(curve);
            },
          },
          {
            pos: 3,
            name: "legend attribute",
            img: "images/attribute.png",
            title: "Sets how the curve is represented on the legend.",
            fun: function () {
              var curve = legendMenu.getCurve();
              if (!curve) return;
              self.curveAttributeDlg.curveAttributeCb(curve);
            },
          },
          {
            pos: 6,
            name: "fit",
            img: "images/fit.png",
            title: "Defines a curve fitter.",
            fun: function () {
              var curve = legendMenu.getCurve();
              if (!curve) return;
              self.curveFitDlg.curveFitCb(curve);
            },
          },
          {
            pos: 7,
            name: "symbol",
            img: "images/symbol.png",
            title: "attach/modify curve symbol",
            subMenu: null,
          },
          {
            pos: 8,
            name: "pen",
            img: "images/pen.png",
            title: "modify/change curve pen",
            subMenu: legendMenu.getPenSubMenu(),
          },
          /* {
            pos: 9,
            name: "Zone",
            img: "images/zone.jfif",
            title: "Adds a zone",
            fun: function () {
              var curve = legendMenu.getCurve();
              if (!curve) {
                alert("Must have at least one curve.");
                return;
              }
              self.zoneDlg.zoneCb(curve.plot());
            },
          }, */
        ]);
      }

      if (curve.rtti === PlotItem.RttiValues.Rtti_PlotSpectroCurve) {
        legendMenu.modifyMenu(null, {
          name: "pen width",
          //title: 'It will replace row',
          //img:'images/replace.png',
          subMenu: legendMenu.getPenWidthSubMenu(),
        });
      } else {
        legendMenu.modifyMenu("pen width", {});
      }

      if (!legendMenu.getCurve().fitType) {
        legendMenu.modifyMenu("fit info...", {});
        return;
      }

      //legendMenu.modifyMenu(null, menuArray1);

      legendMenu.modifyMenu(null, {
        pos: 100,
        name: "fit info...",
        title: "Displays information associated with curve fitting.",
        fun: function () {
          var curve = legendMenu.getCurve();
          if (!curve) return;
          var info = self.curveFitDlg.curveFitInfoCb(curve);
          if (info.length) {
            Utility.alert(info);
          } else {
            Utility.alert(
              'No curve fitting equation found for "' + curve.title() + '."'
            );
          }
        },
      });
    });

    this.file.setInputElement($("#fileInput"));

    this.replot();
    this.setAutoReplot(true);

    Static.bind("visibilityChange", function (e, plotItem, on) {
      if (
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectroCurve ||
        plotItem.rtti == PlotItem.RttiValues.Rtti_PlotSpectrogram
      ) {
        if (!self.hasVisiblePlotCurve()) {
          self.watchAreaBelowCurve.setEnable(false);
        } else {
          self.watchAreaBelowCurve.setEnable(
            self.tbar.isDropdownItemChecked("Watch", 6)
          );
          /* self.tbar.setDropdownItemCheck("Watch", 6, false);
          self.watchAreaBelowCurve.setEnable(false); */
          //Static.trigger("positionChanged"); //force sidebar update
        }
      }
    });

    var el = self.getLayout().getCentralDiv();

    // el.on("touchend", function () {
    //   console.log(456);
    // });
    //console.log(el);
    var menu = [
      {
        name: "Hide rulers",
        img: "images/hide.png",
        title: "Hide all rulers",
        fun: function () {
          self.rv.setVisible(false);
        },
      },
      {
        name: "Show rulers",
        img: "images/show.png",
        title: "Show any hidden rulers",
        //disable: true,
        fun: function () {
          self.rv.setVisible(true);
        },
      },
      {
        name: "Unlock rulers",
        img: "images/unlock.png",
        title: "Unlock any locked rulers",
        //disable: true,
        fun: function () {
          self.rv.unlockAllRulers();
        },
      },
      {
        name: "Remove all items",
        title: "Permanently remove all items",
        //disable: true,
        img: "images/trashAll.png",
        fun: function () {
          var L = self
            .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotZone))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotMarker));

          L.forEach(function (curve) {
            if (
              curve.title() !== "cgMarker@12345" &&
              curve.title() !== "ClosestPointMarker123@###" &&
              curve.title() !== "v_ruler1" &&
              curve.title() !== "v_ruler2" &&
              curve.title() !== "h_ruler1" &&
              curve.title() !== "h_ruler2"
            ) {
              self.trashDlg.trash(curve);
              // curve.detach();
              // curve.delete();
            }
          });
        },
      },
      {
        name: "Remove all hidden items",
        title: "Permanently remove all hidden items",
        //disable: true,
        img: "images/trashAllHidden.png",
        fun: function () {
          var L = self
            .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotZone))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotMarker));

          L.forEach(function (curve) {
            if (
              curve.title() !== "cgMarker@12345" &&
              curve.title() !== "ClosestPointMarker123@###" &&
              curve.title() !== "v_ruler1" &&
              curve.title() !== "v_ruler2" &&
              curve.title() !== "h_ruler1" &&
              curve.title() !== "h_ruler2"
            ) {
              if (!curve.isVisible()) {
                self.trashDlg.trash(curve);
                // curve.detach();
                // curve.delete();
              }
            }
          });
        },
      },
      {
        name: "Hide all items",
        title: "Hide all items",
        //disable: true,
        img: "images/hide.png",
        fun: function () {
          var L = self
            .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotZone))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotMarker));

          L.forEach(function (curve) {
            //console.log(curve.title());
            if (
              curve.title() !== "cgMarker@12345" &&
              curve.title() !== "ClosestPointMarker123@###" &&
              curve.title() !== "v_ruler1" &&
              curve.title() !== "v_ruler2" &&
              curve.title() !== "h_ruler1" &&
              curve.title() !== "h_ruler2"
            )
              curve.setVisible(false);
            //Static.trigger("hideAllItems");
          });
          Static.trigger("hideAllItems");
        },
      },
      {
        name: "Show all items",
        title: "Show all items",
        //disable: true,
        img: "images/show.png",
        fun: function () {
          var L = self
            .itemList(PlotItem.RttiValues.Rtti_PlotCurve)
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotSpectroCurve))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotSpectrogram))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotZone))
            .concat(self.itemList(PlotItem.RttiValues.Rtti_PlotMarker));

          L.forEach(function (curve) {
            if (
              curve.title() !== "cgMarker@12345" &&
              curve.title() !== "ClosestPointMarker123@###" &&
              curve.title() !== "v_ruler1" &&
              curve.title() !== "v_ruler2" &&
              curve.title() !== "h_ruler1" &&
              curve.title() !== "h_ruler2"
            )
              curve.setVisible(true);
            //Static.trigger("showAllItems");
          });
          Static.trigger("showAllItems");
        },
      },
    ];

    Static.bind("rulerDeselected", function () {
      el.contextMenu(menu, {
        triggerOn: "contextmenu",
        zIndex: 1,
      });
    });
    //Start with this menu
    el.contextMenu(menu, {
      triggerOn: "contextmenu",
      zIndex: 1,
    });

    var m_gridlinesAccordingToCurve = true;

    Static.bind(
      "gridlinesAccordingToCurve",
      function (e, gridlinesAccordingToCurve) {
        m_gridlinesAccordingToCurve = gridlinesAccordingToCurve;
        var currentCurve = rulers.currentCurve();
        if (currentCurve && m_gridlinesAccordingToCurve) {
          self.grid.setAxes(currentCurve.xAxis(), currentCurve.yAxis());
        }
      }
    );

    Static.bind("currentCurveChanged", function (e, newCurve) {
      if (newCurve && m_gridlinesAccordingToCurve) {
        self.grid.setAxes(newCurve.xAxis(), newCurve.yAxis());
      }
      if (newCurve && m_zoomAccordingToCurve) {
        self.zm.setAxis(newCurve.xAxis(), newCurve.yAxis());
      }
      /* if (newCurve) {
        const sz = newCurve.dataSize();
        const val = (1 / 100) * sz;
        console.log(val);
        if(!Static.dicontinuityUserSetting){
          Static.dicontinuityOffsetFactor = val / Static.dicontinuityFactor;
          Static.trigger("dicontinuityOffsetFactor", val);
        }
      } */
    });

    Static.bind("axisChanged", function (e, axis, curve) {
      var c = self.rv.currentCurve() || curve;
      //console.log(c.title())

      if (curve && m_gridlinesAccordingToCurve) {
        self.grid.setAxes(c.xAxis(), c.yAxis());
      }
      if (curve && m_zoomAccordingToCurve) {
        self.zm.setAxis(c.xAxis(), c.yAxis());
      }
    });

    var m_zoomAccordingToCurve = true;

    Static.bind("zoomAccordingToCurve", function (e, zoomAccordingToCurve) {
      m_zoomAccordingToCurve = zoomAccordingToCurve;
      var currentCurve = rulers.currentCurve();
      if (currentCurve && m_zoomAccordingToCurve) {
        self.zm.setAxis(currentCurve.xAxis(), currentCurve.yAxis());
      }
    });

    /* Static.bind("currentCurveChanged", function (e, newCurve) {
          if (newCurve && m_zoomAccordingToCurve){
            self.zm.setAxis(newCurve.xAxis(), newCurve.yAxis());				
          }
        }); */

    /* Static.bind("axisChanged", function (e, axis, curve) {
          if (curve && m_zoomAccordingToCurve){
            self.zm.setAxis(curve.xAxis(), curve.yAxis());				
          }
        }); */

    ///////////////////Mongo-Filesystem///////////////////////////////////////
    //fsServerUrl: "https://grapher-file-system.herokuapp.com",
    //imageLoaderSrc: "img/imageLoader.png",
    //imageFolderSrc: "img/folder.png",
    // imageFileSrc: "img/file.png",
    //accessTokenExpiry: 20, //default == 10
    //persistSession: false, //default === true
    const fsOptions = {
      //zIndex: 2000,
      enableNotepad: true,
      //For Dev. Uncomment the following line.
      //fsServerUrl: "http://localhost:5500", //only necessary for cross domain

      listOfFileTypes: [
        {
          display: "Grapher plot (*.plt)",
          ext: ".plt",
          defaultFilename: "Grapher Plot",
        },
        {
          display: "Data table (*.tbl)",
          ext: ".tbl",
          defaultFilename: "Data table",
        },
        {
          display: "Defines (*.def)",
          ext: ".def",
          defaultFilename: "Defines",
        },
        {
          display: "Image (*.png)",
          ext: ".png",
          defaultFilename: "PNG Image",
        },
        {
          display: "Excel (*.xls)",
          ext: ".xls",
          defaultFilename: "Excel Worksheet",
        },
      ],

      listOfOpenWithTypes: [
        /* This type is added by default when notepad is enabled (i.e. enableNotepad: true) */
        /* { 
          name: "Text Editor", 
          options: { encoding: "utf8", flag: "r" } 
        }, */
        {
          img: "images/favicon.ico",
          name: "Grapher",
          options: { encoding: "utf8", flag: "r" },
        },
      ],
    };

    function p(params) {
      return new Promise((resolve, reject) => {
        resolve(localStorage.getItem("RefreshToken"));
      });
    }

    class FileSystem extends FileSystemServices {
      constructor(options) {
        super(options);
        const self = this;

        $(window).on("beforeSave", () => {});

        $(window).on("afterSave", () => {
          $("#myText").focus();
        });

        $("#myText").on("input", () => {
          self.currentFileModified();
        });
      }

      setData(data, filename, fileExt, editor) {
        //if (fileExt == '.plt' || editor == "Grapher") {
        // console.log(`Do not know how to open files with extension "${fileExt}".`);
        alert(`Do not know how to open files with extension "${fileExt}".`);
        // }
      }

      getRefreshToken() {
        return super.getRefreshToken();
      }
    }

    const fileSystemServices = (self.fileSystemServices = new FileSystem(
      fsOptions
    ));

    class GrapherEditor extends Editor {
      constructor(options) {
        super(options);
        const self = this;

        //Associate save and saveas menu items with the editor
        options.fs.addSaveAndSaveAsMenuItems();

        options.fs.registerEditor({ name: "Grapher", editor: self });

        //If the editor has content from a known file (i.e self.currentFilename() returns a valid filename)
        //and an input is detected, we set the currentFileModified flag (i.e we call currentFileModified(true))
        Static.bind("replot", function () {
          if (self.currentFilename()) self.currentFileModified(true);
        });
      }
      getData() {
        return self.file.getPlotData(); //'[{"bottomScaleEngineType":"[LinearScaleEngine]","leftScaleEngineType":"[LinearScaleEngine]","topScaleEngineType":"[LinearScaleEngine]","rightScaleEngineType":"[LinearScaleEngine]","title":"Plot","titleFont":{"th":20,"name":"Arial","style":"normal","weight":"bold","fontColor":"black"},"footer":"Footer","footerFont":{"th":15,"name":"Arial","style":"normal","weight":"bold","fontColor":"black"},"axisTitleFont":{"th":14,"name":"Arial","style":"normal","weight":"normal","fontColor":"black"},"xBottomAxisTitle":"Bottom scale","xTopAxisTitle":"Top scale","yLeftAxisTitle":"Left scale","yRightAxisTitle":"Right scale","autoScale":true},{"rtti":5,"title":"curve_1","functionDlgData":{"rtti":5,"coeffs":[],"expandedFn":"x^2","fn":"x^2","lowerLimit":-10,"numOfPoints":100,"threeD":false,"title":"curve_1","unboundedRange":false,"upperLimit":10,"variable":"x"},"fn":"x^2","pen":{"color":"rgb(75,122,25)","width":1,"style":"solid"},"symbolType":-1,"style":0,"xAxis":2,"yAxis":0}]';
      }

      setData(data, filename, ext, editorName) {
        if (
          ext === ".tbl" ||
          ext === ".txt" ||
          ext === ".plt" ||
          editorName == "Grapher"
        ) {
          if (ext === ".plt" || ext === ".txt" || ext === ".tbl") {
            self.file.setPlotData({ content: data, fileName: filename });
          }
          if (ext === ".plt") {
            this.currentFilename(filename);
          }
        }
      }
    }

    class DefinesEditor extends Editor {
      constructor(options) {
        super(options);
        const self = this;

        options.fs.registerEditor({ name: "Defines", editor: self });
      }
    }

    const options = {};
    options.fs = fileSystemServices;
    options.editorName = "Grapher";
    options.fileExtensions = [".plt", ".tbl", ".txt"];
    //options.explorerDialogParentId = "plotDiv";

    self.grapherEditor = new GrapherEditor(options);

    //If not called and the buit-in notepad is enabled, notepad is assume to be the default editor
    options.fs.setDefaultEditor(self.grapherEditor);

    const definesOptions = {};
    definesOptions.fs = fileSystemServices;
    definesOptions.editorName = "Defines";
    definesOptions.fileExtensions = [".def", ".txt"];
    //options.explorerDialogParentId = "definesModal";

    self.definesEditor = new DefinesEditor(definesOptions);
    this.defines = new MDefines(this, self.definesEditor);

    //this.defines.setEditor(self.definesEditor);

    //fileSystemServices.enableNotepad();
    ////////////////////////////////////////////////////////////////

    // var leftSidebarVisible_gridItem_0 = false;
    // var leftSidebarVisible_gridItem_1 = false;
    // var rightSidebarVisible = false;
    function beforePrintCb() {
      // leftSidebarVisible_gridItem_0 = self.leftSidebar.isGridItemVisible(0);//self.leftSidebar.isSideBarVisible();
      // if (leftSidebarVisible_gridItem_0)
      // 	self.leftSidebar.showGridItem(0, false);
      // leftSidebarVisible_gridItem_1 = self.leftSidebar.isGridItemVisible(1);//self.leftSidebar.isSideBarVisible();
      // if (leftSidebarVisible_gridItem_1)
      // 	self.leftSidebar.showGridItem(1, false);
      // rightSidebarVisible = self.rightSidebar.isSideBarVisible();
      // if (rightSidebarVisible)
      // 	self.rightSidebar.showSidebar(false);
      console.log("before Print");
    }

    function afterPrintCb() {
      // self.rightSidebar.showSidebar(rightSidebarVisible);
      // self.leftSidebar.showGridItem(0, leftSidebarVisible_gridItem_0);
      // self.leftSidebar.showGridItem(1, leftSidebarVisible_gridItem_1);
      console.log("after Print");
    }

    // self.registerPrintCb("beforePrint", beforePrintCb);
    // self.registerPrintCb("afterPrint", afterPrintCb);
    // var f = new Misc.Font();
    // f.th = 20;
    // this.setAxisLabelFont(Axis.AxisId.xBottom, f)

    // const options2 = {
    //     hideAlphas: true,
    //     title: 'Function Editor',
    //     screenColor: "#fff",
    //     screenTextColor: "#00f",
    //     prettyOnly: true,
    //     initializeWithLastValue: true,
    //     validOnly: true,
    //     bigDialog: true,
    //     //operatorButtonTextColor: "red"
    //     //buttonImages: {xSquareImg: "img/xSquare3.png"}
    //     // buttonImages: {xSquareImg: "Sqr", squareRootImg: "Sqrt", xToPowYImg: "x^y"}
    // }

    // //Create a second equation editor that will be trigger when a clickable html element with id 'test2' is clicked.
    // let edlg = new EquationEditor("equationEditor"/* , options2 */);

    // console.log(edlg)

    /* $(window).bind("equationEditorAngleModeChanged", function (e, mode) {
      console.log(mode);
    });

    var core = nerdamer.getCore();
    var _ = core.PARSER;
    core.Math2.sin_d = function (x) {
      return sin((x * pi) / 180);
    };
    //symbolic handler
    function symbolicHandler(x) {
      //for simplicity we'll work stricly with the Symbol class
      //Remember earlier we spoke of calling clone? In this case the A !== a
      //but it's good practice to call clone on values that are going to be reused
      //If a was to become 2*a then we'd also be dividing by 2*a and not a
      return new core.Symbol(Math.sin((x * Math.PI) / 180));
    }
    //let nerdamer know that it's ok to access this function
    //we do that using an array. The first parameter is the special handler
    //which we'll leave blank for now. This will only give it numeric capabilities
    _.functions.sin_d = [symbolicHandler, 1];
    //we can now use the function
    // var x = nerdamer("sin_d(90)").evaluate();
    // console.log(x.toString()); //i

    // x = nerdamer("solve(sin_d(x)=0,x)");
    // console.log(x.toString());

    core.Math2.asin_d = function (x) {
      return (Math.asin(x) * 180) / Math.PI;
    };
    //symbolic handler
    function symbolicHandler2(x) {
      //for simplicity we'll work stricly with the Symbol class
      //Remember earlier we spoke of calling clone? In this case the A !== a
      //but it's good practice to call clone on values that are going to be reused
      //If a was to become 2*a then we'd also be dividing by 2*a and not a
      return new core.Symbol((Math.asin(x) * 180) / Math.PI);
    }
    //let nerdamer know that it's ok to access this function
    //we do that using an array. The first parameter is the special handler
    //which we'll leave blank for now. This will only give it numeric capabilities
    _.functions.asin_d = [symbolicHandler2, 1];
    //we can now use the function
    // var x = nerdamer("asin_d(0.5)").evaluate();
    // console.log(x.toString()); //i

    // var x = nerdamer("solve(sin_r(x)=0,x)");
    // console.log(x.toString()); */

    const tbDiv = this.tbar.html();
    //console.log(tbDiv);
    tbDiv.append(
      $(
        '<span class="GrapherTitle" style="float:right; margin-right:4px"></span>'
      )
    );

    self.grapherEditor.initEditor();
  }
}
;
define("myPlot", ["myLegend","curveClosestPoint","plot","functionData","plotGrid","spectrogram"], function(){});


/**
 * A plot item, that represents a series of points.
 *
 * A curve is the representation of a series of points in the x-y plane. It supports different display styles,
 * interpolation ( f.e. spline ) and symbols.
 *
 * **Usage**
 *
 * **a) Assign curve properties**: When a curve is created, it is configured to draw black solid lines with in {@link Curve.CurveStyle Curve.CurveStyle.Lines} style and no symbols. You can change this by calling {@link Curve#setPen setPen()}, {@link Curve#setStyle setStyle()} and {@link Curve#setSymbol setSymbol()}.
 *
 * b) **Connect/Assign data**: Curve gets its points using a {@link SeriesData}. There are several convenience classes derived from {@link SeriesData}, that also store the points. Curve also offers a couple of variations of setSamples(), that build SeriesData objects from arrays internally.
 *
 * c) **Attach the curve to a plot**: See {@link PlotItem#attach attach()}
 * @extends PlotSeriesItem
 */
class Curve extends PlotSeriesItem {
  static mVerifyRange(size, i1, i2) {
    if (size < 1) return 0;

    i1 = Math.max(0, Math.min(i1, size - 1));
    i2 = Math.max(0, Math.min(i2, size - 1));

    if (i1 > i2) {
      //qSwap( i1, i2 );
      var temp = i1;
      i1 = i2;
      i2 = temp;
    }

    return i2 - i1 + 1;
  }
  /**
   *
   * @param {String} tle Title of curve
   */
  constructor(tle) {
    super(tle);

    var m_style = Curve.CurveStyle.Lines;
    var c_attributes = 0x0;
    var m_baseline = 0;
    var m_paintAttributes = Curve.PaintAttribute.FilterPoints;
    var m_legendAttributes = Curve.LegendAttribute.LegendNoAttribute;
    var m_brush = new Misc.Brush(); //"NoBrush";
    var m_pen = new Misc.Pen(); //mMakePen();

    var m_curveFitter = null;

    var m_symbol = null;

    this.rtti = PlotItem.RttiValues.Rtti_PlotCurve;

    this.setItemInterest(PlotItem.ItemInterest.ScaleInterest, true);

    /**
     *
     * @returns {Number} boundingRect().left()
     */
    this.minXValue = function () {
      return this.boundingRect().left();
    };

    /**
     *
     * @returns {Number} boundingRect().right()
     */
    this.maxXValue = function () {
      return this.boundingRect().right();
    };

    /**
     *
     * @returns {Number} boundingRect().top()
     */
    this.minYValue = function () {
      return this.boundingRect().top();
    };

    /**
     *
     * @returns {Number} boundingRect().bottom()
     */
    this.maxYValue = function () {
      return this.boundingRect().bottom();
    };

    /**
     * Specify an attribute how to draw the legend icon
     * @param {Curve.LegendAttribute} attribute Attribute
     * @param {Boolean} on On/Off
     * @see {@link Curve#testLegendAttribute testLegendAttribute()}
     * @see {@link Curve#legendIcon legendIcon()}
     */
    this.setLegendAttribute = function (attribute, on) {
      if (on != this.testLegendAttribute(attribute)) {
        if (on) m_legendAttributes |= attribute;
        else m_legendAttributes &= ~attribute;

        Utility.updateLegendIconSize(this);
        //alert(this.legendIconSize())
        //legendChanged();

        if (this.plot()) this.plot().updateLegend(this);
      }
    };

    /**
     *
     * @param {Curve.LegendAttribute} attribute
     * @returns {Boolean} True, when attribute is enabled
     * @see {@link Curve#setLegendAttribute setLegendAttribute()}
     */
    this.testLegendAttribute = function (attribute) {
      return m_legendAttributes & attribute;
    };

    /**
     *
     * @returns {Number} Attributes how to draw the legend icon
     */
    this.legendAttributes = function () {
      return m_legendAttributes;
    };

    /**
     * Assign a symbol.
     *
     * The curve will take the ownership of the symbol, hence the previously set symbol will be removed by setting
     * a new one. If symbol is null, no symbol will be drawn.
     * @param {Symbol2} symbol Symbol
     * @see {@link Curve#symbol symbol()}
     */
    this.setSymbol = function (symbol) {
      if (symbol !== m_symbol) {
        m_symbol = symbol;

        Utility.updateLegendIconSize(this);

        this.legendChanged();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Symbol2} Current symbol or null, when no symbol has been assigned
     * @see {@link Curve#setSymbol setSymbol()}
     */
    this.symbol = function () {
      return m_symbol;
    };

    /**
     * Assign a brush.
     *
     * In case of brush.style != Static.NoBrush and {@link Curve#style style()} != {@link Curve.CurveStyle Curve.CurveStyle.Sticks} the area between the curve and the baseline will be filled.
     *
     * The fill algorithm simply connects the first and the last curve point to the baseline. So the curve data has to be sorted (ascending or descending).
     * @param {Misc.Brush} brush New brush
     * @see {@link Curve#brush brush()}
     * @see {@link Curve#setBaseline setBaseline()}
     * @see {@link Curve#baseline baseline()}
     */
    this.setBrush = function (brush) {
      if (typeof brush == "string") brush = new Misc.Brush(brush);
      //if(!m_brush.isEqual(brush)){
      m_brush = brush;
      this.legendChanged();
      this.itemChanged();
      // }
    };

    /**
     *
     * @returns {Misc.Brush} Brush used to fill the area between lines and the baseline
     * @see {@link Curve#setBrush setBrush()}
     * @see {@link Curve#setBaseline setBaseline()}
     * @see {@link Curve#baseline baseline()}
     */
    this.brush = function () {
      return m_brush;
    };

    /**
     * Build and assign a pen
     * @param {Misc.Pen} pen New pen
     * @see {@link Curve#pen pen()}
     * @see {@link Curve#brush brush()}
     */
    this.setPen = function (pen) {
      if (typeof pen !== "object") return;
      //if(!m_pen.isEqual(pen)){
      m_pen = pen;
      this.legendChanged();
      this.itemChanged();
      //}
    };

    /**
     *
     * @returns {Misc.Pen} Pen used to draw the lines
     * @see {@link Curve#setPen setPen()}
     * @see {@link Curve#setBrush setBrush()}
     */
    this.pen = function () {
      return m_pen;
    };

    /**
     * Specify an attribute how to draw the curve
     * @param {Curve.PaintAttribute} attribute Paint attribute
     * @param {Boolean} on On/Off
     * @see {@link Curve#testPaintAttribute testPaintAttribute()}
     */
    this.setPaintAttribute = function (attribute, on) {
      if (on) m_paintAttributes |= attribute;
      else m_paintAttributes &= ~attribute;
    };

    /**
     *
     * @param {Curve.PaintAttribute} attribute
     * @returns {Boolean} True, when attribute is enabled
     * @see {@link Curve#setPaintAttribute setPaintAttribute()}
     */
    this.testPaintAttribute = function (attribute) {
      return m_paintAttributes & attribute;
    };

    /**
     * Initialize data with an array of points.
     * @param {Array<Misc.Point>} samples Array of points
     */
    this.setSamples = function (samples) {
      this.setData(new PointSeriesData(samples));
    };

    /**
     * Specify an attribute for drawing the curve
     * @param {Curve.CurveAttribute} attribute Curve attribute
     * @param {Boolean} on On/Off
     * @see {@link Curve#testCurveAttribute testCurveAttribute()}
     * @see {@link Curve#setCurveFitter setCurveFitter()}
     */
    this.setCurveAttribute = function (attribute, on) {
      if (typeof on === "undefined") on = true;
      if ((c_attributes & attribute) == on) return;

      if (on) c_attributes |= attribute;
      else c_attributes &= ~attribute;

      this.itemChanged();
    };

    /**
     *
     * @returns {Number} Attributes how to draw curve
     */
    this.curveAttributes = function () {
      return c_attributes;
    };

    /**
     *
     * @param {Curve.CurveAttribute} attribute
     * @returns {Boolean} true, if attribute is enabled
     * @see {@link Curve#setCurveAttribute setCurveAttribute()}
     */
    this.testCurveAttribute = function (attribute) {
      return c_attributes & attribute;
    };

    //! Initialize internal members
    this.init = function () {
      this.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
      this.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);

      this.setData(new PointSeriesData());
      //this.setCurveAttribute(Curve.CurveAttribute.Fitted, true);

      this.setZ(20.0);
    };

    /**
     * Set the curve's drawing style
     * @param {Curve.CurveStyle} style Curve style
     * @see {@link Curve#style style()}
     */
    this.setStyle = function (style) {
      if (style != m_style) {
        m_style = style;
        this.legendChanged();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Curve.CurveStyle} Style of the curve
     * @see {@link Curve#setStyle setStyle()}
     */
    this.style = function () {
      return m_style;
    };

    /**
     * Draw an interval of the curve
     * @param {ScaleMap} xMap Maps x-values into pixel coordinates.
     * @param {ScaleMap} yMap Maps y-values into pixel coordinates.
     * @param {Number} from Index of the first point to be painted
     * @param {Number} to Index of the last point to be painted. If to < 0 the curve will be painted to its last point.
     * @see {@link Curve#drawCurve drawCurve()}
     * @see {@link Curve#drawSymbols drawSymbols()}
     */
    this.drawSeries = function (xMap, yMap, from, to) {
      var ctx = this.getContext();

      var painter = new PaintUtil.Painter(ctx);
      // painter.setPen(m_pen);
      // painter.setBrush(m_brush);
      var numSamples = this.dataSize();

      if (numSamples <= 0) return;

      //        if ( typeof(from) == "undefined" )
      //            from = 0;

      //        if ( typeof(to) == "undefined" )
      //            to = numSamples - 1;
      if (to < 0) to = numSamples - 1;

      //alert(from)

      if (Curve.mVerifyRange(numSamples, from, to) > 0) {
        painter.save();
        painter.setPen(m_pen);
        painter.setBrush(m_brush);
        //painter->setPen( d_data->pen );

        /*
                Qt 4.0.0 is slow when drawing lines, but it's even
                slower when the painter has a brush. So we don't
                set the brush before we really need it.
                 */

        this.drawCurve(painter, m_style, xMap, yMap, from, to);
        painter.restore();

        if (m_symbol && m_symbol.style() !== Symbol2.Style.NoSymbol) {
          painter.save();
          painter.setPen(m_symbol.pen());
          painter.setBrush(m_symbol.brush());
          this.drawSymbols(ctx, m_symbol, xMap, yMap, from, to);
          painter.restore();
        }
      }
      painter = null;
    };

    /**
     * Draw symbols
     * @param {object} ctx 2d context for the central div canvas
     * @param {Symbol2} symbol Curve symbol
     * @param {ScaleMap} xMap x map
     * @param {ScaleMap} yMap y map
     * @param {Number} from Index of the first point to be painted
     * @param {Number} to Index of the last point to be painted
     * @see {@link Curve#setSymbol setSymbol()}
     * @see {@link Curve#drawSeries drawSeries()}
     * @see {@link Curve#drawCurve drawCurve()}
     */
    this.drawSymbols = function (ctx, symbol, xMap, yMap, from, to) {
      var mapper = new PointMapper();
      //mapper.setFlag( QwtPointMapper::PointMapper.TransformationFlag.RoundPoints,  QwtPainter::roundingAlignment( painter ) );
      mapper.setFlag(
        PointMapper.TransformationFlag.WeedOutPoints,
        this.testPaintAttribute(Curve.PaintAttribute.FilterPoints)
      );
      //mapper.setBoundingRect( canvasRect );

      var chunkSize = 500;

      //var ctx = this.getContext();
      for (var i = from; i <= to; i += chunkSize) {
        var n = Math.min(chunkSize, to - i + 1);

        var points = mapper.toPointsF(xMap, yMap, this.data(), i, i + n - 1);

        if (points.length > 0) symbol.drawSymbols(ctx, points);
      }
    };

    /**
     * Set the value of the baseline
     *
     * The baseline is needed for filling the curve with a brush or the Sticks drawing style.
     *
     * The interpretation of the baseline depends on the orientation(). With Static.Horizontal, the baseline is
     * interpreted as a horizontal line at y = baseline(), with Static.Vertical, it is interpreted as a vertical line at x = baseline().
     *
     * The default value is 0.0.
     * @param {Number} value Value of the baseline
     * @see {@link Curve#baseline baseline()}
     * @see {@link Curve#setBrush setBrush()}
     * @see {@link Curve#setStyle setStyle()}
     * @see {@link PlotSeriesItem#orientation orientation()}
     */
    this.setBaseline = function (value) {
      if (m_baseline != value) {
        m_baseline = value;
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Number} Value of the baseline
     * @see {@link Curve#setBaseline setBaseline()}
     */
    this.baseline = function () {
      return m_baseline;
    };

    /*!
        \brief Draw lines

        If the CurveAttribute Curve.CurveAttribute.Fitted is enabled a QwtCurveFitter tries
        to interpolate/smooth the curve, before it is painted.

        \param painter Painter
        \param xMap x map
        \param yMap y map
        \param canvasRect Contents rectangle of the canvas
        \param from index of the first point to be painted
        \param to index of the last point to be painted

        \sa setCurveAttribute(), setCurveFitter(), draw(),
        drawLines(), drawDots(), drawSteps(), drawSticks()
         */
    /* this.drawLines = function (painter, xMap, yMap, from, to) {
        if (from > to)
        return;

        //const bool doAlign = QwtPainter::roundingAlignment( painter );
        var doFit = (c_attributes & Curve.CurveAttribute.Fitted) && m_curveFitter;
        var doFill = m_brush.color !== Static.NoBrush ? true : false;
        //alert(doFill)

        //        QRectF clipRect;
        //        if ( d_data->paintAttributes & ClipPolygons )
        //        {
        //            qreal pw = qMax( qreal( 1.0 ), painter->pen().widthF());
        //            clipRect = canvasRect.adjusted(-pw, -pw, pw, pw);
        //        }

        var doIntegers = false;

        //        const bool noDuplicates = d_data->paintAttributes & Curve.PaintAttribute.FilterPoints;


        var mapper = new PointMapper;
        //mapper.setFlag( QwtPointMapper::PointMapper.TransformationFlag.RoundPoints, doAlign );
        //mapper.setFlag( QwtPointMapper::PointMapper.TransformationFlag.WeedOutPoints, noDuplicates );
        //mapper.setBoundingRect( canvasRect );


        //alert(443)
        var polyline = mapper.toPolygonF(xMap, yMap, this.data(), from, to);
        //alert(444)

        if (doFit) {
        //console.log(44)
        polyline = m_curveFitter.fitCurve(polyline);
        }

        //console.log(polyline)


        painter.drawPolyline(polyline);
        if (doFill) {
        this.fillCurve(painter, xMap, yMap, polyline);
        }

        } */

    /**
     * Assign a curve fitter
     *
     * The curve fitter "smooths" the curve points, when the Fitted CurveAttribute is set. setCurveFitter(null) also disables curve fitting.
     *
     * The curve fitter operates on the translated points ( = widget coordinates) to be functional for logarithmic scales. Obviously this is less performant
     * for fitting algorithms, that reduce the number of points.
     *
     * For situations, where curve fitting is used to improve the performance of painting huge series of points it might be
     * better to execute the fitter on the curve points once and to cache the result in the QwtSeriesData object.
     * @param {CurveFitter} curveFitter Curve fitter
     * @see {@link Curve.CurveAttribute Curve.CurveAttribute.Fitted}
     */
    this.setCurveFitter = function (curveFitter) {
      //m_curveFitter = 0;
      m_curveFitter = curveFitter;

      this.itemChanged();
    };

    /**
     * Get the curve fitter. If curve fitting is disabled null is returned.
     * @returns {CurveFitter} Curve fitter
     * @see {@link Curve#setCurveFitter setCurveFitter()}
     * @see {@link Curve.CurveAttribute Curve.CurveAttribute.Fitted}
     */
    this.curveFitter = function () {
      return m_curveFitter;
    };

    function qwtSqr(x) {
      return x * x;
    }

    /**
     * Find the closest curve point index for a specific position
     *
     * closestPoint() implements a dumb algorithm, that iterates over all points
     * @param {Misc.Point} pos Position, where to look for the closest curve point
     * @param {object} dist If dist != null, closestPoint() returns the distance between the position and the closest curve point in the property `dist.distance`
     * @returns {Number} Index of the closest curve point, or -1 if none can be found
     */
    this.closestPoint = function (
      /* const QPoint & */ pos,
      /* double * */ dist
    ) {
      let numSamples = this.dataSize();

      if (this.plot() == null || numSamples <= 0) return -1;

      let series = this.data();

      let xMap = this.plot().canvasMap(this.xAxis());
      let yMap = this.plot().canvasMap(this.yAxis());

      let index = -1;
      let dmin = 1.0e10;

      for (var i = 0; i < numSamples; i++) {
        let sample = series.sample(i);

        let cx = xMap.transform(sample.x) - pos.x;
        let cy = yMap.transform(sample.y) - pos.y;

        /* let cx = sample.x  - pos.x;
                let cy = sample.y  - pos.y; */

        let f = qwtSqr(cx) + qwtSqr(cy);
        if (f < dmin) {
          index = i;
          dmin = f;
        }
      }
      if (dist) dist.distance = Math.sqrt(dmin);

      return index;
    };

    /**
     * Fill the area between the curve and the baseline with the curve brush
     * @param {PaintUtil.Painter} painter Painter
     * @param {ScaleMap} xMap x map
     * @param {ScaleMap} yMap y map
     * @param {Array<Misc.Point>} polygon Polygon - will be modified !
     * @see {@link Curve#setBrush setBrush()}
     * @see {@link Curve#setBaseline setBaseline()}
     * @see {@link Curve#setStyle setStyle()}
     */
    this.fillCurve = function (painter, xMap, yMap, polygon) {
      if (m_brush.color == Static.NoBrush) return;

      //alert(polygon.length)
      this.closePolyline(xMap, yMap, polygon);
      if (polygon.length <= 2)
        // a line can't be filled
        return;

      //alert(polygon.length)

      //if ( d_data->paintAttributes & ClipPolygons )
      //polygon = QwtClipper::clipPolygonF( canvasRect, polygon, true );

      painter.setPen(new Misc.Pen(m_brush.color));
      painter.drawPolygon(polygon);

      //painter->restore();
    };

    /**
     * Complete a polygon to be a closed polygon including the area between the original polygon and the baseline.
     * @param {ScaleMap} xMap X map
     * @param {ScaleMap} yMap Y map
     * @param {Array<Misc.Point>} polygon Polygon to be completed
     */
    this.closePolyline = function (xMap, yMap, polygon) {
      if (polygon.length < 2) return;

      //const bool doAlign = QwtPainter::roundingAlignment( painter );

      var baseline = m_baseline;

      if (this.orientation() == Static.Vertical) {
        if (yMap.transformation())
          baseline = yMap.transformation().bounded(baseline);

        var refY = yMap.transform(baseline);
        //if ( doAlign )
        //refY = qRound( refY );

        //polygon.push({x:polygon[polygon.length -1].x, y:refY} );
        //polygon.push( {x:polygon[0].x, y:refY} );
        polygon.push(new Misc.Point(polygon[polygon.length - 1].x, refY));
        polygon.push(new Misc.Point(polygon[0].x, refY));
      } else {
        if (xMap.transformation())
          baseline = xMap.transformation().bounded(baseline);

        var refX = xMap.transform(baseline);
        //if ( doAlign )
        //refX = qRound( refX );

        //polygon.push( {x:refX, y:polygon[polygon.length -1].y} );
        //polygon.push( {x:refX, y:polygon[0].y} );
        polygon.push(new Misc.Point(refX, polygon[polygon.length - 1].y));
        polygon.push(new Misc.Point(refX, polygon[0].y));
      }
    };

    /**
     * Draw step function
     *
     * The direction of the steps depends on Inverted attribute.
     * @param {PaintUtil.Painter} painter Painter
     * @param {ScaleMap} xMap x map
     * @param {ScaleMap} yMap y map
     * @param {Number} from index of the first point to be painted
     * @param {Number} to index of the last point to be painted
     * @see {@link Curve#draw draw()}
     * @see {@link Curve#drawDots drawDots()}
     * @see {@link Curve#drawLines drawLines()}
     * @see {@link Curve#drawSticks drawSticks()}
     */
    this.drawSteps = function (painter, xMap, yMap, from, to) {
      //const bool doAlign = QwtPainter::roundingAlignment( painter );

      //QPolygonF polygon( 2 * ( to - from ) + 1 );
      //alert(from+", "+to)
      var points = [];
      var sz = 2 * (to - from) + 1;
      for (var i = 0; i < sz; ++i)
        //points.push({x:0,y:0})
        points.push(new Misc.Point());

      //alert(points.length)

      var inverted = this.orientation() == Static.Vertical;
      if (c_attributes & Curve.CurveAttribute.Inverted) inverted = !inverted;

      var series = this.data();

      var i, ip;
      for (i = from, ip = 0; i <= to; i++, ip += 2) {
        var sample = series.sample(i);

        var xi = xMap.transform(sample.x);
        var yi = yMap.transform(sample.y);
        //            if ( doAlign )
        //            {
        //                xi = Math.round( xi );
        //                yi = Math.round( yi );
        //            }

        if (ip > 0) {
          var p0 = points[ip - 2];
          var p = points[ip - 1];

          if (inverted) {
            p.x = p0.x;
            p.y = yi;
          } else {
            p.x = xi;
            p.y = p0.y;
          }
        }

        points[ip].x = xi;
        points[ip].y = yi;
      }
      //alert(points)
      //        if ( d_data->paintAttributes & ClipPolygons )
      //        {
      //            const QPolygonF clipped = QwtClipper::clipPolygonF(
      //                canvasRect, polygon, false );

      //            QwtPainter::drawPolyline( painter, clipped );
      //        }
      //        else
      //        {

      painter.drawPolyline(points);
      if (this.brush() != "noBrush" /* doFill */) {
        this.fillCurve(painter, xMap, yMap, points);
      }
      //if ( this.brush() != "noBrush" )
      //            fillCurve( painter, xMap, yMap, canvasRect, polygon );
    };

    /**
     * Draw sticks
     *
     * @param {PaintUtil.Painter} painter Painter
     * @param {ScaleMap} xMap x map
     * @param {ScaleMap} yMap y map
     * @param {Number} from index of the first point to be painted
     * @param {Number} to index of the last point to be painted
     * @see {@link Curve#draw draw()}
     * @see {@link Curve#drawDots drawDots()}
     * @see {@link Curve#drawLines drawLines()}
     * @see {@link Curve#drawSteps drawSteps()}
     */
    this.drawSticks = function (painter, xMap, yMap, from, to) {
      //alert(45)
      //painter->save();
      //painter->setRenderHint( QPainter::Antialiasing, false );

      //const bool doAlign = QwtPainter::roundingAlignment( painter );
      //m_baseline = -100;

      var x0 = xMap.transform(m_baseline);
      var y0 = yMap.transform(m_baseline);
      //        if ( doAlign )
      //        {
      //            x0 = qRound( x0 );
      //            y0 = qRound( y0 );
      //        }

      var o = this.orientation();

      var series = this.data();

      //var penWidth = 1;
      //var penColor  = "#ff0000";
      //ctx.strokeStyle = penColor;///////////
      //ctx.beginPath();

      for (var i = from; i <= to; i++) {
        var sample = series.sample(i);
        var xi = xMap.transform(sample.x);
        var yi = yMap.transform(sample.y);
        //            if ( doAlign )
        //            {
        //                xi = qRound( xi );
        //                yi = qRound( yi );
        //            }

        if (o == Static.Horizontal)
          //ctx.moveTo(x0, yi);
          painter.drawLine(x0, yi, xi, yi);
        //ctx.moveTo(xi, y0);
        else painter.drawLine(xi, y0, xi, yi);
        //ctx.lineTo(xi, yi);
      }

      //ctx.stroke();
      //ctx.closePath();
    };

    /**
     *
     * Draw dots
     *
     * @param {PaintUtil.Painter} painter Painter
     * @param {ScaleMap} xMap x map
     * @param {ScaleMap} yMap y map
     * @param {Number} from index of the first point to be painted
     * @param {Number} to index of the last point to be painted
     * @see {@link Curve#draw draw()}
     * @see {@link Curve#drawSticks drawSticks()}
     * @see {@link Curve#drawLines drawLines()}
     * @see {@link Curve#drawSteps drawSteps()}
     */
    this.drawDots = function (painter, xMap, yMap, from, to) {
      //TODO
      /*var penWidth = 1;
            var penColor  = "#ff0000";
            //var ctx = this.getContext();
            ctx.fillStyle = penColor;///////////

             */

      //ctx.beginPath();

      //const QColor color = painter->pen().color();

      //if ( painter->pen().style() == Qt::NoPen || color.alpha() == 0 )
      //{
      //return;
      //}

      //const bool doFill = ( d_data->brush.style() != Qt::NoBrush )
      // && ( d_data->brush.color().alpha() > 0 );
      //const bool doAlign = QwtPainter::roundingAlignment( painter );

      var mapper = new PointMapper();
      //mapper.setBoundingRect( canvasRect );
      //mapper.setFlag( QwtPointMapper::PointMapper.TransformationFlag.RoundPoints, doAlign );

      if (m_paintAttributes & Curve.PaintAttribute.FilterPoints) {
        mapper.setFlag(PointMapper.TransformationFlag.WeedOutPoints, true);
      }

      /*if ( doFill ){
            mapper.setFlag( PointMapper.TransformationFlag.WeedOutPoints, false );

            var points = mapper.toPointsF( xMap, yMap, data(), from, to );

            this.drawPoints( painter, points );
            //fillCurve( painter, xMap, yMap, canvasRect, points );
            }*/

      /*else*/
      if (m_paintAttributes & Curve.PaintAttribute.MinimizeMemory) {
        var series = this.data();

        for (var i = from; i <= to; i++) {
          var sample = series.sample(i);

          var xi = xMap.transform(sample.x);
          var yi = yMap.transform(sample.y);

          /*if ( doAlign ){
                    xi = qRound( xi );
                    yi = qRound( yi );
                    }*/

          //this.drawPoint(ctx, {x:xi, y:yi});
          //this.drawPoint(ctx, new Point(xi, yi));
          painter.drawPoint(new Misc.Point(xi, yi));
        }

        //ctx.closePath();
      } else {
        var points = mapper.toPointsF(xMap, yMap, this.data(), from, to);
        //alert(points)

        //this.drawPoints(ctx, points );
        painter.drawPoints(points);
      }
    };

    /**
     *
     * @param {Number} index Index of the legend entry
     * @param {Misc.Size} size Icon size
     * @returns {Graphic} Icon representing the curve on the legend
     * @see {@link PlotItem#setLegendIconSize setLegendIconSize()}
     * @see {@link PlotItem#legendData legendData()}
     */
    this.legendIcon = function (index, size) {
      if (size.width === 0 && size.height === 0) return null;

      var graphic = new Graphic(null, size.width, size.height);

      //graphic.setDefaultSize( size );
      //graphic.setRenderHint( QwtGraphic::RenderPensUnscaled, true );

      //QPainter painter( &graphic );
      //painter.setRenderHint( QPainter::Antialiasing,
      // testRenderHint( QwtPlotItem::RenderAntialiased ) );
      var painter = new PaintUtil.Painter(graphic);

      if (
        this.legendAttributes() == 0 ||
        this.legendAttributes() & Curve.LegendAttribute.LegendShowBrush
      ) {
        var brush = this.brush();

        if (brush.color == Static.NoBrush && this.legendAttributes() == 0) {
          if (this.style() != Curve.CurveStyle.NoCurve) {
            brush = new Misc.Brush(this.pen().color);
          } else if (
            this.symbol() &&
            this.symbol().style() != Symbol2.Style.NoSymbol
          ) {
            brush = new Misc.Brush(this.symbol().pen().color);
          }
        }
        if (brush.color != Static.NoBrush) {
          var r = new Misc.Rect(0, 0, size.width, size.height);
          painter.fillRect(r, brush);
          //graphic.setParent($("#demo"))
        }
      }

      if (this.legendAttributes() & Curve.LegendAttribute.LegendShowLine) {
        if (this.pen().color != Static.NoPen) {
          var pn = this.pen();
          //pn.setCapStyle( Qt::FlatCap );

          painter.setPen(pn);

          var y = 0.5 * size.height;
          painter.drawLine(0.0, y, size.width, y);
        }
      }

      if (this.legendAttributes() & Curve.LegendAttribute.LegendShowSymbol) {
        if (this.symbol()) {
          var sh = size.height / 2; // + 1;
          if (this.symbol().style() == Symbol2.Style.Ellipse) sh -= 1;
          //painter.pen().width = this.symbol().pen().width
          //console.log(painter.pen().width)
          painter.setPen(this.symbol().pen());
          this.symbol().drawGraphicSymbol(
            painter,
            new Misc.Point(size.width / 2, sh),
            size
          );
        }
      }
      painter = null;
      return graphic;
    };

    /**
     * Removes the specified point from the curve.
     *
     * Triggers the pointRemoved event - (Static.trigger("pointRemoved", this))
     * @param {Misc.Point} point Point to remove
     * @param {Boolean} always=false if false (the default) and the curve has only one point, the point is not removed.
     */
    this.removePoint = function (point, always) {
      if (always == undefined) always = false;
      //console.log("Remove: curve found")
      var samples = this.data().samples();
      if (samples.length == 1 && !always) {
        Utility.alert(
          "You cannot remove the only point in the curve. Remove the entire curve."
        );
        return;
      }
      var newSamples = [];
      //var x = point.x;
      //var y = point.y;
      for (var i = 0; i < samples.length; ++i) {
        //if (samples[i].x == x && samples[i].y == y)
        if (samples[i].isEqual(point)) continue;
        newSamples.push(samples[i]);
      }
      if (newSamples.length === samples.length && !always) {
        Utility.alert("The point selected for removal does not exist.");
        return;
      }
      this.setSamples(newSamples);
      this.itemChanged();
      Static.trigger("pointRemoved", this);
    };

    /**
     *
     * @returns {String} A string representation of the object
     */
    this.toString = function () {
      return "[Curve]";
    };

    this.init();
  }

  /**
   * Draw the line part (without symbols) of a curve interval.
   * @param {PaintUtil.Painter} painter
   * @param {Curve.CurveStyle} style curve style
   * @param {ScaleMap} xMap x map
   * @param {ScaleMap} yMap y map
   * @param {Number} from index of the first point to be painted
   * @param {Number} to index of the last point to be painted
   * @see {@link Curve#draw draw()}
   * @see {@link Curve#drawDots drawDots()}
   * @see {@link Curve#drawLines drawLines()}
   * @see {@link Curve#drawSteps drawSteps()}
   * @see {@link Curve#drawSticks drawSticks()}
   */
  drawCurve(painter, style, xMap, yMap, from, to) {
    switch (style) {
      case Curve.CurveStyle.Lines:
        if (this.testCurveAttribute(Curve.CurveAttribute.Fitted)) {
          // we always need the complete
          // curve for fitting
          from = 0;
          to = this.dataSize() - 1;
        }
        this.drawLines(painter, xMap, yMap, from, to);
        break;
      case Curve.CurveStyle.Sticks:
        this.drawSticks(painter, xMap, yMap, from, to);
        break;
      case Curve.CurveStyle.Steps:
        this.drawSteps(painter, xMap, yMap, from, to);
        break;
      case Curve.CurveStyle.Dots:
        this.drawDots(painter, xMap, yMap, from, to);
        break;
      case Curve.CurveStyle.NoCurve:
      default:
        break;
    }
  }

  /**
   *
   * Draw lines
   *
   * If the CurveAttribute Curve.CurveAttribute.Fitted is enabled a CurveFitter tries to interpolate/smooth the curve,
   * before it is painted.
   * @param {PaintUtil.Painter} painter Painter
   * @param {ScaleMap} xMap x map
   * @param {ScaleMap} yMap y map
   * @param {Number} from index of the first point to be painted
   * @param {Number} to index of the last point to be painted
   * @see {@link Curve#setCurveAttribute setCurveAttribute()}
   * @see {@link Curve#setCurveFitter setCurveFitter()}
   * @see {@link Curve#draw draw()}
   * @see {@link Curve#drawSticks drawSticks()}
   * @see {@link Curve#drawDots drawDots()}
   * @see {@link Curve#drawSteps drawSteps()}
   */
  drawLines(painter, xMap, yMap, from, to) {
    if (from > to) return;

    //const bool doAlign = QwtPainter::roundingAlignment( painter );
    var doFit =
      this.curveAttributes() & Curve.CurveAttribute.Fitted &&
      this.curveFitter();
    var doFill = this.brush().color !== Static.NoBrush ? true : false;
    //alert(doFill)

    //        QRectF clipRect;
    //        if ( d_data->paintAttributes & ClipPolygons )
    //        {
    //            qreal pw = qMax( qreal( 1.0 ), painter->pen().widthF());
    //            clipRect = canvasRect.adjusted(-pw, -pw, pw, pw);
    //        }

    var doIntegers = false;

    //        const bool noDuplicates = d_data->paintAttributes & Curve.PaintAttribute.FilterPoints;

    var mapper = new PointMapper();
    //mapper.setFlag( QwtPointMapper::PointMapper.TransformationFlag.RoundPoints, doAlign );
    //mapper.setFlag( QwtPointMapper::PointMapper.TransformationFlag.WeedOutPoints, noDuplicates );
    //mapper.setBoundingRect( canvasRect );

    //alert(443)
    var polyline = mapper.toPolygonF(xMap, yMap, this.data(), from, to);
    //console.log(486, polyline);

    if (doFit) {
      //console.log(44)
      polyline = this.curveFitter().fitCurve(polyline);
    }

    //console.log(polyline)

    painter.drawPolyline(polyline);
    if (doFill) {
      this.fillCurve(painter, xMap, yMap, polyline);
    }
  }
}
/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link Curve.CurveStyle}</div>
 *
 * Curve styles.
 * @name Curve.CurveStyle
 * @readonly
 * @property {Number} NoCurve=-1             Don't draw a curve. Note: This doesn't affect the symbols.
 * @property {Number} Lines                  Connect the points with straight lines. The lines might be interpolated depending on the 'Fitted' attribute. Curve fitting can be configured using {@link Curve#setCurveFitter setCurveFitter()}.
 * @property {Number} Sticks                 Draw vertical or horizontal sticks ( depending on the {@link Curve#orientation orientation()} ) from a baseline which is defined by {@link Curve#setBaseline setBaseline()}.
 * @property {Number} Steps                  Connect the points with a step function. The step function is drawn from the left to the right or vice versa, depending on the {@link Curve.CurveAttribute Curve.CurveAttribute.Inverted} attribute.
 * @property {Number} Dots                   Draw dots at the locations of the data points. Note: This is different from a dotted line (see {@link Curve#setPen setPen()}).
 * @property {Number} UserCurve=100          Styles >= Curve.CurveStyle.UserCurve are reserved for derived classes of Curve that overload {@link Curve#drawCurve drawCurve()} with additional application specific curve types.
 */
Enumerator.enum(
  "CurveStyle {  NoCurve = -1 , Lines , Sticks , Steps , Dots , UserCurve = 100  }",
  Curve
);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link Curve.CurveAttribute}</div>
 *
 * Attribute for drawing the curve
 * @name Curve.CurveAttribute
 * @readonly
 * @property {Number} Inverted=0x01             For Curve.CurveStyle.Steps only. Draws a step function from the right to the left.
 * @property {Number} Fitted=0x02               Only in combination with Curve.CurveStyle.Lines A CurveFitter tries to interpolate/smooth the curve, before it is painted.
 */
Enumerator.enum("CurveAttribute { Inverted = 0x01 , Fitted = 0x02 }", Curve);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link Curve.LegendAttribute}</div>
 *
 * Attributes how to represent the curve on the legend
 * @name Curve.LegendAttribute
 * @readonly
 * @property {Number} LegendNoAttribute=0x00             Curve tries to find a color representing the curve and paints a rectangle with it.
 * @property {Number} LegendShowLine=0x01                If the {@link Curve#style style()} is not Curve.CurveStyle.NoCurve a line is painted with the curve {@link Curve#pen pen()}.
 * @property {Number} LegendShowSymbol=0x02              If the curve has a valid symbol it is painted.
 * @property {Number} LegendShowBrush=0x04               If the curve has a brush a rectangle filled with the curve {@link Curve#brush brush()} is painted.
 */
Enumerator.enum(
  "LegendAttribute { LegendNoAttribute = 0x00 , LegendShowLine = 0x01 , LegendShowSymbol = 0x02 , LegendShowBrush = 0x04 }",
  Curve
);

/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link ClassName.EnumName}</div>
 *
 * enum description
 * @name ClassName.EnumName
 * @readonly
 * @property {Number} flag1             This is flag 1.
 * @property {Number} flag2             This is flag 2.
 */
Enumerator.enum(
  "PaintAttribute { ClipPolygons = 0x01 , FilterPoints = 0x02 , MinimizeMemory = 0x04 , ImageBuffer = 0x08 , FilterPointsAggressive = 0x10}",
  Curve
);

define("plotcurve", ["static","seriesData"], function(){});

"include ['plotcurve']";

class MyCurve extends Curve {
  constructor(tle) {
    super(tle);
    const self = this;
    this.setAxis = false;
    this.rc = null;
    this.axesSwapped = false;

    this.parameterLimits = []; //Array of object: {minimum, maximum}

    this.toString = function () {
      return "[MyCurve]";
    };

    Static.bind("itemAttached", function (e, item, on) {
      //console.log(486, item == self, on);
      if (item == self && on) {
        if (Static.swapAxes == 0) {
          //Implicit
          if (self.xIsDependentVariable) {
            self.swapAxes();
            Static.trigger("axesSwapped", item);
          }
        }
        if (Static.swapAxes == 1) {
          //Do not swap
        }
        if (Static.swapAxes == 2) {
          //Swap
          self.swapAxes();
          Static.trigger("axesSwapped", item);
        }
      }
    });

    //this.discontinuity = [0]; //-2, 2]; //0, Math.PI, 2 * Math.PI, 3 * Math.PI, 4 * Math.PI];
  }

  //f(x) is horizontal and x is vertical
  swapAxes() {
    const self = this;
    let samples = self.data().samples();
    if (!this.axesSwapped) {
      this.axesSwapped = true;
      samples = samples.map(function (pt) {
        let x = pt.x;
        pt.x = pt.y;
        pt.y = x;
        return pt;
      });
      self.setSamples(samples);
      self.plot().autoRefresh();
    }
  }

  //x is horizontal and f(x) is vertical
  unSwapAxes() {
    if (!this.axesSwapped) return;
    this.axesSwapped = false;
    const self = this;
    let samples = self.data().samples();
    samples = samples.map(function (pt) {
      let x = pt.x;
      pt.x = pt.y;
      pt.y = x;
      return pt;
    });
    self.setSamples(samples);
    self.plot().autoRefresh();
  }

  drawCurve(painter, style, xMap, yMap, from, to) {
    const self = this;
    let samples = null; //self.data().samples();
    //console.log(self.data());
    if (!self.unboundedRange) {
      samples = self.data().samples();
    }

    //this.unSwapAxes();

    let indexBeforeDiscontinuity = [];
    const plot = self.plot();
    if (
      //!self.unboundedRange &&
      self.discontinuity &&
      self.discontinuity.length
    ) {
      // const autoReplot = plot.autoReplot();
      // plot.setAutoReplot(false);
      if (!self.unboundedRange) {
        //Account for discontinuity

        //samples are free of discontinuity.
        const samples = self.data().samples().slice();

        for (let n = 0; n < self.discontinuity.length; n++) {
          for (let i = 0; i < samples.length; i++) {
            if (samples[i].x > self.discontinuity[n]) {
              indexBeforeDiscontinuity.push(i - 1);
              break;
            }
          }
        }

        if (indexBeforeDiscontinuity.length < self.discontinuity.length)
          indexBeforeDiscontinuity.push(samples.length - 1);

        let m_from = from,
          m_to;
        for (let i = 0; i < indexBeforeDiscontinuity.length; i++) {
          if (indexBeforeDiscontinuity[i] <= 0) continue;
          m_to = indexBeforeDiscontinuity[i];
          if (m_from < m_to) {
            super.drawCurve(painter, style, xMap, yMap, m_from, m_to);
          }
          m_from = m_to + 1;
        }

        if (
          indexBeforeDiscontinuity.length == 1 &&
          indexBeforeDiscontinuity[0] == -1
        ) {
          super.drawCurve(painter, style, xMap, yMap, m_from, to);
        }

        if (m_to < to && m_from < to) {
          super.drawCurve(painter, style, xMap, yMap, m_from, to);
        }
      } else {
        //console.log("Draw unbounded");
        let samples = [];
        const data = self.data();

        const sz = data.size();

        const scaleDiv = plot.axisScaleDiv(self.xAxis());
        let left = scaleDiv.lowerBound(),
          right = scaleDiv.upperBound();

        let discontinuity = Utility.discontinuity(
          self.fn,
          left,
          right,
          self.variable
        );
        if (!discontinuity.length) {
          data.discontinuitySamples = null;
          return super.drawCurve(painter, style, xMap, yMap, from, to);
        }

        const obj = {
          fx: self.fn,
          lowerX: left,
          upperX: right,
          numOfSamples: sz,
          //indepVarIsDegree: obj.indepVarIsDegree,
          indepVar: Utility.findIndepVar(self.fn),
          //indepVarY = obj.variableY; // || findIndepVarY(fx); TODO

          discontinuity: discontinuity,
        };

        data.discontinuitySamples = Utility.makeSamples(obj);

        for (let n = 0; n < discontinuity.length; n++) {
          for (let i = 0; i < data.discontinuitySamples.length; i++) {
            if (data.discontinuitySamples[i].x > discontinuity[n]) {
              indexBeforeDiscontinuity.push(i - 1);
              break;
            }
          }
        }

        if (indexBeforeDiscontinuity.length < discontinuity.length)
          indexBeforeDiscontinuity.push(data.discontinuitySamples.length - 1);

        let m_from = from,
          m_to;
        for (let i = 0; i < indexBeforeDiscontinuity.length; i++) {
          if (indexBeforeDiscontinuity[i] <= 0) continue;
          m_to = indexBeforeDiscontinuity[i];
          if (m_from < m_to) {
            super.drawCurve(painter, style, xMap, yMap, m_from, m_to);
          }
          m_from = m_to + 1;
        }

        if (m_to < to && m_from < to) {
          super.drawCurve(painter, style, xMap, yMap, m_from, to);
        }
      }
      if (!self.setAxis) {
        self.setAxis = true;
        plot.setAxisScale(self.yAxis(), -60, 60);
      }
      // plot.setAutoReplot(autoReplot);
      // plot.autoRefresh();
    } else {
      super.drawCurve(painter, style, xMap, yMap, from, to);
    }
  }
}
;
define("myCurve", ["plotcurve"], function(){});



/**
 * Curve that displays 3D points as dots, where the z coordinate is mapped to a color.
 * @extends PlotSeriesItem
 */
class SpectroCurve extends PlotSeriesItem {
  /**
   *
   * @param {String} tle Title of the curve
   */
  constructor(tle) {
    super(tle);

    this.rtti = PlotItem.RttiValues.Rtti_PlotSpectroCurve;
    var m_colorMap = new LinearColorMap(ColorMap.Format.Indexed);
    var m_colorRange = new Interval(0.0, 1000.0);
    var m_penWidth = 0.0;
    var m_colorTable = [];

    //! Initialize internal members
    this.init = function () {
      this.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
      this.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);

      this.setData(new Point3DSeriesData());
    };

    /*!
        Specify an attribute how to draw the curve

        \param attribute Paint attribute
        \param on On/Off
        \sa testPaintAttribute()
         */
    this.setPaintAttribute = function (attribute, on) {
      if (on) m_paintAttributes |= attribute;
      else m_paintAttributes &= ~attribute;
    };

    /*!
        \return True, when attribute is enabled
        \sa setPaintAttribute()
         */
    this.testPaintAttribute = function (attribute) {
      return m_paintAttributes & attribute;
    };

    /**
     * Initialize data with an array of samples.
     * @param {Array<Misc.Point>} samples  Array of points
     */
    this.setSamples = function (samples) {
      this.setData(new Point3DSeriesData(samples));
    };

    /**
     * Change the color map
     * Often it is useful to display the mapping between intensities and
     * colors as an additional plot axis, showing a color bar.
     * @param {ColorMap} colorMap Color Map
     * @see {@link SpectroCurve#colorMap colorMap()}
     * @see {@link SpectroCurve#setColorRange setColorRange()}
     * @see {@link ColorMap#rgb rgb()}
     */
    this.setColorMap = function (colorMap) {
      if (colorMap != m_colorMap) {
        m_colorMap = colorMap;
      }
      itemChanged();
    };

    /**
     *
     * @returns {ColorMap}  Color Map used for mapping the intensity values to colors
     * @see {@link SpectroCurve#colorMap colorMap()}
     * @see {@link SpectroCurve#setColorRange setColorRange()}
     * @see {@link ColorMap#rgb rgb()}
     */
    this.colorMap = function () {
      return m_colorMap;
    };

    /**
     * Set the value interval, that corresponds to the color map
     *
     * @param {Interval} interval interval.minValue() corresponds to 0.0,
     * interval.maxValue() to 1.0 on the color map.
     * @see {@link SpectroCurve#colorRange colorRange()}
     * @see {@link SpectroCurve#setColorMap setColorMap()}
     * @see {@link ColorMap#rgb rgb()}
     */
    this.setColorRange = function (interval) {
      if (interval != m_colorRange) {
        m_colorRange = interval;

        //legendChanged();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Interval} Value interval, that corresponds to the color map
     * @see {@link SpectroCurve#setColorRange setColorRange()}
     * @see {@link SpectroCurve#setColorMap setColorMap()}
     * @see {@link ColorMap#rgb rgb()}
     */
    this.colorRange = function () {
      return m_colorRange;
    };

    /**
     * Assign a pen width
     * @param {Number} penWidth New pen width
     * @see {@link SpectroCurve#penWidth penWidth()}
     */
    this.setPenWidth = function (penWidth) {
      if (penWidth < 0.0) penWidth = 0.0;

      if (m_penWidth != penWidth) {
        m_penWidth = penWidth;

        //legendChanged();
        this.itemChanged();
      }
    };

    /**
     *
     * @returns {Number} Pen width used to draw a dot
     * @see {@link SpectroCurve#setPenWidth setPenWidth()}
     */
    this.penWidth = function () {
      return m_penWidth;
    };

    /**
     * Set the color range
     * Add stops at 0.0 and 1.0.
     * @param {string|object} color1 Color used for the minimum value of the value interval
     * @param {string|object} color2 Color used for the maximum value of the value interval
     * @see {@link SpectroCurve#color1 color1()}
     * @see {@link SpectroCurve#color2 color2()}
     */
    this.setColorInterval = function (color1, color2) {
      m_colorMap.setColorInterval(color1, color2);
      this.itemChanged();
    };

    /**
     *
     * @returns {string|object} The first color of the color range
     * @see {@link LinearColorMap#color1 color1()}
     */
    this.color1 = function () {
      return m_colorMap.color1();
    };

    /**
     *
     * @returns {string|object} The second color of the color range
     * @see {@link LinearColorMap#color2 color2()}
     */
    this.color2 = function () {
      return m_colorMap.color2();
    };

    /**
     * Draw a subset of the points
     * @param {ColorMap} xMap Maps x-values into pixel coordinates.
     * @param {ColorMap} yMap Maps y-values into pixel coordinates.
     * @param {Number} from Index of the first sample to be painted
     * @param {Number} to Index of the last sample to be painted. If to < 0 the
     * series will be painted to its last sample.
     * @see {@link SpectroCurve#drawDots drawDots()}
     */
    this.drawSeries = function (xMap, yMap, from, to) {
      var ctx = this.getContext();

      var painter = new PaintUtil.Painter(ctx);

      //if ( !painter || this.dataSize() <= 0 )
      if (this.dataSize() <= 0) return;

      if (to < 0) to = this.dataSize() - 1;

      if (from < 0) from = 0;

      if (from > to) return;

      this.drawDots(painter, xMap, yMap, /*canvasRect,*/ from, to);
      painter = null;
    };

    /**
     *
     * @param {PaintUtil.Painter} painter Painter
     * @param {ColorMap} xMap Maps x-values into pixel coordinates.
     * @param {ColorMap} yMap Maps y-values into pixel coordinates.
     * @param {Number} from Index of the first sample to be painted
     * @param {Number} to Index of the last sample to be painted. If to < 0 the
     * series will be painted to its last sample.
     * @see {@link SpectroCurve#drawSeries drawSeries()}
     */
    this.drawDots = function (painter, xMap, yMap, /*canvasRect,*/ from, to) {
      if (!m_colorRange.isValid()) return;

      //const bool doAlign = QwtPainter::roundingAlignment( painter );

      var format = m_colorMap.format();
      if (format == ColorMap.Format.Indexed)
        m_colorTable = m_colorMap.colorTable(m_colorRange);

      var series = this.data();

      for (var i = from; i <= to; i++) {
        var sample = series.sample(i);

        var xi = xMap.transform(sample.x);
        var yi = yMap.transform(sample.y);
        /*if ( doAlign ){
                xi = Math.round( xi );
                yi = Math.round( yi );
                }*/

        /*if ( d_data->paintAttributes & QwtPlotSpectroCurve::ClipPoints )
            {
                if ( !canvasRect.contains( xi, yi ) )
                continue;
                }*/

        if (format == ColorMap.Format.RGB) {
          var rgb = m_colorMap.rgb(m_colorRange, sample.z);
          painter.setPen(new Misc.Pen(Utility.RGB2HTML(rgb), m_penWidth));
          painter.setBrush(new Misc.Brush(Utility.RGB2HTML(rgb)));
        } else {
          var index = parseInt(m_colorMap.colorIndex(m_colorRange, sample.z));
          var color = m_colorTable[index];
          painter.setPen(new Misc.Pen(Utility.RGB2HTML(color), m_penWidth));
          painter.setBrush(new Misc.Brush(Utility.RGB2HTML(color)));
        }
        painter.drawPoint(new Misc.Point(xi, yi));
      }
      m_colorTable = []; //clear m_colorTable
    };

    this.init();
  }
}
;
define("plotSpectroCurve", ["static","colorMap","plotItem","seriesData"], function(){});



/**
 * Magnifier provides zooming, by magnifying in steps.
 *
 * Using Magnifier, a plot can be zoomed in/out in steps using keys, the mouse wheel or moving a mouse button in vertical direction.
 * Together with {@link PlotZoomer} and {@link Panner} it is possible to implement individual and powerful navigation of the plot canvas.
 * @extends HObject
 * @see {@link PlotZoomer}
 * @see {@link Panner}
 * @see {@link Plot}
 */
class Magnifier extends HObject {
  /**
   * Creates a magnifier for the plot.
   * @param {Plot} plot Plot object associated with the magnifier.
   */
  constructor(plot) {
    super();
    var self = this;
    var m_plot = null;
    var m_isEnabled = true;
    var m_wheelFactor = 1.9;
    var m_wheelModifiers = Static.NoModifier;
    var m_mouseFactor = 0.95;
    var m_mouseButton = Static.RightButton;
    var m_mouseButtonModifiers = Static.NoModifier;
    var m_keyFactor = 0.9;
    var m_zoomInKey = 107; //Key_Plus;
    var m_zoomInKeyModifiers = Static.Key_Shift; //Static.NoModifier;
    var m_zoomOutKey = 109; //Key_Minus;
    var m_zoomOutKeyModifiers = Static.Key_Shift; //Static.NoModifier;
    var m_mousePressed = false;
    var m_zoomInKeyModifiersEnabled = false;
    var m_zoomOutKeyModifiersEnabled = false;
    var initialPosX = 0;
    var initialPosY = 0;
    var tm = 0;
    var m_isAxisEnabled = [];

    for (var axis = 0; axis < Axis.AxisId.axisCnt; axis++)
      m_isAxisEnabled[axis] = true;

    m_isAxisEnabled[1] = false;
    m_isAxisEnabled[3] = false;

    /**
     * Disable an axis.
     * Only Axes that are enabled will be zoomed. All other axes will remain unchanged.
     * @see {@link Magnifier#isAxisEnabled isAxisEnabled()}
     * @param {Axis.AxisId} axis Axis
     * @param {boolean} on On/Off
     */
    this.setAxisEnabled = function (axis, on) {
      if (axis >= 0 && axis < Axis.AxisId.axisCnt) m_isAxisEnabled[axis] = on;
    };

    /**
     * Test if an axis is enabled
     * @param {Axis.AxisId} axis Axis
     * @returns {boolean} true, if the axis is enabled.
     */
    this.isAxisEnabled = function (axis) {
      if (axis >= 0 && axis < Axis.AxisId.axisCnt) return m_isAxisEnabled[axis];
      return true;
    };

    if (typeof plot !== "undefined") {
      plot.magnifier = this;
      m_plot = plot;
      this.setElement(m_plot.getLayout().getCentralDiv());
    }

    /**
     *
     * @returns {Plot} Plot, containing the observed plot canvas.
     */
    this.plot = function () {
      return m_plot;
    };

    /**
     * Change the wheel factor.
     * The wheel factor defines the ratio between the current range
     * on the parent widget and the zoomed range for each
     * step of the wheel. Use values > 1 for magnification (i.e. 2.0)
     * and values < 1 for scaling down (i.e. 1/2.0 = 0.5).
     * You can use this feature for inverting the direction of the wheel.
     * The default value is 0.9.
     * @see {@link Magnifier#wheelFactor wheelFactor()},
     * {@link Magnifier#setMouseFactor setMouseFactor()} and
     * {@link Magnifier#setKeyFactor setKeyFactor()}
     * @param {number} factor Wheel factor
     */
    this.setWheelFactor = function (factor) {
      m_wheelFactor = factor;
    };

    /**
     *
     * @returns {number}  Wheel factor.
     * @see {@link Magnifier#setWheelFactor setWheelFactor()}
     */
    this.wheelFactor = function () {
      return m_wheelFactor;
    };

    /**
     *
     * @param {number} modifiers Keyboard modifiers. Use the bitwise OR operator as
     * necessary (e.g Static.ShiftModifier | Static.ControlModifier
     * indicates SHIFT and CTRL keys pressed).
     */
    this.setWheelModifiers = function (modifiers) {
      m_wheelModifiers = modifiers;
    };

    /**
     *
     * @returns {number} Wheel modifiers
     */
    this.wheelModifiers = function () {
      return m_wheelModifiers;
    };

    /**
     * Change the mouse factor. The mouse factor defines the ratio
     * between the current range on the parent widget
     * and the zoomed range for each vertical mouse movement.
     * The default value is 0.95.
     * @see {@link Magnifier#mouseFactor mouseFactor()},
     * {@link Magnifier#setMouseButton setMouseButton()},
     * {@link Magnifier#setWheelFactor setWheelFactor()} and
     * {@link Magnifier#setKeyFactor setKeyFactor()}
     * @param {number} factor Mouse factor
     */
    this.setMouseFactor = function (factor) {
      m_mouseFactor = factor;
    };

    /**
     *
     * @returns {number} Mouse factor
     * @see {@link  Magnifier#setMouseFactor setMouseFactor()}
     */
    this.mouseFactor = function () {
      return m_mouseFactor;
    };

    /**
     * Assign the mouse button, that is used for zooming in/out.
     * The default value is Qt::RightButton.
     * @param {number} button
     * @param {number} modifiers Keyboard modifiers
     * @see {@link Magnifier#getMouseButton getMouseButton()}
     */
    this.setMouseButton = function (button, modifiers) {
      m_mouseButton = button;
      m_mouseButtonModifiers = modifiers;
    };

    /**
     *
     * @returns {object} object containing button and modifiers
     */
    this.getMouseButton = function () {
      return {
        button: m_mouseButton,
        modifiers: m_mouseButtonModifiers,
      };
    };

    /**
     * Change the key factor. The key factor defines the ratio between
     * the current range on the parent widget and the zoomed
     * range for each key press of the zoom in/out keys.
     * The default value is 0.9.
     * @see {@link Magnifier#keyFactor keyFactor()},
     * {@link Magnifier#setZoomInKey setZoomInKey()},
     * {@link Magnifier#setZoomOutKey setZoomOutKey()},
     * {@link Magnifier#setWheelFactor setWheelFactor()} and
     * {@link Magnifier#setMouseFactor setMouseFactor()}
     * @param {number} factor Key factor
     */
    this.setKeyFactor = function (factor) {
      m_keyFactor = factor;
    };

    /**
     *
     * @returns {number} Key factor
     */
    this.keyFactor = function () {
      return m_keyFactor;
    };

    /**
     * Assign the key, that is used for zooming in. The default
     * combination is Qt::Key_Plus + Qt::NoModifier.
     * @see {@link Magnifier#getZoomInKey getZoomInKey()} and
     * {@link Magnifier#setZoomInKey setZoomInKey()}
     * @param {number} key
     * @param {number} modifiers
     */
    this.setZoomInKey = function (key, modifiers) {
      m_zoomInKey = key;
      m_zoomInKeyModifiers = modifiers;
    };

    /**
     * Retrieve the settings of the zoom in key
     * @see {@link Magnifier#setZoomInKey setZoomInKey()}
     * @returns {object}
     */
    this.getZoomInKey = function () {
      return {
        key: m_zoomInKey,
        modifiers: m_zoomInKeyModifiers,
      };
    };

    /**
     * Assign the key that is used for zooming out. The default combination
     * is Qt::Key_Minus + Qt::NoModifier.
     * @param {number} key
     * @param {number} modifiers
     * @see {@link Magnifier#getZoomOutKey getZoomOutKey()} and
     * {@link Magnifier#setZoomOutKey setZoomOutKey()}
     */
    this.setZoomOutKey = function (key, modifiers) {
      m_zoomOutKey = key;
      m_zoomOutKeyModifiers = modifiers;
    };

    /**
     * Retrieve the settings of the zoom out key.
     * @see {@link Magnifier#setZoomOutKey setZoomOutKey()}
     * @returns {object}
     */
    this.getZoomOutKey = function () {
      return {
        key: m_zoomOutKey,
        modifiers: m_zoomOutKeyModifiers,
      };
    };

    // /**
    //  * When enabled, mouse and keyboard events are monitored.
    //  * @param {Boolean} on true / false
    //  * @see {@link Magnifier#isEnabled isEnabled()}
    //  */
    // this.setEnabled = function (on) {
    //   m_isEnabled = on;
    // };

    // /**
    //  *
    //  * @returns {boolean} true / false
    //  * @see {@link Magnifier#setEnabled setEnabled()}
    //  */
    // this.isEnabled = function () {
    //   return m_isEnabled;
    // };

    //Documented in base class
    this.event = function (event) {
      if (!m_isEnabled) return;
      switch (event.type) {
        case "mousedown":
          {
            if (this.plot() == null) {
              return true;
            }
            if (event.button !== m_mouseButton) {
              return true;
            }
            initialPosX = event.clientX;
            initialPosY = event.clientY;
            m_mousePressed = true;
            return true;
          }
          break;
        case "mouseup":
          {
            if (
              event.button === m_mouseButton &&
              m_mousePressed &&
              this.plot()
            ) {
              m_mousePressed = false;
            }
          }
          break;
        case "mousemove":
          {
            if (!m_mousePressed) return;
            var dy = event.clientY - initialPosY;
            if (dy != 0) {
              var f = m_mouseFactor;
              if (dy < 0) f = 1 / f;
              this.rescale(f);
            }
            initialPosX = event.clientX;
            initialPosY = event.clientY;
          }
          break;
        case "keydown":
          {
            if (event.keyCode == m_zoomInKeyModifiers) {
              m_zoomInKeyModifiersEnabled = true;
            }
            if (event.keyCode == m_zoomOutKeyModifiers) {
              m_zoomOutKeyModifiersEnabled = true;
            }
            if (event.keyCode == m_zoomInKey && m_zoomInKeyModifiersEnabled) {
              this.rescale(m_keyFactor);
            } else if (
              event.keyCode == m_zoomOutKey &&
              m_zoomOutKeyModifiersEnabled
            ) {
              this.rescale(1.0 / m_keyFactor);
            }
          }
          break;
        case "keyup":
          {
            if (event.keyCode == m_zoomInKeyModifiers) {
              m_zoomInKeyModifiersEnabled = false;
            }
            if (event.keyCode == m_zoomOutKeyModifiers) {
              m_zoomOutKeyModifiersEnabled = false;
            }
          }
          break;
        case "mousewheel":
          {
            if (m_wheelFactor != 0.0) {
              var f = Math.pow(m_wheelFactor, Math.abs(event.deltaY / 15));
              if (event.deltaY > 0) f = 1 / f;
              this.rescale(f);
            }
          }
          break;
        default:
        // code block
      }
    };

    /**
     * Zoom in/out the axes scales
     * @param {number} factor
     * @returns {(void|boolean)} If boolean, false.
     */
    this.rescale = function (factor) {
      var plt = this.plot();
      if (plt == null) return;
      factor = Math.abs(factor);
      if (factor == 1.0 || factor == 0.0) return;
      var doReplot = false;
      var autoReplot = plt.autoReplot();
      plt.setAutoReplot(false);
      clearTimeout(tm);
      Static.trigger("magnifyingStart");

      for (var axisId = 0; axisId < Axis.AxisId.axisCnt; axisId++) {
        var scaleDiv = this.plot().axisScaleDiv(axisId);
        if (this.isAxisEnabled(axisId)) {
          var scaleEngine = this.plot().axisScaleEngine(axisId);
          var center, width_2, lower, upper;
          //Static.mLog = function(base, value)
          if (scaleEngine instanceof LogScaleEngine) {
            center =
              (Static.mLog(scaleEngine.base(), scaleDiv.lowerBound()) +
                Static.mLog(scaleEngine.base(), scaleDiv.upperBound())) /
              2;
            width_2 =
              ((Static.mLog(scaleEngine.base(), scaleDiv.upperBound()) -
                Static.mLog(scaleEngine.base(), scaleDiv.lowerBound())) /
                2) *
              factor;
            lower = Math.pow(scaleEngine.base(), center - width_2);
            upper = Math.pow(scaleEngine.base(), center + width_2);
          } else {
            center = scaleDiv.lowerBound() + scaleDiv.range() / 2;
            width_2 = (scaleDiv.range() / 2) * factor;
            lower = center - width_2;
            upper = center + width_2;
          }
          plt.setAxisScale(axisId, lower, upper);
          doReplot = true;
        }
      }
      //Ensure "magnifyingEnd" event is not triggered if rescaling is occurs within 100ms.
      tm = setTimeout(function () {
        //Static.trigger("magnifyingEnd");
        Static.trigger("magnifyingEnd");
      }, 100);
      //plt.setAxesAutoScale(false);
      plt.setAutoReplot(autoReplot);
      plt.autoRefresh();
      return false;
    };

    //Enable the object. Turn on envent monitoring.
    this.setEnabled_1(true);

    /**
     *
     * @returns {string} a string representing the object.
     */
    this.toString = function () {
      return "[Magnifier]";
    };
  }
}
;
define("magnifier", ["static","hObject"], function(){});

class PrivateData_2 {
  constructor() {
    this.zoomRectIndex;
    /*QStack<QRectF>*/
    this.zoomStack = [];

    this.maxStackDepth;
  }
}

/**
 * PlotZoomer provides stacked zooming for a plot widget. It is tailored for plots with one x and y axis.
 *
 * PlotZoomer selects rectangles from user inputs ( mouse or keyboard ) translates them into plot coordinates and adjusts the axes to
 * them. The selection is supported by a rubber band and optionally by displaying the coordinates of the current mouse position.
 *
 * Zooming can be repeated as often as possible, limited only by {@link PlotZoomer#maxStackDepth maxStackDepth()} or {@link PlotZoomer#minZoomSize minZoomSize()}. Each rectangle
 * is pushed on a stack.
 *
 * The default setting how to select rectangles is a {@link PickerDragRectMachine} with the following bindings:
 * - `EventPattern::MouseSelect1` The first point of the zoom rectangle is selected by a mouse press, the second point from the position, where the mouse is released.
 * - `EventPattern::KeySelect1` The first key press selects the first, the second key press selects the second point.
 * - `EventPattern::KeyAbort` Discard the selection in the state, where the first point is selected.
 *
 * To traverse the zoom stack the following bindings are used:
 * - `EventPattern::MouseSelect3`, `EventPattern::KeyUndo` Zoom out one position on the zoom stack
 * - `EventPattern::MouseSelect6`, `EventPattern::KeyRedo` Zoom in one position on the zoom stack
 * - `EventPattern::MouseSelect2`, `EventPattern::KeyHome` Zoom to the zoom base
 *
 * The {@link PlotZoomer#setKeyPattern setKeyPattern()} and {@link PlotZoomer#setMousePattern setMousePattern()} functions can be used to configure the zoomer actions. The example below shows, how to configure the 'I' and 'O' keys for zooming in and out one position on the zoom stack. The "Home" key is used to "unzoom" the plot.
 * @example
 * //Using the overloaded constructor
 * const canvas = plot.getCentralWidget();
 * new PlotZoomer(canvas); //The default axes (Axis.AxisId.xBottom, Axis.AxisId.yLeft)
 * new PlotZoomer(Axis.AxisId.xTop, Axis.AxisId.yRight, canvas);
 *
 * //Setting up kepatterns
 * zoomer = new PlotZoomer( plot );
 * zoomer->setKeyPattern( EventPattern.KeyPatternCode.KeyUndo, Static.Key_I, Static.ShiftModifier );
 * zoomer->setKeyPattern( EventPattern.KeyPatternCode.KeyRedo, Static.Key_O, Static.ShiftModifier );
 * zoomer->setKeyPattern( EventPattern.KeyPatternCode.KeyHome, Static.Key_Home );
 * @extends PlotPicker
 */
class PlotZoomer extends PlotPicker {
  /**
   * Create a zoomer for a plot canvas. See example.
   * @param {Axis.AxisId} [xAxis] Axis of the zoomer
   * @param {Axis.AxisId} [yAxis] Axis of the zoomer
   * @param {Widget} canvas Central widget
   * @param {Boolean} doReplot=true Call {@link Plot#replot replot()} for the attached plot before initializing the zoomer with its scales. This might be necessary, when the plot is in a state with pending scale changes.
   * @example
   * const canvas = plot.getCentralWidget();
   * new PlotZoomer(canvas); //The default axes (Axis.AxisId.xBottom, Axis.AxisId.yLeft)
   * new PlotZoomer(Axis.AxisId.xTop, Axis.AxisId.yRight, canvas);
   */
  constructor(xAxis, yAxis, /*QWidget **/ canvas, doReplot = true) {
    if (typeof xAxis !== "number") {
      //first argument is a widget
      canvas = xAxis;
      super(canvas);
    } else {
      super(xAxis, yAxis, canvas);
    }

    /*if ( canvas )
		this.init( doReplot );*/

    var self = this;

    /*PrivateData*/
    var d_data;

    this.privateData = function () {
      return d_data;
    };

    this.getZoomerData = function () {
      return d_data;
    };

    //! Init the zoomer, used by the constructors
    this.init = function (doReplot) {
      d_data = new PrivateData_2();

      d_data.maxStackDepth = -1;

      this.setTrackerMode(Picker.DisplayMode.ActiveOnly);
      //this.setTrackerMode( Picker.DisplayMode.AlwaysOn );
      this.setRubberBand(Picker.RubberBand.RectRubberBand);
      this.setStateMachine(new PickerDragRectMachine());

      this.plot().zoomer = this;

      Static.trigger("zoomerAdded", this);

      if (doReplot && this.plot()) {
        this.plot().autoRefresh();
      }

      this.setZoomBase(this.scaleRect());
    };

    /**
     * Reinitialized the zoom stack with scaleRect() as base.
     * @param {boolean | Misc.Rect} [doReplot = true] - If boolean and true, calls replot() method for the attached plot before initializing
     * the zoomer with its scales. This is necessary, when the plot is in a state with pending scale changes. The default is true.
     * If a valid Rect object, sets the initial size of the zoomer. The Rect is united with the current scaleRect() and the zoom stack is
     * reinitialized with it as zoom base. plot is zoomed to scaleRect().
     * @see {@link PlotPicker}, {@link Plot#autoReplot autoReplot()}
     * @see {@link Plot#replot replot()}.
     */
    this.setZoomBase = function (doReplot = true) {
      //or  /*setZoomBase( const QRectF & );*/
      if (typeof doReplot == "object") {
        var base = doReplot;
        var plt = this.plot();
        if (!plt) return;

        /*const QRectF*/
        var sRect = this.scaleRect();
        /*const QRectF*/
        var bRect = base | sRect;
        var bRect = null;
        if (!base) bRect = sRect;
        else bRect = base;

        //d_data.zoomStack.clear();
        d_data.zoomStack = [];
        d_data.zoomStack.push(bRect);
        d_data.zoomRectIndex = 0;

        if (!base.isEqual(sRect)) {
          d_data.zoomStack.push(sRect);
          d_data.zoomRectIndex++;
        }

        this.rescale();
      } else {
        var plt = this.plot();
        if (plt == null) return;

        if (doReplot) plt.autoRefresh();

        //d_data.zoomStack.clear();
        d_data.zoomStack = [];
        d_data.zoomStack.push(this.scaleRect());
        d_data.zoomRectIndex = 0;

        this.rescale();
      }
    };

    /**
     *
     * @returns Initial rectangle of the zoomer.
     * @see {@link PlotZoomer#setZoomBase setZoomBase()}
     * @see {@link PlotZoomer#zoomRect zoomRect()}
     */
    this.zoomBase = function () {
      return d_data.zoomStack[0];
    };

    /**
     *
     * @returns Rectangle at the current position on the zoom stack.
     * @see {@link PlotZoomer#zoomRectIndex zoomRectIndex()}
     * @see {@link PlotZoomer#scaleRect scaleRect()}
     */
    this.zoomRect = function () {
      return d_data.zoomStack[d_data.zoomRectIndex];
    };

    /**
     * Limit the number of recursive zoom operations to depth.
     *
     * A value of -1 set the depth to unlimited, 0 disables zooming.
     * If the current zoom rectangle is below depth, the plot is unzoomed.
     *
     * depth doesn't include the zoom base, so zoomStack().count() might be maxStackDepth() + 1.
     * @param {Number} depth Maximum for the stack depth
     * @see {@link PlotZoomer#maxStackDepth maxStackDepth()}
     */
    this.setMaxStackDepth = function (depth) {
      d_data.maxStackDepth = depth;

      if (depth >= 0) {
        // unzoom if the current depth is below d_data2->maxStackDepth

        /*const int*/
        var zoomOut = d_data.zoomStack.length - 1 - depth; // -1 for the zoom base

        if (zoomOut > 0) {
          this.zoom(-zoomOut);
          for (
            var i = d_data.zoomStack.length - 1;
            i > d_data.zoomRectIndex;
            i--
          ) {
            d_data.zoomStack.pop(); // remove trailing rects
          }
        }
      }
    };

    /**
     *
     * @returns {Number} Maximal depth of the zoom stack.
     * @see {@link PlotZoomer#setMaxStackDepth setMaxStackDepth()}
     */
    this.maxStackDepth = function () {
      return d_data.maxStackDepth;
    };

    /**
     *
     * @returns {Array<Misc.Rect>} The zoom stack. zoomStack()[0] is the zoom base, zoomStack()[1] the first zoomed rectangle.
     * @see {@link PlotZoomer#setZoomStack setZoomStack()}
     * @see {@link PlotZoomer#zoomRectIndex zoomRectIndex()}
     */
    this.zoomStack = function () {
      return d_data.zoomStack;
    };

    /**
     * Assign a zoom stack. If zoomed, the zoomed event is triggered - Static.trigger("zoomed", this.zoomRect())
     *
     * In combination with other types of navigation it might be useful to modify to manipulate the complete zoom stack.
     * @param {Array<Misc.Rect>} zoomStack  New zoom stack
     * @param {Number} zoomRectIndex=-1 Index of the current position of zoom stack. In case of -1 the current position is at the top of the stack.
     * @see {@link PlotZoomer#zoomStack zoomStack()}
     * @see {@link PlotZoomer#zoomRectIndex zoomRectIndex()}
     */
    this.setZoomStack = function (zoomStack, zoomRectIndex = -1) {
      if (this.zoomStack.length == 0) return;

      if (
        d_data.maxStackDepth >= 0 &&
        this.zoomStack.length > d_data.maxStackDepth
      ) {
        return;
      }

      if (zoomRectIndex < 0 || zoomRectIndex > this.zoomStack.length)
        zoomRectIndex = zoomStack.length - 1;

      var doRescale = this.zoomStack[zoomRectIndex] != this.zoomRect();

      d_data.zoomStack = zoomStack;
      d_data.zoomRectIndex = zoomRectIndex;

      if (doRescale) {
        this.rescale();
        //Q_EMIT zoomed( zoomRect() );
        Static.trigger("zoomed", this.zoomRect());
      }
    };

    /**
     *
     * @returns {Number} Index of current position of zoom stack.
     */
    this.zoomRectIndex = function () {
      return d_data.zoomRectIndex;
    };

    /**
     * Move the current zoom rectangle.
     *
     * The changed rectangle is limited by the zoom base
     * @param {Number} dx X offset
     * @param {Number} dy Y offset
     * @see {@link PlotZoomer#moveTo moveTo()}
     */
    this.moveBy = function (dx, dy) {
      /*const QRectF*/
      var rect = d_data.zoomStack[d_data.zoomRectIndex];
      moveTo(new Misc.Point(rect.left() + dx, rect.top() + dy));
    };

    /**
     * Move the the current zoom rectangle.
     *
     * The changed rectangle is limited by the zoom base
     * @param {Misc.Point} pos New position
     * @see {@link PlotZoomer#moveBy moveBy()}
     */
    this.moveTo = function (/*const QPointF*/ pos) {
      var x = pos.x;
      var y = pos.y;

      if (x < this.zoomBase().left()) x = this.zoomBase().left();
      if (x > this.zoomBase().right() - this.zoomRect().width())
        x = this.zoomBase().right() - this.zoomRect().width();

      if (y < this.zoomBase().top()) y = this.zoomBase().top();
      if (y > this.zoomBase().bottom() - this.zoomRect().height())
        y = this.zoomBase().bottom() - this.zoomRect().height();

      if (x != this.zoomRect().left() || y != this.zoomRect().top()) {
        d_data.zoomStack[d_data.zoomRectIndex].moveTo(x, y);
        this.rescale();
      }
    };

    /**
     * Zoom in. If zoomed, the zoomed event is triggered - Static.trigger("zoomed", this.zoomRect())
     *
     * Clears all rectangles above the current position of the zoom stack and pushes the normalized rectangle on it.
     *
     * If the maximal stack depth is reached, zoom is ignored.
     * @param {Misc.Rect} rect
     */
    this.zoom = function (/*QRectF*/ rect) {
      //or /*virtual void zoom( int up );*/
      if (typeof rect == "number") {
        var offset = rect;
        if (offset == 0) d_data.zoomRectIndex = 0;
        else {
          var newIndex = d_data.zoomRectIndex + offset;
          newIndex = Math.max(0, newIndex);
          newIndex = Math.min(d_data.zoomStack.length - 1, newIndex);

          d_data.zoomRectIndex = newIndex;
        }

        this.rescale();

        Static.trigger("zoomed", this.zoomRect());
      } else {
        if (
          d_data.maxStackDepth >= 0 &&
          d_data.zoomRectIndex >= d_data.maxStackDepth
        ) {
          return;
        }

        var zoomRect = rect.normalized();
        if (!zoomRect.isEqual(d_data.zoomStack[d_data.zoomRectIndex])) {
          for (
            var i = d_data.zoomStack.length - 1;
            i > d_data.zoomRectIndex;
            i--
          ) {
            d_data.zoomStack.pop();
          }
          d_data.zoomStack.push(zoomRect);
          d_data.zoomRectIndex++;

          this.rescale();

          Static.trigger("zoomed", zoomRect);
        }
      }
    };

    /**
     * Limit zooming by a minimum rectangle
     * @returns {Misc.Size} zoomBase().width() / 10e4, zoomBase().height() / 10e4
     */
    this.minZoomSize = function () {
      return new Misc.Size(
        d_data.zoomStack[0].width() / 10e4,
        d_data.zoomStack[0].height() / 10e4
      );
    };

    /**
     * Check and correct a selected rectangle
     *
     * Reject rectangles with a height or width < 2, otherwise expand the selected rectangle to a minimum size of 11x11 and
     * accept it.
     * @param {Array<Misc.Point>} pa List of selected points to validate
     * @returns {Boolean} true If the rectangle is accepted, or has been changed to an accepted one.
     */
    this.accept = function (/*QPolygon*/ pa) {
      if (pa.length < 2) return false;

      var rect = new Misc.Rect(pa[0], pa[pa.length - 1]);
      rect = rect.normalized();

      var minSize = 2;
      if (rect.width() < minSize && rect.height() < minSize) return false;

      var minZoomSize = 11;

      var center = rect.center();
      rect.setSize(
        rect.size().expandedTo(new Misc.Size(minZoomSize, minZoomSize))
      );
      rect.moveCenter(center);

      pa.resize(2);
      pa[0] = rect.topLeft();
      pa[1] = rect.bottomRight();

      return true;
    };

    if (canvas) this.init(doReplot);
  }

  /**
   * Adjust the observed plot to zoomRect()
   *
   * Initiates {@link Plot#replot replot()}
   *
   */
  rescale() {
    var plt = this.plot();
    if (!plt) return;
    let d_data = this.privateData();
    var rect = d_data.zoomStack[d_data.zoomRectIndex];
    /*if ( rect !== this.scaleRect() )*/
    if (!rect.isEqual(this.scaleRect())) {
      var doReplot = plt.autoReplot();
      plt.setAutoReplot(false);

      var x1 = rect.left();
      var x2 = rect.right();
      if (!plt.axisScaleDiv(this.xAxis()).isIncreasing()) {
        //qSwap( x1, x2 );
        var temp = x1;
        x1 = x2;
        x2 = temp;
      }

      plt.setAxisScale(this.xAxis(), x1, x2);

      var y1 = rect.top();
      var y2 = rect.bottom();
      if (!plt.axisScaleDiv(this.yAxis()).isIncreasing()) {
        //qSwap( y1, y2 );
        var temp = y1;
        y1 = y2;
        y2 = temp;
      }

      plt.setAxisScale(this.yAxis(), y1, y2);

      plt.setAutoReplot(doReplot);

      plt.autoRefresh();
    }
  }

  /**
   * Static.Key_Plus zooms in, Static.Key_Minus zooms out one position on the zoom stack, Static.Key_Escape zooms out to the zoom base.
   *
   * Changes the current position on the stack, but doesn't pop any rectangle.
   *
   * The keys codes can be changed, using {@link EventPattern#setKeyPattern setKeyPattern()}
   * @param {Event} ke Key event
   */
  widgetKeyPressEvent(ke) {
    const Enum = Enumerator.getDefaultEnumNampespace();
    if (!this.isActive()) {
      if (this.keyMatch(EventPattern.KeyPatternCode.KeyUndo, ke)) this.zoom(-1);
      else if (this.keyMatch(EventPattern.KeyPatternCode.KeyRedo, ke))
        this.zoom(+1);
      else if (this.keyMatch(EventPattern.KeyPatternCode.KeyHome, ke))
        this.zoom(0);
    }

    super.widgetKeyPressEvent(ke);
  }

  /**
   * Static.MidButton zooms out one position on the zoom stack. Static.MidButton + Static.ShiftModifier zooms in one position on the zoom stack.
   *
   * Changes the current position on the stack, but doesn't pop any rectangle.
   *
   * The mouse events can be changed, using {@link EventPattern#setMousePattern setMousePattern()}
   * @param {Event} me Mouse event
   */
  widgetMouseReleaseEvent(me) {
    const Enum = Enumerator.getDefaultEnumNampespace();
    if (this.mouseMatch(EventPattern.MousePatternCode.MouseSelect2, me));
    else if (this.mouseMatch(EventPattern.MousePatternCode.MouseSelect3, me))
      //this.zoom(0);
      this.zoom(-1);
    else if (this.mouseMatch(EventPattern.MousePatternCode.MouseSelect6, me))
      this.zoom(+1);
    else super.widgetMouseReleaseEvent(me);
  }

  /**
   * Expand the selected rectangle to {@link PlotZoomer#minZoomSize minZoomSize()} and zoom in if accepted.
   * @param {Boolean} ok If true, complete the selection and emit selected signals otherwise discard the selection.
   * @returns {Boolean} True if the selection has been accepted, false otherwise
   * @see {@link PlotZoomer#accept accept()}
   * @see {@link PlotZoomer#minZoomSize minZoomSize()}
   */
  end(ok = true) {
    ok = super.end(ok);
    if (!ok) return false;

    var plot = this.plot();
    if (!plot) return false;

    var pa = this.selection();
    if (pa.length < 2) return false;

    var rect = new Misc.Rect(pa[0], pa[pa.length - 1]);
    rect = rect.normalized();

    var zoomRect = this.invTransform(rect).normalized();

    var minSize = this.minZoomSize();
    if (minSize.isValid()) {
      /*const QPointF*/
      var center = zoomRect.center();
      zoomRect.setSize(zoomRect.size().expandedTo(this.minZoomSize()));
      zoomRect.moveCenter(center);
    }
    this.zoom(zoomRect);
    return true;
  }

  /**
   * Rejects selections, when the stack depth is too deep, or the zoomed rectangle is {@link PlotZoomer#minZoomSize minZoomSize()}.
   * @see {@link PlotZoomer#minZoomSize minZoomSize()}
   * @see {@link PlotZoomer#maxStackDepth maxStackDepth()}
   */
  begin() {
    var d = this.getZoomerData();
    if (d.maxStackDepth >= 0) {
      if (d.zoomRectIndex >= d.maxStackDepth) return;
    }
    var minSize = this.minZoomSize();
    if (minSize.isValid()) {
      var sz = new Misc.Size(
        d.zoomStack[d.zoomRectIndex].width() * 0.9999,
        d.zoomStack[d.zoomRectIndex].height() * 0.9999
      );

      if (minSize.width >= sz.width && minSize.height >= sz.height) {
        return;
      }
    }
    super.begin();
  }

  /**
   * Reinitialize the axes, and set the zoom base to their scales.
   * @param {Axis.AxisId} xAxis X axis
   * @param {Axis.AxisId} yAxis Y axis
   */
  setAxis(xAxis, yAxis) {
    if (xAxis != super.xAxis() || yAxis != super.yAxis()) {
      super.setAxis(xAxis, yAxis);
      if (this.setZoomBase !== undefined) this.setZoomBase(this.scaleRect());
    }
  }
}
;
define("plotzoomer", ["plotpicker"], function(){});

"include ['plotzoomer']";

class MyPlotZoomer extends PlotZoomer {
  constructor(plot) {
    super(plot);
    this.setEnabled(false);
    this.setTrackerMode(Picker.DisplayMode.AlwaysOff);
    this.setTrackerPen(new Misc.Pen("blue"));
    var f = this.trackerFont();
    //f.th = 14;
    f.fontColor = "blue";
    this.setTrackerFont(f);

    // this.setStateMachine(new PickerClickRectMachine());

    // this.setRubberBand(Picker.RubberBand.RectRubberBand);

    // Static.bind("zoomed", function (e, zoomRect) {
    //   console.log(zoomRect);
    // });
  }

  rescale() {
    if (Static.aspectRatioOneToOne) {
      let d_data = this.privateData();
      var rect = d_data.zoomStack[d_data.zoomRectIndex];
      if (rect.width() < rect.height()) {
        rect.setWidth(rect.height());
      }
      if (rect.width() > rect.height()) {
        rect.setHeight(rect.width());
      }
      d_data.zoomStack[d_data.zoomRectIndex] = rect;
    }
    super.rescale();
  }

  trackerText(pos) {
    var plot = this.plot();
    pos = this.invTransform(pos);
    var label; //= "";
    var numberOfDigitsX = 1;
    if (plot.axisEnabled(Axis.AxisId.xBottom)) {
      numberOfDigitsX = plot.axisPrecision(Axis.AxisId.xBottom);
    } else if (plot.axisEnabled(Axis.AxisId.xTop)) {
      numberOfDigitsX = plot.axisPrecision(Axis.AxisId.xTop);
    } else numberOfDigitsX = plot.axisPrecision(Axis.AxisId.xBottom);
    var numberOfDigitsY = 1;
    if (plot.axisEnabled(Axis.AxisId.yLeft))
      numberOfDigitsY = plot.axisPrecision(Axis.AxisId.yLeft);
    else if (plot.axisEnabled(Axis.AxisId.yRight))
      numberOfDigitsY = plot.axisPrecision(Axis.AxisId.yRight);
    else numberOfDigitsY = plot.axisPrecision(Axis.AxisId.yLeft);

    var yVal = Utility.toPrecision(pos.y, numberOfDigitsY);
    var xVal = Utility.toPrecision(pos.x, numberOfDigitsX);

    switch (this.rubberBand()) {
      case Picker.RubberBand.HLineRubberBand:
        label = yVal.toString();
        break;
      case Picker.RubberBand.VLineRubberBand:
        label = xVal.toString();
        break;
      default:
        label = xVal.toString() + ", " + yVal.toString();
    }
    return label;
  }

  // adjustedPoints(points) {
  //   let adjusted = [];
  //   if (points.length == 2) {
  //     const width = Math.abs(points[1].x - points[0].x);
  //     const height = Math.abs(points[1].y - points[0].y);
  //     const rect = new Misc.Rect(0, 0, 2 * width, 2 * height);
  //     rect.moveCenter(points[0]);
  //     adjusted.push(rect.topLeft());
  //     adjusted.push(rect.bottomRight());
  //   }
  //   return adjusted;
  // }
}
;
define("myZoomer", ["plotzoomer"], function(){});



/**
 * Abstract base class for a curve fitter.
 * @abstract
 *
 */
class CurveFitter {
  constructor() {
    Utility.makeAbstract(this, CurveFitter);
    /**
     * Find a curve which has the best fit to a series of data points
     *
     * @abstract
     * @param {Misc.Polygon} polygon Series of data points
     * @returns {Array<Misc.Point>} Curve points
     */
    this.fitCurve = function (polygon) {
      throw '"fitCurve()" not reimplemented in subclass';
    };
  }
}

/*!
Use the default spline algorithm for polygons with
increasing x values ( p[i-1] < p[i] ), otherwise use
a parametric spline algorithm.
*/

/**
 * A curve fitter using cubic splines.
 * @extends CurveFitter
 *
 */
class SplineCurveFitter extends CurveFitter {
  constructor() {
    super();
    var m_fitMode = SplineCurveFitter.FitMode.Auto;
    var m_spline = new Spline();
    var m_splineSize = 100;

    function fitSpline(points) {
      m_spline.setPoints(points);
      if (!m_spline.isValid()) return points;

      var fittedPoints = new Array(m_splineSize);

      var x1 = points[0].x;
      var x2 = points[points.length - 1].x;
      var dx = x2 - x1;
      var delta = dx / (m_splineSize - 1);

      for (var i = 0; i < m_splineSize; i++) {
        //var p = fittedPoints[i];

        var v = x1 + i * delta;
        var sv = m_spline.value(v);

        /*p.x = v;
				p.y = sv;*/
        fittedPoints[i] = new Misc.Point(v, sv);
      }
      m_spline.reset();

      return fittedPoints;
    }

    function fitParametric(points) {
      var i;
      var size = points.length;

      var fittedPoints = []; //( d_data->splineSize );
      //fittedPoints.resize(m_splineSize, new Misc.Point(-1, -1))
      for (var i = 0; i < m_splineSize; i++) {
        fittedPoints.push(new Misc.Point(-1, -1));
      }
      var splinePointsX = []; //( size );
      var splinePointsY = []; //( size );

      for (var i = 0; i < size; i++) {
        splinePointsX.push(new Misc.Point(-1, -1));
        splinePointsY.push(new Misc.Point(-1, -1));
      }

      var p = points;
      var spX = splinePointsX;
      var spY = splinePointsY;

      var param = 0.0;
      for (i = 0; i < size; i++) {
        var x = p[i].x;
        var y = p[i].y;
        if (i > 0) {
          //console.log(Math)
          var delta = Math.sqrt(
            Utility.sqr(x - spX[i - 1].y) + Utility.sqr(y - spY[i - 1].y)
          );
          param += Math.max(delta, 1.0);
        }
        spX[i].x = param;
        spX[i].y = x;
        //spX.push({x:param, y:x});
        spY[i].x = param;
        spY[i].y = y;
        //spY.push({x:param, y:y});
      }

      m_spline.setPoints(splinePointsX);
      if (!m_spline.isValid()) return points;

      var deltaX = splinePointsX[size - 1].x / (m_splineSize - 1);
      for (i = 0; i < m_splineSize; i++) {
        var dtmp = i * deltaX;
        fittedPoints[i].x = m_spline.value(dtmp);
      }

      m_spline.setPoints(splinePointsY);
      if (!m_spline.isValid()) return points;

      var deltaY = splinePointsY[size - 1].x / (m_splineSize - 1);
      for (i = 0; i < m_splineSize; i++) {
        var dtmp = i * deltaY;
        fittedPoints[i].y = m_spline.value(dtmp);
      }

      return fittedPoints;
    }

    /**
     * Set the algorithm used for building the spline.
     *
     * @param {mod} mode Mode representing a spline algorithm.
     * @see {@link SplineCurveFitter#fitMode fitMode()}
     */
    this.setFitMode = function (mode) {};

    /**
     *
     * @returns {} Mode representing a spline algorithm
     * @see {@link SplineCurveFitter#setFitMode setFitMode()}
     */
    this.fitMode = function () {
      return;
    };

    /**
     * Assign a spline
     * @param {Spline} spline
     * @see {@link SplineCurveFitter#spline spline()}
     */
    this.setSpline = function (spline) {
      m_spline = spline;
      m_spline.reset();
    };

    /**
     *
     * @returns {Spline} Spline
     * @see {@link SplineCurveFitter#setSpline setSpline()}
     */
    this.spline = function () {
      return m_spline;
    };

    /**
     * Assign a spline size ( has to be at least 10 points )
     * @param {Number} splineSize Spline size
     * @see {@link SplineCurveFitter#splineSize splineSize()}
     */
    this.setSplineSize = function (splineSize) {
      m_splineSize = Math.max(splineSize, 10);
    };

    /**
     *
     * @returns {Number} Spline size
     * @see {@link SplineCurveFitter#setSplineSize setSplineSize()}
     */
    this.splineSize = function () {
      return m_splineSize;
    };

    /**
     * Find a curve which has the best fit to a series of data points.
     *
     * @param {Misc.Polygon} points Series of data points
     * @returns {Array<Misc.Point>} Curve points
     */
    this.fitCurve = function (points) {
      //console.log(polygon)
      var size = points.length;
      if (size <= 2) return points;

      var fitMode = m_fitMode;
      if (fitMode == SplineCurveFitter.FitMode.Auto) {
        fitMode = SplineCurveFitter.FitMode.Spline;

        var p = points; //.data();
        for (var i = 1; i < size; i++) {
          if (p[i].x <= p[i - 1].x) {
            fitMode = SplineCurveFitter.FitMode.ParametricSpline;
            break;
          }
        }
      }

      if (fitMode == SplineCurveFitter.FitMode.ParametricSpline)
        return fitParametric(points);
      else return fitSpline(points);
    };
  }
}
/**
 * <div style="border-bottom: 1px solid #7393B3; font-size: 20px">enum{@link SplineCurveFitter.FitMode}</div>
 *
 * A curve fitter using cubic splines. The default setting is Auto.
 *
 * @name SplineCurveFitter.FitMode
 * @readonly
 * @property {Number} Auto               Use the default spline algorithm for polygons with increasing x values ( p[i-1] < p[i] ), otherwise use a parametric spline algorithm.
 * @property {Number} Spline             Use a default spline algorithm.
 * @property {Number} ParametricSpline   Use a parametric spline algorithm.
 */
Enumerator.enum("FitMode {	Auto, Spline, ParametricSpline}", SplineCurveFitter);

////////////////////WeedingCurveFitter////////////////////////////////////////////////
class WC_PrivateData {
  constructor() {
    this.tolerance = 1.0;
    this.chunkSize = 0;
  }
}

class WC_Line {
  constructor(i1 = 0, i2 = 0) {
    //super();

    this.from = i1;
    this.to = i2;
  }
}

/** 
  A curve fitter implementing Douglas and Peucker algorithm

  The purpose of the Douglas and Peucker algorithm is that given a 'curve'
  composed of line segments to find a curve not too dissimilar but that
  has fewer points. The algorithm defines 'too dissimilar' based on the
  maximum distance (tolerance) between the original curve and the
  smoothed curve.

  The runtime of the algorithm increases non linear ( worst case O( n*n ) )
  and might be very slow for huge polygons. To avoid performance issues
  it might be useful to split the polygon ( setChunkSize() ) and to run the algorithm
  for these smaller parts. The disadvantage of having no interpolation
  at the borders is for most use cases irrelevant.

  The smoothed curve consists of a subset of the points that defined the
  original curve.

  In opposite to SplineCurveFitter the Douglas and Peucker algorithm reduces
  the number of points. By adjusting the tolerance parameter according to the
  axis scales SplineCurveFitter can be used to implement different
  level of details to speed up painting of curves of many points.  
  * @extends CurveFitter
*/
class WeedingCurveFitter extends CurveFitter {
  /**
   *
   * @param {Number} tolerance=1.0 Tolerance
   * @example
   * new WeedingCurveFitter(); //Default construction. Tolerance == 1.0
   * new WeedingCurveFitter(2.0); //Tolerance == 2.0
   */
  constructor(tolerance = 1.0) {
    super();
    var d_data;

    var simplify = function (/* QPolygonF */ points) {
      var toleranceSqr = d_data.tolerance * d_data.tolerance;

      /* QStack<Line> */ var stack = [];
      //stack.reserve( 500 );

      /* const QPointF * */ var p = points; //.data();
      /* const int */ var nPoints = points.length;

      //QVector<bool> usePoint( nPoints, false );
      var usePoint = [];
      usePoint.resize(nPoints, false);

      stack.push(new WC_Line(0, nPoints - 1));

      //while ( !stack.isEmpty() )
      while (stack.length) {
        /* const Line */ var r = stack.pop();

        // initialize line segment
        /* const double */ var vecX = p[r.to].x - p[r.from].x;
        /* const double */ var vecY = p[r.to].y - p[r.from].y;

        /* const double */ var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);

        /* const double */ var unitVecX =
          vecLength != 0.0 ? vecX / vecLength : 0.0;
        /* const double */ var unitVecY =
          vecLength != 0.0 ? vecY / vecLength : 0.0;

        var maxDistSqr = 0.0;
        var nVertexIndexMaxDistance = r.from + 1;
        for (var i = r.from + 1; i < r.to; i++) {
          //compare to anchor
          var fromVecX = p[i].x - p[r.from].x;
          var fromVecY = p[i].y - p[r.from].y;

          var distToSegmentSqr;
          if (fromVecX * unitVecX + fromVecY * unitVecY < 0.0) {
            distToSegmentSqr = fromVecX * fromVecX + fromVecY * fromVecY;
          } else {
            var toVecX = p[i].x - p[r.to].x;
            var toVecY = p[i].y - p[r.to].y;
            var toVecLength = toVecX * toVecX + toVecY * toVecY;

            var s = toVecX * -unitVecX + toVecY * -unitVecY;
            if (s < 0.0) {
              distToSegmentSqr = toVecLength;
            } else {
              distToSegmentSqr = Math.abs(toVecLength - s * s);
            }
          }

          if (maxDistSqr < distToSegmentSqr) {
            maxDistSqr = distToSegmentSqr;
            nVertexIndexMaxDistance = i;
          }
        }
        if (maxDistSqr <= toleranceSqr) {
          usePoint[r.from] = true;
          usePoint[r.to] = true;
        } else {
          stack.push(new WC_Line(r.from, nVertexIndexMaxDistance));
          stack.push(new WC_Line(nVertexIndexMaxDistance, r.to));
        }
      }

      /* QPolygonF */ var stripped = [];
      for (var i = 0; i < nPoints; i++) {
        if (usePoint[i])
          //stripped += p[i];
          stripped.push(p[i]);
      }

      return stripped;
    };

    /**
     * Assign the tolerance
     * The tolerance is the maximum distance, that is acceptable
     * between the original curve and the smoothed curve.
     *
     * Increasing the tolerance will reduce the number of the resulting points.
     *
     * @param {Number} tolerance Tolerance
     * @see {@link WeedingCurveFitter#tolerance tolerance()}
     */
    this.setTolerance = function (tolerance) {
      d_data.tolerance = Math.max(tolerance, 0.0);
    };

    /**
     *
     * @returns {Number} Tolerance
     * @see {@link WeedingCurveFitter#setTolerance setTolerance()}
     */
    this.tolerance = function () {
      return d_data.tolerance;
    };

    /**
     * Limit the number of points passed to a run of the Douglas Peucker algorithm
     *
     * The runtime of the Douglas Peucker algorithm increases non linear
     * with the number of points. For a chunk size > 0 the polygon
     * is split into pieces passed to the algorithm one by one.
     * @param {Number} numPoints Maximum for the number of points passed to the algorithm
     * @see {@link WeedingCurveFitter#chunkSize chunkSize()}
     */
    this.setChunkSize = function (numPoints) {
      if (numPoints > 0)
        //numPoints = Math.max( numPoints, 3U );
        numPoints = Math.max(numPoints, 3);

      d_data.chunkSize = numPoints;
    };

    /**
     *
     * @returns {Number} Maximum for the number of points passed to a run
     * of the algorithm - or 0, when unlimited
     * @see {@link WeedingCurveFitter#setChunkSize setChunkSize()}
     */
    this.chunkSize = function () {
      return d_data.chunkSize;
    };

    /**
     *
     * @param {Array<Misc.Point>} points Series of data points
     * @returns {Array<Misc.Point>} Curve points
     */
    this.fitCurve = function (/* QPolygonF */ points) {
      /* QPolygonF */ var fittedPoints = [];

      if (d_data.chunkSize == 0) {
        fittedPoints = simplify(points);
      } else {
        for (var i = 0; i < points.length; i += d_data.chunkSize) {
          var p = points.mid(i, d_data.chunkSize);
          //fittedPoints += simplify( p );
          fittedPoints = fittedPoints.concat(simplify(p));
        }
      }

      return fittedPoints;
    };

    d_data = new WC_PrivateData();
    this.setTolerance(tolerance);
  }
}
;
define("curveFitter", ["static"], function(){});


/*!
  \brief A class for spline interpolation

  The QwtSpline class is used for cubical spline interpolation.
  Two types of splines, natural and periodic, are supported.

  \par Usage:
  <ol>
  <li>First call setPoints() to determine the spline coefficients
      for a tabulated function y(x).
  <li>After the coefficients have been set up, the interpolated
      function value for an argument x can be determined by calling
      QwtSpline::value().
  </ol>

  \par Example:
  \code
#include <qwt_spline.h>

QPolygonF interpolate(const QPolygonF& points, int numValues)
{
    QwtSpline spline;
    if ( !spline.setPoints(points) )
        return points;

    QPolygonF interpolatedPoints(numValues);

    const double delta =
        (points[numPoints - 1].x() - points[0].x()) / (points.size() - 1);
    for(i = 0; i < points.size(); i++)  / interpolate
    {
        const double x = points[0].x() + i * delta;
        interpolatedPoints[i].setX(x);
        interpolatedPoints[i].setY(spline.value(x));
    }
    return interpolatedPoints;
}
  \endcode
*/

//! Spline type
Static.SplineType = {}

//! A natural spline
Static.SplineType.Natural = 0

//! A periodic spline
Static.SplineType.Periodic = 1

Static.lookup = function (x, values) {
    var i1;
    var size = values.length;

    if (x <= values[0].x)
        i1 = 0;
    else if (x >= values[size - 2].x)
        i1 = size - 2;
    else {
        i1 = 0;
        var i2 = size - 2;
        var i3 = 0;

        while (i2 - i1 > 1) {
            i3 = i1 + ((i2 - i1) >> 1);

            if (values[i3].x > x)
                i2 = i3;
            else
                i1 = i3;
        }
    }
    return i1;
}

class Spline {
    constructor() {

        var m_points = null
        var m_a = []
        var m_b = []
        var m_c = []
        var m_splineType = Static.SplineType.Natural

        this.setSplineType = function (splineType) {
            m_splineType = splineType;
        }

        this.splineType = function () {
            return m_splineType;
        }

        /*!
          \brief Calculate the spline coefficients
    
          Depending on the value of \a periodic, this function
          will determine the coefficients for a natural or a periodic
          spline and store them internally.
    
          \param points Points
          \return true if successful
          \warning The sequence of x (but not y) values has to be strictly monotone
                   increasing, which means <code>points[i].x() < points[i+1].x()</code>.
               If this is not the case, the function will return false
        */
        this.setPoints = function (points) {
            var size = points.length;
            if (size <= 2) {
                this.reset();
                return false;
            }

            m_points = points;

            m_a.resize(size - 1);
            m_b.resize(size - 1);
            m_c.resize(size - 1);

            var ok;
            if (m_splineType == Static.SplineType.Periodic)
                ok = this.buildPeriodicSpline(points);
            else
                ok = this.buildNaturalSpline(points);

            if (!ok)
                this.reset();

            return ok;
        }

        this.points = function () {
            return m_points;
        }

        this.reset = function () {
            m_a.resize(0);
            m_b.resize(0);
            m_c.resize(0);
            m_points.resize(0);
        }

        this.isValid = function () {
            return m_a.length > 0;
        }

        /*!
          Calculate the interpolated function value corresponding
          to a given argument x.
    
          \param x Coordinate
          \return Interpolated coordinate
        */
        this.value = function (x) {
            if (m_a.length == 0)
                return 0.0;

            var i = Static.lookup(x, m_points);

            var delta = x - m_points[i].x;
            return ((((m_a[i] * delta) + m_b[i])
                * delta + m_c[i]) * delta + m_points[i].y);
        }

        this.coefficientsA = function () {
            return m_a;
        }

        this.coefficientsB = function () {
            return m_b;
        }

        this.coefficientsC = function () {
            return m_c;
        }

        this.buildNaturalSpline = function (points) {
            var i;

            var p = points;
            var size = points.length

            var a = m_a;
            var b = m_b;
            var c = m_c;

            //  set up tridiagonal equation system; use coefficient
            //  vectors as temporary buffers
            var h = new Array(size - 1);
            for (i = 0; i < size - 1; i++) {
                h[i] = p[i + 1].x - p[i].x;
                if (h[i] <= 0)
                    return false;
            }

            var d = new Array(size - 1);
            var dy1 = (p[1].y - p[0].y) / h[0];
            for (i = 1; i < size - 1; i++) {
                b[i] = c[i] = h[i];
                a[i] = 2.0 * (h[i - 1] + h[i]);

                var dy2 = (p[i + 1].y - p[i].y) / h[i];
                d[i] = 6.0 * (dy1 - dy2);
                dy1 = dy2;
            }

            //
            // solve it
            //

            // L-U Factorization
            for (i = 1; i < size - 2; i++) {
                c[i] /= a[i];
                a[i + 1] -= b[i] * c[i];
            }

            // forward elimination
            var s = new Array(size);
            s[1] = d[1];
            for (i = 2; i < size - 1; i++)
                s[i] = d[i] - c[i - 1] * s[i - 1];

            // backward elimination
            s[size - 2] = - s[size - 2] / a[size - 2];
            for (i = size - 3; i > 0; i--)
                s[i] = - (s[i] + b[i] * s[i + 1]) / a[i];
            s[size - 1] = s[0] = 0.0;

            //
            // Finally, determine the spline coefficients
            //
            for (i = 0; i < size - 1; i++) {
                a[i] = (s[i + 1] - s[i]) / (6.0 * h[i]);
                b[i] = 0.5 * s[i];
                c[i] = (p[i + 1].y - p[i].y) / h[i]
                    - (s[i + 1] + 2.0 * s[i]) * h[i] / 6.0;
            }

            return true;

        }

        this.buildPeriodicSpline = function (points) {
            var i;

            var p = points;
            var size = points.length

            var a = m_a
            var b = m_b
            var c = m_c

            var d = new Array(size - 1);
            var h = new Array(size - 1);
            var s = new Array(size);

            //
            //  setup equation system; use coefficient
            //  vectors as temporary buffers
            //
            for (i = 0; i < size - 1; i++) {
                h[i] = p[i + 1].x - p[i].x;
                if (h[i] <= 0.0)
                    return false;
            }

            var imax = size - 2;
            var htmp = h[imax];
            var dy1 = (p[0].y - p[imax].y) / htmp;
            for (i = 0; i <= imax; i++) {
                b[i] = c[i] = h[i];
                a[i] = 2.0 * (htmp + h[i]);
                var dy2 = (p[i + 1].y - p[i].y) / h[i];
                d[i] = 6.0 * (dy1 - dy2);
                dy1 = dy2;
                htmp = h[i];
            }

            //
            // solve it
            //

            // L-U Factorization
            a[0] = Math.sqrt(a[0]);
            c[0] = h[imax] / a[0];
            var sum = 0;

            for (i = 0; i < imax - 1; i++) {
                b[i] /= a[i];
                if (i > 0)
                    c[i] = - c[i - 1] * b[i - 1] / a[i];
                a[i + 1] = Math.sqrt(a[i + 1] - Utility.sqr(b[i]));
                sum += Utility.sqr(c[i]);
            }
            b[imax - 1] = (b[imax - 1] - c[imax - 2] * b[imax - 2]) / a[imax - 1];
            a[imax] = Math.sqrt(a[imax] - Utility.sqr(b[imax - 1]) - sum);


            // forward elimination
            s[0] = d[0] / a[0];
            sum = 0;
            for (i = 1; i < imax; i++) {
                s[i] = (d[i] - b[i - 1] * s[i - 1]) / a[i];
                sum += c[i - 1] * s[i - 1];
            }
            s[imax] = (d[imax] - b[imax - 1] * s[imax - 1] - sum) / a[imax];


            // backward elimination
            s[imax] = - s[imax] / a[imax];
            s[imax - 1] = -(s[imax - 1] + b[imax - 1] * s[imax]) / a[imax - 1];
            for (i = imax - 2; i >= 0; i--)
                s[i] = - (s[i] + b[i] * s[i + 1] + c[i] * s[imax]) / a[i];

            //
            // Finally, determine the spline coefficients
            //
            s[size - 1] = s[0];
            for (i = 0; i < size - 1; i++) {
                a[i] = (s[i + 1] - s[i]) / (6.0 * h[i]);
                b[i] = 0.5 * s[i];
                c[i] = (p[i + 1].y - p[i].y)
                    / h[i] - (s[i + 1] + 2.0 * s[i]) * h[i] / 6.0;
            }

            return true;

        }

    }
};


define("spline", ["static"], function(){});


/**
 * Panner provides panning of a widget.
 *
 * Panner grabs the contents of a widget, that can be dragged in all directions. During dragging, all plotItems are move by the
 * computed offset (deltaX, deltaY). When dragging stops, new scales are calculated to account for the offset and
 * plotitems are re-drawn. Areas, that are not part of content are not painted while panning. This makes
 * panning fast enough for widgets, where repaints are too slow for mouse movements.
 * @extends HObject
 */
class Panner extends HObject {
  /**
   * Creates an panner that is enabled for the left mouse button.
   * @param {Plot} plot Parent widget to be panned
   */
  constructor(plot) {
    super();

    var self = this;
    var m_plot = null;
    var m_mouseButton = Static.LeftButton;
    var buttonModifiers = Static.NoModifier;

    var abortKey = Static.Key_Escape;
    var abortKeyModifiers = Static.NoModifier;

    var initialPosX = 0;
    var initialPosY = 0;
    var posX = 0;
    var posY = 0;

    var m_enabled = false;

    var m_canvas = null;

    var m_mouseDown = false;

    var m_cursor = "";
    var m_restoreCursor = "";
    var m_hasCursor = false;
    var m_orientations = Static.Vertical | Static.Horizontal;

    var deltaX = 0;
    var deltaY = 0;

    if (typeof plot !== "undefined") {
      plot.panner = this;
      m_plot = plot;
    }

    /**
     *
     * @returns {Plot} Plot associated with the Panner
     */
    this.plot = function () {
      return m_plot;
    };

    /**
     * Change the mouse button and modifiers used for panning
     * @param {Number} btn button id (e.g. Static.LeftButton, Static.RightButton, Static.MidButton)
     * @param {Number} modifiers=Static.NoModifier Modifiers (e.g. Static.ShiftModifier, Static.ControlModifier, Static.AltModifier).
     *
     * Modifiers can be combined (e.g. Static.ShiftModifier|Static.ControlModifier)
     */
    this.setMouseButton = function (btn, modifiers = Static.NoModifier) {
      m_mouseButton = btn;
      buttonModifiers = modifiers;
    };

    /**
     *
     * @returns {object} Get mouse button and modifiers used for panning. The returned object has two properties: button and modifiers.
     */
    this.getMouseButton = function () {
      return { button: m_mouseButton, modifiers: buttonModifiers };
    };

    /**
     * Set the orientations, where panning is enabled
     *
     * The default value is in both directions: Static.Vertical | Static.Horizontal
     * @param {Number} orientation
     */
    this.setOrientation = function (orientation) {
      m_orientations = orientation;
    };

    function movePlotItems() {
      var itemStore = self.plot().plotItemStore();
      for (var i = 0; i < itemStore.length; ++i) {
        var c = itemStore[i].getCanvas();
        c.css("left", deltaX);
        c.css("top", deltaY);
      }
    }

    /**
     * Calculate new scales to account for the offset and redraw plotitems in accordance with the new scales.
     * @param {Number} _deltaX X offset in paint coodinate
     * @param {Number} _deltaY Y offset in paint coodinate
     */
    this.rescaleAndRedraw = function (_deltaX, _deltaY) {
      var itemStore = self.plot().plotItemStore();
      for (var i = 0; i < itemStore.length; ++i) {
        var c = itemStore[i].getCanvas();
        c.css("left", 0);
        c.css("top", 0);
      }
      var doReplot = false;
      var autoReplot = m_plot.autoReplot();
      m_plot.setAutoReplot(false);
      var rescaled = false;
      for (var axis = 0; axis < Axis.AxisId.axisCnt; axis++) {
        var map = self.plot().canvasMap(axis);
        var p1 = map.transform(self.plot().axisScaleDiv(axis).lowerBound());
        var p2 = map.transform(self.plot().axisScaleDiv(axis).upperBound());
        var d1, d2;

        if (axis == Axis.AxisId.xBottom || axis == Axis.AxisId.xTop) {
          d1 = map.invTransform(p1 - _deltaX);
          d2 = map.invTransform(p2 - _deltaX);
        } else {
          d1 = map.invTransform(p1 - _deltaY);
          d2 = map.invTransform(p2 - _deltaY);
        }
        //this.setAxisScale(axis, d1, d2);
        this.plot().setAxisScale(axis, d1, d2);

        doReplot = true;
      }

      m_plot.setAutoReplot(autoReplot);
      m_plot.autoRefresh();
    };

    const showCursor = function (on) {
      if (on == m_hasCursor) return;

      if (self.plot() == null || m_cursor == "") return;

      m_hasCursor = on;

      if (on) {
        if (self.plot().isCursorSet()) {
          m_restoreCursor = self.plot().cursor();
        }
        self.plot().setCursor(m_cursor);
      } else {
        if (m_restoreCursor !== "") {
          self.plot().setCursor(m_restoreCursor);
          m_restoreCursor = "";
        } else self.plot().unsetCursor();
      }
    };

    /**
     * Sets the cursor that is active during panning
     * @param {String} cursor valid html cursor string
     */
    this.setCursor = function (cursor) {
      m_cursor = cursor;
    };

    /**
     *
     * @returns {String} Cursor that is active while panning
     */
    this.cursor = function () {
      if (m_cursor != "") return m_cursor;

      if (this.plot() != null) return this.plot().cursor();

      return "";
    };

    if (this.plot()) this.setEnabled_1(true);

    /**
     * En/disable the panner
     *
     * When enabled is true an event filter is installed for the observed widget, otherwise the event filter is removed.
     * @param {Boolean} enabled rue or false
     */
    this.setEnabled = function (enabled) {
      if (m_enabled != enabled) {
        m_enabled = enabled;

        /*QWidget*/
        var w = plot.getCentralWidget();
        if (w) {
          if (enabled) {
            //w.setEnabled_1(true)
            w.installEventFilter(this);
          } else {
            w.removeEventFilter(this);
          }
        }
      }
    };

    /**
     *
     * @returns {Boolean} true, if panner is enabled
     */
    this.isEnabled = function () {
      return m_enabled;
    };

    /**
     * Handle a mouse press event for the observed widget.
     * @param {Event} event Mouse press
     */
    this.widgetMousePressEvent = function (event) {
      var isMobile = Static.isMobile();

      if (!isMobile) {
        if (
          event.button != m_mouseButton ||
          Utility.modifiers(event) !== buttonModifiers
        )
          return true;
      }

      if (isMobile) {
        initialPosX = event.originalEvent.touches[0].clientX;
        initialPosY = event.originalEvent.touches[0].clientY;
        m_mouseDown = true;
      } else {
        initialPosX = event.clientX;
        initialPosY = event.clientY;
        m_mouseDown = true;
      }

      showCursor(true);
      //return true
      return true;
    };

    /**
     * Handle a mouse up event for the observed widget.
     * @param {Event} event Mouse up
     */
    this.widgetMouseUpEvent = function (event) {
      if (!m_mouseDown) return;
      m_mouseDown = false;
      showCursor(false);
      if (deltaX != 0 || deltaY != 0) {
        self.rescaleAndRedraw(deltaX, deltaY);
        deltaX = 0;
        deltaY = 0;
      }

      // return true
    };

    /**
     * Handle a mouse move event for the observed widget.
     * @param {Event} event Mouse event
     */
    this.widgetMouseMoveEvent = function (event) {
      if (m_mouseDown) {
        if (!Static.isMobile()) {
          deltaX = event.clientX - initialPosX;
          deltaY = event.clientY - initialPosY;
        } else {
          var touchobj = event.originalEvent.changedTouches[0]; // reference first touch point for this event
          deltaX = parseInt(touchobj.clientX) - initialPosX;
          deltaY = parseInt(touchobj.clientY) - initialPosY;
        }
        if (m_orientations == Static.Vertical) deltaX = 0;
        if (m_orientations == Static.Horizontal) deltaY = 0;
        movePlotItems(/*deltaX, deltaY*/);
      }
      // return true;
    };
    Static.trigger("pannerAdded", this);
    this.setEnabled(true);
  }

  // setAxisScale(axis, d1, d2) {
  //   this.plot().setAxisScale(axis, d1, d2);
  // }

  /**
   * Event filter.
   *
   * When {@link Panner#isEnabled isEnabled()} is true mouse events of the observed widget are filtered.
   * @param {HObject} watched Object to be filtered
   * @param {Event} event Event
   */
  eventFilter(watched, event) {
    if (!this.isEnabled()) return;
    var mt = false;
    switch (event.type) {
      case "mousedown":
      case "touchstart":
        {
          this.widgetMousePressEvent(event);
        }
        break;
      case "mousemove":
      case "touchmove":
        this.widgetMouseMoveEvent(event);
        break;
      case "mouseleave":
        this.widgetMouseUpEvent(event);
        break;
      case "mouseup":
      case "touchend":
        {
          this.widgetMouseUpEvent(event);
        }
        break;
      default:
      // code block
    }
  }

  /**
   *
   * @returns A string representing the object.
   */
  toString() {
    return "[Panner]";
  }
}
;
define("panner", ["static","hObject"], function(){});

"include ['static','widgetOverlay', 'plotMarker']";

class MyCurveSelectorOverlay extends WidgetOverlay {
  //function MyCurveSelectorOverlay(widget){
  constructor(widget, eventObject) {
    super(widget);
    //WidgetOverlay.call(this, widget);////////////////
    var self = this;

    this.eventObject = eventObject;
    this.curve = null;

    this.setZ(2000.0);

    this.toString = function () {
      return "[MyCurveSelectorOverlay]";
    };
  }
  drawOverlay(painter) {
    let brushColor = "noBrush";
    if (this.eventObject.selected) brushColor = "darkGrey";
    painter.setBrush(new Misc.Brush(brushColor));
    painter.drawCircle(this.eventObject.pp.x, this.eventObject.pp.y, 8);
  }
}

class MyCurveSelectorObject extends HObject {
  constructor(plot, curveSelector) {
    super();
    var self = this;
    this._plot = plot;
    this.curveSelector = curveSelector;
    this._dmin = 10;
    //this._cb == null;
    this.selected = false;
    this.button = Static.LeftButton;
    this.abortButton = Static.LeftButton;
    this.abortLastButton = Static.LeftButton;
    this.modifiers = Static.NoModifier;
    this.abortModifiers = Static.ShiftModifier;
    this.abortLastModifiers = Static.ControlModifier;

    this.selectedCurves = [];

    //if (cb !== undefined) this._cb = cb;

    this.selectorWidgetOverlay = new MyCurveSelectorOverlay(
      plot.getCentralWidget(),
      this
    );

    Static.bind("visibilityChange", function (e, curve, on) {
      if (self.selectorWidgetOverlay.curve !== curve) return;
      if (!on) {
        self.selectorWidgetOverlay.clearCanvas();
        this.selected = false;
      }
    });

    this.toString = function () {
      return "[MyCurveSelectorObject]";
    };

    this.curves = [];

    function timesSelected(curve) {
      let times = 0;
      for (let i = 0; i < self.selectedCurves.length; i++) {
        if (self.selectedCurves[i] == curve) times++;
      }
      return times;
    }

    this.highLightSelectedCurve = function () {
      const curve = new Curve();
      curve.setItemAttribute(PlotItem.ItemAttribute.Legend, false);
      curve.setSamples(this.selectorWidgetOverlay.curve.data().samples());
      const times = timesSelected(this.selectorWidgetOverlay.curve) + 1;
      const highLightPen = new Misc.Pen(
        this.selectorWidgetOverlay.curve.pen().color,
        times * 3 * this.selectorWidgetOverlay.curve.pen().width,
        this.selectorWidgetOverlay.curve.pen().style
      );
      this.curves.push(curve);
      curve.setPen(highLightPen);

      curve.setAxes(
        this.selectorWidgetOverlay.curve.xAxis(),
        this.selectorWidgetOverlay.curve.yAxis()
      );
      curve.attach(plot);
    };

    function abortLastSelection() {
      if (self.curves.length == 1) {
        self.abortSelection();
      } else {
        self.curves[self.curves.length - 1].detach();
        self.curves.pop();
        self.selectedCurves.pop();
        self.selectorWidgetOverlay.curve = 0;
      }
    }

    this.mouseDown = function (event) {
      if (
        event.button == this.abortButton &&
        Utility.modifiers(event) == this.abortModifiers
      ) {
        this.abortSelection();
        return;
      }
      if (
        event.button == this.abortLastButton &&
        Utility.modifiers(event) == this.abortLastModifiers
      ) {
        abortLastSelection();
        return;
      }
      if (
        event.button == this.button &&
        Utility.modifiers(event) == this.modifiers
      ) {
        if (this.selected) {
          this.highLightSelectedCurve();
          this.selectedCurves.push(this.selectorWidgetOverlay.curve);
        } else {
          Static.trigger("selectedCurves", [self.selectedCurves]);
          this.abortSelection();
        }
      }
      return true;
    };

    function setAlignment(pt) {
      var curve = self.selectorWidgetOverlay.curve;
      var xs = plot.axisScaleDiv(curve.xAxis());
      var ys = plot.axisScaleDiv(curve.yAxis());
      var rect = new Misc.Rect(
        xs.lowerBound(),
        ys.lowerBound(),
        xs.range(),
        ys.range()
      );
      rect = rect.normalized();
      var alignment = 0;
      alignment |=
        pt.x < rect.left() + 0.3 * rect.width()
          ? Static.AlignRight
          : Static.AlignLeft;
      alignment |=
        pt.y - 0.3 * rect.height() > rect.top()
          ? Static.AlignBottom
          : Static.AlignTop;
      self.mPos.setLabelAlignment(alignment);
    }

    this.showMarker = function (point) {
      var doReplot = plot.autoReplot();
      plot.setAutoReplot(false);
      var curve = this.selectorWidgetOverlay.curve;
      self.mPos.setAxes(curve.xAxis(), curve.yAxis());

      setAlignment(point);
      self.mPos.setVisible(true);
      self.mPos.setValue(point);

      plot.setAutoReplot(doReplot);
      plot.autoRefresh();
    };

    this.hideMarker = function () {
      self.mPos.setVisible(false);
    };
  }

  abortSelection() {
    for (let i = 0; i < this.curves.length; i++) {
      this.curves[i].detach();
    }
    this.curves = [];
    this.selectedCurves = [];
    this.selectorWidgetOverlay.curve = 0;
    this.curveSelector.setEnabled(false);
  }

  eventFilter(watched, event) {
    if (Static.isMobile()) {
      if (event.type == "touchstart") {
        let curves = this._plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
        if (!curves.length) return;

        var pt = watched.mapToElement({
          x: event.originalEvent.touches[0].clientX,
          y: event.originalEvent.touches[0].clientY,
        });

        let dist = {
          distance: -1,
        };
        let curvePointIndex = -1;
        let curvePointIndexAtDmin = -1;

        let dmin = 1.0e10;
        let indexInCurvesListAtDmin = -1;

        for (var i = 0; i < curves.length; ++i) {
          if (
            !curves[i].isVisible() ||
            curves[i].data().toString() == "[SyntheticPointData]"
          )
            continue;
          curvePointIndex = curves[i].closestPoint(pt, dist);
          if (dist.distance < dmin) {
            dmin = dist.distance;
            indexInCurvesListAtDmin = i;
            curvePointIndexAtDmin = curvePointIndex;
          }
        }
        if (curvePointIndexAtDmin == -1) return;

        this.p = curves[indexInCurvesListAtDmin].data().samples()[
          curvePointIndexAtDmin
        ];

        if (dmin < this._dmin) {
          if (this._cb == null)
            alert(
              "Curve: " +
                curves[indexInCurvesListAtDmin].title() +
                "; point: (" +
                this.p.x +
                ", " +
                this.p.y +
                ")"
            );
          else {
            this._cb(curves[indexInCurvesListAtDmin], this.p);
          }
        }
      }
      return;
    } else if (event.type == "mousedown" /* || event.type == 'touchstart' */) {
      this.mouseDown(event);
    } else if (event.type == "dblclick" /* || event.type == 'touchstart' */) {
      //this.abortSelection();
    } else if (event.type == "mouseleave" /* || event.type == 'touchstart' */) {
      if (this.selected) {
        this.selectorWidgetOverlay.clearCanvas();
        this.selected = false;
      }
    } else if (event.type == "mousemove" /*  || event.type == 'touchmove' */) {
      event.preventDefault();
      let curves = this._plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve);
      if (!curves.length) return;
      var pt = watched.mapToElement({
        x: event.clientX,
        y: event.clientY,
      });

      this.pp = pt;
      this.selectorWidgetOverlay.draw();

      let dist = {
        distance: -1,
      };
      let curvePointIndex = -1;
      let curvePointIndexAtDmin = -1;

      let dmin = 1.0e10;
      let indexInCurvesListAtDmin = -1;

      for (var i = 0; i < curves.length; ++i) {
        if (
          !curves[i].isVisible() ||
          curves[i].data().toString() == "[SyntheticPointData]"
        )
          continue;
        curvePointIndex = curves[i].closestPoint(pt, dist);
        if (dist.distance < dmin) {
          dmin = dist.distance;
          indexInCurvesListAtDmin = i;
          curvePointIndexAtDmin = curvePointIndex;
        }
      }
      if (curvePointIndexAtDmin == -1) return;
      if (
        curves[indexInCurvesListAtDmin].data().toString() ==
        "[SyntheticPointData]"
      )
        return;
      this.p = curves[indexInCurvesListAtDmin].data().samples()[
        curvePointIndexAtDmin
      ];

      if (dmin < this._dmin) {
        this.selectorWidgetOverlay.curve = curves[indexInCurvesListAtDmin];
        if (!this.selected) {
          this.selected = true;
          Static.trigger("pointSelected");
        }
      } else {
        this.selected = false;
        Static.trigger("pointNotSelected");
      }
    }
    return true;
  }
}

/**
 * The default behaviour is as follows:
 *
 * - Click on a point in the curve to select it.
 * - Ctrl and click anywhere in the plot area to deselect curves in reverse order. Deselecting the last curve exits the selection mode.
 * - Shift and click anywhere in the plot area to deselect all curves and exit selection mode.
 * - Click anywhere in the plot area except on a curve to end selection and trigger the "selectedCurves" event.
 * 
 * You can change the default behaviour with {@link setMousePattern setMousePattern()}, {@link setAbortMousePattern setAbortMousePattern()} and {@link setAbortLastMousePattern setAbortLastMousePattern()}
 * 
 * Applications bind to the "selectedCurves" event as shown below:
 * ~~~~
 *  Static.bind("selectedCurves", function (e, curves) { 
      //curves: array of selected curves;     
    });
    ~~~~
 * 
 */
class CurveSelector {
  constructor(plot) {
    const self = this;
    this._plot = plot;
    this.defaultCursor = this._plot.cursor();
    this.eventHandlingObject = new MyCurveSelectorObject(plot, this);
    this.cw = plot.getCentralWidget();
    this.cw.setEnabled_1(true);

    // Static.bind("selectionAborted", function () {
    //   self.setEnabled(false);
    // });
  }

  setDistance(dist) {
    this.eventHandlingObject._dmin = dist;
  }

  abortSelection() {
    this.eventHandlingObject.abortSelection();
  }

  setEnabled(on) {
    if (on) {
      if (this._plot.cursor() == "none") return;
      this.cw.installEventFilter(this.eventHandlingObject);
      this._plot.setCursor("none");
    } else {
      this.cw.removeEventFilter(this.eventHandlingObject);
      this.eventHandlingObject.selectorWidgetOverlay.clearCanvas();
      this._plot.setCursor(this.defaultCursor);
    }
  }

  isEnabled() {
    return this._plot.cursor() == "none" ? true : false;
  }

  /**
   * Set the mouse button and keyboard modifiers for selection
   * @param {Number} button Button id (e.g Static.LeftButton, Static.RightButton or Static.MidButton)
   * @param {Number} modifiers Keyboard modifiers (e.g Static.ShiftModifier, Static.AltModifier or Static.ControlModifier)
   *
   * @example
   *  const curveSelector = new CurveSelector(plot);
   *  curveSelector.setMousePattern(Static.LeftButton, Static.AltModifier);
   *
   * This changes the default click to alt-click
   */
  setMousePattern(button, modifiers) {
    this.eventHandlingObject.button = button;
    this.eventHandlingObject.modifiers = modifiers;
  }

  /**
   * Set the mouse button and keyboard modifiers for aborting all selections
   * @param {Number} button Button id (e.g Static.LeftButton, Static.RightButton or Static.MidButton)
   * @param {Number} modifiers Keyboard modifiers (e.g Static.ShiftModifier, Static.AltModifier or Static.ControlModifier)
   *
   * @example
   *  const curveSelector = new CurveSelector(plot);
   *  curveSelector.setAbortMousePattern(Static.LeftButton, Static.AltModifier);
   *
   * This changes the default shift-click to alt-click
   */
  setAbortMousePattern(button, modifiers) {
    this.eventHandlingObject.abortButton = button;
    this.eventHandlingObject.abortModifiers = modifiers;
  }

  /**
   * Set the mouse button and keyboard modifiers for aborting the last selection
   * @param {Number} button Button id (e.g Static.LeftButton, Static.RightButton or Static.MidButton)
   * @param {Number} modifiers Keyboard modifiers (e.g Static.ShiftModifier, Static.AltModifier or Static.ControlModifier)
   *
   * @example
   *  const curveSelector = new CurveSelector(plot);
   *  curveSelector.setAbortLastMousePattern(Static.LeftButton, Static.AltModifier);
   *
   * This changes the default ctrl-click to alt-click
   */
  setAbortLastMousePattern(button, modifiers) {
    this.eventHandlingObject.abortLastButton = button;
    this.eventHandlingObject.abortLastModifiers = modifiers;
  }
}
;
define("curveSelector", ["static","widgetOverlay","plotMarker"], function(){});



/**
 * A plot item, which displays any graphical shape, that can be defined by a Misc.MPath.
A Misc.MPath is a shape composed from intersecting and uniting regions, rectangles, ellipses or irregular areas defined by lines, and curves. PlotShapeItem displays a shape with a pen and brush.
PlotShapeItem offers a couple of optimizations like clipping or weeding. These algorithms need to convert the Misc.MPath into polygons that might be less performant for paths built from curves and ellipses.
*/
class PlotShapeItem extends PlotItem {
  constructor() {
    super("Shape");

    var m_renderTolerance = 0.0;

    var m_boundingRect = super.boundingRect();

    var m_pen = new Misc.Pen("black", 1, Static.NoPen);

    var m_brush = new Misc.Brush("#006464");
    var m_shape = new Misc.MPath();

    this.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);
    this.setItemAttribute(PlotItem.ItemAttribute.Legend, false);

    this.setZ(8.0);

    this.rtti = PlotItem.RttiValues.Rtti_PlotShape;

    this.getBoundingRect = function () {
      return m_boundingRect;
    };

    /**
     * Set a path built from a rectangle
     * @param {Misc.Rect} rect Rectangle
     * @see {@link PlotShapeItem#setShape setShape()}
     * @see {@link PlotShapeItem#shape shape()}
     * @see {@link PlotShapeItem#setPolygon setPolygon()}
     */
    this.setRect = function (rect) {
      var path = new Misc.MPath();
      path.addRect(rect);
      this.setShape(path);
    };

    /**
     * Set a path built from a polygon
     * @param {Misc.Polygon} polygon Polygon
     * @see {@link PlotShapeItem#setShape setShape()}
     * @see {@link PlotShapeItem#shape shape()}
     * @see {@link PlotShapeItem#setRect setRect()}
     */
    this.setPolygon = function (polygon) {
      var shape = new Misc.MPath();
      shape.addPolygon(polygon);
      this.setShape(shape);
    };

    /**
     * Set the shape to be displayed
     * @param {Misc.MPath} shape
     * @see {@link PlotShapeItem#setShape setShape()}
     * @see {@link PlotShapeItem#shape shape()}
     */
    this.setShape = function (shape) {
      //if ( shape != m_shape )
      {
        m_shape = shape;

        if (shape.isEmpty()) {
          m_boundingRect = PlotItem.prototype.boundingRect.call(this);
        } else {
          m_boundingRect = m_shape.boundingRect();
        }

        //itemChanged();
      }
    };

    /**
     * Assign a brush
     * @param {Misc.Brush} pen Brush
     */
    this.setBrush = function (brush) {
      m_brush = brush;
      this.itemChanged();
    };

    /**
     *
     * @returns {Misc.Brush} Brush used to fill the shape
     */
    this.brush = function () {
      return m_brush;
    };

    /**
     * Assign a pen
     * @param {Misc.Pen} pen Pen
     */
    this.setPen = function (pen) {
      m_pen = pen;
      this.itemChanged();
    };

    /**
     *
     * @returns {Misc.Pen} Pen used to draw the outline of the shape
     */
    this.pen = function () {
      return m_pen;
    };

    /**
     * Draw the shape item
     * @param {ScaleMap} xMap X-Scale Map
     * @param {ScaleMap} yMap Y-Scale Map
     *
     */
    this.draw = function (xMap, yMap) {
      //start with a clean canvas
      this.clearCanvas();
      if (m_shape.isEmpty()) return;

      if (m_pen.style == Static.NoPen && m_brush == Static.NoBrush) {
        return;
      }

      var canvasRect = this.getCanvasRect();
      //alert(canvasRect)
      var cRect = ScaleMap.invTransform_Rect(xMap, yMap, canvasRect);
      if (m_boundingRect.intersects(cRect)) {
        //alert(11)
        var ctx = this.getContext();
        var doAlign = false; //QwtPainter::roundingAlignment( painter );

        var path = ScaleMap.transformPath(xMap, yMap, m_shape, doAlign);

        /*if ( testPaintAttribute( QwtPlotShapeItem::ClipPolygons ) ){
                qreal pw = qMax( qreal( 1.0 ), painter->pen().widthF());
                QRectF clipRect = canvasRect.adjusted( -pw, -pw, pw, pw );

                QPainterPath clippedPath;
                clippedPath.setFillRule( path.fillRule() );

                const QList<QPolygonF> polygons = path.toSubpathPolygons();
                for ( int i = 0; i < polygons.size(); i++ ){
                const QPolygonF p = QwtClipper::clipPolygonF(
                clipRect, polygons[i], true );

                clippedPath.addPolygon( p );

                }

                path = clippedPath;
                }*/

        /*if ( d_data->renderTolerance > 0.0 )
            {
                QwtWeedingCurveFitter fitter( d_data->renderTolerance );

                QPainterPath fittedPath;
                fittedPath.setFillRule( path.fillRule() );

                const QList<QPolygonF> polygons = path.toSubpathPolygons();
                for ( int i = 0; i < polygons.size(); i++ )
                fittedPath.addPolygon( fitter.fitCurve( polygons[ i ] ) );

                path = fittedPath;
                }*/

        var painter = new PaintUtil.Painter(ctx);
        painter.setBrush(m_brush);
        painter.setPen(m_pen);
        painter.drawPath(path);
        painter = null;
      }
    };

    /**
     *
     * @returns {Misc.Rect} Bounding rectangle of the shape.
     */
    this.boundingRect = function () {
      return this.getBoundingRect();
    };

    /**
     *
     * @returns Returns a string representing the object.
     */
    this.toString = function () {
      return "[PlotShapeItem]";
    };
  }
}
;
define("plotShapeItem", ["static","plotItem"], function(){});

"include ['plotShapeItem']";

class CurveShapeItem extends PlotShapeItem {
  constructor(plot) {
    super();
    var _curve = null;
    var _poly = null;
    var _lowerLimit = undefined;
    var _upperLimit = undefined;
    var _enabled = true;
    var self = this;

    function polygonBelowCurve /* curve,  */() {
      /* lowerLimit, upperLimit */
      var samples = null;
      var poly = [];
      if (_curve.rtti !== PlotItem.RttiValues.Rtti_PlotCurve) return;
      if (_curve.data().toString() == "[SyntheticPointData]") {
        //curve.setData(new FunctionData(fn, numOfPoints));
        let sz = _curve.functionData.size();
        let smpls = [];

        for (var i = 0; i < sz - 1; ++i) {
          smpls.push(_curve.functionData.sample(i));
        }
        samples = smpls;
      } else {
        samples = _curve.data().samples();
      }

      if (!samples) return;
      //var samples =  _curve.data().samples();
      if (samples.length < 2) return;

      if (
        _lowerLimit < samples[0].x ||
        _upperLimit > samples[samples.length - 1].x ||
        _lowerLimit >= _upperLimit
      ) {
        return null;
      }

      if (_lowerLimit == undefined) _lowerLimit = samples[0].x;
      if (_upperLimit == undefined) _upperLimit = samples[samples.length - 1].x;
      var lowerIndex = -1;
      var upperIndex = -1;
      var poly = [];

      for (var i = 1; i < samples.length; i++) {
        if (samples[i].x > _lowerLimit && lowerIndex == -1) {
          lowerIndex = i - 1;
          poly.push(samples[lowerIndex]);
        }
        if (samples[i - 1].x < _upperLimit) {
          upperIndex = i;
          if (lowerIndex != -1) poly.push(samples[upperIndex]);
        }
      }

      var lowerInterpolatedPt;
      var upperInterpolatedPt;

      //console.log(samples[lowerIndex + 1])
      var axisScaleEngine = _curve
        .plot()
        .axisScaleEngine(_curve.xAxis())
        .toString();
      //console.log(axisScaleEngine.toString())//[LinearScaleEngine]
      if (axisScaleEngine == "[LinearScaleEngine]") {
        lowerInterpolatedPt = samples[lowerIndex].interpolatedPoint(
          samples[lowerIndex + 1],
          _lowerLimit
        );
        upperInterpolatedPt = samples[upperIndex - 1].interpolatedPoint(
          samples[upperIndex],
          _upperLimit
        );
      } else if (axisScaleEngine == "[LogScaleEngine]") {
        lowerInterpolatedPt = samples[lowerIndex].logInterpolatedPoint(
          samples[lowerIndex + 1],
          _lowerLimit
        );
        upperInterpolatedPt = samples[upperIndex - 1].logInterpolatedPoint(
          samples[upperIndex],
          _upperLimit
        );
      }

      if (poly.length && poly[0].x !== lowerInterpolatedPt.x) {
        poly.splice(0, 1, lowerInterpolatedPt);
      }
      if (poly.length && poly[poly.length - 1].x !== upperInterpolatedPt.x) {
        poly.pop();
        poly.push(upperInterpolatedPt);
      }
      //We pass Number.MIN_VALUE instead of 0 so that for log scale, Math.log(0) is not called.
      poly.splice(0, 0, new Misc.Point(poly[0].x, Number.MIN_VALUE));
      poly.push(new Misc.Point(poly[poly.length - 1].x, Number.MIN_VALUE));

      return poly;
    }

    this.setEnabled = function (on) {
      _enabled = on;
      if (_enabled && _curve && _curve.isVisible()) {
        this.setVisible(true);
        this.refresh();
      } else {
        this.setVisible(false);
      }
    };

    this.enabled = function (on) {
      return _enabled;
    };

    this.setCurve = function (curve) {
      if (curve && _curve == curve) return;
      _curve = curve;
      this.setLimits(); //set limits to undefined (i.e. invalidate limits)
      if (_enabled && _curve && _curve.isVisible()) {
        this.setVisible(true);
        this.refresh();
      }
    };

    this.curve = function () {
      return _curve;
    };

    this.refresh = function () {
      if (this.isVisible() && _curve) {
        _poly = polygonBelowCurve /* _curve, */();
        /* _lowerLimit, _upperLimit */
      } else {
        _poly = null;
      }
      this.setPolygon(_poly);
      if (_curve && _poly) {
        self.setAxes(_curve.xAxis(), _curve.yAxis());
        _curve.plot().autoRefresh();
      }
    };

    this.setLimits = function (lowerLimit, upperLimit) {
      _lowerLimit = lowerLimit;
      _upperLimit = upperLimit;
      this.refresh();
    };

    this.setLowerLimit = function (lowerLimit) {
      _lowerLimit = lowerLimit;
      this.refresh();
    };

    this.setUpperLimit = function (upperLimit) {
      _upperLimit = upperLimit;
      this.refresh();
    };

    Static.bind("visibilityChange", function (e, curve, on) {
      if (curve.rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        if (_curve && curve == _curve && _enabled && on) {
          self.setVisible(true);
        } else {
          if (self.plot().curveShapeEnabledByPlotSettings())
            self.setEnabled(self.plot().tbar.isDropdownItemChecked("Watch", 6));
          if (curve == _curve) {
            self.setVisible(false);
            self.setLimits(); //set limits to undefined
          }
        }
        //Static.trigger("positionChanged"); //force sidebar update
      }
      Static.trigger("curveAdjusted"); //force sidebar update
    });

    Static.bind("axisChanged", function (e, axis, curve) {
      if (curve.rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        //if (self._curve && (curve === self._curve) && _enabled && on) {
        if (_curve && curve === _curve /*  && _enabled */) {
          /*
					set limits to undefined. setLimits() call refresh() and refresh() ensures
					that the curve axis is in sync with the ShapeItem (i.e self or this) axis.
					*/
          self.setLimits();
          //self.setAxes(curve.xAxis(), curve.yAxis());
        } /* else if (curve == self._curve) {
                    self.setVisible(false);
                } */
        //self.setLimits(); //set limits to undefined
      }
    });

    function adjustCurveShape(ruler, pos) {
      if (ruler && _curve) {
        if (ruler.title() == "v_ruler1" || ruler.title() == "v_ruler2") {
          //left ruler
          if (!plot.axisScaleDiv(_curve.xAxis()).isIncreasing()) {
            if (ruler.title() == "v_ruler2") self.setLowerLimit(pos);
            else self.setUpperLimit(pos);
          } else {
            if (ruler.title() == "v_ruler1") self.setLowerLimit(pos);
            else self.setUpperLimit(pos);
          }
        }
      }
    }

    var prevRulerPos = Number.MAX_VALUE;
    var prevRuler = Number.MAX_VALUE;
    Static.bind("positionChanging", function (e, ruler, pos) {
      if (prevRuler === ruler && prevRulerPos === pos) return;
      var plot = ruler.plot();
      var doReplot = plot.autoReplot();
      plot.setAutoReplot(false);
      adjustCurveShape(ruler, pos);
      prevRuler = ruler;
      prevRulerPos = pos;
      plot.setAutoReplot(doReplot);
      plot.autoRefresh();
    });

    Static.bind("positionChanged", function (e, ruler, pos) {
      if (!ruler) return;
      if (prevRuler === ruler && prevRulerPos === pos) return;
      var plot = ruler.plot();
      var doReplot = plot.autoReplot();
      plot.setAutoReplot(false);
      adjustCurveShape(ruler, pos);
      prevRuler = ruler;
      prevRulerPos = pos;
      plot.setAutoReplot(doReplot);
      plot.autoRefresh();
    });

    Static.bind("currentCurveChanged", function (e, newCurve) {
      if (newCurve) self.setCurve(newCurve);
    });

    Static.bind("curveShapeColorChanged", function (e, color) {
      var brush = self.brush();
      brush.color = color;
      self.setBrush(brush);
      var pen = self.pen();
      pen.color = color;
      self.setPen(pen);
    });

    Static.bind("watchEnabled", function (e, watch, on) {
      if (plot.settings() && plot.settings().shadeWatchArea) {
        if (watch.name() == "Area below curve") {
          //if(watch === m_watch){
          self.setEnabled(on);
        }
      }
    });

    Static.bind("shadeWatchArea", function (e, on) {
      plot.setCurveShapeEnabledByPlotSettings(on);
      //case: watch is enabled && shadeWatchArea off
      if (
        (!on && plot.watchAreaBelowCurve.isEnable()) ||
        (!on && !plot.watchAreaBelowCurve.isEnable())
      ) {
        self.setEnabled(false);
      }
      //case: watch is enabled && shadeWatchArea on
      else if (on && plot.watchAreaBelowCurve.isEnable()) {
        self.setEnabled(true);
        //console.log("case: watch is  enabled && shadeWatchArea on")
      }
    });

    Static.bind("itemAttached", function (e, plotItem, on) {
      //only plotcure has shapeitem
      if (plotItem.rtti == PlotItem.RttiValues.Rtti_PlotCurve) {
        if (on) {
          //attached
          if (!self.curve()); //plot.cs.setCurve(plotItem);
        } else {
          //detached
          if (
            !plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve).length ||
            !plot.hasVisiblePlotCurve()
          ) {
            self.setCurve(null);
          }
        }
        Static.trigger("visibilityChange", [plotItem, on]);
        if (plot.itemList(PlotItem.RttiValues.Rtti_PlotCurve).length == 1)
          Static.trigger("currentCurveChanged", plotItem);
      }
    });

    Static.bind("curveAdjusted", function () {
      if (!self.isVisible()) return;
      self.setLimits(); //set curveShapeItem limits to undefined
      //self.refresh(); //setLimits() call refresh
    });

    //this.setItemAttribute(PlotItem.ItemAttribute.AutoScale, false);

    Static.bind("autoScaleCurveShapeItem", function (e, on) {
      self.setItemAttribute(PlotItem.ItemAttribute.AutoScale, on);
    });

    this.attach(plot);
    this.setEnabled(false);
  }
}
;
define("curveShapeItem", ["plotShapeItem"], function(){});

"include ['basicWatch']";

class Watches {
    constructor(plot) {
        var _watchElements = [];
		
		this.watchElements = function(){
			return _watchElements;
		}
	
		//plot.rv = new Rulers(plot)
			
		
		function addwatch(watch, options, disabled) {
			plot.rv.addToWatchList(watch)
			_watchElements.push(options)
			if (disabled) {
				watch.setEnable(false)
			}
		}

		//m_watch = new WatchAreaBelowCurve();

		addwatch(new WatchCurveName(plot.rv), {
			text: "Curve name",
			tooltip: "Name of the curve that is the subject of watches.",
			checkboxState: "checked"
		})
		addwatch(new WatchLeftRulerPosition(plot.rv), {
			text: "Left ruler position",
			tooltip: "Current position of the left ruler.",
			checkboxState: "checked"
		})
		addwatch(new WatchRightRulerPosition(plot.rv), {
			text: "Right ruler position",
			tooltip: "Current position of the right ruler.",
			checkboxState: "checked"
		})
		addwatch(new WatchBottomRulerPosition(plot.rv), {
			text: "Bottom ruler position",
			tooltip: "Current position of the bottom ruler."
		}, true)
		addwatch(new WatchTopRulerPosition(plot.rv), {
			text: "Top ruler position",
			tooltip: "Current position of the top ruler."
		}, true)
		addwatch(new WatchSlope(plot.rv), {
			text: "Slope at left ruler",
			tooltip: "Slope (gradient) in the curve at the point where the left ruler intersects the curve."
		}, true)
		
		plot.watchAreaBelowCurve = new WatchAreaBelowCurve(plot.rv);
		addwatch(plot.watchAreaBelowCurve, {
			text: "Area below curve",
			tooltip: "Area bounded by the curve, right ruler, x-axis and left ruler."
		}, true)
		addwatch(new WatchVolumeOfRevolution(plot.rv), {
			text: "Volume of revolution(X)",
			tooltip: "Volume generated by a 360 degrees rotation about the x-axis of the area bounded by the curve, right ruler, x-axis and left ruler."
		}, true);
		
		
    }
};
define("watches", ["basicWatch"], function(){});

"include ['plot', 'curveClosestPoint', 'plotpicker', 'plotcurve', 'symbol']";

class AddRemovePointPicker extends PlotPicker {
  constructor(plot) {
    super(
      Axis.AxisId.xBottom,
      Axis.AxisId.yLeft,
      Picker.RubberBand.NoRubberBand,
      Picker.DisplayMode.AlwaysOn,
      plot
    );
    var self = this;
    var curve = null;
    var m_activated = false;
    this.setStateMachine(new PickerDblClickPointMachine());
    //this.setTrackerPen(new Misc.Pen("blue"));

    var cp = new CurveClosestPoint(plot, function (curve, p) {
      if (!m_activated) return;
      curve.removePoint(p);
      Static.trigger("curveAdjusted");
    });

    this.setEnabled(false);

    this.activate = function (on) {
      m_activated = on;
      this.setEnabled(on);
      cp.setEnabled(on);
    };

    this.setAddRemoveMousePattern = function (
      pattern,
      button,
      modifiers = Static.NoModifier
    ) {
      this.setMousePattern(pattern, button, modifiers);
      cp.setMousePattern(button, modifiers);
    };

    Static.bind("currentCurveChanged", function (e, _curve) {
      if (curve === _curve) return;
      curve = _curve || null;
      if (curve) {
        self.setAxis(curve.xAxis(), curve.yAxis());
      }
    });

    Static.bind("axisChanged", function (e, axis, _curve) {
      if (curve === _curve) self.setAxis(curve.xAxis(), curve.yAxis());
    });

    Static.bind("pointSelected", function () {
      if (m_activated) self.setEnabled(false);
    });

    Static.bind("pointNotSelected", function () {
      if (m_activated) self.setEnabled(true);
    });

    function enterPoint(p) {
      if (!m_activated) return;
      if (!curve) {
        //"Create curve"
        curve = new MyCurve(Utility.generateCurveName(plot));
        // console.log(plot.axisAutoScale(0));
        // curve.setItemAttribute(
        //   PlotItem.ItemAttribute.AutoScale,
        //   plot.axisAutoScale(0)
        // );
        //console.log(plot);
        let color = Utility.randomColor();
        curve.setPen(new Misc.Pen(color));
        let sym = new Symbol2(
          Symbol2.Style.MRect,
          new Misc.Brush(Utility.invert(color)),
          new Misc.Pen(color),
          new Misc.Size(8, 8)
        );
        curve.setSymbol(sym);
        let attribute = "";
        if (Static.showline && Static.showsymbol) {
          attribute = "lineAndSymbol";
        } else if (Static.showline) {
          attribute = "line";
        } else if (Static.showsymbol) {
          attribute = "symbol";
        }
        Utility.setLegendAttribute(curve, attribute, curve.getLegendIconSize()); //attribute = "line" or "symbol" or "lineAndSymbol"
        curve.attach(plot);
      }
      let samples = curve.data().samples();
      if (!samples.containsPoint(p)) {
        samples.push(p);
      }
      samples.sort(function (a, b) {
        /* if(a.x < b.x) return -1;
                if(a.x > b.x) return 1;
                return 0; */
        return a.x - b.x;
      });
      curve.setSamples(samples);
      plot.autoRefresh();
      Static.trigger("pointAdded", curve);
      //plot.cs.setLimits(); //set curveShapeItem limits to undefined
      Static.trigger("curveAdjusted");
      /* We have at least one point. Ensure remove button is enabled. */
      //$('#pointEntryDlg_remove').attr('disabled', false);
    }

    var prevPoint = new Misc.Point(Number.MAX_VALUE, Number.MAX_VALUE);
    Static.bind("selected", function (e, pickedPoints) {
      var selection = self.selection()[0];
      if (!selection) return;
      if (prevPoint.isEqual(selection)) return;
      prevPoint = selection;
      if (curve)
        enterPoint(
          ScaleMap.invTransform(
            plot.axisScaleDraw(curve.xAxis()).scaleMap(),
            plot.axisScaleDraw(curve.yAxis()).scaleMap(),
            selection
          )
        );
      else
        enterPoint(
          ScaleMap.invTransform(
            plot.axisScaleDraw(Axis.AxisId.xBottom).scaleMap(),
            plot.axisScaleDraw(Axis.AxisId.yLeft).scaleMap(),
            selection
          )
        );
    });

    var f = this.trackerFont();
    //f.th = 14;
    f.fontColor = "blue";
    this.setTrackerFont(f);
  }

  trackerText(pos) {
    var plot = this.plot();
    pos = this.invTransform(pos);
    var label; //= "";
    var numberOfDigitsX = 1;
    if (plot.axisEnabled(Axis.AxisId.xBottom)) {
      numberOfDigitsX = plot.axisPrecision(Axis.AxisId.xBottom);
    } else if (plot.axisEnabled(Axis.AxisId.xTop)) {
      numberOfDigitsX = plot.axisPrecision(Axis.AxisId.xTop);
    } else numberOfDigitsX = plot.axisPrecision(Axis.AxisId.xBottom);
    var numberOfDigitsY = 1;
    if (plot.axisEnabled(Axis.AxisId.yLeft))
      numberOfDigitsY = plot.axisPrecision(Axis.AxisId.yLeft);
    else if (plot.axisEnabled(Axis.AxisId.yRight))
      numberOfDigitsY = plot.axisPrecision(Axis.AxisId.yRight);
    else numberOfDigitsY = plot.axisPrecision(Axis.AxisId.yLeft);

    var yVal = Utility.toPrecision(pos.y, numberOfDigitsY);
    var xVal = Utility.toPrecision(pos.x, numberOfDigitsX);

    switch (this.rubberBand()) {
      case Picker.RubberBand.HLineRubberBand:
        label = yVal.toString();
        break;
      case Picker.RubberBand.VLineRubberBand:
        label = xVal.toString();
        break;
      default:
        label = xVal.toString() + ", " + yVal.toString();
    }
    return label;
  }
}
;
define("addRemovePointPicker", ["plot","curveClosestPoint","plotpicker","plotcurve","symbol"], function(){});



"include ['modalDlg']";

class MFontPickerDlg extends ModalDlg {
  constructor() {
    const options = {
      title: "Font Picker",
      spaceRows: true,
    };

    super(options);
    const self = this;
    self.labelFont = null;

    this.addRow([
      '<div class="col-sm-2">Font:</div>',
      '<div class="col-sm-7">\
            <select id="fontPickerFont">\
                <option value="Arial">Arial</option>\
                <option value="Arial Black">Arial Black</option>\
                <option value="Comic Sans MS">Comic Sans MS</option>\
                <option value="Courier New">Courier New</option>\
                <option value="Georgia">Georgia</option>\
                <option value="Impact">Impact</option>\
                <option value="Lucida Console">Lucida Console</option>\
                <option value="Lucida Sans Unicode">Lucida Sans Unicode</option>\
                <option value="PalatinoLinotype">PalatinoLinotype</option>\
                <option value="Tahoma">Tahoma</option>\
                <option value="Times New Roman">Times New Roman</option>\
                <option value="Trebuchet MS">Trebuchet MS</option>\
                <option value="Verdana">Verdana</option>\
                <option value="Gill Sans">Gill Sans</option>\
            </select>\
        </div>',
    ]);

    this.addRow([
      '<div class="col-sm-2">Point:</div>',
      '<div class="col-sm-4">\
            <input id="fontPickerPoint" type="number" min=6 max=40 value=12>\
        </div>',
      '<div class="col-sm-6">\
      <label>Bold: <input id="fontPickerBold" type="checkbox"></label>\
        </div>',
    ]);

    this.addRow([
      '<div class="col-sm-2">Color:</div>',
      '<div class="col-sm-4">\
            <input id="fontPickerColor" type="color" >\
        </div>',
      '<div class="col-sm-6">\
            <label>Italic: <input id="fontPickerItalic" type="checkbox" ></label>\
        </div>',
    ]);

    this.addHandler("fontPickerFont", "change", function () {
      self.labelFont.name = $(this).val();
      //console.log(self.labelFont);
    });

    this.addHandler("fontPickerColor", "change", function () {
      self.labelFont.fontColor = $(this).val();
      //console.log(self.labelFont);
    });

    this.addHandler("fontPickerPoint", "change", function () {
      self.labelFont.th = parseInt($(this).val());
    });

    this.addHandler("fontPickerBold", "change", function () {
      const checked = $(this)[0].checked;
      self.labelFont.weight = checked == true ? "bold" : "normal";
    });

    this.addHandler("fontPickerItalic", "change", function () {
      const checked = $(this)[0].checked;
      self.labelFont.style = checked == true ? "italic" : "normal";
    });

    this.fontPickerCb = function () {
      this.showDlg();
    };
  }

  initializeDialog() {
    //We create a new font similiar to the one we receive. This new font may be modified. The one we received is not modified.
    this.labelFont = new Misc.Font(this.labelFont);

    this.selector("fontPickerColor").val(this.labelFont.fontColor);
    this.selector("fontPickerFont").val(this.labelFont.name);
    this.selector("fontPickerPoint").val(this.labelFont.th);
    if (this.labelFont.weight == "bold")
      this.selector("fontPickerBold")[0].checked = true;
    else this.selector("fontPickerBold")[0].checked = false;
    if (this.labelFont.style == "italic")
      this.selector("fontPickerItalic")[0].checked = true;
    else this.selector("fontPickerItalic")[0].checked = false;
  }
}
;
define("fontPicker", ["modalDlg"], function(){});

"include ['fontPicker']";

class MMarkerDlg {
  constructor() {
    const self = this;
    var fontDlg = null;

    /* Remove any $("#markerModal") from the DOM before appending a new one.*/
    fontDlg = new MFontPickerDlg();
    fontDlg.labelFont = new Misc.Font();
    $("#markerModal").remove();
    const dlg = $(
      '\
                        <div class="modal fade" id="markerModal" role="dialog">\
                        <div class="modal-dialog modal-md">\
                        <div class="modal-content">\
                        <div class="modal-header">\
                        <button type="button" class= "close" id="closeMarkerDlg">&times;</button>\
                        <h4 id="markerTitle" class="modal-title">Marker</h4>\
                        </div>\
                        <div class="modal-body">\
\
\
\
  <!--div class="panel panel-default">\
    <div class="panel-heading">Panel Heading</div>\
    <div class="panel-body">\
    Panel Content\
    </div>\
  </div-->\
\
\
\
  <div class="panel panel-default">\
    <div class="panel-heading">General</div>\
    <div class="panel-body">\
    <div class="row"><!--row start-->\
    <div class="col-sm-3">Name</div>\
    <div class="col-sm-3"><input id="marker_name" type="text"      value="marker_1" style="width:100%"></div>\
    <div class="col-sm-3">Show on legend</div><div class="col-sm-3"><input id="marker_legend" type="checkbox"></div>\
    </div><!--row end-->\
    <div class="row"><!--row start-->\
    <div class="col-sm-3">Horizontal axis:</div>\
    <div class="col-sm-3">\
       <select id="markerHorizontalAxis"style="width:100%">\
         <option value="markerAxisBottom">Bottom</option>\
         <option value="markerAxisTop">Top</option>\
	 </select>\
    </div>\
    <div class="col-sm-3">Vertical axis:</div>\
    <div class="col-sm-3">\
       <select id="markerVerticalAxis"style="width:100%">\
         <option value="markerAxisLeft">Left</option>\
         <option value="markerAxisRight">Right</option>\
       </select>\
     </div>\
    </div><!--row end-->\
    <div class="row"><!--row start-->\
    <div class="col-sm-3">X-value</div>\
    <div class="col-sm-3"><input id="marker_xValue" type="text"  value=0.0 size="6" style="width:100%"></div>\
    <div class="col-sm-3">Y-value</div>\
<div class="col-sm-3"><input id="marker_yValue" type="text" value=0.0 size="6" style="width:100%"></div>\
    </div><!--row end-->\
    </div>\
  </div>\
\
\
\
<div class="panel panel-default">\
    <div class="panel-heading">Label</div>\
    <div class="panel-body">\
    <div class="row"><!--row start-->\
    <div class="col-sm-3">Text</div>\
    <div class="col-sm-3"><input id="marker_label" type="text"  value="Marker 1" size=12 style="width:100%"></div>\
    <div class="col-sm-1">Font</div>\
<div class="col-sm-1"><input id="marker_labelFont" type="button" value="//"></div>\
    <div class="col-sm-1">Space</div>\
<div class="col-sm-3"><input id="marker_labelSpace" type="number" value=2 min=2 max=40 style="width:100%"></div>\
    </div><!--row end-->\
    <div class="row"><!--row start-->\
    <div class="col-sm-3">Alignment:</div>\
    <div class="col-sm-3">\
       <select id="markerLabelAlignment" style="width:100%">\
        <option value="markerAlignmentLeftTop">Left-Top</option>\
		<option value="markerAlignmentLeftCenter">Left-Center</option>\
        <option value="markerAlignmentLeftBottom">Left-Bottom </option>\
        <option value="markerAlignmentRightTop">Right-Top</option>\
		<option value="markerAlignmentRightCenter">Right-Center</option>\
        <option value="markerAlignmentRightBottom">Right-Bottom</option>\
	    <option value="markerAlignmentCenterTop">Center-Top</option>\
		<option value="markerAlignmentCenterCenter">Center-Center</option>\
        <option value="markerAlignmentCenterBottom">Center-Bottom</option>\
       </select>\
    </div>\
    <div class="col-sm-3">Orientation:</div>\
    <div class="col-sm-3">\
       <select id="markerLabelOrientation" style="width:100%">\
         <option value="markerLabelHorizontal">Horizontal</option>\
         <option value="markerLabelVertical">Vertical</option>\
       </select>\
    </div>\
    </div><!--row end-->\
    </div>\
  </div>\
\
\
\
<div class="panel panel-default">\
    <div class="panel-heading">Line</div>\
    <div class="panel-body">\
    <div class="row"><!--row start-->\
    <div class="col-sm-1">Style:</div>\
    <div class="col-sm-3">\
      <select id="markerLineStyle">\
	   <option value=NoLine>No line</option>\
        <option value=VLine>Vertical line</option>\
        <option value=HLine>Horizontal line</option>\
	   <option value=Cross>Cross line</option>\
      </select>\
    </div>\
    <div class="col-sm-2">Pen color</div>\
    <div class="col-sm-1"><input id="marker_lineColor" type="color" style="width:100%"></div>\
    <div class="col-sm-2">Pen type:</div>\
    <div class="col-sm-3">\
      <select id="markerLineType" style="width:100%">\
	   <option value=solid>solid</option>\
        <option value=dot>dot</option>\
        <option value=dash>dash</option>\
	   <option value=dashDot>dash-dot</option>\
	   <option value=dashDotDot>dash-dot-dot</option>\
	 </select>\
    </div>\
    </div><!--row end-->\
    </div>\
  </div>\
\
\
\
<div class="panel panel-default">\
    <div class="panel-heading">Symbol</div>\
    <div class="panel-body">\
    <div class="row"><!--row start-->\
    <div class="col-sm-1">Style:</div>\
                        <div class="col-sm-3">\
                        <select id="markerSymbol">\
						<option value=none>No symbol</option>\
                        <option value=arrow>Arrow</option>\
                        <option value=dotOnLine>Dot-on-line</option>\
						</select>\
                        </div>\
						<div class="col-sm-1">Angle:</div>\
                        <div class="col-sm-2"><input id="marker_symbolAngle" type="number" style="width:100%" value=0.0></div>\
<div class="col-sm-3">Size(widthXheight)</div>\
                        <div class="col-sm-1" title="width x height">\
                        <select id="markerSymbolSize">\
					<option value="6x6">6x6</option>\
                        	<option value="6x8">6x8</option>\
                        	<option value="6x10">6x10</option>\
					<option value="6x12">6x12</option>\
                        	<option value="6x14">6x14</option>\
					<option value="8x6">8x6</option>\
                        	<option value="8x8">8x8</option>\
                        	<option value="8x10">8x10</option>\
					<option value="8x12">8x12</option>\
                        	<option value="8x14">8x14</option>\
					<option value="10x6">10x6</option>\
                        	<option value="10x8">10x8</option>\
                        	<option value="10x10">10x10</option>\
					<option value="10x12">10x12</option>\
                        	<option value="10x14">10x14</option>\
					<option value="12x6">12x6</option>\
                        	<option value="12x8">12x8</option>\
                        	<option value="12x10">12x10</option>\
					<option value="12x12">12x12</option>\
                        	<option value="12x14">12x14</option>\
					<option value="14x6">14x6</option>\
                        	<option value="14x8">14x8</option>\
                        	<option value="14x10">14x10</option>\
					<option value="14x12">14x12</option>\
                        	<option value="14x14">14x14</option>\
				  </select>\
                        </div>\
    </div><!--row end-->\
    </div>\
  </div>\
\
\
\
\
<div class="modal-footer">\
                        <button id="markerDlg_cancel" type="button" class="btn btn-default" data-dismiss="modal">Cancel</button>\
						<button id="markerDlg_remove" type="button" class="btn btn-default">Remove</button>\
                        <button id="markerDlg_ok" type="button" class="btn btn-default">Ok</button>\
                        </div>\
                        </div>\
                        </div>\
                        </div>\
                        </div>\
                        '
    );

    $("body").append(dlg);

    $("#markerSymbolSize").val("14x14");

    $("#markerDlg_ok").click(okCb);
    $("#markerDlg_remove").click(removeCb);
    $("#closeMarkerDlg").click(closeCb);
    $("#marker_name").focusout(focusoutCb);
    $("#marker_labelFont").click(labelFontCb);

    $("#markerLineStyle").click(function () {
      if ($(this).val() == "NoLine") {
        $("#marker_lineColor").attr("disabled", true);
        $("#markerLineType").attr("disabled", true);
      } else {
        $("#marker_lineColor").attr("disabled", false);
        $("#markerLineType").attr("disabled", false);
      }
    });

    $("#markerModal").on("shown.bs.modal", function () {
      $("#markerDlg_ok").trigger("focus");
    });

    this.markerCb = function (plot) {
      $("body").append(dlg);
      self.plot = plot;
      showDlg();
    };

    function removeCb() {
      var marker = self.plot.findPlotMarker($("#marker_name").val());
      if (marker) {
        // marker.detach();
        // marker.delete();
        self.plot.trashDlg.trash(marker);
        closeCb();
      }
    }

    function initDlg() {
      fontDlg.labelFont = new Misc.Font();
      var marker = self.plot.findPlotMarker($("#marker_name").val());
      if (marker) {
        fontDlg.labelFont = marker.labelFont();
        $("#markerDlg_remove").attr("disabled", false);
        $("#marker_label").val(marker.label());
        $("#marker_xValue").val(marker.xValue());
        $("#marker_yValue").val(marker.yValue());

        $("#marker_labelSpace").val(marker.spacing());

        if (
          marker.labelAlignment() & Static.AlignLeft &&
          marker.labelAlignment() & Static.AlignTop
        ) {
          $("#markerLabelAlignment").val("markerAlignmentLeftTop");
        } else if (
          marker.labelAlignment() & Static.AlignLeft &&
          marker.labelAlignment() & Static.AlignCenter
        ) {
          $("#markerLabelAlignment").val("markerAlignmentLeftCenter");
        } else if (
          marker.labelAlignment() & Static.AlignLeft &&
          marker.labelAlignment() & Static.AlignBottom
        ) {
          $("#markerLabelAlignment").val("markerAlignmentLeftBottom");
        } else if (
          marker.labelAlignment() & Static.AlignRight &&
          marker.labelAlignment() & Static.AlignTop
        ) {
          $("#markerLabelAlignment").val("markerAlignmentRightTop");
        } else if (
          marker.labelAlignment() & Static.AlignRight &&
          marker.labelAlignment() & Static.AlignCenter
        ) {
          $("#markerLabelAlignment").val("markerAlignmentRightCenter");
        } else if (
          marker.labelAlignment() & Static.AlignRight &&
          marker.labelAlignment() & Static.AlignBottom
        ) {
          $("#markerLabelAlignment").val("markerAlignmentRightBottom");
        } else if (
          marker.labelAlignment() & Static.AlignCenter &&
          marker.labelAlignment() & Static.AlignTop
        ) {
          $("#markerLabelAlignment").val("markerAlignmentCenterTop");
        } else if (
          marker.labelAlignment() & Static.AlignCenter &&
          marker.labelAlignment() & Static.AlignBottom
        ) {
          $("#markerLabelAlignment").val("markerAlignmentCenterBottom");
        } else if (marker.labelAlignment() & Static.AlignCenter) {
          $("#markerLabelAlignment").val("markerAlignmentCenterCenter");
        }

        if (marker.labelOrientation() == Static.Horizontal) {
          $("#markerLabelOrientation").val("markerLabelHorizontal");
        } else {
          $("#markerLabelOrientation").val("markerLabelVertical");
        }

        if (marker.testItemAttribute(PlotItem.ItemAttribute.Legend)) {
          $("#marker_legend")[0].checked = true;
        } else {
          $("#marker_legend")[0].checked = false;
        }
        if (marker.xAxis() === Axis.AxisId.xBottom)
          $("#markerHorizontalAxis").val("markerAxisBottom");
        else $("#markerHorizontalAxis").val("markerAxisTop");
        if (marker.yAxis() === Axis.AxisId.yLeft)
          $("#markerVerticalAxis").val("markerAxisLeft");
        else $("#markerVerticalAxis").val("markerAxisRight");

        var mstyle = "NoLine";
        var lineStyle = marker.lineStyle();
        if (lineStyle == PlotMarker.LineStyle.VLine) mstyle = "VLine";
        else if (lineStyle == PlotMarker.LineStyle.HLine) mstyle = "HLine";
        else if (lineStyle == PlotMarker.LineStyle.Cross) mstyle = "Cross";
        $("#markerLineStyle").val(mstyle);

        $("#marker_lineColor").val(marker.linePen().color);
        $("#markerLineType").val(marker.linePen().style);

        var symbol = marker.symbol();
        if (symbol) {
          if (symbol.type === "arrow") {
            $("#markerSymbol").val("arrow");
          } else if (symbol.type === "dotOnLine") {
            $("#markerSymbol").val("dotOnLine");
          }
          var path = symbol.path();
          if (path) {
            $("#marker_symbolAngle").val(parseFloat(path.data.rotation));
          }
        } else {
          $("#markerSymbol").val("none");
        }
      } else {
        $("#markerDlg_remove").attr("disabled", true);
        //$("#marker_lineColor").attr("disabled", true);
        //$("#markerLineType").attr("disabled", true);
      }
      if ($("#markerLineStyle").val() == "NoLine") {
        $("#marker_lineColor").attr("disabled", true);
        $("#markerLineType").attr("disabled", true);
      } else {
        $("#marker_lineColor").attr("disabled", false);
        $("#markerLineType").attr("disabled", false);
      }

      if (symbol) {
        if (symbol.size().width == 6 && symbol.size().height == 6)
          $("#markerSymbolSize").val("6x6");
        else if (symbol.size().width == 6 && symbol.size().height == 8)
          $("#markerSymbolSize").val("6x8");
        else if (symbol.size().width == 6 && symbol.size().height == 10)
          $("#markerSymbolSize").val("6x10");
        else if (symbol.size().width == 6 && symbol.size().height == 12)
          $("#markerSymbolSize").val("6x12");
        else if (symbol.size().width == 6 && symbol.size().height == 14)
          $("#markerSymbolSize").val("6x14");
        else if (symbol.size().width == 8 && symbol.size().height == 6)
          $("#markerSymbolSize").val("8x6");
        else if (symbol.size().width == 8 && symbol.size().height == 8)
          $("#markerSymbolSize").val("8x8");
        else if (symbol.size().width == 8 && symbol.size().height == 10)
          $("#markerSymbolSize").val("8x10");
        else if (symbol.size().width == 8 && symbol.size().height == 12)
          $("#markerSymbolSize").val("8x12");
        else if (symbol.size().width == 8 && symbol.size().height == 14)
          $("#markerSymbolSize").val("8x14");
        else if (symbol.size().width == 10 && symbol.size().height == 6)
          $("#markerSymbolSize").val("10x6");
        else if (symbol.size().width == 10 && symbol.size().height == 8)
          $("#markerSymbolSize").val("10x8");
        else if (symbol.size().width == 10 && symbol.size().height == 10)
          $("#markerSymbolSize").val("10x10");
        else if (symbol.size().width == 10 && symbol.size().height == 12)
          $("#markerSymbolSize").val("10x12");
        else if (symbol.size().width == 10 && symbol.size().height == 14)
          $("#markerSymbolSize").val("10x14");
        else if (symbol.size().width == 12 && symbol.size().height == 6)
          $("#markerSymbolSize").val("12x6");
        else if (symbol.size().width == 12 && symbol.size().height == 8)
          $("#markerSymbolSize").val("12x8");
        else if (symbol.size().width == 12 && symbol.size().height == 10)
          $("#markerSymbolSize").val("12x10");
        else if (symbol.size().width == 12 && symbol.size().height == 12)
          $("#markerSymbolSize").val("12x12");
        else if (symbol.size().width == 12 && symbol.size().height == 14)
          $("#markerSymbolSize").val("12x14");
        else if (symbol.size().width == 14 && symbol.size().height == 6)
          $("#markerSymbolSize").val("14x6");
        else if (symbol.size().width == 14 && symbol.size().height == 8)
          $("#markerSymbolSize").val("14x8");
        else if (symbol.size().width == 14 && symbol.size().height == 10)
          $("#markerSymbolSize").val("14x10");
        else if (symbol.size().width == 14 && symbol.size().height == 12)
          $("#markerSymbolSize").val("14x12");
        else if (symbol.size().width == 14 && symbol.size().height == 14)
          $("#markerSymbolSize").val("14x14");
      }
    }

    function focusoutCb() {
      initDlg();
    }

    /* fontColor: "black"
name: "Arial"
style: "normal"
th: 12
weight: "normal" */

    function labelFontCb() {
      var marker = self.plot.findPlotMarker($("#marker_name").val());
      var font;
      if (marker) {
        //console.log(marker.title());
        fontDlg.labelFont = marker.labelFont();
      } else {
        //fontDlg.labelFont = new Misc.Font();
      }
      fontDlg.fontPickerCb();
      //fontDlg.labelFont = new Misc.Font();
    }

    function closeCb() {
      $("#markerDlg_cancel").click();
    }

    /* // an arrow at a specific position
		var mPos = new PlotMarker( "Marker" );
		mPos.setItemAttribute( PlotItem.ItemAttribute.Legend, true );
		mPos.setSymbol(new ArrowSymbol() );
		mPos.setValue(new Misc.Point( x, Math.sin( x ) ) );
		mPos.setLabel( "x = " + x );
		mPos.setLabelAlignment( Static.AlignRight | Static.AlignBottom );

		mPos.attach( this ); */

    function okCb() {
      var marker = self.plot.findPlotMarker($("#marker_name").val());
      if (marker) {
        marker.detach();
        //marker = null;
      }
      marker = new PlotMarker($("#marker_name").val());
      marker.setItemAttribute(PlotItem.ItemAttribute.AutoScale, true);

      marker.setSpacing(parseInt($("#marker_labelSpace").val()));

      marker.setLabelFont(new Misc.Font(fontDlg.labelFont));

      if ($("#markerHorizontalAxis").val() === "markerAxisBottom")
        marker.setXAxis(Axis.AxisId.xBottom);
      else marker.setXAxis(Axis.AxisId.xTop);
      if ($("#markerVerticalAxis").val() === "markerAxisLeft")
        marker.setYAxis(Axis.AxisId.yLeft);
      else marker.setYAxis(Axis.AxisId.yRight);
      if ($("#markerSymbol").val() === "arrow")
        marker.setSymbol(
          new ArrowSymbol(parseFloat($("#marker_symbolAngle").val()))
        );
      else if ($("#markerSymbol").val() === "dotOnLine")
        marker.setSymbol(
          new DotOnLineSymbol(parseFloat($("#marker_symbolAngle").val()))
        );

      marker.setLinePen(
        new Misc.Pen(
          $("#marker_lineColor").val(),
          1,
          $("#markerLineType").val()
        )
      );

      if ($("#markerLineStyle").val() === "HLine")
        marker.setLineStyle(PlotMarker.LineStyle.HLine);
      else if ($("#markerLineStyle").val() === "VLine")
        marker.setLineStyle(PlotMarker.LineStyle.VLine);
      else if ($("#markerLineStyle").val() === "Cross")
        marker.setLineStyle(PlotMarker.LineStyle.Cross);
      else {
        marker.setLineStyle(PlotMarker.LineStyle.NoLine);
      }

      //call marker.setItemAttribute(PlotItem.ItemAttribute.Legend, true) after lineStyle and or symbolType is set
      if ($("#marker_legend")[0].checked) {
        marker.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
      } else {
        marker.setItemAttribute(PlotItem.ItemAttribute.Legend, false);
      }

      marker.setLegendIconSize(new Misc.Size(20, 20));

      var xVal = math.evaluate(
        self.plot.defines.expandDefines($("#marker_xValue").val())
      );

      var yVal = math.evaluate(
        self.plot.defines.expandDefines($("#marker_yValue").val())
      );
      marker.setValue(new Misc.Point(xVal, yVal));
      marker.setLabel($("#marker_label").val());
      //var labelAlignment = Static.AlignRight;
      if ($("#markerLabelAlignment").val() == "markerAlignmentLeftTop") {
        marker.setLabelAlignment(Static.AlignLeft | Static.AlignTop);
      } else if (
        $("#markerLabelAlignment").val() == "markerAlignmentLeftCenter"
      ) {
        marker.setLabelAlignment(Static.AlignLeft | Static.AlignCenter);
      } else if (
        $("#markerLabelAlignment").val() == "markerAlignmentLeftBottom"
      ) {
        marker.setLabelAlignment(Static.AlignLeft | Static.AlignBottom);
      } else if (
        $("#markerLabelAlignment").val() == "markerAlignmentRightTop"
      ) {
        marker.setLabelAlignment(Static.AlignRight | Static.AlignTop);
      } else if (
        $("#markerLabelAlignment").val() == "markerAlignmentRightCenter"
      ) {
        marker.setLabelAlignment(Static.AlignRight | Static.AlignCenter);
      } else if (
        $("#markerLabelAlignment").val() == "markerAlignmentRightBottom"
      ) {
        marker.setLabelAlignment(Static.AlignRight | Static.AlignBottom);
      } else if (
        $("#markerLabelAlignment").val() == "markerAlignmentCenterTop"
      ) {
        marker.setLabelAlignment(Static.AlignCenter | Static.AlignTop);
      } else if (
        $("#markerLabelAlignment").val() == "markerAlignmentCenterCenter"
      ) {
        marker.setLabelAlignment(Static.AlignCenter);
      } else if (
        $("#markerLabelAlignment").val() == "markerAlignmentCenterBottom"
      ) {
        marker.setLabelAlignment(Static.AlignCenter | Static.AlignBottom);
      }

      if ($("#markerLabelOrientation").val() == "markerLabelHorizontal") {
        marker.setLabelOrientation(Static.Horizontal);
      } else if ($("#markerLabelOrientation").val() == "markerLabelVertical") {
        marker.setLabelOrientation(Static.Vertical);
      }

      var m_symbol = marker.symbol();
      if (m_symbol) {
        if ($("#markerSymbolSize").val() === "6x6")
          m_symbol.setSize(new Misc.Size(6, 6));
        else if ($("#markerSymbolSize").val() === "6x10")
          m_symbol.setSize(new Misc.Size(6, 12));
        else if ($("#markerSymbolSize").val() === "6x12")
          m_symbol.setSize(new Misc.Size(6, 12));
        else if ($("#markerSymbolSize").val() === "6x14")
          m_symbol.setSize(new Misc.Size(6, 14));
        else if ($("#markerSymbolSize").val() === "8x6")
          m_symbol.setSize(new Misc.Size(8, 6));
        else if ($("#markerSymbolSize").val() === "8x8")
          m_symbol.setSize(new Misc.Size(8, 8));
        else if ($("#markerSymbolSize").val() === "8x10")
          m_symbol.setSize(new Misc.Size(8, 10));
        else if ($("#markerSymbolSize").val() === "8x12")
          m_symbol.setSize(new Misc.Size(8, 12));
        else if ($("#markerSymbolSize").val() === "8x14")
          m_symbol.setSize(new Misc.Size(8, 14));
        else if ($("#markerSymbolSize").val() === "10x6")
          m_symbol.setSize(new Misc.Size(10, 6));
        else if ($("#markerSymbolSize").val() === "10x8")
          m_symbol.setSize(new Misc.Size(10, 8));
        else if ($("#markerSymbolSize").val() === "10x10")
          m_symbol.setSize(new Misc.Size(10, 10));
        else if ($("#markerSymbolSize").val() === "10x12")
          m_symbol.setSize(new Misc.Size(10, 12));
        else if ($("#markerSymbolSize").val() === "10x14")
          m_symbol.setSize(new Misc.Size(10, 14));
        else if ($("#markerSymbolSize").val() === "12x6")
          m_symbol.setSize(new Misc.Size(12, 6));
        else if ($("#markerSymbolSize").val() === "12x8")
          m_symbol.setSize(new Misc.Size(12, 8));
        else if ($("#markerSymbolSize").val() === "12x10")
          m_symbol.setSize(new Misc.Size(12, 10));
        else if ($("#markerSymbolSize").val() === "12x12")
          m_symbol.setSize(new Misc.Size(12, 12));
        else if ($("#markerSymbolSize").val() === "12x14")
          m_symbol.setSize(new Misc.Size(12, 14));
        else if ($("#markerSymbolSize").val() === "14x6")
          m_symbol.setSize(new Misc.Size(14, 6));
        else if ($("#markerSymbolSize").val() === "14x8")
          m_symbol.setSize(new Misc.Size(14, 8));
        else if ($("#markerSymbolSize").val() === "14x10")
          m_symbol.setSize(new Misc.Size(14, 10));
        else if ($("#markerSymbolSize").val() === "14x12")
          m_symbol.setSize(new Misc.Size(14, 12));
        else if ($("#markerSymbolSize").val() === "14x14")
          m_symbol.setSize(new Misc.Size(14, 14));

        //marker.setSymbol(m_symbol)
      }

      //marker.setLegendIconSize(new Misc.Size(20,20))
      //marker.setItemAttribute(PlotItem.ItemAttribute.Legend, true);

      marker.attach(self.plot);

      closeCb();
      self.plot.autoRefresh();
    }

    function showDlg() {
      /* var marker = self.plot.findPlotMarker($("#marker_name").val());
			if(marker){
				$("#markerDlg_remove").attr("disabled", false);
			}else{
				$("#markerDlg_remove").attr("disabled", true);
			} */

      initDlg();
      //fontDlg.labelFont = new Misc.Font();
      $("#markerModal").modal({
        backdrop: "static",
      });
    }

    dlg.on("hidden.bs.modal", function () {
      dlg.detach();
    });

    dlg.detach();
  }
}
;
define("markerDlg", ["fontPicker"], function(){});



/**
 * Base class for all type of plot canvases.
 * @abstract
 *
 */
class AbstractCanvas {
  constructor(parentDiv) {
    Utility.makeAbstract(this, AbstractCanvas);
    var m_frameStyle = "none"; //Any valid CSS border-style property
    var m_lineWidth = 0;
    var m_lineColor = "#000000";
    var m_borderRadius = 0;
    var m_color = "#000000";
    var m_parentDiv = parentDiv;

    /**
     * Sets the witdth of the canvas borders.
     * @param {Number} width The width.
     * @returns {object} <strong><i>this</i></strong> For chaining.
     */
    this.setLineWidth = function (width) {
      m_lineWidth = width;
      //if (m_lineWidth)
      m_parentDiv.css("border-width", m_lineWidth);
      return this; //for chaining
    };

    /**
     * Sets the color of the canvas borders.
     * @param {(Number|String)} red This could be a number between [0-255] representing the red in a RGB color or a string such as "red" or "#ff0000" representing a color. If it is a string, other arguments may be omitted.
     * @param {(Number|undefined)} green If the first argument is a number, this argument is required. It is integer between 0-255 representing green in RGB color.
     * @param {(Number|undefined)} blue If the first argument is a number, this argument is required. It is integer between 0-255 representing blue in RGB color.
     * @returns {object} <strong><i>this</i></strong> For chaining.
     */
    this.setLineColor = function (red, green, blue) {
      if (typeof red == "number") {
        m_lineColor = Utility.RGB2HTML(red, green, blue);
      } else if (typeof red == "string") {
        m_lineColor = red;
      }
      m_parentDiv.css("border-color", m_lineColor);
      return this; //for chaining
    };

    /**
     * Sets the style of the cavas's border.
     * @param {String} style A string representing a valid HTML border style (e.g. "dotted", "dashed", "solid", "double", etc.)
     * @returns {object} <strong><i>this</i></strong> For chaining.
     */
    this.setFrameStyle = function (style) {
      m_frameStyle = s;
      m_parentDiv.css("border-style", s);
      return this; //for chaining
    };

    /**
     * Set the radius for the corners of the border frame
     * @param {Number} radius Radius of a rounded corner
     * @see {@link AbstractCanvas#getBorderRadius getBorderRadius()}
     * @returns {object} <strong><i>this</i></strong> For chaining.
     */
    this.setBorderRadius = function (radius) {
      m_borderRadius = radius;
      m_parentDiv.css("border-radius", m_borderRadius);
      return this; //for chaining
    };

    /**
     * Sets the background color of the canvas.
     * @param {(Number|String)} red This could be a number between [0-255] representing the red in a RGB color or a string such as "red" or "#ff0000" representing a color. If it is a string, other arguments may be omitted.
     * @param {(Number|undefined)} green If the first argument is a number, this argument is required. It is integer between 0-255 representing green in RGB color.
     * @param {(Number|undefined)} blue If the first argument is a number, this argument is required. It is integer between 0-255 representing blue in RGB color.
     * @returns {object} <strong><i>this</i></strong> For chaining.
     */
    this.setBackgroundColor = function (red, green, blue) {
      if (typeof red == "number") {
        m_color = Utility.RGB2HTML(red, green, blue);
      } else if (typeof red == "string") {
        m_color = red;
      }
      m_parentDiv.css("background-color", m_color);
      return this; //for chaining
    };

    /**
     * Sets the the cavas background.
     * @param {String} style A string representing a valid HTML background (e.g. "linear-gradient(yellow, white)", "lightblue url("img_tree.gif") no-repeat fixed center", etc.)
     * @returns {object} <strong><i>this</i></strong> For chaining.
     */
    this.setBackground = function (style) {
      m_parentDiv.css("background", style);
      return this; //for chaining
    };

    /**
     *
     * @returns {Number} Radius for the corners of the border frame.
     * @see {@link AbstractCanvas#setBorderRadius setBorderRadius()}
     */
    this.getBorderRadius = function () {
      return m_borderRadius;
    };

    /**
     *
     * @param {object} sheet Style sheet specifying style attributes.
     * @returns {object} <strong><i>this</i></strong> For chaining.
     * @example var pc = new PlotCanvas(plot); //create a canvas
     * var styleSheet = //Define the syles in a style sheet
     * {
     *  backgroundColor: "yellow",
     *  background: "linear-gradient(yellow, white)",
     *  borderRadius: 15,
     *  lineColor: "red",
     *  lineWidth: 4
     * };
     * pc.setStyleSheet(styleSheet); //Apply the styles to the canvas.
     */
    this.setStyleSheet = function (sheet) {
      if (sheet.backgroundColor !== undefined)
        this.setBackgroundColor(sheet.backgroundColor);
      if (sheet.background !== undefined) this.setBackground(sheet.background);
      if (sheet.borderRadius !== undefined)
        this.setBorderRadius(sheet.borderRadius);
      if (sheet.frameStyle !== undefined) this.setFrameStyle(sheet.frameStyle);
      if (sheet.lineColor !== undefined) this.setLineColor(sheet.lineColor);
      if (sheet.lineWidth !== undefined) this.setLineWidth(sheet.lineWidth);

      return this; //for chaining
    };
  }
}

/**
 * Canvas is the widget where all plot items are displayed
 * @extends AbstractCanvas
 */
class PlotCanvas extends AbstractCanvas {
  constructor(plot) {
    super(plot.getCentralWidget().getElement());
  }
}

/**
 * Canvas is the parent widget of the PlotCanvas widget.
 * @extends AbstractCanvas
 */
class PlotContainerCanvas extends AbstractCanvas {
  constructor(plot) {
    super(plot.getCentralWidget().getElement().parent());
  }
}
;
define("canvas", ["static"], function(){});



/**
 * A plot item, which displays a zone. See example
 *
 * A horizontal zone highlights an interval of the y axis - a vertical zone an interval of the x axis - and is unbounded
 * in the opposite direction. It is filled with a brush and its border lines are optionally displayed with a pen.
 * @extends PlotItem
 *
 * @example
 * const plot = new Plot();
 * const z = new PlotZoneItem();
 * z.setInterval(250, 280);
 * z.setPen(new Misc.Pen("red"));
 * //z.setBrush(new Misc.Brush("blue"));
 * //z.setOrientation(Static.Horizontal);
 * //z.setItemAttribute(PlotItem.ItemAttribute.Legend, true);
 * z.attach(plot);
 */
class PlotZoneItem extends PlotItem {
  /**
   * Initializes the zone with no pen and a semi transparent gray brush
   */
  constructor(title) {
    super(title);

    var m_orientation = Static.Vertical;
    var m_pen = new Misc.Pen("red", 8, Static.NoPen);
    var m_brush = new Misc.Brush("darkGray");
    var m_interval = new Interval();

    this.setItemAttribute(PlotItem.ItemAttribute.AutoScale, false);
    //setItemAttribute( QwtPlotItem::Legend, false );
    this.setItemAttribute(PlotItem.ItemAttribute.Legend, false);

    this.setZ(5);

    this.rtti = PlotItem.RttiValues.Rtti_PlotZone;

    /**
     * Assign a pen
     *
     * The pen is used to draw the border lines of the zone
     * @param {Misc.Pen} pen Pen
     * @see {@link PlotZoneItem#pen pen()}
     * @see {@link PlotZoneItem#setBrush setBrush()}
     */
    this.setPen = function (pen) {
      //if ( d_data->pen != pen )
      {
        m_pen = pen;
        //itemChanged();
      }
    };

    /**
     *
     * @returns {Misc.Pen} Pen used to draw the border lines
     * @see {@link PlotZoneItem#setPen setPen()}
     * @see {@link PlotZoneItem#brush brush()}
     */
    this.pen = function () {
      return m_pen;
    };

    /**
     * Assign a brush
     *
     * The brush is used to fill the zone
     * @param {Misc.Brush} brush Brush
     * @see {@link PlotZoneItem#pen pen()}
     * @see {@link PlotZoneItem#setBrush setBrush()}
     */
    this.setBrush = function (brush) {
      //if ( m_brush != brush )
      {
        m_brush = brush;
        //itemChanged();
      }
    };

    /**
     *
     * @returns {Misc.Brush} Brush used to fill the zone
     * @see {@link PlotZoneItem#setPen setPen()}
     * @see {@link PlotZoneItem#brush brush()}
     */
    this.brush = function () {
      return m_brush;
    };

    /**
     * Set the orientation of the zone
     *
     * A horizontal zone highlights an interval of the y axis, a vertical zone of the x axis. It is unbounded in the
     * opposite direction.
     * @param {Number} orientation Orientation (Static.Vertical or Static.Horizontal)
     * @see {@link PlotZoneItem#orientation orientation()}
     * @see {@link PlotItem#setAxes setAxes()}
     */
    this.setOrientation = function (orientation) {
      if (m_orientation != orientation) {
        m_orientation = orientation;
        //itemChanged();
      }
    };

    /**
     *
     * @returns {Number} Orientation of the zone
     * @see {@link PlotZoneItem#setOrientation setOrientation()}
     */
    this.orientation = function () {
      return m_orientation;
    };

    /**
     * Sets the interval of the zone
     * @param {Number | Interval} param1 Minimum of the interval or Interval object
     * @param {Number} [param2] Maximum of the interval (only considered if param1 is a Number)
     * @see {@link PlotZoneItem#interval interval()}
     * @see {@link PlotZoneItem#setOrientation setOrientation()}
     */
    this.setInterval = function (param1, param2) {
      if (typeof param2 == "undefined") m_interval = param1;
      else m_interval = new Interval(param1, param2);
    };

    /**
     *
     * @returns {Interval} Zone interval
     * @see {@link PlotZoneItem#setInterval setInterval()}
     * @see {@link PlotZoneItem#orientation orientation()}
     */
    this.interval = function () {
      return m_interval;
    };

    /**
     *  Draw the zone
     * @param {ScaleMap} xMap Scale Map
     * @param {ScaleMap} yMap Scale Map
     */
    this.draw = function (xMap, yMap) {
      if (!m_interval.isValid()) return;

      var pen = m_pen;
      //pen.setCapStyle( Qt::FlatCap );

      //const bool doAlign = QwtPainter::roundingAlignment( painter );
      var canvasRect = this.getCanvasRect();
      var ctx = this.getContext();

      var painter = new PaintUtil.Painter(ctx);
      painter.setBrush(m_brush);
      painter.setPen(m_pen);

      if (m_orientation == Static.Horizontal) {
        var y1 = yMap.transform(m_interval.minValue());
        var y2 = yMap.transform(m_interval.maxValue());

        //            if ( doAlign )
        //            {
        //                y1 = qRound( y1 );
        //                y2 = qRound( y2 );
        //            }

        var r = new Misc.Rect(
          new Misc.Point(canvasRect.left(), y1),
          canvasRect.width(),
          y2 - y1
        );
        r = r.normalized();

        if (m_brush.style != Static.NoBrush && y1 != y2) {
          painter.fillRect(r, m_brush);
        }

        if (m_pen.style != Static.NoPen) {
          painter.drawLine(r.left(), r.top(), r.right(), r.top());
          painter.drawLine(r.left(), r.bottom(), r.right(), r.bottom());
        }
      } else {
        var x1 = xMap.transform(m_interval.minValue());
        var x2 = xMap.transform(m_interval.maxValue());

        //            if ( doAlign )
        //            {
        //                x1 = qRound( x1 );
        //                x2 = qRound( x2 );
        //            }

        var r = new Misc.Rect(
          new Misc.Point(x1, canvasRect.top()),
          x2 - x1,
          canvasRect.height()
        );
        r = r.normalized();

        if (m_brush != Static.NoBrush && x1 != x2) {
          painter.fillRect(r, m_brush);
        }

        if (m_pen.style != Static.NoPen) {
          painter.drawLine(r.left(), r.top(), r.left(), r.bottom());
          painter.drawLine(r.right(), r.top(), r.right(), r.bottom());
        }
      }
      painter = null;
    };

    /**
     * The bounding rectangle is build from the interval in one direction and something invalid for the opposite direction.
     * @returns {Misc.Rect} An invalid rectangle with valid boundaries in one direction
     */
    this.boundingRect = function () {
      var br = new Misc.Rect(); //super.boundingRect();

      var intv = m_interval;

      if (intv.isValid()) {
        if (m_orientation == Static.Horizontal) {
          br.setTop(intv.minValue());
          br.setBottom(intv.maxValue());
        } else {
          br.setLeft(intv.minValue());
          br.setRight(intv.maxValue());
        }
      }

      return br;
    };
  }

  /**
   *
   * @returns {String} A string representation of the object.
   */
  toString() {
    return "[PlotZoneItem]";
  }
}
;
define("plotZoneItem", ["static","plotItem"], function(){});

"include ['static', 'modalDlg']";

class Trash extends ModalDlg {
  constructor(plot) {
    const options = {
      title: "Recycle bin",
      spaceRows: true,
      //dialogSize: "modal-md",
    };
    super(options);
    const self = this;
    const _plot = plot;
    let trashCollection = [];

    this.selector("ok").hide();

    this.addRow(['<div class="col-sm-12">No items found.</div>'], "noTrash");
    this.addRow(
      [
        '<div class="col-sm-12"><div style="overflow:auto"><table id="trashTable"></table></div></div>',
      ],
      "trash"
    );

    this.addFooterElement(
      '<button id="empty" type="button" class="btn btn-default" data-dismiss="modal">Empty bin</button>'
    );

    this.addHandler("empty", "click", function () {
      trashCollection = [];
    });

    this.addFooterElement(
      '<button id="restore" type="button" class="btn btn-primary" data-dismiss="modal">Restore</button>'
    );

    this.addHandler("restore", "click", function () {
      const entries = self.selector("trashTable").find("INPUT");
      let modifiedCollection = [];
      for (let i = 0; i < entries.length; i++) {
        if (!entries[i].checked) {
          modifiedCollection.push(trashCollection[i]);
        } else {
          let existCurve = plot.findPlotItem(trashCollection[i].title());
          if (existCurve) {
            if (
              confirm(
                `The plot already has a plot item with a title "${trashCollection[
                  i
                ].title()}".\n\nReplace the plot item in the plot.`
              )
            ) {
              existCurve.detach();
            } else {
              modifiedCollection.push(trashCollection[i]);
              continue;
            }
          }
          //console.log(existCurve);
          trashCollection[i].attach(plot);
        }
      }
      trashCollection = modifiedCollection;
    });

    this.initDlg = function () {
      if (trashCollection.length < 1) {
        self.selector("noTrash").show();
        self.selector("trash").hide();
        self.selector("empty").hide();
        self.selector("restore").hide();
      } else {
        self.selector("empty").show();
        self.selector("noTrash").hide();
        self.selector("trash").show();
        self.selector("trashTable").empty();

        for (let i = 0; i < trashCollection.length; i++) {
          let entry = $(
            "<tr></td><td><label><input class='selectedForTrash' type='checkbox' style='width:30px'>" +
              trashCollection[i].title() +
              "</input></label></td></tr>"
          );
          self.selector("trashTable").append(entry);
        }

        self.selector("restore").hide();
        $(".selectedForTrash").on("change", function () {
          const entries = self.selector("trashTable").find("INPUT");
          for (let i = 0; i < entries.length; i++) {
            if (entries[i].checked) {
              self.selector("restore").show();
              return;
            }
          }
          self.selector("restore").hide();
        });
      }
    };

    this.trash = function (plotItem) {
      trashCollection.push(plotItem);
      plotItem.detach();
    };

    this.trashCb = function () {
      this.showDlg();
    };
  }

  initializeDialog() {
    this.initDlg();
  }
}
;
define("trash", ["static","modalDlg"], function(){});

"include []";


class Transformation {
  constructor(plot) {
    const m_plot = plot;

    this.transform = function (curve, type, param1, param2) {
      const variable = curve.variable;
      const numOfPoints = curve.dataSize();
      if (type == "Translate") {
        //console.log(curve.expandedFn, param1, param2);
        let fn = curve.fn;
        if (param1 !== 0) {
          fn = fn.replaceAll("x", "(x+" + param1 * -1 + ")");
          //fn = fn.replaceAll("+-", "-");
        }
        if (param2 !== 0) {
          fn = "(" + fn + ")+" + param2;
        }
        fn = math
          .simplify(fn.replaceAll("+-", "-"), {}, { exactFractions: false })
          .toString();
        //Replace the whitespace delimiters stripped out by simplify()
        fn = fn.replaceAll("mod", " mod ");

        const functionDlgData = {
          rtti: PlotItem.RttiValues.Rtti_PlotCurve,
          lowerLimit: curve.minXValue() + param1, //Number
          upperLimit: curve.maxXValue() + param1, //Number
          threeD: false,
          title: Utility.generateCurveName(m_plot, "trans_"), //eq + domain[0], //String
          variable, //String
          fn: fn, //String
          expandedFn: fn, //String
          numOfPoints, //Number
          unboundedRange: false, //Boolean
          coeffs: curve.coeffs, //Array
          threeDType: null, //String e.g. "spectrocurve"
          threeDInterpolationType: null, //String e.g. "bilinear"
          lowerLimitY: undefined, //Number
          upperLimitY: undefined, //Number
          lowerLimitFxy: undefined, //Number
          upperLimitFxy: undefined, //Number
          variableY: undefined, //String
          color1: "#008b8b", //String
          color2: "#ff0000", //String
          // discontinuity: Utility.discontinuity(
          //   fn,
          //   curve.minXValue() + param1,
          //   curve.maxXValue() + param1
          // ),
          // discontinuity: curve.discontinuity.map(function (e) {
          //   return e + param1;
          // }),
        };

        const _curve = m_plot.functionDlgCb(functionDlgData);
        //_curve.setAxis = true;
        // _curve.discontinuity = curve.discontinuity.map(function (e) {
        //   return e + param1;
        // });
        _curve.attach(m_plot);
      }

      if (type == "Scale") {
        //console.log(curve.expandedFn, param1, param2);
        let fn = curve.fn;

        fn = math
          .simplify("(" + fn + ")*" + param1, {}, { exactFractions: false })
          .toString();
        //Replace the whitespace delimiters stripped out by simplify()
        fn = fn.replaceAll("mod", " mod ");

        //console.log(fn);

        const functionDlgData = {
          rtti: PlotItem.RttiValues.Rtti_PlotCurve,
          lowerLimit: curve.minXValue(), //Number
          upperLimit: curve.maxXValue(), //Number
          threeD: false,
          title: Utility.generateCurveName(m_plot, "trans_"), //eq + domain[0], //String
          variable, //String
          fn: fn, //String
          expandedFn: fn, //String
          numOfPoints, //Number
          unboundedRange: false, //Boolean
          coeffs: curve.coeffs, //Array
          threeDType: null, //String e.g. "spectrocurve"
          threeDInterpolationType: null, //String e.g. "bilinear"
          lowerLimitY: undefined, //Number
          upperLimitY: undefined, //Number
          lowerLimitFxy: undefined, //Number
          upperLimitFxy: undefined, //Number
          variableY: undefined, //String
          color1: "#008b8b", //String
          color2: "#ff0000", //String
          // discontinuity: Utility.discontinuity(
          //   fn,
          //   curve.minXValue(),
          //   curve.maxXValue()
          // ),
        };

        const _curve = m_plot.functionDlgCb(functionDlgData);
        //_curve.discontinuity = curve.discontinuity;
        _curve.attach(m_plot);
      }

      if (type == "Reflect x-axis") {
        //console.log(curve.expandedFn, param1, param2);

        let fn = math
          .simplify(`-(${curve.fn})`, {}, { exactFractions: false })
          .toString();
        //Replace the whitespace delimiters stripped out by simplify()
        fn = fn.replaceAll("mod", " mod ");
        const functionDlgData = {
          rtti: PlotItem.RttiValues.Rtti_PlotCurve,
          lowerLimit: curve.minXValue(), //Number
          upperLimit: curve.maxXValue(), //Number
          threeD: false,
          title: Utility.generateCurveName(m_plot, "trans_"), //eq + domain[0], //String
          variable, //String
          fn: fn, //String
          expandedFn: fn, //String
          numOfPoints, //Number
          unboundedRange: false, //Boolean
          coeffs: curve.coeffs, //Array
          threeDType: null, //String e.g. "spectrocurve"
          threeDInterpolationType: null, //String e.g. "bilinear"
          lowerLimitY: undefined, //Number
          upperLimitY: undefined, //Number
          lowerLimitFxy: undefined, //Number
          upperLimitFxy: undefined, //Number
          variableY: undefined, //String
          color1: "#008b8b", //String
          color2: "#ff0000", //String

          // discontinuity: Utility.discontinuity(
          //   fn,
          //   curve.minXValue(),
          //   curve.maxXValue()
          // ),
        };

        const _curve = m_plot.functionDlgCb(functionDlgData);
        _curve.attach(m_plot);
      }

      if (type == "Reflect y-axis") {
        //console.log(curve.expandedFn, param1, param2);

        let fn = curve.fn;
        fn = math
          .simplify(
            fn.replaceAll(variable, `(-1*${variable})`),
            {},
            { exactFractions: false }
          )
          .toString();
        //Replace the whitespace delimiters stripped out by simplify()
        fn = fn.replaceAll("mod", " mod ");
        const functionDlgData = {
          rtti: PlotItem.RttiValues.Rtti_PlotCurve,
          lowerLimit: curve.maxXValue() * -1, //Number
          upperLimit: curve.minXValue() * -1, //Number
          threeD: false,
          title: Utility.generateCurveName(m_plot, "trans_"), //eq + domain[0], //String
          variable, //String
          fn: fn, //String
          expandedFn: fn, //String
          numOfPoints, //Number
          unboundedRange: false, //Boolean
          coeffs: curve.coeffs, //Array
          threeDType: null, //String e.g. "spectrocurve"
          threeDInterpolationType: null, //String e.g. "bilinear"
          lowerLimitY: undefined, //Number
          upperLimitY: undefined, //Number
          lowerLimitFxy: undefined, //Number
          upperLimitFxy: undefined, //Number
          variableY: undefined, //String
          color1: "#008b8b", //String
          color2: "#ff0000", //String

          // discontinuity: Utility.discontinuity(
          //   fn,
          //   curve.maxXValue() * -1,
          //   curve.minXValue() * -1
          // ),
        };

        const _curve = m_plot.functionDlgCb(functionDlgData);
        _curve.attach(m_plot);
      }

      if (type == "Reflect x and y-axis") {
        // console.log(curve.expandedFn, param1, param2);
        let fn = `-(${curve.fn})`;
        fn = math
          .simplify(
            fn.replaceAll(variable, `(-1*${variable})`),
            {},
            { exactFractions: false }
          )
          .toString();
        //Replace the whitespace delimiters stripped out by simplify()
        fn = fn.replaceAll("mod", " mod ");
        const functionDlgData = {
          rtti: PlotItem.RttiValues.Rtti_PlotCurve,
          lowerLimit: curve.maxXValue() * -1, //Number
          upperLimit: curve.minXValue() * -1, //Number
          threeD: false,
          title: Utility.generateCurveName(m_plot, "trans_"), //eq + domain[0], //String
          variable, //String
          fn: fn, //String
          expandedFn: fn, //String
          numOfPoints, //Number
          unboundedRange: false, //Boolean
          coeffs: curve.coeffs, //Array
          threeDType: null, //String e.g. "spectrocurve"
          threeDInterpolationType: null, //String e.g. "bilinear"
          lowerLimitY: undefined, //Number
          upperLimitY: undefined, //Number
          lowerLimitFxy: undefined, //Number
          upperLimitFxy: undefined, //Number
          variableY: undefined, //String
          color1: "#008b8b", //String
          color2: "#ff0000", //String

          // discontinuity: Utility.discontinuity(
          //   fn,
          //   curve.maxXValue() * -1,
          //   curve.minXValue() * -1
          // ),
        };

        const _curve = m_plot.functionDlgCb(functionDlgData);
        _curve.attach(m_plot);
      }
    };
  }
}
;
define("transformation", function(){});



require([
  // "mathsteps-master/math-steps",
  "enumerator",
  "curveLegendAttributeDlg",
  "regression",
  "functionDlg",
  "curveFitDlg",
  "curveStyleDlg",
  "axisDlg",
  "zoneDlg",
  "pointEntryDlg",
  "mtoolBar",
  "file",
  "watch",
  "basicWatch",
  "legendMenu",
  "rulers",
  "infoSidebar",
  "infoPropertiesPane",
  "plotSideBar",
  "curvePropertiesPane",
  "plotPropertiesPane",
  "myPlot",
  "myCurve",
  "plotSpectroCurve",
  "plotRasterItem",
  "plotSpectrogram",
  "rasterFileData",
  "rasterFunctionData",
  "pointData",
  "symbol",
  "legend",
  "magnifier",
  "plotGrid",
  "widgetOverlay",
  "myZoomer",
  "curveFitter",
  "spline",
  "panner",
  //"contextMenu",
  "plotMarker",
  "curveClosestPoint",
  "curveSelector",
  "curveShapeItem",
  "underscore",
  "widgetOverlay",
  "functionData",
  "watches",
  "addRemovePointPicker",
  "markerDlg",
  "defines",
  "canvas",
  "fontPicker",
  "plotZoneItem",
  "trash",
  "transformation",
], function (/* mathsteps */) {
  ////////////
  //var plot = new Plot($("#plotDiv"), "Plot");

  //We call these two methods early so that the entire application is properly informed.
  Enumerator.noThrowOnEnumRedefinition();
  Enumerator.setDefaultEnumNampespace("Enum");

  // // Utility.alert('This application is design to run in \"chrome browser\". While it may run in other browsers, some features may not behave as expected.', "small");

  var plot = new MyPlot($("#plotDiv"), "Plot");
  // var lgnd = new Legend()
  // var legendMenu = new LegendMenu(plot);
  /* remove menu items */
  // legendMenu.modifyMenu("rename", {})
  // legendMenu.modifyMenu("symbol", {})
  // legendMenu.modifyMenu("pen", {})
  // legendMenu.modifyMenu("remove", {})
  // legendMenu.modifyMenu("curve brush", {})
  // console.log(legendMenu)
  // plot.insertLegend(lgnd);
  // plot.enableLegend(true);
  // var c = new Curve("curve 1")
  // c.setSamples([new Misc.Point(0, 0), new Misc.Point(2, 6),  new Misc.Point(6, 3), new Misc.Point(10, 10)])
  // c.attach(plot)
  // plot.setAutoReplot(true)

  //plot.setLegendFont(new Misc.Font(20))

  // var plot1 = new Plot($("#plotDiv"), "Plot 1" );
  // plot1.setAutoReplot(true);

  // var g = new PlotGrid()
  // Utility.minorGridLines(g, true)
  // g.attach(plot1)
  // var m = new Magnifier(plot1)
  // plot1.setFooter("Footer")

  // var plot2 = new Plot($("#plotDiv2"), "Plot 2" );
  // plot2.setAutoReplot(true)
  // var m2 = new Magnifier(plot2);
  // plot2.setFooter("Footer2")

  // var plot3 = new Plot($("#plotDiv3")/* , "Plot 2"  */);
  // plot3.setAutoReplot(true)
  // var m2 = new Magnifier(plot3);
  // plot3.setFooter("Footer3")

  // Enumerator.setDefaultEnumNampespace("Enum")
  // Enumerator.noThrowOnEnumRedefinition()

  // Enumerator.enum("Hello{world1, world2, world3")
  // Enumerator.enum("Hello{world1=45, world2, world3")
  // //Enum.Hello.world1 = 45;
  //console.log((0x01 | 0x02))

  // const options2 = {
  //   hideAlphas: true,
  //   title: "Function Editor",
  //   screenColor: "#fff",
  //   screenTextColor: "#00f",
  //   prettyOnly: true,
  //   initializeWithLastValue: true,
  //   validOnly: true,
  //   bigDialog: true,
  //   //operatorButtonTextColor: "red"
  //   //buttonImages: {xSquareImg: "img/xSquare3.png"}
  //   // buttonImages: {xSquareImg: "Sqr", squareRootImg: "Sqrt", xToPowYImg: "x^y"}
  // };

  // //Create a second equation editor that will be trigger when a clickable html element with id 'test2' is clicked.
  // new EquationEditor("equationEditor" /* , options2 */);

  //////////////////////////////

  // class MyModal extends ModalDlg {
  //   constructor(obj) {
  //     super(obj);

  //     const columns = [
  //       '<div id="select101aa" class="col-sm-5">Horizontal:</div>',

  //       '<div class="col-sm-7">\
  //           <select id="select1">\
  //             <option value="bottomAxis">Bottom axis</option>\
  //             <option value="topAxis">Top axis</option>\
  //           </select>\
  //       </div>',
  //     ];

  //     const columns2 = [
  //       '<div class="col-sm-5">Vertical:</div>',

  //       '<div class="col-sm-7">\
  //           <select id="select2">\
  //             <option value="leftAxis">Left axis</option>\
  //             <option value="rightAxis">Right axis</option>\
  //           </select>\
  //       </div>',
  //     ];

  //     this.addRow(columns, "row1");
  //     this.addRow(columns2);
  //     this.addHandler("cancel", "click", function () {
  //       console.log("cancel");
  //     });
  //     this.addHandler("ok", "click", function () {
  //       console.log(456);
  //       //dlg.closeDlg();
  //     });
  //     this.addHandler("select1", "change", function () {
  //       if ($(this).val() == "bottomAxis") {
  //         console.log("bottomAxis");
  //       } else {
  //         console.log("topAxis");
  //       }
  //     });

  //     this.addHandler("select2", "change", function () {
  //       if ($(this).val() == "leftAxis") {
  //         console.log("leftAxis");
  //       } else {
  //         console.log("rightAxis");
  //       }
  //     });
  //   }
  // }

  // const options = {
  //   title: "Test Modal",
  //   //hideCancelButton: true,
  //   //spaceRows: true,
  //   // beforeDetach: function () {
  //   //   console.log("beforeDetach");
  //   // },
  // };
  // var dlg = new MyModal(options);
  // // dlg.hide("row1");
  // // dlg.show("row1");
  // // console.log(dlg.css("ok", {"width": 200}))
  // // console.log(dlg.css("ok", "width"))
  // dlg.addFooterButton("testButtonId", "Test Btn")
  // console.log(dlg.attr("testButtonId", "id"))
  // dlg.showDlg();

  /* var plot = new Plot($("#plotDiv"), "Plot");
  plot.setAutoReplot(true);

  plot.insertLegend(new Legend());
  plot.enableLegend(true);

  const curve = new Curve("Aaaa");
  curve.setSamples([new Misc.Point(1, 1), new Misc.Point(10, 10)]);
  curve.attach(plot);

  curve.detach();
  curve.attach(plot);

  curve.detach();
  curve.attach(plot);
  curve.detach();
  curve.attach(plot);
  curve.detach();
  curve.attach(plot);
  curve.detach();
  curve.attach(plot); */

  /* class MyPicker extends PlotPicker {
    constructor(plot) {
      super(
        Axis.AxisId.xBottom,
        Axis.AxisId.yLeft,
        Picker.RubberBand.NoRubberBand,
        Picker.DisplayMode.AlwaysOn,
        plot
      );
      var self = this;

      Static.bind("selected", function (e, pickedPoints) {
        var selection = self.selection()[0];
        console.log(
          ScaleMap.invTransform(
            plot.axisScaleDraw(Axis.AxisId.xBottom).scaleMap(),
            plot.axisScaleDraw(Axis.AxisId.yLeft).scaleMap(),
            selection
          )
        );
      });

      this.setStateMachine(new PickerClickPointMachine());

      this.setMousePattern(
        EventPattern.MousePatternCode.MouseSelect1,
        Static.LeftButton,
        Static.ShiftModifier
      );

      // this.setEnabled(true);
    }
  }

  var picker = new MyPicker(plot); */

  // let fx1 = "8x";
  // let fx2 = "4x";

  // let op = "/";

  // let fx = math.parse(`(${fx1}) ${op} (${fx2})`);
  // console.log(math.simplify(fx).toString());
  // fx = math.parse(math.simplify(fx).toString());
  // if (fx.fn == "divide") {
  //   //console.log(fx.args[0].toString());
  //   console.log(fx.args[1].toString());
  // } else {
  //   console.log("No denominator");
  // }

  //console.log(math.evaluate("1e-1").toString());

  // const a = [
  //   [-2, 3], //-2x +3y = 11
  //   [2, 1], //2x + y = 9
  // ];
  // const b = [11, 9];
  // const x = math.lusolve(a, b); // [ [[2], [5]] ]
  // console.log(x);

  // var Fraction = algebra.Fraction;
  // var Expression = algebra.Expression;
  // var Equation = algebra.Equation;

  // var x1 = algebra.parse("1/5  x + 2/15");
  // var x2 = algebra.parse("1/7  x + 4");

  // var eq = new Equation(x1, x2);
  // console.log(eq.toString());

  // var answer = eq.solveFor("x");

  // console.log("x = " + answer.toString());

  // const trash = new Trash();
  // trash.showDlg();

  // Utility.alertYesNo("AAA", function (val) {
  //   console.log(val);
  // });

  //const s = "|-2|x||";
  //console.log(Utility.insertAbs(s));

  /* const parser = new math.parser();
  parser.evaluate("f(x) = (4x^2)^(1/3)");

  const s = (10 + 10) / 20;

  console.log(parser.evaluate(`f(-10)`));
  for (let i = 1; i < 20; i++) {
    let x = -10 + s * i;
    console.log(parser.evaluate(`f(${x})`));
  }
  console.log(parser.evaluate(`f(10)`)); */

  //console.log(math.simplify("2 * 1 * x ^ (2 - 1)").toString());

  // var Fraction = algebra.Fraction;
  // var Expression = algebra.Expression;
  //var Equation = algebra.Equation;

  // var expr = new Expression("x");
  // expr = expr.subtract(3);
  // expr = expr.add("x");

  // console.log(expr.toString());

  // var eq = new Equation(expr, 4);

  // console.log(eq.toString());

  // var x = eq.solveFor("x");

  // console.log("x = " + x.toString());

  //var quad = new Equation(algebra.parse("81.2*x^2 +322.4*x-579.05"), 0);
  // var quad = new Equation(
  //   algebra.parse(
  //     "2.59e-5 * x ^ 3 - 0.0297938 * x ^ 2 + 8.8587678 * x - 100.2425242"
  //   ),
  //   0
  // );

  //console.log(quad.toString());
  // var answers = quad.solveFor("x");

  // console.log("x = " + answers.toString());

  //27x^3 +161x^2-579x+180

  //console.log(Utility.curveTurningPoint1("27x^3 +161x^2-579x+180", "x"));
  // console.log(
  //   Utility.curveTurningPoint(
  //     "2.28e-5x^3 - 0.0307742*x^2 + 10.9604433x - 271.7014375",
  //     "x"
  //   )
  // );

  //console.log(Utility.curveTurningPoint(curve));

  // let n = { value: 2.125456 };
  // n.value = Utility.adjustForDecimalPlaces(n.value, 2);
  // console.log(n);

  // let n = 212545.6;
  // n = Utility.toPrecision(n, 10);
  // console.log(n);
  //Utility.toPrecision(,precisionX);
  //console.log(486, math.evaluate(1 / 1e-100));

  /* function discontinuity(exp){    
    let m_exp = math.parse(exp);
    let denominators = [];
    let result = [];
    m_exp.forEach(function(e){
      if(e.op == "/"){
        denominators.push(e.args[1].toString());
      }    
    });
    
    denominators.forEach(function(e){
      let equat = new Equation(algebra.parse(e), 0); 
      if(equat.lhs.toString().indexOf("x") !==-1){
        let answers = equat.solveFor("x");        
        if(typeof answers == "object"){
          answers.forEach(function(ans){
            result.push(math.evaluate(ans.toString()));
          });
        }else{
          result.push(math.evaluate(answers.toString()));
        } 
      }     
    });
    return result;
  } */

  // var eq = nerdamer("x^2+y^2=1");
  // var y = eq.solveFor("y");
  // console.log(y.toString());

  // var eq = nerdamer("cos(1 / cos(x))=0");
  // var x = eq.solveFor("x");
  // console.log(x.toString());

  //x = Math.min.apply(null, x.toString())
  // x = Math.min.apply(null,x.toString().replace("[", "").replace("]", "").split(",").map(function(e){
  //   return parseFloat(e)
  // }))

  // for (let i = 0; i < x.length; i++) {
  //   console.log(i, x.at(i).valueOf());
  // }

  // var e = nerdamer("x/2+y/3");
  // var denominator = e.denominator().toString();
  // console.log(denominator);

  //1/(cos(1/(cos(x))))

  //console.log(486, math.evaluate("sin(180)"));

  //console.log(math.simplify("(-(x^2))^2").toString());
  //console.log("(-(x^2))^2");

  /* let entry = "1,1";
  Utility.prompt("Enter comma separated values", entry, function (csvStr) {
    if (csvStr) {
      const arr = csvStr.split(",");
      if (arr.length !== 2) {
        Utility.promptErrorMsg = `Improper translate values.\nExpected a comma separated value (csv).`;
        return false;
      }

      let m_translateX = Number.MAX_VALUE,
        m_translateY = Number.MAX_VALUE;

      try {
        let parser = new EvaluateExp(arr[0], self.defines.expandDefines);
        m_translateX = parser.eval();
        if (!math.isNumeric(m_translateX)) m_translateX = Number.MAX_VALUE;
      } catch (error) {
        m_translateX = Number.MAX_VALUE;
      }
      try {
        let parser = new EvaluateExp(arr[1], self.defines.expandDefines);
        m_translateY = parser.eval();
        if (!math.isNumeric(m_translateY)) m_translateY = Number.MAX_VALUE;
      } catch (error) {
        m_translateY = Number.MAX_VALUE;
      }
      // if (arr.length == 2) {
      if (
        m_translateX == Number.MAX_VALUE &&
        m_translateY == Number.MAX_VALUE
      ) {
        Utility.promptErrorMsg = `\"${arr[0]},${arr[1]}\" represent improper translate values.`;
        entry = csvStr;
        return false;
      }
      if (m_translateX == Number.MAX_VALUE) {
        Utility.promptErrorMsg = `\"${arr[0]}\" is an improper translate values.`;
        entry = csvStr;
        return false;
      }
      if (m_translateY == Number.MAX_VALUE) {
        Utility.promptErrorMsg = `\"${arr[1]}\" is an improper translate values.`;
        entry = csvStr;
        return false;
      }
      //entry = csvStr;
      //} else {
      validInput = true;
      // const m_translateX = math.evaluate(arr[0]);
      // const m_translateY = math.evaluate(arr[1]);

      for (let i = 0; i < curves.length; i++) {
        self.transformation.transform(
          curves[i],
          "Translate",
          m_translateX,
          m_translateY
        );
      }
      //}
    } else {
      return;
    }

    // console.log(str); //If the visitor clicks OK, the input is log to the console.
    // Utility.promptErrorMsg = "Invalid input. Expected a number.";
    return true;
  }); */

  // $("#testButton").click(function () {
  //   Utility.alert("No curves found", "small", true); //Display a small alert box with the message "No curves found".
  // });
  //console.log(math.evaluate("4^2a", { a: 2 }).toString());

  /* <div style="width:20%">
<div><output style="display: flex;justify-content: center;" name="ageOutputName" id="ageOutputId">24</output></div>
    <input id="min_value" style="width:11%;padding:0;" oninput="ageInputId.min = min_value.value"><input style="width:68%" type="range" name="ageInputName" id="ageInputId" value="24" min="1" max="100" oninput="ageOutputId.value = ageInputId.value"><input id="max_value" style="width:11%;padding:0;" oninput="ageInputId.max = max_value.value">
    
</div> */

  // console.log(math.simplify("sin(x)^2+cos(x)^2").toString());
  //console.log(asciimath.parseMath);

  // const str = "aaaaaaaa 26 c 44";
  //console.log(math.simplify("4x/a").toString());

  // var x = nerdamer("sin(9^0.5*4)/0.9");
  //console.log(math.parse("log(8,a+2)").toTex());

  // const parser = math.parser();
  // parser.set("a", 4);
  // const p = math.parse("x^2+a");
  // // const expEval = new EvaluateExp("x^2+a");

  // console.log(p.evaluate({ x: 2 }));

  //const parser = math.parser();
  //console.log(parser);
  //let simplified = parser.parse();
  //let simplified = parser.evaluate("x^2");
  // const parser2 = math.parser();
  //console.log(simplified.evaluate({ x: 2 }));
  //simplified.evaluate("f(x)=x^2");

  //console.log(mathsteps);

  /* const steps = mathsteps.solveEquation("3x +1= 35");

  steps.forEach((step) => {
    console.log("before change: " + step.oldEquation.ascii()); // e.g. before change: 2x + 3x = 35
    console.log("change: " + step.changeType); // e.g. change: SIMPLIFY_LEFT_SIDE
    console.log("after change: " + step.newEquation.ascii()); // e.g. after change: 5x = 35
    console.log("# of substeps: " + step.substeps.length); // e.g. # of substeps: 2
  }); */

  /* const Logger = Utility.loggerSetup();

  var expression = "(24x+32)(2x+2)/2";
  Logger.log(expression); */

  // const customFunctions = {
  //   log_: function (a, b) {
  //     return math.log(b, a);
  //   },
  // };

  //let result = text.match(/[^\(]*(\(.*\))[^\)]/);

  // customFunctions.logg_.toTex = "\\mathrm{${logg_}}\\left(${args}\\right)";
  // customFunctions.logg_.toString = "logg(${args})"; //template string

  //math.import(customFunctions);

  // console.log(math.simplify("logg_2(8,2)").toString());

  // function getOperand(str, startIndex, keyword, postKeyword = true) {
  //   const _str = str.substring(startIndex);

  //   //let re = new RegExp(`${keyword}[\\(]*(\\(.*\\))[^\\)]`);
  //   let re = new RegExp(`[\\(]*(\\(.*\\))[^\\)](?=mod)`);

  //   let result = text.match(re);

  //   return result;
  // }

  //let text = "log_(1+a)(1+x)-4x+3-log_(1+b)(1+x)";
  //let result = text.match(/\((?:[^)(]*(?R)?)*+\)/);
  //let result = text.match(/[^\(]*(\(.*\))[^\)](?=mod)/);
  //console.log(XRegExp.matchRecursive(text, "\\(", "\\)" /* , "g" */));

  //console.log(getOperand(text, 0, "mod"));

  // let text = "1bgmod4(1+x)";

  // console.log(
  //   text.match(/(\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)(?=mod)|.(?=mod))/g)
  // );
  // console.log(
  //   text.match(
  //     /((?<=mod)\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)|(?<=mod).)/g
  //   )
  // );

  // function handleLog_(text) {
  //   const matches = text.match(
  //     /(?<=log_)\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/g
  //   );
  //   let text2 = text.replace(
  //     /(?<=log_)\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/g,
  //     ""
  //   );
  //   const matches2 = text2.match(
  //     /(?<=log_)\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/g
  //   );
  //   matches.forEach(function (str, i) {
  //     text = text.replace(
  //       `_${matches[i]}${matches2[i]}`,
  //       `(${matches2[i]},${matches[i]})`
  //     );
  //   });
  //   return text;
  // }

  // console.log(
  //   math.simplify("-4.07 mod 4", {}, { exactFractions: false }).toString()
  // );

  //  \((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)

  //////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  //let str1 = "log^2(x)+log(x)+log_(1+b)^2(45-log_(a+2)(1+x))";

  //let str1 = "log(45-log_(a+2)(1+x))";
  //let str1 = "log(45)";
  //let str1 = "log(45+x)";
  //let str1 = "log_2(45)";
  //let str1 = "log_2(45+x)";
  //let str1 = "log_(a+2)(45+x)";

  //let str1 = "log_(1+b)^2(45-log_(a+2)(1+x))";
  //let str1 = "log^2(x)+log(x)+log^2(45-log_(a+2)(1+x))";
  //let str1 = "log^2(45-log_(a+2)(1+x))";
  //let str1 = "(sin^(-1)^(45))^(-1)";
  //let str1 = "log^2(45+x)";
  //let str1 = "log_2^2(45)";
  //let str1 = "log_2^2(45+x)";
  //let str1 = "log_(a+2)^2(45+x)";

  // function operand(str, keyword, indexOfKeyword) {
  //   let subStr = str.substring(indexOfKeyword + keyword.length);
  //   let result = null;
  //   try {
  //     result = XRegExp.matchRecursive(subStr, "\\(", "\\)", "g");
  //   } catch (error) {
  //     const subStrCpy = subStr.slice();
  //     subStr = subStrCpy.substring(0, subStrCpy.lastIndexOf(")"));
  //     try {
  //       result = XRegExp.matchRecursive(subStr, "\\(", "\\)", "g");
  //     } catch (error) {
  //       subStr = subStrCpy.substring(0, subStrCpy.lastIndexOf(")") - 1);
  //       try {
  //         result = XRegExp.matchRecursive(subStr, "\\(", "\\)", "g");
  //       } catch (error) {
  //         subStr = subStrCpy.replace(")", "");
  //         result = XRegExp.matchRecursive(subStr, "\\(", "\\)", "g");
  //       }
  //     }
  //   }

  //   let operand1 = subStr[0];
  //   //let result = XRegExp.matchRecursive(subStr, "\\(", "\\)", "g");
  //   if (result) {
  //     if (operand1 !== "(") {
  //       return { operand1, operand2: result[0] };
  //     } else {
  //       return { operand1: result[0], operand2: result[1] };
  //     }
  //   }
  //   return null;
  // }

  // function prefix(str, keyword, indexOfKeyword) {
  //   const subStr = str.substring(0, indexOfKeyword);
  //   // if (subStr[subStr.length - 1] === ")") {
  //   //   let result = XRegExp.matchRecursive(subStr, "\\(", "\\)", "g");
  //   //   if (result) {
  //   //     return `(${result[result.length - 1]})`;
  //   //   }
  //   // } else {
  //   let result = XRegExp.match(subStr, /(log_.*|[a-z]+)/g);
  //   if (result) {
  //     return result[result.length - 1];
  //   }
  //   //}
  //   return null;
  // }

  // function handleExponent(str) {
  //   //log_4^2(x)
  //   //handleExponent is be called before handleLog()
  //   XRegExp.forEach(str, /\^/g, function (e, i) {
  //     let obj = operand(e.input, "^", e.index);
  //     let pref = prefix(e.input, "^", e.index);
  //     if (
  //       obj &&
  //       obj.operand1 &&
  //       obj.operand2 &&
  //       pref &&
  //       pref.length > 1 &&
  //       pref[0] !== "("
  //     ) {
  //       let operand1 = obj.operand1;
  //       if (operand1.length > 1) {
  //         operand1 = `(${operand1})`;
  //       }
  //       if (Static.trigKeywords.indexOf(pref) !== -1 && operand1 === "(-1)") {
  //         const _pref = pref[0] === "a" ? pref.substring(1) : "a" + pref;
  //         str = str.replace(
  //           `${pref}^${operand1}(${obj.operand2})`,
  //           `${_pref}(${obj.operand2})`
  //         );
  //       } else {
  //         str = str.replace(
  //           `${pref}^${operand1}(${obj.operand2})`,
  //           `(${pref}(${obj.operand2}))^${operand1}`
  //         );
  //       }
  //     }
  //   });
  //   return str;
  // }

  // function handleLog(str) {
  //   //handleExponent must be called before handleLog()
  //   XRegExp.forEach(str, /log/g, function (e, i) {
  //     let obj = null;
  //     if (e.input[e.index + 3] !== "_") {
  //       obj = operand(e.input, "log", e.index);
  //       str = str.replace(`log(${obj.operand1})`, `~#~(${obj.operand1},10)`);
  //     } else {
  //       obj = operand(e.input, "log_", e.index);
  //       if (obj.operand1.replaceAll(" ", "").length === 1) {
  //         str = str.replace(
  //           `log_${obj.operand1}(${obj.operand2})`,
  //           `~#~(${obj.operand2},${obj.operand1})`
  //         );
  //       } else {
  //         str = str.replace(
  //           `log_(${obj.operand1})(${obj.operand2})`,
  //           `~#~(${obj.operand2},${obj.operand1})`
  //         );
  //       }
  //     }
  //   });
  //   return str; //.replaceAll("~#~", "log");
  // }

  // function handleExponentAndLog(str) {
  //   let resultCpy = null;
  //   let result = handleExponent(str);
  //   while (result !== resultCpy) {
  //     resultCpy = result.slice();
  //     result = handleLog(result);
  //   }
  //   return result.replaceAll("~#~", "log");
  // }

  // // console.log(handleExponent(str1));
  // // console.log(handleLog(str1));
  // console.log(handleExponentAndLog(str1));

  //operand(str1, "log");

  // let s =
  //   "0x^9+2.58e-10x^8+0x^7-4.8413e-8x^6+0x^5+0.000002702086x^4+0x^3+0.999955582217x^2+0x+0.000099537348";
  // s = s.replaceAll("0x", "0");

  // console.log(456, math.parse(s));

  const fn = "x^2";
  const variable = "x";
  const _rulerLeft = -10;
  const _rulerRight = 10;
  const step = 0.1;

  // const value = math.evaluate(
  //   `integrate(${fn} , ${variable}, ${_rulerLeft}, ${_rulerRight}, false, ${step})`
  // );
  //console.log("value:", value);
});

define("app/main", function(){});

/*This file was generated through the dependencies build proess. Do not modify or delete this file. If the file is accidentally modified or you suspect it is somehow corrupted, run build. It is always a good idea to run build before embarking on heavy troubleshooting.*/
requirejs.config({
  baseUrl: "lib",
  paths: {
    app: "../app",
    underscore:
      "https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min",
    addRemovePointPicker: "../app/src/addRemovePointPicker",
    axisDlg: "../app/src/axisDlg",
    basicWatch: "../app/src/basicWatch",
    curveClosestPoint: "../app/src/curveClosestPoint",
    curveFitDlg: "../app/src/curveFitDlg",
    curveLegendAttributeDlg: "../app/src/curveLegendAttributeDlg",
    curvePropertiesPane: "../app/src/curvePropertiesPane",
    curveSelector: "../app/src/curveSelector",
    curveSettings: "../app/src/curveSettings",
    curveShapeItem: "../app/src/curveShapeItem",
    curveStyleDlg: "../app/src/curveStyleDlg",
    defines: "../app/src/defines",
    fontPicker: "../app/src/fontPicker",
    functionData: "../app/src/functionData",
    functionDlg: "../app/src/functionDlg",
    infoPropertiesPane: "../app/src/infoPropertiesPane",
    infoSidebar: "../app/src/infoSidebar",
    legendMenu: "../app/src/legendMenu",
    markerDlg: "../app/src/markerDlg",
    modalDlg: "../app/src/modalDlg",
    mpicker: "../app/src/mpicker",
    mtoolBar: "../app/src/mtoolBar",
    myCurve: "../app/src/myCurve",
    myLegend: "../app/src/myLegend",
    myPlot: "../app/src/myPlot",
    myZoomer: "../app/src/myZoomer",
    pane: "../app/src/pane",
    plotPropertiesPane: "../app/src/plotPropertiesPane",
    plotSideBar: "../app/src/plotSideBar",
    pointEntryDlg: "../app/src/pointEntryDlg",
    propertiesPane: "../app/src/propertiesPane",
    rasterFileData: "../app/src/rasterFileData",
    rasterFunctionData: "../app/src/rasterFunctionData",
    ruler: "../app/src/ruler",
    rulers: "../app/src/rulers",
    sideBar: "../app/src/sideBar",
    spectrogram: "../app/src/spectrogram",
    toolBar: "../app/src/toolBar",
    transformation: "../app/src/transformation",
    trash: "../app/src/trash",
    watch: "../app/src/watch",
    watches: "../app/src/watches",
    zoneDlg: "../app/src/zoneDlg",
  },
  shim: {
    static: { deps: ["miscObjects"] },
    file: { deps: ["xlsx", "upload"] },
    utility: { deps: ["evaluateExp"] },
    plot: {
      deps: [
        "static",
        "widget",
        "scaleWidget",
        "utility",
        "enumerator",
        "miscObjects",
        "painter",
        "scaleDiv",
        "interval",
        "scaleMap",
        "scaleWidget",
        "transform",
        "layout",
        "scaleDraw",
        "scaleEngine",
        "pointMapper",
        "graphic",
        "enumerator",
      ],
    },
    plotItem: { deps: ["static", "enumerator"] },
    scaleMap: { deps: ["static", "transform"] },
    canvas: { deps: ["static"] },
    curveFitter: { deps: ["static"] },
    spline: { deps: ["static"] },
    symbol: { deps: ["static", "graphic"] },
    seriesData: { deps: ["static", "plotItem"] },
    pointMapper: { deps: ["static"] },
    pointData: { deps: ["static", "seriesData"] },
    scaleEngine: { deps: ["static"] },
    scaleDraw: { deps: ["static", "abstractScaleDraw"] },
    widget: { deps: ["static", "hObject"] },
    widgetOverlay: { deps: ["static", "widget"] },
    scaleWidget: { deps: ["static", "widget"] },
    picker: {
      deps: ["underscore", "static", "widgetOverlay", "pickermachine"],
    },
    plotpicker: { deps: ["static", "picker"] },
    plotzoomer: { deps: ["plotpicker"] },
    plotGrid: { deps: ["static", "plotItem"] },
    plotZoneItem: { deps: ["static", "plotItem"] },
    plotSpectrogram: { deps: ["static", "conrec", "plotRasterItem"] },
    plotRasterItem: { deps: ["static", "plotItem"] },
    plotSpectroCurve: {
      deps: ["static", "colorMap", "plotItem", "seriesData"],
    },
    colorMap: { deps: ["static"] },
    plotcurve: { deps: ["static", "seriesData"] },
    panner: { deps: ["static", "hObject"] },
    magnifier: { deps: ["static", "hObject"] },
    plotShapeItem: { deps: ["static", "plotItem"] },
    plotMarker: { deps: ["static", "plotItem"] },
    legend: { deps: ["static"] },
    pickermachine: { deps: ["static", "eventpattern"] },
    widget: { deps: ["static", "hObject"] },
    addRemovePointPicker: {
      deps: ["plot", "curveClosestPoint", "plotpicker", "plotcurve", "symbol"],
    },
    axisDlg: { deps: ["modalDlg"] },
    basicWatch: { deps: ["static", "watch", "plotMarker", "symbol"] },
    curveClosestPoint: { deps: ["static", "widgetOverlay", "plotMarker"] },
    curveFitDlg: { deps: ["static", "modalDlg"] },
    curveLegendAttributeDlg: { deps: ["modalDlg"] },
    curvePropertiesPane: { deps: ["propertiesPane"] },
    curveSelector: { deps: ["static", "widgetOverlay", "plotMarker"] },
    curveSettings: { deps: [] },
    curveShapeItem: { deps: ["plotShapeItem"] },
    curveStyleDlg: { deps: ["modalDlg"] },
    defines: { deps: ["static", "modalDlg"] },
    fontPicker: { deps: ["modalDlg"] },
    functionData: { deps: ["pointData"] },
    functionDlg: { deps: ["defines"] },
    infoPropertiesPane: { deps: ["pane"] },
    infoSidebar: { deps: ["sideBar"] },
    legendMenu: { deps: ["static"] },
    markerDlg: { deps: ["fontPicker"] },
    modalDlg: { deps: [] },
    mpicker: { deps: ["static", "plotpicker"] },
    mtoolBar: { deps: ["toolBar", "curveSettings"] },
    myCurve: { deps: ["plotcurve"] },
    myLegend: { deps: ["legend"] },
    myPlot: {
      deps: [
        "myLegend",
        "curveClosestPoint",
        "plot",
        "functionData",
        "plotGrid",
        "spectrogram",
      ],
    },
    myZoomer: { deps: ["plotzoomer"] },
    pane: { deps: [] },
    plotPropertiesPane: { deps: ["propertiesPane"] },
    plotSideBar: { deps: ["sideBar"] },
    pointEntryDlg: { deps: ["modalDlg"] },
    propertiesPane: { deps: ["pane"] },
    rasterFileData: { deps: ["rasterData"] },
    rasterFunctionData: { deps: ["rasterData"] },
    ruler: { deps: ["static", "plotMarker"] },
    rulers: { deps: ["static", "mpicker", "ruler"] },
    sideBar: { deps: [] },
    spectrogram: {
      deps: [
        "static",
        "plotSpectrogram",
        "colorMap",
        "rasterFileData",
        "rasterFunctionData",
      ],
    },
    toolBar: { deps: [] },
    transformation: { deps: [] },
    trash: { deps: ["static", "modalDlg"] },
    watch: { deps: [] },
    watches: { deps: ["basicWatch"] },
    zoneDlg: { deps: [] },
  },
});
requirejs(["app/main"]);

define("app", function(){});

